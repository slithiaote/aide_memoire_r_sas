# Gestion par groupe

## Numéroter les lignes

### Numéroter les lignes de la base

::: {.panel-tabset group="language"}

### SAS {.unnumbered .unlisted}
``` sas
data donnees_sas;
  set donnees_sas;
  Num_observation = _n_;
run;

/* Autre solution */
proc sql noprint;select count(*) into :nbLignes from donnees_sas;quit;
data numLigne;do Num_observation = 1 to &nbLignes.;output;end;run;
/* Autre possibilité */
data _NULL_;
  set donnees_sas nobs = n;
  call symputx('nbLignes', n);
run;
%put Nombre de lignes : &nbLignes.;

/* Le merge "simple" (sans by) va seulement concaténer les deux bases l'une à côté de l'autre */
data donnees_sas;
  merge donnees_sas numLigne;
run;
```

### R base {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Numéro de l'observation : 2 manières différentes
donnees_rbase$num_observation <- seq(1, nrow(donnees_rbase))
donnees_rbase$num_observation <- seq_len(nrow(donnees_rbase))
donnees_rbase$num_observation <- row.names(donnees_rbase)
```

### tidyverse {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Numéro de l'observation
donnees_tidyverse <- donnees_tidyverse %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>% 
  mutate(num_observation = row_number())
```

### data.table {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Numéro de l'observation : 2 manières différentes
donnees_datatable[, num_observation := .I]
donnees_datatable[, num_observation := seq_len(.N)]
```

### arrow/duckdb {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

### pandas {.unnumbered .unlisted}
```{python, warning=FALSE, message=FALSE, results='hide', python.reticulate = FALSE}
# Python commence le compte à 0 (penser à ajouter 1 pour coïncider avec la numérotation de R)
donnees_python['num_observation'] = range(1, len(donnees_python) + 1)

donnees_python['num_observation'] = donnees_python.index + 1
```

:::

### Numéroter les contrats de l'individu

::: {.panel-tabset group="language"}

### SAS {.unnumbered .unlisted}
``` sas
/* Numéro du contrat de chaque individu, contrat trié par date d'entrée */
proc sort data = donnees_sas;by identifiant date_entree;run;

data donnees_sas;
  set donnees_sas;
  by identifiant date_entree;
  retain num_contrat;
  if first.identifiant then num_contrat = 1;
  else                      num_contrat = num_contrat + 1;
run;
```

### R base {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Numéro du contrat de chaque individu, contrat trié par date d'entrée
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]
donnees_rbase$un <- 1
# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN = !
donnees_rbase$numero_contrat <- ave(donnees_rbase$un, donnees_rbase$identifiant, FUN = cumsum)
donnees_rbase$un <- NULL

# Autre solution
# Utiliser seq_along ne nécessite pas un tri préalable !
donnees_rbase$numero_contrat <- as.numeric(ave(donnees_rbase$identifiant, donnees_rbase$identifiant, FUN = seq_along))

# Autre solution : order pour éviter le as.numeric
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]
donnees_rbase$numero_contrat <- ave(order(donnees_rbase$date_entree), donnees_rbase$identifiant, FUN = seq_along)
```

### tidyverse {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Numéro du contrat de chaque individu, contrat trié par date d'entrée
# arrange() va permettre de trier les observations par identifiant et date d'entrée 
donnees_tidyverse <- donnees_tidyverse %>% 
  group_by(identifiant) %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>% 
  mutate(numero_contrat = row_number()) %>% 
  ungroup()
# À FAIRE : Dans group_by, à quoi sert le drop ?
```

### data.table {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Numéro du contrat de chaque individu, contrat trié par date d'entrée
setorder(donnees_datatable, "identifiant", "date_entree", na.last = FALSE)
donnees_datatable[, numero_contrat := rowid(identifiant)]
donnees_datatable[, numero_contrat := seq_len(.N), by = identifiant]

# Les seuls numéros de colonnes
rowidv(donnees_datatable, identifiant)
```

### arrow/duckdb {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

### pandas {.unnumbered .unlisted}
```{python, warning=FALSE, message=FALSE, results='hide', python.reticulate = FALSE}
# 1. Trier les données par 'identifiant' et 'date_entree'
donnees_python = donnees_python.sort_values(by=['identifiant', 'date_entree'])

# 2. Créer le numéro de contrat
donnees_python['numero_contrat'] = donnees_python.groupby('identifiant').cumcount() + 1
```

:::

## Première et dernière ligne par identifiant

### Première ligne par identifiant
::: {.panel-tabset group="language"}

### SAS {.unnumbered .unlisted}
``` sas
proc sort data = donnees_sas;by identifiant date_entree;run;
/* L'instruction options permet de ne pas afficher d'erreur si la variable numero_contrat n'existe pas */
options dkricond=nowarn dkrocond=nowarn;
data donnees_sas;
  set donnees_sas (drop = numero_contrat);
  by identifiant date_entree;
  retain numero_contrat 0;
  if first.identifiant then numero_contrat = 1;
  else                      numero_contrat = numero_contrat + 1;
run;

options dkricond=warn dkrocond=warn;
/* Pour trier les colonnes */
data donnees_sas;
  retain identifiant date_entree numero_contrat numero_contrat;
  set donnees_sas;
run;
```

### R base {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]
donnees_rbase[! duplicated(donnees_rbase$identifiant), , drop = FALSE]
```

### tidyverse {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse %>% 
  group_by(identifiant) %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>%
  filter(row_number() == 1) %>% 
  ungroup()

# Autres solutions
donnees_tidyverse %>% 
  group_by(identifiant) %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>%
  slice(1) %>% 
  ungroup()

donnees_tidyverse %>%  
  group_by(identifiant) %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>%
  slice_head(n = 1) %>% 
  ungroup()

donnees_tidyverse %>%  
  group_by(identifiant) %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>%
  filter(row_number() == nth(row_number(), 1)) %>%
  ungroup()
```

### data.table {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable[, .SD[1], by = identifiant]

# On peut aussi utiliser keyby si l'on souhaite que les résultats soient triés par la variable de groupement (ici identifiant)
donnees_datatable[, .SD[1], keyby = identifiant]
```

### arrow/duckdb {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

### pandas {.unnumbered .unlisted}
```{python, warning=FALSE, message=FALSE, results='hide', python.reticulate = FALSE}
donnees_python.drop_duplicates(subset='identifiant', keep='first')
```

:::

### Dernière ligne par identifiant
::: {.panel-tabset group="language"}

### SAS {.unnumbered .unlisted}
``` sas
proc sort data = donnees_sas;by identifiant date_entree;run;
/* L'instruction options permet de ne pas afficher d'erreur si la variable numero_contrat n'existe pas */
options dkricond=nowarn dkrocond=nowarn;
data donnees_sas;
  set donnees_sas (drop = numero_contrat);
  by identifiant date_entree;
  retain numero_contrat 0;
  if first.identifiant then numero_contrat = 1;
  else                      numero_contrat = numero_contrat + 1;
run;

options dkricond=warn dkrocond=warn;
/* Pour trier les colonnes */
data donnees_sas;
  retain identifiant date_entree numero_contrat numero_contrat;
  set donnees_sas;
run;
```

### R base {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]
donnees_rbase[! duplicated(donnees_rbase$identifiant, fromLast = TRUE), , drop = FALSE]
```

### tidyverse {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse %>% 
  group_by(identifiant) %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>%
  filter(row_number() == n()) %>% 
  ungroup()

# Autres solutions
donnees_tidyverse %>%  
  group_by(identifiant) %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>%
  slice(n()) %>% 
  ungroup()

donnees_tidyverse %>%  
  group_by(identifiant) %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>%
  filter(row_number() == nth(row_number(), -1)) %>%
  ungroup()
```

### data.table {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable[, .SD[.N], by = identifiant]
```

### arrow/duckdb {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

### pandas {.unnumbered .unlisted}
```{python, warning=FALSE, message=FALSE, results='hide', python.reticulate = FALSE}
donnees_python.drop_duplicates(subset='identifiant', keep='last')
```

:::

## Le premier contrat, le dernier contrat, ni le premier ni le dernier contrat de chaque individu
::: {.panel-tabset group="language"}

## SAS {.unnumbered .unlisted}
``` sas
proc sort data = donnees_sas;by identifiant date_entree;run;
data donnees_sas;
  set donnees_sas;
  by identifiant date_entree;
  Premier_Contrat = (first.identifiant = 1);
  Dernier_Contrat = (last.identifiant = 1);
  Ni_Prem_Ni_Der  = (first.identifiant = 0 and last.identifiant = 0);
run;
```

## R base {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]
donnees_rbase$premier_contrat <- ifelse(! duplicated(donnees_rbase$identifiant, fromLast = FALSE), 
                                        1, 0)
donnees_rbase$dernier_contrat <- ifelse(! duplicated(donnees_rbase$identifiant, fromLast = TRUE), 
                                        1, 0)
donnees_rbase$ni_prem_ni_der  <- ifelse(! c(! duplicated(donnees_rbase$identifiant, fromLast = FALSE) | ! duplicated(donnees_rbase$identifiant, fromLast = TRUE)), 
                                        1, 0)
```

## tidyverse {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Premier contrat
donnees_tidyverse <- donnees_tidyverse %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>% 
  group_by(identifiant) %>% 
  mutate(premier_contrat = ifelse(row_number() == 1, 1, 0)) %>% 
  ungroup()

# Dernier contrat
donnees_tidyverse <- donnees_tidyverse %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>% 
  group_by(identifiant) %>% 
  mutate(dernier_contrat = ifelse(row_number() == n(), 1, 0)) %>% 
  ungroup()

# Ni le premier, ni le dernier contrat
donnees_tidyverse <- donnees_tidyverse %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>% 
  group_by(identifiant) %>% 
  mutate(ni_prem_ni_der = ifelse( ! (row_number() == n() | row_number() == 1), 1, 0)) %>% 
  ungroup()
```

## data.table {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable <- donnees_datatable[order(identifiant, date_entree, na.last = FALSE)]
donnees_datatable[, premier_contrat := fifelse(! duplicated(identifiant, fromLast = FALSE), 
                                               1, 0)]
donnees_datatable[, dernier_contrat := fifelse(! duplicated(identifiant, fromLast = TRUE), 
                                               1, 0)]
donnees_datatable[, ni_prem_ni_der  := fifelse(! c(! duplicated(identifiant, fromLast = FALSE) | ! duplicated(identifiant, fromLast = TRUE)), 
                                               1, 0)]
```

## arrow/duckdb {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

## pandas {.unnumbered .unlisted}
```{python, warning=FALSE, message=FALSE, results='hide', python.reticulate = FALSE}
# 1. Trier les données par 'identifiant' et 'date_entree'
donnees_python = donnees_python.sort_values(by=['identifiant', 'date_entree'])

# Premier contrat
donnees_python['premier_contrat'] = 1 - donnees_python.duplicated(subset='identifiant', keep='first').astype(int)

# Dernier contrat
donnees_python['dernier_contrat'] = 1 - donnees_python.duplicated(subset='identifiant', keep='last').astype(int)

# Ni premier ni dernier contrat
donnees_python['ni_prem_ni_der'] = (~donnees_python['premier_contrat'].astype(bool) & ~donnees_python['dernier_contrat'].astype(bool)).astype(int)
```

:::

## Sélection de lignes par identifiant

### Les 2 premières lignes de chaque identifiant
::: {.panel-tabset group="language"}

### SAS {.unnumbered .unlisted}
``` sas
/* Numéro du contrat */
proc sort data = donnees_sas;by identifiant date_entree;run;
data donnees_sas;
  set donnees_sas;
  by identifiant date_entree;
  retain num_contrat;
  if first.identifiant then num_contrat = 1;
  else                      num_contrat = num_contrat + 1;
run;

proc sort data = donnees_sas;by identifiant numero_contrat;run;
proc sql;
  select * from donnees_sas group by identifiant
  having numero_contrat <= 2;
quit;
```

### R base {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]

# En utilisant la fonction by
deux_premieres_lignes <- Reduce(rbind, by(donnees_rbase, donnees_rbase["identifiant"], head, 2))

# En utilisant la fonction split pour découper par identifiant, et en ne retenant que les deux premières lignes des groupes créés
deux_premieres_lignes <- do.call(rbind, 
                                 lapply(
                                   split(donnees_rbase, donnees_rbase$identifiant), head, 2
                                   ))

# On peut aussi utiliser les numéros de contrat
donnees_rbase$un <- 1L
# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN = !
donnees_rbase$numero_contrat <- ave(donnees_rbase$un, donnees_rbase$identifiant, FUN = cumsum)
deux_premieres_lignes <- donnees_rbase[which(donnees_rbase$numero_contrat <= 2), ]
donnees_rbase$un <- NULL

# Version en R Base
#https://stackoverflow.com/questions/14800161/select-the-top-n-values-by-group
```

### tidyverse {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
deux_premieres_lignes <- donnees_tidyverse %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>% 
  group_by(identifiant) %>% 
  slice(1:2) %>% 
  ungroup()
```

### data.table {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
deux_premieres_lignes <- donnees_datatable[, .SD[1:2], by = identifiant]
```

### arrow/duckdb {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

### pandas {.unnumbered .unlisted}
```{python, warning=FALSE, message=FALSE, results='hide', python.reticulate = FALSE}
deux_premieres_lignes = (donnees_python
            .sort_values(by=['identifiant', 'date_entree'], ascending=[True, True], na_position='last')
            .groupby('identifiant')
            .head(2)
            .reset_index(drop=True)
)
```

:::

### Les 2 dernières lignes de chaque identifiant
::: {.panel-tabset group="language"}

### SAS {.unnumbered .unlisted}
``` sas
/* Numéro du contrat */
proc sort data = donnees_sas;by identifiant date_entree;run;
data donnees_sas;
  set donnees_sas;
  by identifiant date_entree;
  retain num_contrat;
  if first.identifiant then num_contrat = 1;
  else                      num_contrat = num_contrat + 1;
run;

proc sort data = donnees_sas;by identifiant numero_contrat;run;
proc sql;
  select * from donnees_sas group by identifiant
  having numero_contrat >= count(*) - 1;
quit;
```

### R base {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
deux_dernieres_lignes <- donnees_rbase[unlist(tapply(seq_len(nrow(donnees_rbase)), 
                                                     donnees_rbase$identifiant, 
                                                     function(x) tail(x, 2))), ]

# Version en R Base
#https://stackoverflow.com/questions/14800161/select-the-top-n-values-by-group
```

### tidyverse {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# À FAIRE : ne fait pas la même-chose !
deux_dernieres_lignes <- donnees_tidyverse %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>% 
  group_by(identifiant) %>% 
  slice(n() - 2) %>% 
  ungroup()
```

### data.table {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
deux_dernieres_lignes <- donnees_datatable[, tail(.SD, 2), by = identifiant]
```

### arrow/duckdb {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

### pandas {.unnumbered .unlisted}
```{python, warning=FALSE, message=FALSE, results='hide', python.reticulate = FALSE}
deux_dernieres_lignes = (donnees_python
            .sort_values(by=['identifiant', 'date_entree'], ascending=[True, True], na_position='last')
            .groupby('identifiant')
            .tail(2)
            .reset_index(drop=True)
)
```

:::

### 2e ligne de l'individu (et rien si l'individu a 1 seule ligne)
::: {.panel-tabset group="language"}

### SAS {.unnumbered .unlisted}
``` sas
/* Numéro du contrat */
proc sort data = donnees_sas;by identifiant date_entree;run;
data donnees_sas;
  set donnees_sas;
  by identifiant date_entree;
  retain numero_contrat 0;
  if first.identifiant then numero_contrat = 1;
  else                      numero_contrat = numero_contrat + 1;
run;

/* 2 stratégies possibles */
data Deuxieme_Contrat;
  set donnees_sas;
  if numero_contrat = 2;
run;

data Deuxieme_Contrat;
  set donnees_sas (where = (numero_contrat = 2));
run;
```

### R base {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]
donnees_rbase[unlist(tapply(seq_len(nrow(donnees_rbase)), donnees_rbase$identifiant, function(x) head(x, 2))), ]

# Avec le numéro de contrat
donnees_rbase$un <- 1L
# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN = !
donnees_rbase$numero_contrat <- ave(donnees_rbase$un, donnees_rbase$identifiant, FUN = cumsum)
deuxieme_ligne <- donnees_rbase[donnees_rbase$numero_contrat == 2, ]
donnees_rbase$un <- NULL
```

### tidyverse {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse %>% 
  group_by(identifiant) %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>% 
  filter(row_number() == 2) %>% 
  ungroup()
```

### data.table {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
deuxieme_ligne <- donnees_datatable[, .SD[2], by = identifiant]
```

### arrow/duckdb {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

### pandas {.unnumbered .unlisted}
```{python, warning=FALSE, message=FALSE, results='hide', python.reticulate = FALSE}
deuxieme_ligne_par_groupe = (
    donnees_python
    .sort_values(by=['identifiant', 'date_entree'], ascending=[True, True], na_position='last')
    .groupby('identifiant')
    .nth(1)  # 1 correspond à la deuxieme ligne
    .reset_index()
)
```

:::

### L'avant-dernière ligne de l'individu (et rien si l'individu a 1 seul contrat)
::: {.panel-tabset group="language"}

### SAS {.unnumbered .unlisted}
``` sas
/* Nécessite d'avoir le numéro du contrat */
proc sql;
  select * from donnees_sas group by identifiant
  having numero_contrat = count(*) - 1;
quit;
```

### R base {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase[unlist(tapply(seq_len(nrow(donnees_rbase)), donnees_rbase$identifiant, function(x) x[length(x)-1])), ]
```

### tidyverse {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse %>% 
  group_by(identifiant) %>% 
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>% 
  filter(row_number() == nth(row_number(), -2))
```

### data.table {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable[, .SD[.N-1], by = identifiant]
```

### arrow/duckdb {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

### pandas {.unnumbered .unlisted}
```{python, warning=FALSE, message=FALSE, results='hide', python.reticulate = FALSE}
deuxieme_ligne_par_groupe = (
    donnees_python
    .sort_values(by=['identifiant', 'date_entree'], ascending=[True, True], na_position='last')
    .groupby('identifiant')
    .nth(1)  # 1 correspond à la deuxieme ligne
    .reset_index()
)
```

:::

## Sélection par groupement

### Personnes qui ont eu au moins une entrée en 2022

::: {.panel-tabset group="language"}

### SAS {.unnumbered .unlisted}
``` sas
/* Personnes qui ont eu au moins une entrée en 2022 */
proc sql;
  select *
  from donnees_sas
  group by identifiant
  having sum(year(date_entree) = 2022) >= 1;
quit;
```

### R base {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Personnes qui ont eu au moins une entrée en 2022
auMoins2022 <- subset(donnees_rbase, identifiant %in% unique(identifiant[lubridate::year(date_entree) %in% c(2022)]))

# Autre solution : ne semble possible que pour une seule variable
# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN = !
auMoins2022 <- donnees_rbase[with(donnees_rbase, ave(lubridate::year(date_entree) %in% c(2022), identifiant, FUN = any)), ]
auMoins2022 <- subset(
  transform(donnees_rbase, 
            cond = ave(lubridate::year(date_entree), identifiant, FUN = function(x) sum(ifelse(x %in% c(2022), 1, 0)))),
  cond >= 1)
auMoins2022$cond <- NULL
```

### tidyverse {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Personnes qui ont eu au moins une entrée en 2022
auMoins2022 <- donnees_tidyverse %>% 
  group_by(identifiant) %>%
  filter(any(lubridate::year(date_entree) == 2022)) %>% 
  ungroup()

# Ou plus simplement
auMoins2022 <- donnees_tidyverse %>% 
  filter(any(lubridate::year(date_entree) == 2022), .by = identifiant)
```

### data.table {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Personnes qui ont eu au moins une entrée en 2022
# Une fonction year() est déjà implémentée en data.table, l'usage de lubridate est inutile
auMoins2022 <- donnees_datatable[, if(any(data.table::year(date_entree) %in% 2022)) .SD, by = identifiant]

# Autre solution
auMoins2022 <- donnees_datatable[, if (sum(data.table::year(date_entree) == 2022, na.rm = TRUE) > 0) .SD, by = identifiant]
```

### arrow/duckdb {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

### pandas {.unnumbered .unlisted}
```{python, warning=FALSE, message=FALSE, results='hide', python.reticulate = FALSE}
auMoins2022 = (
    donnees_python
    .groupby('identifiant')
    .filter(lambda x: (x['date_entree'].dt.year == 2022).any())
)
```

:::

### Personnes qui ont suivi à la fois une formation qualifiée et une formation non qualifiée

::: {.panel-tabset group="language"}

### SAS {.unnumbered .unlisted}
``` sas
proc sql;
  create table Qualif_Non_Qualif as
  select *
  from donnees_sas
  group by identifiant
  having sum(Niveau = "Non qualifie") >= 1 and sum(Niveau = "Non qualifie") >= 1;
quit;
```

### R base {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Personnes qui ont suivi à la fois une formation qualifiée et une formation non qualifiée
# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN = !
qualif_non_qualif <- subset(
  transform(donnees_rbase, 
            qualif     = ave(niveau, identifiant, FUN = function(x) sum(ifelse(x == "Qualifié", 1, 0), na.rm = TRUE)), 
            non_qualif = ave(niveau, identifiant, FUN = function(x) sum(ifelse(x == "Non Qualifié", 1, 0), na.rm = TRUE))),
  qualif >= 1 & non_qualif >= 1)
```

### tidyverse {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Personnes qui ont suivi à la fois une formation qualifiée et une formation non qualifiée
qualif_non_qualif <- donnees_tidyverse %>% 
  group_by(identifiant) %>%
  filter(any(niveau == "Qualifié") & any(niveau == "Non qualifié")) %>% 
  ungroup()

# Ou plus simplement
qualif_non_qualif <- donnees_tidyverse %>% 
  filter(any(niveau == "Qualifié") & any(niveau == "Non qualifié"), .by = identifiant)
```

### data.table {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Personnes qui ont suivi à la fois une formation qualifiée et une formation non qualifiée

# Méthode la plus simple
donnees_datatable[, if (sum(niveau == "Qualifié", na.rm = TRUE) > 0 & sum(niveau == "Non qualifié", na.rm = TRUE) > 0) .SD, by = identifiant]

# Autre méthode
donnees_datatable[, `:=` (qualif = sum(fifelse(niveau == "Qualifié", 1, 0), na.rm = TRUE),
                          non_qualif = sum(fifelse(niveau == "Non qualifié", 1, 0), na.rm = TRUE)),
                by = identifiant][qualif > 0 & non_qualif > 0]

# Autre méthode
donnees_datatable[, `:=` (qualif = sum(niveau == "Qualifié", na.rm = TRUE), non_qualif = sum(niveau == "Non qualifié", na.rm = TRUE)), by = identifiant][qualif > 0 & non_qualif > 0]

# Group by et Having de SQL
# https://github.com/Rdatatable/data.table/issues/788
```

### arrow/duckdb {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

### pandas {.unnumbered .unlisted}
```{python, warning=FALSE, message=FALSE, results='hide', python.reticulate = FALSE}
qualif_non_qualif = (
    donnees_python
    .groupby('identifiant')
    .filter(lambda x: (x['niveau'] == 'Qualifié').any() and (x['niveau'] == 'Non qualifié').any())
)
```

:::

### Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins a débuté en 2022

::: {.panel-tabset group="language"}

### SAS {.unnumbered .unlisted}
``` sas
/* Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins a débuté en 2022 */
proc sql;
  create table Deux_Contrats as
  select *
  from donnees_sas
  group by identifiant
  having count(*) = 2 and sum(year(date_entree) = 2022) >= 1;
quit;
```

### R base {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins a débuté en 2022
# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN = !
deux_contrats <- subset(
  transform(donnees_rbase, 
            nb = ave(identifiant, identifiant, FUN = length), 
            an = ave(date_entree, identifiant, 
                     FUN = function(x) 
                       sum(ifelse(lubridate::year(x) == 2022, 1, 0), na.rm = TRUE))),
  nb == 2 & an >= 1)
```

### tidyverse {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins a débuté en 2022
deux_contrats <- donnees_tidyverse %>% 
  group_by(identifiant) %>%
  filter(n() == 2) %>% 
  filter(any(lubridate::year(date_entree) == 2022)) %>%
  ungroup()

# Ou plus simplement
deux_contrats <- donnees_tidyverse %>% 
  filter(any(lubridate::year(date_entree) == 2022 & n() == 2), .by = identifiant)
```

### data.table {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins a débuté en 2022
# Une fonction year() est déjà implémentée en data.table, l'usage de lubridate est inutile
donnees_datatable[, if (.N == 2 & sum(data.table::year(date_entree) == 2022, na.rm = TRUE) >= 1) .SD, by = identifiant]
```

### arrow/duckdb {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

### pandas {.unnumbered .unlisted}
```{python, warning=FALSE, message=FALSE, results='hide', python.reticulate = FALSE}
deux_contrats = (
    donnees_python
    .groupby('identifiant')
    .filter(lambda x: len(x) == 2 and (x['date_entree'].dt.year == 2022).any())
)
```

:::

## Ajouter le nombre d'observations par CSP
::: {.panel-tabset group="language"}

## SAS {.unnumbered .unlisted}
``` sas
proc sql;
  create table donnees_sas as
  select a.*, b.n
  from donnees_sas a left join
       (select CSPF, count(*) as n from donnees_sas group by CSPF) b on CSPF = CSPF
  order by identifiant;
quit;
```

## R base {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN = !
donnees_rbase <- transform(donnees_rbase, 
                           n = ave(cspf, cspf, FUN = length))
```

## tidyverse {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse <- donnees_tidyverse %>% add_count(cspf)

# Autre solution
donnees_tidyverse <- donnees_tidyverse %>%
  group_by(cspf) %>%
  mutate(n = n()) %>% 
  ungroup()
```

## data.table {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable[, n := .N, by = cspf]
donnees_datatable[, n := length(identifiant), by = cspf]
```

## arrow/duckdb {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

## pandas {.unnumbered .unlisted}
```{python, warning=FALSE, message=FALSE, results='hide', python.reticulate = FALSE}
donnees_python['n'] = donnees_python.groupby('cspf')['cspf'].transform('count')
```
:::

## Ajouter deux colonnes désignant la note moyenne et la somme de Note_Contenu, par individu
::: {.panel-tabset group="language"}

## SAS {.unnumbered .unlisted}
``` sas
/* 1ère solution */
proc sort data = donnees_sas;by identifiant;run;
proc means data = donnees_sas mean noprint;
  var Note_Contenu;
  by identifiant;
  output out = Temp;
run;
data Temp;
  set Temp (where = (_STAT_ = "MEAN"));
  keep identifiant Note_Contenu;
  rename Note_Contenu = Note_Contenu_Moyenne;
run;
data donnees_sas;
  merge donnees_sas (in = a) Temp (in = b);
  by identifiant;
  if a;
run;

/* 2e solution : plus souple */
/* Pour supprimer la variable ajoutée lors de la 1ère solution */
data donnees_sas;
  set donnees_sas (drop = Note_Contenu_Moyenne Note_Contenu_Somme);
run;
proc sql;
  create table donnees_sas as
  select *
  from donnees_sas a left join
       (select identifiant,
               mean(Note_Contenu) as Note_Contenu_Moyenne,
               sum(Note_Contenu) as Note_Contenu_Somme
        from donnees_sas group by identifiant) b
       on a.identifiant = b.identifiant
  order by identifiant;
quit;
```

## R base {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN = !
donnees_rbase <- transform(donnees_rbase, 
                           note_contenu_moyenne = ave(note_contenu, identifiant, FUN = mean, na.rm = TRUE), 
                           note_contenu_somme   = ave(note_contenu, identifiant, FUN = sum,  na.rm = TRUE))
```

## tidyverse {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse <- donnees_tidyverse %>%
  group_by(identifiant) %>%
  mutate(note_contenu_moyenne = mean(note_contenu, na.rm = TRUE),
         note_contenu_somme   = sum(note_contenu, na.rm = TRUE)) %>% 
  ungroup()
```

## data.table {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_datatable[, `:=` (note_contenu_moyenne = mean(note_contenu, na.rm = TRUE),
                          note_contenu_somme = sum(note_contenu, na.rm = TRUE)), by = identifiant]
# Moyenne de chaque note par individu
notes <- tolower(c("Note_Contenu", "Note_Formateur", "Note_Moyens", "Note_Accompagnement", "Note_Materiel"))
donnees_datatable[, paste0(notes, "_m") := lapply(.SD, mean, na.rm = TRUE), .SDcols = notes, keyby = identifiant]
```

## arrow/duckdb {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

## pandas {.unnumbered .unlisted}
```{python, warning=FALSE, message=FALSE, results='hide', python.reticulate = FALSE}
donnees_python['note_contenu_moyenne'] = donnees_python.groupby('identifiant')['note_contenu'].transform('mean')
donnees_python['note_contenu_somme'] = donnees_python.groupby('identifiant')['note_contenu'].transform('sum')
```

:::

## Ajouter une variable d'entrée initiale par individu

On souhaite ajouter dans la base une variable représentant la première date d'entrée de l'individu.

::: {.panel-tabset group="language"}

## SAS {.unnumbered .unlisted}
``` sas
proc sort data = donnees_sas;by Identifiant date_entree;run;
data donnees_sas;
  set donnees_sas;
  by Identifiant date_entree;
  format premiere_entree ddmmyy10.;
  retain premiere_entree;
  if first.Identifiant then premiere_entree = date_entree;
  else                      premiere_entree = premiere_entree;
run;
```

## R base {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]
# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN = !
donnees_rbase <- transform(donnees_rbase,
                           premiere_entree = ave(date_entree, identifiant, FUN = function(x) head(x, 1)))

# Autre solution, sans le tri préalable
donnees_rbase <- transform(donnees_rbase,
                           premiere_entree = ave(date_entree, identifiant, FUN = function(x) min(x) ))
```

## tidyverse {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
donnees_tidyverse <- donnees_tidyverse %>%
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>%
  mutate(premiere_entree = head(date_entree, 1), .by = identifiant)

# Autre solution
donnees_tidyverse <- donnees_tidyverse %>%
  # Pour trier les données de la même façon que SAS
  arrange(identifiant, !is.na(date_entree), date_entree) %>%
  group_by(identifiant) %>%
  mutate(premiere_entree = case_when(row_number() == 1 ~ date_entree,
                                     TRUE              ~ NA)) %>%
  fill(premiere_entree, .direction = c("down")) %>% 
  ungroup()
```

## data.table {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
setorderv(donnees_datatable, c("identifiant", "date_entree"), na.last = FALSE)
donnees_datatable[, premiere_entree := head(date_entree, 1), by = identifiant]
```

## arrow/duckdb {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

## pandas {.unnumbered .unlisted}
```{python, warning=FALSE, message=FALSE, results='hide', python.reticulate = FALSE}
donnees_python['premiere_entree'] = donnees_python.groupby('identifiant')['date_entree'].transform('min')
```

:::

## Ligne où se trouve une valeur maximale pour un individu (À REVOIR)

On cherche, pour chaque individu, la ligne où se trouve la valeur maximale de note_contenu.

<https://stackoverflow.com/questions/24558328/select-the-row-with-the-maximum-value-in-each-group>

::: {.panel-tabset group="language"}

## SAS {.unnumbered .unlisted}
``` sas
/* On note un comportement un peu différent de R : la note de l'identifiant 087 est inconnue, et l'identifiant est conservé en SAS, pas en R */

/* Renvoie toutes les lignes où note_contenu est maximale, s'il y a plusieurs ex-aequo */
proc sort data = donnees_sas;by identifiant descending note_contenu;run;
data ligne_max_note_contenu;
  set donnees_sas;
  by identifiant descending note_contenu;
  if first.note_contenu;
run;

/* Renvoie seulement la première ligne en cas d'ex-aequo */
proc sort data = donnees_sas;by identifiant descending note_contenu;run;
data ligne_max_note_contenu;
  set donnees_sas;
  by identifiant descending note_contenu;
  if first.identifiant;
run;
```

## R base {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# On note un comportement un peu différent de R : la note de l'identifiant 087 est inconnue, et la ligne est conservée en SAS, pas en R.
# Ceci est dû au fait que la fonction max ignore les NA.

# Renvoie toutes les lignes où note_contenu est maximale, s'il y a plusieurs ex-aequo
ligne_max_note_contenu <- merge(aggregate(note_contenu ~ identifiant, max, data = donnees_rbase), donnees_rbase)

# Autre solution
# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN = !
ligne_max_note_contenu <- donnees_rbase[with(donnees_rbase, which(note_contenu == ave(note_contenu, identifiant, FUN = max))), ]

# Renvoie seulement la première ligne en cas d'ex-aequo
donnees_rbase <- donnees_rbase[order(donnees_rbase$identifiant, -donnees_rbase$note_contenu), ]
ligne_max_note_contenu <- donnees_rbase[! duplicated(donnees_rbase$identifiant), ]

# Autre solution
ligne_max_note_contenu <- do.call(rbind, lapply(split(donnees_rbase, as.factor(donnees_rbase$identifiant)), function(x) {return(x[which.max(x$note_contenu), ])}))
```

## tidyverse {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# On note un comportement un peu différent de R : la note de l'identifiant 087 est inconnue, et l'identifiant est conservé en SAS, pas en R

# Renvoie toutes les lignes où note_contenu est maximale, s'il y a plusieurs ex-aequo
ligne_max_note_contenu <- donnees_tidyverse %>% 
  group_by(identifiant) %>% 
  slice_max(note_contenu)

# Renvoie seulement la première ligne en cas d'ex-aequo
ligne_max_note_contenu <- donnees_tidyverse %>%
     group_by(identifiant) %>%
     slice(which.max(note_contenu))
```

## data.table {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# On note un comportement un peu différent de R : la note de l'identifiant 087 est inconnue, et l'identifiant est conservé en SAS, pas en R

# Renvoie toutes les lignes où note_contenu est maximale, s'il y a plusieurs ex-aequo
ligne_max_note_contenu <- donnees_datatable[donnees_datatable[, .I[note_contenu == max(note_contenu)], by = identifiant]$V1]

# Renvoie seulement la première ligne en cas d'ex-aequo
ligne_max_note_contenu <- donnees_datatable[, .SD[which.max(note_contenu)], by = identifiant]
```

## arrow/duckdb {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

## pandas {.unnumbered .unlisted}
```{python, warning=FALSE, message=FALSE, results='hide', python.reticulate = FALSE}
# Renvoie toutes les lignes où note_contenu est maximale, s'il y a plusieurs ex-aequo
ligne_max_note_contenu = (
    donnees_python
    .groupby('identifiant')
    .apply(lambda x: x[x['note_contenu'] == x['note_contenu'].max()], include_groups=False).reset_index()
)

```

:::

## Identifier les changements d'état

Numérote les états successifs identiques d'un même identifiant. À chaque changement d'état d'un même individu, la variable d'état est incrémentée d'une unité.

::: {.panel-tabset group="language"}

## SAS {.unnumbered .unlisted}
``` sas
/* On suppose que l'on dispose d'une base sur le type de financement de la formation */
data Financement_sas;
  infile cards dsd dlm='|';
  format Identifiant $3. Date ddmmyy10.  Financement $10.;
  input  Identifiant $   Date :ddmmyy10. Financement $;
  cards;
  173|02/01/2022|Public
  173|18/07/2022|Public
  173|15/09/2022|Privé
  173|28/12/2022|Public
  173|02/04/2023|Privé
  173|06/06/2024|Privé
  211|02/07/2024|Privé
  ;
run;

proc sort data = Financement_sas;by Identifiant Date Financement;run;
data Financement_sas;
  set Financement_sas;
  Financement_1 = lag(Financement);
  by Identifiant;
  retain Etat;
  if      first.Identifiant            then Etat = 1;
  else if Financement = Financement_1  then Etat = Etat;
  else if Financement ne Financement_1 then Etat = Etat + 1;
run;
```

## R base {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# On suppose que l'on dispose d'une base sur le type de financement de la formation
financement_rbase <- data.frame(
  identifiant = c(rep("173", 6), "211"),
  date = c("02/01/2022", "18/07/2022", "15/09/2022", "28/12/2022", "02/04/2023", "06/06/2024", "02/07/2024"),
  financement = c("Public", "Public", "Privé", "Public", "Privé", "Privé", "Privé")
)
financement_rbase$date <- lubridate::dmy(financement_rbase$date)
financement_rbase <- financement_rbase[order(financement_rbase$identifiant, financement_rbase$date, na.last = FALSE), ]
financement_rbase$etat <- rep(seq_along(rle(financement_rbase$financement)$values), 
                              times = rle(financement_rbase$financement)$lengths)
```

## tidyverse {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# On suppose que l'on dispose d'une base sur le type de financement de la formation
financement_tidyverse <- data.frame(
  identifiant = c(rep("173", 6), "211"),
  date = c("02/01/2022", "18/07/2022", "15/09/2022", "28/12/2022", "02/04/2023", "06/06/2024", "02/07/2024"),
  financement = c("Public", "Public", "Privé", "Public", "Privé", "Privé", "Privé")
)

financement_tidyverse %>% 
  arrange(identifiant, date) %>% 
  group_by(identifiant) %>% 
  mutate(etat = consecutive_id(financement))
```

## data.table {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# On suppose que l'on dispose d'une base sur le type de financement de la formation
financement_datatable <- data.table(
  identifiant = c(rep("173", 6), "211"),
  date = c("02/01/2022", "18/07/2022", "15/09/2022", "28/12/2022", "02/04/2023", "06/06/2024", "02/07/2024"),
  financement = c("Public", "Public", "Privé", "Public", "Privé", "Privé", "Privé")
)

setorder(financement_datatable, identifiant, date)
financement_datatable[, etat := rleid(financement_datatable), by = identifiant]
```

## arrow/duckdb {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}

```

## pandas {.unnumbered .unlisted}
```{python, warning=FALSE, message=FALSE, results='hide', python.reticulate = FALSE}
financement_python = pd.DataFrame({
    'identifiant': ['173']*6 + ['211'],
    'date': ['02/01/2022', '18/07/2022', '15/09/2022', '28/12/2022', '02/04/2023', '06/06/2024', '02/07/2024'],
    'financement': ['Public', 'Public', 'Privé', 'Public', 'Privé', 'Privé', 'Privé']
})

# Création de la fonction pour identifier les groupes consécutifs
def consecutive_id(series):
    return (series != series.shift()).cumsum()
  
  # Transformation des dates en format datetime
financement_python['date'] = pd.to_datetime(financement_python['date'], format='%d/%m/%Y')

# Tri des données par identifiant et date
financement_python = financement_python.sort_values(by=['identifiant', 'date'])

# Application de la fonction pour identifier les groupes consécutifs
financement_python['etat'] = (
    financement_python.groupby('identifiant')['financement']
    .transform(consecutive_id)
)

```

:::