# Sélection de colonnes

## Sélectionner des colonnes par position
::: {.panel-tabset group="language"}

## SAS {.unnumbered .unlisted}
``` sas
%let pos = 1;
proc contents data = donnees_sas out = Var noprint;run;

proc sql noprint;
  select name into :nom_col separated by " "
  from Var
  where varnum = &pos.;
run;

data Colonnes;set donnees_sas (keep = &nom_col.);run;
proc datasets lib = Work nolist;delete Var;run;
```

## R base {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
pos <- 1
# Résultat sous forme de vecteur caractère
id <- donnees_rbase[[pos]] ; class(id)
id <- donnees_rbase[, pos] ; class(id)

# Résultat sous forme de data.frame
id <- donnees_rbase[pos] ; class(id)
# Attention, utilisation du drop = FALSE étrange
# En fait, l'affectation par [] a pour option par défaut drop = TRUE. Ce qui implique que si l'affectation renvoie un data.frame d'1 seule colonne, l'objet sera transformé en objet plus simple (vecteur en l'occurrence)
id <- donnees_rbase[, pos, drop = FALSE] ; class(id)
```

## tidyverse {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Sous forme de vecteur
id <- donnees_tidyverse %>% pull(1)
class(id)
pos <- 1
id <- donnees_tidyverse %>% pull(all_of(pos))
class(id)

# Sous forme de tibble
id <- donnees_tidyverse %>% select(1)
class(id)
pos <- 1
id <- donnees_tidyverse %>% select(all_of(pos))
class(id)
```

## data.table {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
pos <- 1
# Résultat sous forme de vecteur caractère
id <- donnees_datatable[[pos]] ; class(id)

# Résultat sous forme de data.table
id <- donnees_datatable[pos] ; class(id)
```

## arrow/duckdb {.unnumbered .unlisted}

En DuckDB, il y a une vraie différence entre `select` et `pull`. Dans le premier cas, les calculs restent du côté DuckDB, et c'est donc le moteur SQL qui continue à exécuter les calculs. Avec `pull`, le résultat est un `tibble` et les données sont transférées à la session R.

```{r, warning=FALSE, message=FALSE}
requete_duckdb %>% select(3)
```

:::

## Sélectionner des colonnes par nom
::: {.panel-tabset group="language"}

## SAS {.unnumbered .unlisted}
``` sas
data Colonnes;set donnees_sas (keep = identifiant);run;
data Colonnes;set donnees_sas;keep identifiant;run;
```

## R base {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Résultat sous forme de vecteur caractère
id <- donnees_rbase$identifiant ; class(id)
id <- donnees_rbase[["identifiant"]] ; class(id)
id <- donnees_rbase[, "identifiant"] ; class(id)

# Résultat sous forme de data.frame
id <- donnees_rbase[, "identifiant"] ; class(id)
id <- donnees_rbase["identifiant"] ; class(id)

# Attention, utilisation du drop = FALSE étrange
# En fait, l'affectation par [] a pour option par défaut drop = TRUE. Ce qui implique que si l'affectation renvoie un data.frame d'1 seule colonne, l'objet sera transformé en objet plus simple (vecteur en l'occurrence)
id <- donnees_rbase[, "identifiant", drop = FALSE] ; class(id)
```

## tidyverse {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Sous forme de vecteur
id <- donnees_tidyverse %>% pull(identifiant)
id <- donnees_tidyverse %>% pull("identifiant")

# Sous forme de tibble
id <- donnees_tidyverse %>% select(identifiant)
id <- donnees_tidyverse %>% select("identifiant")
```

## data.table {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Résultat sous forme de vecteur caractère
id <- donnees_datatable$identifiant ; class(id)
id <- donnees_datatable[["identifiant"]] ; class(id)
id <- donnees_datatable[, identifiant] ; class(id)

# Résultat sous forme de data.table
id <- donnees_datatable[, "identifiant"] ; class(id)
# Ne fonctionnent pas !
#id <- donnees_datatable[, .("identifiant")] ; class(id)
#id <- donnees_datatable[J("identifiant")] ; class(id)
#id <- donnees_datatable[, list("identifiant")] ; class(id)
#id <- donnees_datatable[list("identifiant")] ; class(id)
```

## arrow/duckdb {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}
requete_duckdb %>% select(identifiant)
requete_duckdb %>% select("identifiant")
requete_duckdb %>% select(any_of("identifiant"))
```
Note : on déconseille l'utilisation de `select` sur des chaînes de caractère : certaines fonction du tidyvers nécessient de passer par les opérateurs `any_of` ou `all_of` pour ce genre d'opérations (`distinct` par exemple).

:::

## Sélectionner des colonnes par un vecteur de noms
::: {.panel-tabset group="language"}

## SAS {.unnumbered .unlisted}
``` sas
%let var = identifiant Sexe note_contenu;
data Colonnes;
  /* Sélection de colonnes */
  set donnees_sas (keep = &var.);
  /* Autre solution */
  keep &var.;
run;
```

## R base {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
variable <- "identifiant"
# Résultat sous forme de vecteur caractère
id <- donnees_rbase[, variable] ; class(id)
id <- donnees_rbase[[variable]] ; class(id)

# Résultat sous forme de data.frame
id <- donnees_rbase[variable] ; class(id)
# Attention, utilisation du drop = FALSE étrange
# En fait, l'affectation par [] a pour option par défaut drop = TRUE. Ce qui implique que si l'affectation renvoie un data.frame d'1 seule colonne, l'objet sera transformé en objet plus simple (vecteur en l'occurrence)
id <- donnees_rbase[, variable, drop = FALSE] ; class(id)
```

## tidyverse {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
variable <- "identifiant"
# Sous forme de vecteur
id <- donnees_tidyverse %>% pull(all_of(variable))
# Sous forme de tibble
id <- donnees_tidyverse %>% select(all_of(variable))
```

## data.table {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# Résultat sous forme de vecteur caractère
variable <- "identifiant"
id <- donnees_datatable[[variable]] ; class(id)
id <- donnees_datatable[, get(variable)] ; class(id)

# Résultat sous forme de data.table
id <- donnees_datatable[, ..variable] ; class(id)
id <- donnees_datatable[, variable, with = FALSE] ; class(id)
id <- donnees_datatable[, .SD, .SDcols = variable] ; class(id)
id <- donnees_datatable[, variable, env = list(variable = as.list(variable))] ; class(id)

# Attention, ces syntaxes ne fonctionnent pas ! Il faut nécessairement passer par les syntaxes au-dessus.
#id <- donnees_datatable[, .(variable)] ; class(id)
#id <- donnees_datatable[, list(variable)] ; class(id)
```

## arrow/duckdb {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}
variable <- c("identifiant","duree")
requete_duckdb %>% select(any_of(variable))
```

:::

## Sauf certaines variables
::: {.panel-tabset group="language"}

## SAS {.unnumbered .unlisted}
``` sas
%let var = identifiant Sexe note_contenu;
data Colonnes;set donnees_sas (drop = &var.);run;
```

## R base {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
variable <- c("identifiant", "sexe", "note_contenu")
exclusion_var <- donnees_rbase[, setdiff(names(donnees_rbase), variable)]

# Ne fonctionne pas !
#exclusion_var <- donnees_rbase[, -c(variable)]
```

## tidyverse {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
variable <- c("identifiant", "sexe", "note_contenu")
exclusion_var <- donnees_tidyverse %>% select(!all_of(variable))
exclusion_var <- donnees_tidyverse %>% select(-all_of(variable))
```

## data.table {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
variable <- c("identifiant", "sexe", "note_contenu")
exclusion_var <- donnees_datatable[, !..variable]
```

## arrow/duckdb {.unnumbered .unlisted}

Les opérateurs `-` et `!` fonctionnent.

```{r, warning=FALSE, message=FALSE}
requete_duckdb %>% select(!identifiant)
requete_duckdb %>% select(-all_of(variable))
```

:::

## Sélectionner la 3e colonne
::: {.panel-tabset group="language"}

## SAS {.unnumbered .unlisted}
``` sas
proc contents data = donnees_sas out = Var noprint;run;

proc sql noprint;
  select name into :nom_col separated by " "
  from Var
  where varnum = 3;
run;

data Col3;set donnees_sas (keep = &nom_col.);run;
```

## R base {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
col3 <- donnees_rbase[, 3]
col3 <- donnees_rbase[3]
```

## tidyverse {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
col3 <- donnees_tidyverse %>% pull(3)
col3 <- donnees_tidyverse %>% select(3)
```

## data.table {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
col3 <- donnees_datatable[, 3]
```

## arrow/duckdb {.unnumbered .unlisted}

```{r, warning=FALSE, message=FALSE}
requete_duckdb %>% select(3)
```

:::

## Sélectionner plusieurs colonnes
::: {.panel-tabset group="language"}

## SAS {.unnumbered .unlisted}
``` sas
%let var = identifiant note_contenu sexe;
data Colonnes;set donnees_sas (keep = &var.);run;

/* Autre solution */
/* En SQL, les variables sélectionnées dans l'instruction SELECT sont séparées par des virgules. On ajoute des virgules entre les variables. */
proc sql;
  create table Colonnes as
  select %sysfunc(tranwrd(&var., %str( ), %str(, )))
  from donnees_sas;
quit;
```

## R base {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
cols <- c("identifiant", "note_contenu", "sexe")
colonnes <- donnees_rbase[, cols]
```

## tidyverse {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
cols <- c("identifiant", "note_contenu", "sexe")
# Plusieurs possibilités
colonnes <- donnees_tidyverse %>% select(all_of(cols))
colonnes <- donnees_tidyverse %>% select(any_of(cols))
colonnes <- donnees_tidyverse %>% select({{ cols }})
colonnes <- donnees_tidyverse %>% select(!!cols)
```

## data.table {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
cols <- c("identifiant", "note_contenu", "sexe")
# Plusieurs écritures possibles

# Ecriture cohérente avec la logique data.table
colonnes <- donnees_datatable[, .SD, .SDcols = cols]

# Ecriture avec with = FALSE : désactive la possibilité de se référer à des colonnes sans les guillemets
colonnes <- donnees_datatable[, cols, with = FALSE]

# Ecriture avec mget
colonnes <- donnees_datatable[, mget(cols)]

# Ecriture un peu contre-intuitve. Attention ! L'écriture est bien ..cols, et non ..(cols) !!
# Les syntaxes donnees_datatable[, ..(cols)] et donnees_datatable[, .(cols)] ne fonctionnent pas
colonnes <- donnees_datatable[, ..cols]
```

## arrow/duckdb {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}
cols <- c("identifiant", "note_contenu", "sexe")
# Plusieurs possibilités
requete_duckdb %>% select(all_of(cols))
requete_duckdb %>% select(any_of(cols))
requete_duckdb %>% select({{ cols }})
requete_duckdb %>% select(!!cols)
```
:::

## Sélectionner les colonnes qui débutent par le mot Note
::: {.panel-tabset group="language"}

## SAS {.unnumbered .unlisted}
``` sas
/* 1ère solution */
data Selection_Variables;set donnees_sas (keep = Note:);run;

/* 2e solution */
proc contents data = donnees_sas out = Var noprint;run;
proc sql;
  select name into :var_notes separated by " "
  from Var where substr(upcase(name), 1, 4) = "NOTE" order by varnum;
run;
proc datasets lib = Work nolist;delete Var;run;
data donnees_sas_Notes;set donnees_sas (keep = &var_notes.);run;
```

## R base {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
varNotes <- donnees_rbase[grepl("^note", names(donnees_rbase))]
varNotes <- donnees_rbase[substr(tolower(names(donnees_rbase)), 1, 4) == "note"]
```

## tidyverse {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
varNotes <- donnees_tidyverse %>% select(starts_with("note"))
```

## data.table {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
# 1ère méthode
cols <- names(donnees_datatable)[substr(names(donnees_datatable), 1, 4) == "note"]
# Ou encore
cols <- names(donnees_datatable)[names(donnees_datatable) %like% "^note"]

sel <- donnees_datatable[, .SD, .SDcols = cols]

# 2e méthode
sel <- donnees_datatable[, .SD, .SDcols = patterns("^note")]
```

## arrow/duckdb {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}
requete_duckdb %>% select(starts_with("note"))
```
:::

## Sélectionner les colonnes qui ne débutent pas par le mot Note
::: {.panel-tabset group="language"}

## SAS {.unnumbered .unlisted}
``` sas
data Selection_Variables;set donnees_sas (drop = Note:);run;
```

## R base {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
varNotes <- donnees_rbase[! grepl("^note", names(donnees_rbase))]
varNotes <- donnees_rbase[substr(tolower(names(donnees_rbase)), 1, 4) != "note"]
```

## tidyverse {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
varNotes <- donnees_tidyverse %>% select(-starts_with("note"))
varNotes <- donnees_tidyverse %>% select(!starts_with("note"))
```

## data.table {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
cols <- grep("^note", names(donnees_datatable), value = TRUE, ignore.case = TRUE)
sel <- donnees_datatable[, .SD, .SDcols = -cols]
sel <- donnees_datatable[, .SD, .SDcols = -patterns("^note")]
```

## arrow/duckdb {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}
requete_duckdb %>% select(-starts_with("note"))
requete_duckdb %>% select(!starts_with("note"))
```
:::

## Sélectionner l'ensemble des variables numériques de la base
::: {.panel-tabset group="language"}

## SAS {.unnumbered .unlisted}
``` sas
data Colonnes;set donnees_sas (keep = _numeric_);run;
```

## R base {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
varNumeriques <- donnees_rbase[, sapply(donnees_rbase, is.numeric), drop = FALSE]
```

## tidyverse {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
varNumeriques <- donnees_tidyverse %>% select(where(is.numeric))
varNumeriques <- donnees_tidyverse %>% select_if(is.numeric)
```

## data.table {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
sel <- donnees_datatable[, .SD, .SDcols = is.numeric]
```

## arrow/duckdb {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}
requete_duckdb %>% select_if(is.numeric)
# requete_duckdb %>% select(where(is.numeric))
```
:::

## Sélectionner l'ensemble des variables de format "Date"
::: {.panel-tabset group="language"}

## SAS {.unnumbered .unlisted}
``` sas
proc contents data = donnees_sas out = Var noprint;run;
proc sql noprint;
  select name into :nom_col separated by " "
  from Var where format not in ("$", "");
run;
data Colonnes;set donnees_sas (keep = &nom_col.);run;
proc datasets lib = Work nolist;delete Var;run;
```

## R base {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
varDates <- donnees_rbase[, sapply(donnees_rbase, is.Date), drop = FALSE]
varDates <- Filter(is.Date, donnees_rbase)
```

## tidyverse {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
varDates <- donnees_tidyverse %>% select(where(is.Date))
varDates <- donnees_tidyverse %>% select_if(is.Date)
```

## data.table {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE, results='hide'}
var_dates <- donnees_datatable[, .SD, .SDcols = is.Date]
```

## arrow/duckdb {.unnumbered .unlisted}
```{r, warning=FALSE, message=FALSE}
requete_duckdb %>% select_if(is.Date)
# requete_duckdb %>% select(where(is.Date))
```
:::
