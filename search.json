[
  {
    "objectID": "04-specificites_sas_r.html",
    "href": "04-specificites_sas_r.html",
    "title": "Spécificités de SAS par rapport à R",
    "section": "",
    "text": "Voici une liste non-exhaustive de spécificités de SAS par rapport à R à connaître.",
    "crumbs": [
      "Spécificités de SAS et R"
    ]
  },
  {
    "objectID": "04-specificites_sas_r.html#logiciel-libre",
    "href": "04-specificites_sas_r.html#logiciel-libre",
    "title": "Spécificités de SAS par rapport à R",
    "section": "1 Logiciel libre",
    "text": "1 Logiciel libre\nDe par son statut de logiciel libre, de multiples extensions existent (packages). L’usage des packages :\n\npeut être un atout, car les packages permettent de réaliser plus facilement des choses complexes ;\npeut aussi être source de problèmes, d’abord de maintenance du fait des dépendances (une mise-à-jour peut casser les dépendances), ensuite du fait que des packages peuvent disparaître ou ne plus être maintenus au cours du temps, engendrant des coûts de maintenance de code ;\npeut engendrer des problèmes de rétrocompatibilité (un code écrit dans le passé ne fonctionne plus suite à une mise-à-jour) : il convient d’être conscient de ces considérations avant d’utiliser aveuglément des packages.",
    "crumbs": [
      "Spécificités de SAS et R"
    ]
  },
  {
    "objectID": "04-specificites_sas_r.html#gestion-de-la-mémoire",
    "href": "04-specificites_sas_r.html#gestion-de-la-mémoire",
    "title": "Spécificités de SAS par rapport à R",
    "section": "2 Gestion de la mémoire",
    "text": "2 Gestion de la mémoire\nLa gestion de la mémoire est différente entre les logiciels. R importe l’ensemble des données en mémoire vive, SAS en copie une partie sur le disque dur. Ceci a plusieurs implications pour le travail statistique :\n\nsi le volume des données excède la mémoire vive, il n’est pas possible de les traiter nativement en R. Il faut alors utiliser des stratégies alternatives ;\nil faut être parcimonieux sur le nombre de colonnes à inclure dans les bases de données en R. Par exemple, il vaut mieux recréer dans le programme les variables explicatives faciles à obtenir plutôt que les inclure dans la base de données, où elles occupent de la place et accaparent de la mémoire vive.\n\nQuelles solutions adopter dans le cas où les données à manipuler ne tiennent pas en mémoire vive de l’ordinateur ?\n\nchercher à réduire la taille de la base de données en supprimant des colonnes inutiles ;\nchercher à modifier le processus de production pour le rendre moins gourmand en mémoire ;\naugmenter la mémoire vive de son ordinateur ;\nutiliser les packages Arrow et DuckDb qui peuvent gérer des données excédant la mémoire vive.",
    "crumbs": [
      "Spécificités de SAS et R"
    ]
  },
  {
    "objectID": "Trucs et astuces en R.html",
    "href": "Trucs et astuces en R.html",
    "title": "Trucs et astuces en R",
    "section": "",
    "text": "Voici quelques trucs et astuces utiles à connaître sur R, issus en partie des livres The R Inferno et Advanced R, à consulter pour plus de détails.\n\n\n1 Effets des calculs en virgule flottante\n\nsqrt(2) ^ 2 == 2\n\n[1] FALSE\n\n1 / 49 * 49 == 1\n\n[1] FALSE\n\n.1 == .3 / 3\n\n[1] FALSE\n\nseq(0, 1, by=.1) == .3\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\nunique(c(.3, .4 - .1, .5 - .2, .6 - .3, .7 - .4))\n\n[1] 0.3 0.3 0.3\n\n\n\n\n2 Les types d’objet\n\n# En savoir plus sur ses données\ndata(\"cars\")\ntypeof(cars)\n\n[1] \"list\"\n\nclass(cars)\n\n[1] \"data.frame\"\n\nmode(cars)\n\n[1] \"list\"\n\nstr(cars)\n\n'data.frame':   50 obs. of  2 variables:\n $ speed: num  4 4 7 7 8 9 10 10 10 11 ...\n $ dist : num  2 10 4 22 16 10 18 26 34 17 ...\n\ndim(cars)\n\n[1] 50  2\n\nc(is.data.frame(cars), is.list(cars), is.vector(cars), is.array(cars))\n\n[1]  TRUE  TRUE FALSE FALSE\n\n\nNotation L\n\n# Notation L : imposer à R de créer un nombre sous format \"integer\", pour des raisons d'efficacité\nclass(1)\n\n[1] \"numeric\"\n\nclass(1L)\n\n[1] \"integer\"\n\n\n\n\n3 Les affectations\n\n# Importance des espaces\nx&lt;-3\n# S'agit-il de ?\nx &lt;- 3\n# Ou de ?\nx &lt; -3\n\n[1] FALSE\n\n# Il s'agit du premier cas !\nx\n\n[1] 3\n\n\n\n# Les {} permettent de réaliser une affectation (&lt;-) au sein d'un traitement plus complexe !\n# Exemple ici : sommer les positions paires multipliées par 2 et les positions impaires multipliées par 3\nsum({x &lt;- 1:6 ; x[1:length(x) %% 2 == 0] &lt;- x[1:length(x) %% 2 == 0] * 2 ; x[1:length(x) %% 2 != 0] &lt;- x[1:length(x) %% 2 != 0] * 3 ; x})\n\n[1] 51\n\n\n\n# Afficher ou non la valeur de l'objet affecté pendant l'affectation\nx &lt;- pi\n(x &lt;- pi)\n\n[1] 3.141593\n\n\n\n# Comparaisons multiples\nx &lt;- 0.5\n# Correct\n0 &lt; x & x &lt; 1\n# Incorrect\n0 &lt; x &lt; 1\n\nError: &lt;text&gt;:6:7: unexpected '&lt;'\n5: # Incorrect\n6: 0 &lt; x &lt;\n         ^\n\n\n\n# Ne pas confondre !\nseq(0:10)\n\n [1]  1  2  3  4  5  6  7  8  9 10 11\n\n0:10\n\n [1]  0  1  2  3  4  5  6  7  8  9 10\n\nseq(0, 10)\n\n [1]  0  1  2  3  4  5  6  7  8  9 10\n\n\n\n# Privilégier seq_len à : lorsqu'il y a un risque de 0\n# Fonctionnement identique\nn &lt;- 5\n1:n\n\n[1] 1 2 3 4 5\n\nseq_len(n)\n\n[1] 1 2 3 4 5\n\n# Problème avec les 0\nn &lt;- 0\n1:n\n\n[1] 1 0\n\nseq_len(n)\n\ninteger(0)\n\n\n\n# Préférer seq_along à : au cas où la taille de l'objet est 0\nx &lt;- c() ;length(x)\n\n[1] 0\n\nfor(i in 1:length(x)) print(i)\n\n[1] 1\n[1] 0\n\nfor(i in seq_along(x)) print(i)\nfor(i in seq(along=x)) print(i)\n\n\n# Equivalent des list-comprehensions de type Python en R\n# Somme des entiers de 1 à 1 000 multiples de 3 ou 5, en une ligne !\n# 4 manières de faire\nsum({l &lt;- 1:1000 ; l[l %% 3 == 0 | l %% 5 == 0]})\n\n[1] 234168\n\nsum({l &lt;- 1:1000 ; l[seq_along(l) %% 3 == 0 | seq_along(l) %% 5 == 0]})\n\n[1] 234168\n\nsum(l&lt;-(1:1000)[l %% 3 == 0 | l %% 5 == 0])\n\n[1] 234168\n\nsum((1:1000)[(1:1000 %% 3) == 0 | (1:1000 %% 5) == 0])\n\n[1] 234168\n\n\n\n# Opérations mathématiques\n# Infini\n1/0\n\n[1] Inf\n\n# Nan = not a number\n0/0\n\n[1] NaN\n\nlog(-1)\n\n[1] NaN\n\n\n\n\n4 Principe de vectorisation\nLa fonction s’applique à tous les éléments du vecteur !!\n\n# Exemple de vecteur\nvaleurs &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nvaleurs &lt;- 1:10\n\n\n# Valeurs au carré\nvaleurs ** 2\n\n [1]   1   4   9  16  25  36  49  64  81 100\n\n\n\n# logarithme des valeurs\nlog(valeurs)\n\n [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 1.7917595 1.9459101\n [8] 2.0794415 2.1972246 2.3025851\n\n\n\n# Maximum des valeurs\nmax(valeurs)\n\n[1] 10\n\n\n\n# Limite des valeurs\nrange(valeurs)\n\n[1]  1 10\n\n\n\n# Correct\nmean(valeurs)\n\n[1] 5.5\n\n\n\n# Correct\nmean(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))\n\n[1] 5.5\n\n\n\n# Inattendu\nmean(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n\n[1] 1\n\n\n\n# Attention aux parenthèses !\nn &lt;- 10\n# Inattendu ! Correspond à (1-1, 2-1, 3-1, ..., 10-1)\n1:n-1\n\n [1] 0 1 2 3 4 5 6 7 8 9\n\n# Correct\n1:(n-1)\n\n[1] 1 2 3 4 5 6 7 8 9\n\n\n\n# Minimum ou maximum élément par élément\nx1 &lt;- c(1, 2, 5, 6, 8)\nx2 &lt;- c(4, 0, 7, 2, 1)\n# Minimum : 2 possibilités\npmin(x1, x2)\n\n[1] 1 0 5 2 1\n\nmapply(min, x1, x2)\n\n[1] 1 0 5 2 1\n\n# Maximum : 2 possibilités\npmax(x1, x2)\n\n[1] 4 2 7 6 8\n\nmapply(max, x1, x2)\n\n[1] 4 2 7 6 8\n\n\n\n# Calculer (x - min) / (max - min) pour chaque élément x d'un vecteur\nx &lt;- c(1,2,3)\nsapply(x, function(xi, mn, mx) {(xi - mn) / (mx - mn)}, mn = min(x), mx = max(x))\n\n[1] 0.0 0.5 1.0\n\n\n\n\n5 Principe de coercion\nDans les comparaisons, les objets R sont successivement convertis en logical, integer, numeric, complex et character, jusqu’à ce que la comparaison puisse se faire.\n\n# TRUE / FALSE est transformé en integer (1 / 0)\nTRUE == 1\n\n[1] TRUE\n\nTRUE == 2\n\n[1] FALSE\n\nFALSE == 0\n\n[1] TRUE\n\n\n\n# TRUE est convertit en character\nTRUE == \"1\"\n\n[1] FALSE\n\n\n\n# 5 est convertit en character\n5 &lt; '7'\n\n[1] TRUE\n\n\n\n# 50 est convertit en character\n50 &lt; '7'\n\n[1] TRUE\n\n\n\n\n6 Principe de recycling\n\n# Fonctionne sans soulever de message d'erreur\nx &lt;- c(1, 2, 3)\ny &lt;- c(1, 2, 3, 4, 5, 6)\nx + y\n\n[1] 2 4 6 5 7 9\n\n\n\n# Fonctionne, mais Warning\nx &lt;- c(1, 2, 3)\ny &lt;- c(1, 2, 3, 4, 5, 6, 7)\nx + y\n\nWarning in x + y: longer object length is not a multiple of shorter object\nlength\n\n\n[1] 2 4 6 5 7 9 8\n\n\n\n\n7 Opérateurs de contrôle\n\n# Conditions if / else\nx &lt;- 1\n\n\n# Correct\nif (identical(x, 1)) {\nprint(\"x est égal à 1\")\n} else {\nprint(\"x est différent de 1\")\n}\n\n[1] \"x est égal à 1\"\n\n\n\n# Correct\nif (identical(x, 1)) {print(\"x est égal à 1\")\n} else {print(\"x est différent de 1\")}\n\n[1] \"x est égal à 1\"\n\n\n\n# Correct\nif (identical(x, 1)) print(\"x est égal à 1\") else\nprint(\"x est différent de 1\")\n\n[1] \"x est égal à 1\"\n\n\n\n# Correct\nif (identical(x, 1)) print(\"x est égal à 1\") else print(\"x est différent de 1\")\n\n[1] \"x est égal à 1\"\n\n\n\n# Incorrect\nif (identical(x, 1)) print(\"x est égal à 1\")\nelse print(\"x est différent de 1\")\n\nError: &lt;text&gt;:3:1: unexpected 'else'\n2: if (identical(x, 1)) print(\"x est égal à 1\")\n3: else\n   ^\n\n\n\n# Switch\n# Fonctions et conditions if / else\ncondition &lt;- function(langue = \"Français\") {\nif (langue == \"Français\") {\n\"salut\"\n} else if (langue == \"Anglais\") {\n\"hello\"\n} else if (langue == \"Russe\") {\n\"привет\"\n} else {\nstop(\"salut\")\n}\n}\ncondition(\"Anglais\")\n\n[1] \"hello\"\n\n\n\n# Autre possibilité avec switch, mais à réserver aux variables caractères !\ncondition &lt;- function(langue = \"Français\") {\nswitch(langue,\nFrançais = \"salut\",\nAnglais = \"hello\",\nRusse = \"привет\",\nstop(\"salut\")\n)\n}\ncondition(\"Français\")\n\n[1] \"salut\"\n\n\n\n# Penser au print\nfor(i in 1:5) i\nfor(i in 1:5) print(i)\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n\n\n\n# Différences print et cat\ncat(\"Salut !\\nComment vas-tu ?\")\n\nSalut !\nComment vas-tu ?\n\nprint(\"Salut !\\nComment vas-tu ?\")\n\n[1] \"Salut !\\nComment vas-tu ?\"\n\n\n\n\n8 Les valeurs manquantes\n\n# Transformer les valeurs manquantes en 0\nx &lt;- data.frame(X1 = c(1, NA, 2), X2 = c(NA, NA, 3))\nx\n\n  X1 X2\n1  1 NA\n2 NA NA\n3  2  3\n\nx[is.na(x)] &lt;- 0\nx\n\n  X1 X2\n1  1  0\n2  0  0\n3  2  3\n\n\n\n# Pour les valeurs manquantes, toujours utiliser is.na et non ==\nNA == c(3, 1, 3, NA)\n\n[1] NA NA NA NA\n\nis.na(c(3, 1, 3, NA))\n\n[1] FALSE FALSE FALSE  TRUE\n\n\n\n# Utiliser %in% et non == pour vérifier une appartenance à plusieurs variables\nx1 &lt;- 1:6\nx1 == c(1, 5)\n\n[1]  TRUE FALSE FALSE FALSE FALSE FALSE\n\nx1 %in% c(1, 5)\n\n[1]  TRUE FALSE FALSE FALSE  TRUE FALSE\n\n\n\n# Sélection de données en cas de valeurs manquantes\nxna &lt;- c(1, NA, 3, 2, 4, 2)\n\n\n# Avec ce code, les NA sont conservés\nxna[xna == 2]\n\n[1] NA  2  2\n\n\n\n# Code sans les NA\nxna[!is.na(xna) & xna == 2]\n\n[1] 2 2\n\n\n\n# Code compact sans les NA\nxna[which(xna == 2)]\n\n[1] 2 2\n\n\n\n# Incidence des NA dans le calcul de statistiques !\n# Besoin de l'instruction na.rm = TRUE pour en supprimer l'incidence\nx &lt;- c(1, 5, 6, NA, 8)\nmean(x)\n\n[1] NA\n\nmean(x, na.rm = TRUE)\n\n[1] 5\n\nmax(x)\n\n[1] NA\n\nmax(x, na.rm = TRUE)\n\n[1] 8\n\n\n\n# Une moyenne de NA donne NaN (Not a Number) avec na.rm = TRUE !\nmean(c(NA, NA, NA), na.rm = TRUE)\n\n[1] NaN\n\n# Et donne NA avec na.rm = FALSE !\nmean(c(NA, NA, NA), na.rm = FALSE)\n\n[1] NA\n\n\n\n\n9 Sélection d’éléments\n\n# Le 1er élément est numéroté 1 et non 0 comme dans Python\nx &lt;- 1:3\nx[c(0, 4)] &lt;- c(-1, 9)\n# Marche !!\nfor(i in 0:3) print(x[i])\n\nnumeric(0)\n[1] 1\n[1] 2\n[1] 3\n\n\n\n# Cas où les noms ne sont pas uniques\nx &lt;- c(a = 1, b = 2, a = 3)\nx[\"a\"]\n\na \n1 \n\nx[names(x) %in% \"a\"]\n\na a \n1 3 \n\n\n\n# Options drop = FALSE\nx &lt;- data.frame(X1 = c(1,2), X2 = c(3,4), x3 = c(5,6))\nis.data.frame(x[, c(1,2)])\n\n[1] TRUE\n\nis.data.frame(x[, c(1)])\n\n[1] FALSE\n\nis.data.frame(x[, c(1), drop = FALSE])\n\n[1] TRUE\n\n\n\n# Fonction subset\nx &lt;- data.frame(x1 = c(1,2), x2 = c(3,4), x3 = c(5,6))\nsubset(x, select = x1)\n\n  x1\n1  1\n2  2\n\nsubset(x, select = -x1)\n\n  x2 x3\n1  3  5\n2  4  6\n\n\n\n# Correct\nsubset(x, x1 == 1)\n\n  x1 x2 x3\n1  1  3  5\n\n\n\n# Incorrect\nsubset(x, x1 = 1)\n\n  x1 x2 x3\n1  1  3  5\n2  2  4  6\n\n\n\n# Référence à des noms de colonne non usuels\ndf &lt;- data.frame(x = rnorm(5), y = runif(5))\nnames(df) &lt;- 1:2\n\n# Correct\ndf$`1`\n\n# Incorrect\ndf$1\n\nError: &lt;text&gt;:9:4: unexpected numeric constant\n8: # Incorrect\n9: df$1\n      ^\n\n\n\n# Utilisation de assign pour assigner une valeur à un objet en le désignant sous forme caractère\nassign('objet', 3:5)\nobjet\n\n[1] 3 4 5\n\nfor(i in 1:5) assign(paste('objet', i, sep = '_'), i)\nobjet_5\n\n[1] 5\n\n\n\n\n10 Les listes\n\n# Ajouter un élément à une liste\nliste &lt;- list(1, 2)\n# Il faut passer par cette syntaxe\nliste &lt;- c(liste, list(3))\nliste\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n\n\n\n# Trier une liste\nliste &lt;- list(\"2\" = 2, \"0\" = 0, \"1\" = 1)\nliste\n\n$`2`\n[1] 2\n\n$`0`\n[1] 0\n\n$`1`\n[1] 1\n\nliste[order(names(liste))]\n\n$`0`\n[1] 0\n\n$`1`\n[1] 1\n\n$`2`\n[1] 2\n\n\n\n# Extraction de listes\nliste &lt;- list(nombres = 1:5, lettres = letters[1:5])\nliste$nombres\n\n[1] 1 2 3 4 5\n\n\n\n# On veut faire appel à un élement de la liste à partir d'une variable extérieure\nvar &lt;- \"nombres\"\n\n\n# Ne marche pas, car nombres est en caractère\nliste$var\n\nNULL\n\n\n\n# Fonctionne\nliste[[var]]\n\n[1] 1 2 3 4 5\n\n\n\n# Sélection dans une liste\nliste &lt;- list(nombres = 1:5, lettres = letters[1:5])\nliste[\"nombres\"]\n\n$nombres\n[1] 1 2 3 4 5\n\nis.list(liste[\"nombres\"])\n\n[1] TRUE\n\nliste[[\"nombres\"]]\n\n[1] 1 2 3 4 5\n\nis.list(liste[[\"nombres\"]])\n\n[1] FALSE\n\n\n\n# Suppression des éléments d'une liste\nliste &lt;- list(nombres = 1:5, lettres = letters[1:5])\nliste[-1]\n\n$lettres\n[1] \"a\" \"b\" \"c\" \"d\" \"e\"\n\nliste[\"nombres\"] &lt;- NULL\nliste\n\n$lettres\n[1] \"a\" \"b\" \"c\" \"d\" \"e\"\n\n\n\n\n11 Informations sur R\n\n# Informations sur la session de R\nsessionInfo()\nSys.info()\n.Platform\n\n# Version de R\nR.version.string\n\n# Lien vers le bureau de l'utilisateur\nfile.path(path.expand('~'), \"Desktop\")\n\n# Chemin de l'exécutable R est-il installé ?\nR.home(\"bin\")\n\n# Où sont installés les packages R\n.libPaths()\n\n\n\n12 Trucs et astuces divers\n\n# Créer un objet sous forme de code R !\ndata(\"mtcars\")\ndput(mtcars)\n\nstructure(list(mpg = c(21, 21, 22.8, 21.4, 18.7, 18.1, 14.3, \n24.4, 22.8, 19.2, 17.8, 16.4, 17.3, 15.2, 10.4, 10.4, 14.7, 32.4, \n30.4, 33.9, 21.5, 15.5, 15.2, 13.3, 19.2, 27.3, 26, 30.4, 15.8, \n19.7, 15, 21.4), cyl = c(6, 6, 4, 6, 8, 6, 8, 4, 4, 6, 6, 8, \n8, 8, 8, 8, 8, 4, 4, 4, 4, 8, 8, 8, 8, 4, 4, 4, 8, 6, 8, 4), \n    disp = c(160, 160, 108, 258, 360, 225, 360, 146.7, 140.8, \n    167.6, 167.6, 275.8, 275.8, 275.8, 472, 460, 440, 78.7, 75.7, \n    71.1, 120.1, 318, 304, 350, 400, 79, 120.3, 95.1, 351, 145, \n    301, 121), hp = c(110, 110, 93, 110, 175, 105, 245, 62, 95, \n    123, 123, 180, 180, 180, 205, 215, 230, 66, 52, 65, 97, 150, \n    150, 245, 175, 66, 91, 113, 264, 175, 335, 109), drat = c(3.9, \n    3.9, 3.85, 3.08, 3.15, 2.76, 3.21, 3.69, 3.92, 3.92, 3.92, \n    3.07, 3.07, 3.07, 2.93, 3, 3.23, 4.08, 4.93, 4.22, 3.7, 2.76, \n    3.15, 3.73, 3.08, 4.08, 4.43, 3.77, 4.22, 3.62, 3.54, 4.11\n    ), wt = c(2.62, 2.875, 2.32, 3.215, 3.44, 3.46, 3.57, 3.19, \n    3.15, 3.44, 3.44, 4.07, 3.73, 3.78, 5.25, 5.424, 5.345, 2.2, \n    1.615, 1.835, 2.465, 3.52, 3.435, 3.84, 3.845, 1.935, 2.14, \n    1.513, 3.17, 2.77, 3.57, 2.78), qsec = c(16.46, 17.02, 18.61, \n    19.44, 17.02, 20.22, 15.84, 20, 22.9, 18.3, 18.9, 17.4, 17.6, \n    18, 17.98, 17.82, 17.42, 19.47, 18.52, 19.9, 20.01, 16.87, \n    17.3, 15.41, 17.05, 18.9, 16.7, 16.9, 14.5, 15.5, 14.6, 18.6\n    ), vs = c(0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, \n    0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1), am = c(1, \n    1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, \n    0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1), gear = c(4, 4, 4, 3, \n    3, 3, 3, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, \n    3, 3, 4, 5, 5, 5, 5, 5, 4), carb = c(4, 4, 1, 1, 2, 1, 4, \n    2, 2, 4, 4, 3, 3, 3, 4, 4, 4, 1, 2, 1, 1, 2, 2, 4, 2, 1, \n    2, 2, 4, 6, 8, 2)), row.names = c(\"Mazda RX4\", \"Mazda RX4 Wag\", \n\"Datsun 710\", \"Hornet 4 Drive\", \"Hornet Sportabout\", \"Valiant\", \n\"Duster 360\", \"Merc 240D\", \"Merc 230\", \"Merc 280\", \"Merc 280C\", \n\"Merc 450SE\", \"Merc 450SL\", \"Merc 450SLC\", \"Cadillac Fleetwood\", \n\"Lincoln Continental\", \"Chrysler Imperial\", \"Fiat 128\", \"Honda Civic\", \n\"Toyota Corolla\", \"Toyota Corona\", \"Dodge Challenger\", \"AMC Javelin\", \n\"Camaro Z28\", \"Pontiac Firebird\", \"Fiat X1-9\", \"Porsche 914-2\", \n\"Lotus Europa\", \"Ford Pantera L\", \"Ferrari Dino\", \"Maserati Bora\", \n\"Volvo 142E\"), class = \"data.frame\")\n\n\n\n# En tidyverse, la fonction tribble peut être utile pour créer des bases lignes par lignes\nlibrary(tidyverse)\ntribble(\n  ~x, ~y,\n  \"a\",   1,\n  \"b\",   2\n)\n\n# A tibble: 2 × 2\n  x         y\n  &lt;chr&gt; &lt;dbl&gt;\n1 a         1\n2 b         2\n\n\n\n# Outils de debuggage\noptions(error = recover)\noptions(error=NULL)\n\n\n# Définir ses propres opérateurs\n# R reconnait le texte entre %% comme un opérateur binaire\n# Exemple, simplifier la fonction paste\n'%+%' &lt;- function(x, y) { paste(x, y, sep = \"\") }\n\"Groupe_\" %+% 0:9\n\n [1] \"Groupe_0\" \"Groupe_1\" \"Groupe_2\" \"Groupe_3\" \"Groupe_4\" \"Groupe_5\"\n [7] \"Groupe_6\" \"Groupe_7\" \"Groupe_8\" \"Groupe_9\"\n\n\n\n\n13 Le pipe sur R\nCet opérateur permet d’enchaîner les opérations et d’avoir un code plus lisible.\nIl existe différents types :\n\nLe pipe de Rbase : |&gt;\nLe pipe du tidyverse : %&gt;%\n\nLes deux pipes fonctionnent de la même manière mais diffèrent sur les points suivants :\n\n\n\n\n\n\n\n\nThème\n|&gt;\n%&gt;%\n\n\n\n\nPlaceholder (pour indiquer où placer l’objet)\n_\nx |&gt; f(y, a = _)\n.\nx %&gt;% f(y, a = .)\n\n\nPackage\nAucun : directement sur R\nMagrittr (pipe disponible lorsqu’on effectue library(tidyverse)) |\n\n\nFonction\nImpossible\nPossible\n\n\nTemps de calcul\nRapide\nPlus lent\n\n\nOpérateurs\n|&gt;\n%&gt;% %&lt;&gt;% %$% %!&gt;% %T&gt;%\n\n\n\nSource :\n\nhttps://larmarange.github.io/guide-R/manipulation/pipe.html#le-pipe-natif-de-r\n\n\n\n14 Conseils divers\nIl est conseillé d’éviter de nommer des variables temporaires var, car ce nom désigne la fonction R permettant de calculer une variance.\n\n# Exemple : variance d'un échantillon aléatoire de 1000 observations tiré d'une loi normale centrée réduite\nvar(rnorm(1000))\n\n[1] 1.033028",
    "crumbs": [
      "Trucs et astuces"
    ]
  },
  {
    "objectID": "02-avantages_inconvenients_env_R.html",
    "href": "02-avantages_inconvenients_env_R.html",
    "title": "Avantages et inconvénients des environnements R",
    "section": "",
    "text": "Environnements R\n          Avantages\n        Inconvénients\n\n\n\n\n       R base\n\nabsence de dépendance (ne s’appuie sur aucun package) : pas besoin d’installer un package, de gérer sa mise à jour, de craindre pour sa disparition\ngarantit la rétrocompatibilité du code : utile dans des environnements de production\ndans certains cas, se révèle la solution la plus simple\nparfois, la seule façon de faire\n\n\nne permet pas de gérer des bases de données plus volumineuses que la mémoire vive\nsyntaxe plus complexe et parfois incohérente\nsouvent moins rapide que les autres environnements\ndemande plus de connaissance sur le fonctionnement du langage R\ncertaines tâches sont plus simples à traiter avec les autres environnements\n\n\n\n       tidyverse\n\nplus simple à prendre en main\nsyntaxe plus simple que les autres environnements et cohérente\nlargement utilisé dans la communauté R\ntend à s’imposer comme la référence de la gestion de données sur R\nsyntaxe utilisée également dans les packages Arrow / DuckDb\n\n\nne permet pas de gérer des bases de données plus volumineuses que la mémoire vive\nglobalement moins rapide que data.table\ntâches non prévues plus difficiles à réaliser\nforte dépendance : la rétrocompatibilité n’est pas assurée, potentiel problème dans un environnement de production\n\n\n\n       data.table\n\nfaible dépendance : garantit une rétrocompatibilité élevée\nsyntaxe proche du R Base\nplus rapide et puissant que ses concur\n\n\nne permet pas de gérer des bases de données plus volumineuses que la mémoire vive\nsyntaxe parfois déroutante, incohérente, et peu explicite\ncertaines tâches sont plus simples à traiter avec les autres environnements\nmoins utilisé",
    "crumbs": [
      "Avantages et inconvénients des environnements R"
    ]
  },
  {
    "objectID": "03-mise_en_garde.html",
    "href": "03-mise_en_garde.html",
    "title": "Mise en garde",
    "section": "",
    "text": "1 Comment utiliser cet aide-mémoire ?\nSont présentés dans cet aide-mémoire des programmes statistiques courants pour la gestion de données statistiques, traduits dans les langages SAS et R (environnements R-Base, Tidyverse et data.table et Arrow/DuckDb). Ces tâches sont standards dans l’analyse statistique et réalisables en un petit nombre d’instructions.\nCet aide-mémoire vise à faciliter la traduction des programmes statistiques entre ces différents langages (de SAS vers R, et d’un environnement R à un autre), et leur appropriation.\nIl est présenté sous forme de tâches élémentaires statistiques (sélection de lignes ou de colonnes d’une base de données, repérage des doublons, etc.).\nQuatre grands environnements R sont traités : R-Base, Tidyverse et data.table et Arrow/DuckDb). Ils ne doivent pas être vus comme des concurrents, mais comme des compléments :\n\ncertaines tâches peuvent être plus ou moins facilement réalisées avec l’un ou l’autre ;\nils présentent chacun des avantages et des inconvénients ;\nils laissent le choix de la stratégie de codage.\n\nCe guide est destiné à vous permettre de jongler plus facilement entre les environnements.\nPlusieurs solutions pour réaliser la même tâche sont proposées dans ce guide :\n\ncertaines solutions peuvent être plus concises, mais moins claires ;\nd’autres plus ou moins rapides en fonction des données et des matériels et logiciels utilisés ;\ncertaines façons de procéder sont plus efficaces que d’autres en R, mais cela peut dépendre des données et du matériel utilisé.\n\nL’attention du lecteur est attirée sur le fait que :\n\nce guide n’est pas exhaustif. Ainsi, les environnements peuvent proposer des solutions ad-hoc simplifiant grandement la résolution de problèmes moins courants et qui ne sont pas présents dans les autres environnements (ex. des rolling joins de data.table) ;\nce guide ne traite pas de ces stratégies, et le lecteur est invité à se documenter sur les environnements pour en savoir plus ;\nl’exercice de traduction de SAS vers R peut s’apparenter à la traduction d’un texte en langue étrangère. De même qu’une traduction littérale d’un texte en peut parfois être de mauvaise qualité, la traduction littérale d’une masse de codes SAS en codes R au moyen de cet aide-mémoire peut produire des résultats décevants. En effet, toute bonne traduction nécessite au moins a minima d’adapter le code SAS à une “nouvelle langue”, celle de R. La partie sur les spécificités de SAS par rapport à R peut vous aider sur ce point.",
    "crumbs": [
      "Mise en garde"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html",
    "href": "01-aide_memoire_r_sas.html",
    "title": "Aide-mémoire SAS - R",
    "section": "",
    "text": "L’aide-mémoire a pour but de fournir des codes écrits en SAS et d’en donner la traduction en R de différentes manières possibles :\nLes codes traduits sont typiques de la production statistique ou la réalisation d’études descriptives.\nCe document s’adresse notamment aux utilisateurs de SAS qui veulent connaître la traduction du code SAS en R, aux utilisateurs de R qui ont besoin de comprendre le code SAS, ainsi qu’aux utilisateurs d’un environnement R qui sont intéressés par la traduction dans un autre environnement R.\nIl se veut complémentaire de la documentation en ligne en français Utilit’R, née à l’Insee (https://www.book.utilitr.org/). Le lecteur est invité à s’y référer pour obtenir des informations importantes sur l’utilisation de R et qui ne sont pas discutées dans ce document, comme l’importation de données en R (https://www.book.utilitr.org/03_fiches_thematiques/fiche_import_fichiers_plats).\nEnfin, si vous souhaitez collaborer à cet aide-mémoire ou nous faire part de votre avis, n’hésitez pas à nous contacter via nos adresses email.\noptions(width=130)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#importation-des-packages-1",
    "href": "01-aide_memoire_r_sas.html#importation-des-packages-1",
    "title": "Aide-mémoire SAS - R",
    "section": "1.1 Importation des packages",
    "text": "1.1 Importation des packages\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Sans objet pour SAS */\n\n\n\n# Sans objet pour R-Base\n\n# Cependant, on importe le package lubridate pour faciliter la gestion des dates\n\n# Les packages doivent au préalable être installés sur le disque dur\n# Pour installer un package :\n# install.packages(\"nom_du_package\")\n\n# Pour manipuler les dates\nlibrary(lubridate)\n\n\n\n\n# Les packages doivent au préalable être installés sur le disque dur\n# Pour installer un package :\n# install.packages(\"nom_du_package\")\n\n# Chargement des packages\n# Pour manipuler les dates\nlibrary(lubridate)\n# Pour utiliser le pipe %&gt;%\nlibrary(magrittr)\n# Le tidyverse proprement dit\nlibrary(tidyverse)\n# Les packages importés par le tidyverse sont :\n# - dplyr (manipulation de données)\n# - tidyr (réorganisation de bases de données)\n# - readr (importation de données)\n# - purrr (permet de réaliser des boucles)\n# - tibble (format de données tibble, complémentaire du data.frame)\n# - stringr (manipulation de chaînes de caractères)\n# - ggplot2 (création de graphiques)\n# - forcats (gestion des formats \"factors\")\n# Documentation de tidyverse\nvignette(\"dplyr\")\n\n\n\n\n# Les packages doivent au préalable être installés sur le disque dur\n# Pour installer un package :\n# install.packages(\"nom_du_package\")\nlibrary(data.table)\n# Documentation de data.table\n?'[.data.table'\n# Pour manipuler les dates\nlibrary(lubridate)\n\n\n\n\n#library(duckdb)\n#library(arrow)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#mode-demploi-de-laide-mémoire",
    "href": "01-aide_memoire_r_sas.html#mode-demploi-de-laide-mémoire",
    "title": "Aide-mémoire SAS - R",
    "section": "2.1 Mode d’emploi de l’aide-mémoire",
    "text": "2.1 Mode d’emploi de l’aide-mémoire\nLes codes informatiques sont appliqués sur une base de données illustrative fictive. Cette base est importée à cette étape. Aussi, pour répliquer les codes sur sa machine, le lecteur doit d’abord exécuter le code d’importation de la base de données ci-dessous.\nLes codes sont majoritairement exécutables indépendamment les uns des autres.",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#création-dune-base-de-données-sas-dexemple",
    "href": "01-aide_memoire_r_sas.html#création-dune-base-de-données-sas-dexemple",
    "title": "Aide-mémoire SAS - R",
    "section": "2.2 Création d’une base de données SAS d’exemple",
    "text": "2.2 Création d’une base de données SAS d’exemple\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Données fictives sur des formations */\ndata donnees_sas;\n  infile cards dsd dlm='|';\n  format Identifiant $3. Sexe 1. CSP $1. Niveau $30. Date_naissance ddmmyy10. Date_entree ddmmyy10. Duree Note_Contenu Note_Formateur Note_Moyens\n         Note_Accompagnement Note_Materiel poids_sondage 4.1 CSPF $25. Sexef $5.;\n  input Identifiant $ Sexe CSP $ Niveau $ Date_naissance :ddmmyy10. Date_entree :ddmmyy10. Duree Note_Contenu Note_Formateur Note_Moyens\n        Note_Accompagnement Note_Materiel poids_sondage CSPF $ Sexef $;\n  cards;\n  173|2|1|Qualifié|17/06/1998|01/01/2021|308|12|6|17|4|19|117.1|Cadre|Femme\n  173|2|1|Qualifié|17/06/1998|01/01/2022|365|6||12|7|14|98.3|Cadre|Femme\n  173|2|1|Qualifié|17/06/1998|06/01/2022|185|8|10|11|1|9|214.6|Cadre|Femme\n  173|2|1|Non qualifié|17/06/1998|02/01/2023|365|14|15|15|10|8|84.7|Cadre|Femme\n  174|1|1|Qualifié|08/12/1984|17/08/2021|183|17|18|20|15|12|65.9|Cadre|Homme\n  175|1|1|Qualifié|16/09/1989|21/12/2022|730|5|5|8|4|9|148.2|Cadre|Homme\n  198|2|3|Non qualifié|17/03/1987|28/07/2022|30|10|10|10|16|8|89.6|Employé|Femme\n  198|2|3|Qualifié|17/03/1987|17/11/2022|164|11|7|6|14|13|100.3|Employé|Femme\n  198|2|3|Qualifié|17/03/1987|21/02/2023|365|9|20|3|4|17|49.3|Employé|Femme\n  168|1|2|Qualifié|30/07/2002|04/09/2019|365|18|11|20|13|15|148.2|Profession intermédiaire|Homme\n  211|2|3|Non qualifié||17/12/2021|135|16|16|15|12|9|86.4|Employé|Femme\n  278|1|5|Qualifié|10/08/1948|07/06/2018|365|14|10|6|8|12|99.2|Retraité|Homme\n  347|2|5|Qualifié|13/09/1955||180|12|5|7|11|12|105.6|Retraité|Femme\n  112|1|3|Non qualifié|13/09/2001|02/03/2022|212|3|10|11|9|8|123.1|Employé|Homme\n  112|1|3|Non qualifié|13/09/2001|01/03/2021|365|7|13|8|19|2|137.4|Employé|Homme\n  112|1|3|Qualifié|13/09/2001|01/12/2023|365|9|||||187.6|Employé|Homme\n  087|2|4|Non qualifié|||365||10||||87.3|Ouvrier|Femme\n  087|2|4|Non qualifié||31/10/2020|365|||11|||87.3|Ouvrier|Femme\n  099|1|4|Qualifié|06/06/1998|01/03/2021|364|12|11|10|12|13|169.3|Ouvrier|Homme\n  099|1|4|Qualifié|06/06/1998|01/03/2022|364|12|11|10|12|13|169.3|Ouvrier|Homme\n  099|1|4|Qualifié|06/06/1998|01/03/2023|364|12|11|10|12|13|169.3|Ouvrier|Homme\n  187|2|2|Qualifié|05/12/1986|01/01/2022|364|10|10|10|10|10|169.3|Profession intermédiaire|Femme\n  187|2|2|Qualifié|05/12/1986|01/01/2023|364|10|10|10|10|10|234.1|Profession intermédiaire|Femme\n  689|1|1||01/12/2000|06/11/2017|123|9|7|8|13|16|189.3|Cadre|Homme\n  765|1|4|Non qualifié|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9|Ouvrier|Homme\n  765|1|4|Non qualifié|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9|Ouvrier|Homme\n  765|1|4|Non qualifié|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9|Ouvrier|Homme\n  ;\nrun;\n\n/* Date de sortie du dispositif : ajout de la durée à la date d'entrée */\ndata donnees_sas;\n  set donnees_sas;\n  format date_sortie ddmmyy10.;\n  date_sortie = intnx('day', date_entree, duree);\nrun;\n\n\n\n# Données fictives sur des formations\ndonnees_rbase &lt;- data.frame(\n  Identifiant = c(\"173\", \"173\", \"173\", \"173\", \"174\", \"175\", \"198\", \"198\", \"198\", \"168\", \"211\", \"278\", \"347\", \"112\", \"112\", \"112\", \"087\", \"087\", \"099\", \"099\", \"099\", \"187\", \"187\", \"689\", \"765\", \"765\", \"765\"),\n  Sexe = c(\"2\", \"2\", \"2\", \"2\", \"1\", \"1\", \"2\", \"2\", \"2\", \"1\", \"2\", \"1\", \"2\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", \"1\", \"1\"),\n  CSP = c(\"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"3\", \"3\", \"3\", \"2\", \"3\", \"5\", \"5\", \"3\", \"3\", \"3\", \"4\", \"4\", \"4\", \"4\", \"4\", \"2\", \"2\", \"1\", \"4\", \"4\", \"4\"),\n  Niveau = c(\"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \n             \"Non qualifié\", \"Qualifié\", \"Non qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", NA, \"Non qualifié\", \"Non qualifié\", \"Non qualifié\"),\n  Date_naissance = c(\"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"08/12/1984\", \"16/09/1989\", \"17/03/1987\", \"17/03/1987\", \"17/03/1987\", \"30/07/2002\", NA, \"10/08/1948\", \n                     \"13/09/1955\", \"13/09/2001\", \"13/09/2001\", \"13/09/2001\", NA, NA, \"06/06/1998\", \"06/06/1998\", \"06/06/1998\", \"05/12/1986\", \"05/12/1986\", \"01/12/2000\", \"26/12/1995\", \"26/12/1995\", \"26/12/1995\"),\n  Date_entree = c(\"01/01/2021\", \"01/01/2022\", \"06/01/2022\", \"02/01/2023\", \"17/08/2021\", \"21/12/2022\", \"28/07/2022\", \"17/11/2022\", \"21/02/2023\", \"04/09/2019\", \"17/12/2021\", \"07/06/2018\", NA, \"02/03/2022\", \"01/03/2021\", \"01/12/2023\", NA, \n                  \"31/10/2020\", \"01/03/2021\", \"01/03/2022\", \"01/03/2023\", \"01/01/2022\", \"01/01/2023\", \"06/11/2017\", \"17/04/2020\", \"17/04/2020\", \"17/04/2020\"),\n  Duree = c(\"308\", \"365\", \"185\", \"365\", \"183\", \"730\", \"30\", \"164\", \"365\", \"365\", \"135\", \"365\", \"180\", \"212\", \"365\", \"365\", \"365\", \"365\", \"364\", \"364\", \"364\", \"364\", \"364\", \"123\", \"160\", \"160\", \"160\"),\n  Note_Contenu = c(\"12\", \"6\", \"8\", \"14\", \"17\", \"5\", \"10\", \"11\", \"9\", \"18\", \"16\", \"14\", \"12\", \"3\", \"7\", \"9\", NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"9\", \"13\", \"13\", \"13\"),\n  Note_Formateur = c(\"6\", NA, \"10\", \"15\", \"18\", \"5\", \"10\", \"7\", \"20\", \"11\", \"16\", \"10\", \"5\", \"10\", \"13\", NA, \"10\", NA, \"11\", \"11\", \"11\", \"10\", \"10\", \"7\", \"10\", \"10\", \"10\"),\n  Note_Moyens = c(\"17\", \"12\", \"11\", \"15\", \"20\", \"8\", \"10\", \"6\", \"3\", \"20\", \"15\", \"6\", \"7\", \"11\", \"8\", NA, NA, \"11\", \"10\", \"10\", \"10\", \"10\", \"10\", \"8\", \"12\", \"12\", \"12\"),\n  Note_Accompagnement = c(\"4\", \"7\", \"1\", \"10\", \"15\", \"4\", \"16\", \"14\", \"4\", \"13\", \"12\", \"8\", \"11\", \"9\", \"19\", NA, NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"13\", \"18\", \"18\", \"18\"),\n  Note_Materiel = c(\"19\", \"14\", \"9\", \"8\", \"12\", \"9\", \"8\", \"13\", \"17\", \"15\", \"9\", \"12\", \"12\", \"8\", \"2\", NA, NA, NA, \"13\", \"13\", \"13\", \"10\", \"10\", \"16\", \"10\", \"10\", \"10\"),\n  poids_sondage = c(\"117.1\", \"98.3\", \"214.6\", \"84.7\", \"65.9\", \"148.2\", \"89.6\", \"100.3\", \"49.3\", \"148.2\", \"86.4\", \"99.2\", \"105.6\", \"123.1\", \"137.4\", \"187.6\", \"87.3\", \"87.3\",\n                    \"169.3\", \"169.3\", \"169.3\", \"169.3\", \"234.1\", \"189.3\", \"45.9\", \"45.9\", \"45.9\"),\n  CSPF = c(\"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\",\"Cadre\", \"Employé\", \"Employé\", \"Employé\", \"Profession intermédiaire\", \"Employé\", \"Retraité\", \"Retraité\", \"Employé\",\n           \"Employé\", \"Employé\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Profession intermédiaire\", \"Profession intermédiaire\", \"Cadre\", \"Ouvrier\", \"Ouvrier\",\n           \"Ouvrier\"),\n  Sexef = c(\"Femme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Femme\", \"Homme\", \"Femme\", \"Homme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\",\n            \"Homme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Homme\", \"Homme\")\n)\n\n# Mise en forme des données\n# On vérifie que la base importée est bien un data.frame\nis.data.frame(donnees_rbase)\n\n# R est sensible à la casse, il est pertinent d'harmoniser les noms des variables en minuscule\n# Renommer les colonnes de la base\ncolnames(donnees_rbase) &lt;- tolower(colnames(donnees_rbase))\n# Autre possibilité\nsetNames(donnees_rbase, tolower(names(donnees_rbase)))\n\n# On a importé toutes les variables en format caractère\n# On convertit certaines variables en format numérique\nenNumerique &lt;- c(\"duree\", \"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\ndonnees_rbase[, enNumerique] &lt;- lapply(donnees_rbase[, enNumerique], as.integer)\ndonnees_rbase$poids_sondage &lt;- as.numeric(donnees_rbase$poids_sondage)\n\n# On récupère les variables dont le nom débute par le mot \"date\"\nenDate &lt;- names(donnees_rbase)[grepl(\"date\", tolower(names(donnees_rbase)))]\n# On remplace / par - dans les dates\ndonnees_rbase[, enDate] &lt;- lapply(donnees_rbase[, enDate], function(x) gsub(\"/\", \"-\", x))\n# On exprime les dates en format Date\ndonnees_rbase[, enDate] &lt;- lapply(donnees_rbase[, enDate], lubridate::dmy)\n\n# Date de sortie du dispositif\ndonnees_rbase$date_sortie &lt;- donnees_rbase$date_entree + lubridate::days(donnees_rbase$duree)\n\n# Format de la base\nclass(donnees_rbase)\n\n\n\n\n# Données fictives sur des formations\n# Autre solution !\ndonnees_tidyverse &lt;- tibble(\n  Identifiant = c(\"173\", \"173\", \"173\", \"173\", \"174\", \"175\", \"198\", \"198\", \"198\", \"168\", \"211\", \"278\", \"347\", \"112\", \"112\", \"112\", \"087\", \"087\", \"099\", \"099\", \"099\", \"187\", \"187\", \"689\", \"765\", \"765\", \"765\"),\n  Sexe = c(\"2\", \"2\", \"2\", \"2\", \"1\", \"1\", \"2\", \"2\", \"2\", \"1\", \"2\", \"1\", \"2\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", \"1\", \"1\"),\n  CSP = c(\"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"3\", \"3\", \"3\", \"2\", \"3\", \"5\", \"5\", \"3\", \"3\", \"3\", \"4\", \"4\", \"4\", \"4\", \"4\", \"2\", \"2\", \"1\", \"4\", \"4\", \"4\"),\n  Niveau = c(\"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \n             \"Non qualifié\", \"Qualifié\", \"Non qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", NA, \"Non qualifié\", \"Non qualifié\", \"Non qualifié\"),\n  Date_naissance = c(\"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"08/12/1984\", \"16/09/1989\", \"17/03/1987\", \"17/03/1987\", \"17/03/1987\", \"30/07/2002\", NA, \"10/08/1948\", \n                     \"13/09/1955\", \"13/09/2001\", \"13/09/2001\", \"13/09/2001\", NA, NA, \"06/06/1998\", \"06/06/1998\", \"06/06/1998\", \"05/12/1986\", \"05/12/1986\", \"01/12/2000\", \"26/12/1995\", \"26/12/1995\", \"26/12/1995\"),\n  Date_entree = c(\"01/01/2021\", \"01/01/2022\", \"06/01/2022\", \"02/01/2023\", \"17/08/2021\", \"21/12/2022\", \"28/07/2022\", \"17/11/2022\", \"21/02/2023\", \"04/09/2019\", \"17/12/2021\", \"07/06/2018\", NA, \"02/03/2022\", \"01/03/2021\", \"01/12/2023\", NA, \n                  \"31/10/2020\", \"01/03/2021\", \"01/03/2022\", \"01/03/2023\", \"01/01/2022\", \"01/01/2023\", \"06/11/2017\", \"17/04/2020\", \"17/04/2020\", \"17/04/2020\"),\n  Duree = c(\"308\", \"365\", \"185\", \"365\", \"183\", \"730\", \"30\", \"164\", \"365\", \"365\", \"135\", \"365\", \"180\", \"212\", \"365\", \"365\", \"365\", \"365\", \"364\", \"364\", \"364\", \"364\", \"364\", \"123\", \"160\", \"160\", \"160\"),\n  Note_Contenu = c(\"12\", \"6\", \"8\", \"14\", \"17\", \"5\", \"10\", \"11\", \"9\", \"18\", \"16\", \"14\", \"12\", \"3\", \"7\", \"9\", NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"9\", \"13\", \"13\", \"13\"),\n  Note_Formateur = c(\"6\", NA, \"10\", \"15\", \"18\", \"5\", \"10\", \"7\", \"20\", \"11\", \"16\", \"10\", \"5\", \"10\", \"13\", NA, \"10\", NA, \"11\", \"11\", \"11\", \"10\", \"10\", \"7\", \"10\", \"10\", \"10\"),\n  Note_Moyens = c(\"17\", \"12\", \"11\", \"15\", \"20\", \"8\", \"10\", \"6\", \"3\", \"20\", \"15\", \"6\", \"7\", \"11\", \"8\", NA, NA, \"11\", \"10\", \"10\", \"10\", \"10\", \"10\", \"8\", \"12\", \"12\", \"12\"),\n  Note_Accompagnement = c(\"4\", \"7\", \"1\", \"10\", \"15\", \"4\", \"16\", \"14\", \"4\", \"13\", \"12\", \"8\", \"11\", \"9\", \"19\", NA, NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"13\", \"18\", \"18\", \"18\"),\n  Note_Materiel = c(\"19\", \"14\", \"9\", \"8\", \"12\", \"9\", \"8\", \"13\", \"17\", \"15\", \"9\", \"12\", \"12\", \"8\", \"2\", NA, NA, NA, \"13\", \"13\", \"13\", \"10\", \"10\", \"16\", \"10\", \"10\", \"10\"),\n  poids_sondage = c(\"117.1\", \"98.3\", \"214.6\", \"84.7\", \"65.9\", \"148.2\", \"89.6\", \"100.3\", \"49.3\", \"148.2\", \"86.4\", \"99.2\", \"105.6\", \"123.1\", \"137.4\", \"187.6\", \"87.3\", \"87.3\",\n                    \"169.3\", \"169.3\", \"169.3\", \"169.3\", \"234.1\", \"189.3\", \"45.9\", \"45.9\", \"45.9\"),\n  CSPF = c(\"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\",\"Cadre\", \"Employé\", \"Employé\", \"Employé\", \"Profession intermédiaire\", \"Employé\", \"Retraité\", \"Retraité\", \"Employé\",\n           \"Employé\", \"Employé\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Profession intermédiaire\", \"Profession intermédiaire\", \"Cadre\", \"Ouvrier\", \"Ouvrier\",\n           \"Ouvrier\"),\n  Sexef = c(\"Femme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Femme\", \"Homme\", \"Femme\", \"Homme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\",\n            \"Homme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Homme\", \"Homme\")\n  \n)\n\n# Mise en forme des données\n\n# On vérifie que la base importée est bien un tibble\nis_tibble(donnees_tidyverse)\n\n# Transformation en tibble, le format de Tidyverse\ndonnees_tidyverse &lt;- tibble::as_tibble(donnees_tidyverse)\n\n# R est sensible à la casse, il est pertinent d'harmoniser les noms des variables en minuscule\n# Renommer les colonnes de la base en minuscule\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% rename_with(tolower)\n# Autre solution\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  magrittr::set_colnames(value = casefold(colnames(.), upper = FALSE))\n\n# On a importé toutes les variables en format caractère\n# On convertit certaines variables en format numérique\nenNumerique &lt;- c(\"duree\", \"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\n# On convertit certaines variables au format date\n# On récupère d'abord les variables dont le nom débute par le mot \"date\"\nenDate &lt;- names(donnees_tidyverse)[grepl(\"date\", tolower(names(donnees_tidyverse)))]\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%  \n  mutate_at(enNumerique, as.integer) %&gt;% \n  mutate(poids_sondage = as.numeric(poids_sondage)) %&gt;% \n  mutate_at(enDate, lubridate::dmy)\n\n# Date de sortie du dispositif\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(date_sortie = date_entree + lubridate::days(duree))\n\n# Format de la base\nclass(donnees_tidyverse)\n\n\n\n\n# Données fictives sur des formations\ndonnees_datatable &lt;- data.table(\n  Identifiant = c(\"173\", \"173\", \"173\", \"173\", \"174\", \"175\", \"198\", \"198\", \"198\", \"168\", \"211\", \"278\", \"347\", \"112\", \"112\", \"112\", \"087\", \"087\", \"099\", \"099\", \"099\", \"187\", \"187\", \"689\", \"765\", \"765\", \"765\"),\n  Sexe = c(\"2\", \"2\", \"2\", \"2\", \"1\", \"1\", \"2\", \"2\", \"2\", \"1\", \"2\", \"1\", \"2\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", \"1\", \"1\"),\n  CSP = c(\"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"3\", \"3\", \"3\", \"2\", \"3\", \"5\", \"5\", \"3\", \"3\", \"3\", \"4\", \"4\", \"4\", \"4\", \"4\", \"2\", \"2\", \"1\", \"4\", \"4\", \"4\"),\n  Niveau = c(\"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \n             \"Non qualifié\", \"Qualifié\", \"Non qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", NA, \"Non qualifié\", \"Non qualifié\", \"Non qualifié\"),\n  Date_naissance = c(\"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"08/12/1984\", \"16/09/1989\", \"17/03/1987\", \"17/03/1987\", \"17/03/1987\", \"30/07/2002\", NA, \"10/08/1948\", \n                     \"13/09/1955\", \"13/09/2001\", \"13/09/2001\", \"13/09/2001\", NA, NA, \"06/06/1998\", \"06/06/1998\", \"06/06/1998\", \"05/12/1986\", \"05/12/1986\", \"01/12/2000\", \"26/12/1995\", \"26/12/1995\", \"26/12/1995\"),\n  Date_entree = c(\"01/01/2021\", \"01/01/2022\", \"06/01/2022\", \"02/01/2023\", \"17/08/2021\", \"21/12/2022\", \"28/07/2022\", \"17/11/2022\", \"21/02/2023\", \"04/09/2019\", \"17/12/2021\", \"07/06/2018\", NA, \"02/03/2022\", \"01/03/2021\", \"01/12/2023\", NA, \n                  \"31/10/2020\", \"01/03/2021\", \"01/03/2022\", \"01/03/2023\", \"01/01/2022\", \"01/01/2023\", \"06/11/2017\", \"17/04/2020\", \"17/04/2020\", \"17/04/2020\"),\n  Duree = c(\"308\", \"365\", \"185\", \"365\", \"183\", \"730\", \"30\", \"164\", \"365\", \"365\", \"135\", \"365\", \"180\", \"212\", \"365\", \"365\", \"365\", \"365\", \"364\", \"364\", \"364\", \"364\", \"364\", \"123\", \"160\", \"160\", \"160\"),\n  Note_Contenu = c(\"12\", \"6\", \"8\", \"14\", \"17\", \"5\", \"10\", \"11\", \"9\", \"18\", \"16\", \"14\", \"12\", \"3\", \"7\", \"9\", NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"9\", \"13\", \"13\", \"13\"),\n  Note_Formateur = c(\"6\", NA, \"10\", \"15\", \"18\", \"5\", \"10\", \"7\", \"20\", \"11\", \"16\", \"10\", \"5\", \"10\", \"13\", NA, \"10\", NA, \"11\", \"11\", \"11\", \"10\", \"10\", \"7\", \"10\", \"10\", \"10\"),\n  Note_Moyens = c(\"17\", \"12\", \"11\", \"15\", \"20\", \"8\", \"10\", \"6\", \"3\", \"20\", \"15\", \"6\", \"7\", \"11\", \"8\", NA, NA, \"11\", \"10\", \"10\", \"10\", \"10\", \"10\", \"8\", \"12\", \"12\", \"12\"),\n  Note_Accompagnement = c(\"4\", \"7\", \"1\", \"10\", \"15\", \"4\", \"16\", \"14\", \"4\", \"13\", \"12\", \"8\", \"11\", \"9\", \"19\", NA, NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"13\", \"18\", \"18\", \"18\"),\n  Note_Materiel = c(\"19\", \"14\", \"9\", \"8\", \"12\", \"9\", \"8\", \"13\", \"17\", \"15\", \"9\", \"12\", \"12\", \"8\", \"2\", NA, NA, NA, \"13\", \"13\", \"13\", \"10\", \"10\", \"16\", \"10\", \"10\", \"10\"),\n  poids_sondage = c(\"117.1\", \"98.3\", \"214.6\", \"84.7\", \"65.9\", \"148.2\", \"89.6\", \"100.3\", \"49.3\", \"148.2\", \"86.4\", \"99.2\", \"105.6\", \"123.1\", \"137.4\", \"187.6\", \"87.3\", \"87.3\",\n                    \"169.3\", \"169.3\", \"169.3\", \"169.3\", \"234.1\", \"189.3\", \"45.9\", \"45.9\", \"45.9\"),\n  CSPF = c(\"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\",\"Cadre\", \"Employé\", \"Employé\", \"Employé\", \"Profession intermédiaire\", \"Employé\", \"Retraité\", \"Retraité\", \"Employé\",\n           \"Employé\", \"Employé\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Profession intermédiaire\", \"Profession intermédiaire\", \"Cadre\", \"Ouvrier\", \"Ouvrier\",\n           \"Ouvrier\"),\n  Sexef = c(\"Femme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Femme\", \"Homme\", \"Femme\", \"Homme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\",\n            \"Homme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Homme\", \"Homme\")\n)\n\n\n# Mise en forme des données\n\n# On vérifie que la base est bien un data.table\nis.data.table(donnees_datatable)\n\n# Transformation en data.frame\nsetDF(donnees_datatable)\nis.data.frame(donnees_datatable)\n\n# Transformation en data.table\n# En data.table, les instructions débutant par set modifient les éléments par référence, c'est-à-dire sans copie.\n# Ceci est plus efficace pour manipuler des données volumineuses.\nsetDT(donnees_datatable)\nis.data.table(donnees_datatable)\n# Autre possibilité\ndonnees_datatable &lt;- as.data.table(donnees_datatable)\n\n\n# Est-ce une liste ?\nis.list(donnees_datatable)\n\n# Extraire les noms des variables de la base\n# R est sensible à la casse, il est pertinent d'harmoniser les noms des variables en minuscule\nnomCol &lt;- tolower(colnames(donnees_datatable))\n# Renommer les colonnes de la base\ncolnames(donnees_datatable) &lt;- tolower(colnames(donnees_datatable))\n\n# On convertit certaines variables en format 'numeric'\nenNumerique &lt;- c(\"duree\", \"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\n# Ne pas oublier le . devant SDcols !!!!\ndonnees_datatable[, lapply(.SD, as.integer), .SDcols = enNumerique]\n# Autre solution\n# En data.table, les instructions débutant par set modifient les éléments par référence, c'est-à-dire sans copie.\n# Ceci est plus efficace pour manipuler des données volumineuses.\nfor (j in enNumerique) {\n  set(donnees_datatable, j = j, value = as.numeric(donnees_datatable[[j]]))\n}\ndonnees_datatable[, poids_sondage := as.numeric(poids_sondage)]\n\n# On récupère les variables dont le nom débute par le mot \"date\"\nvarDates &lt;- names(donnees_datatable)[grepl(\"date\", tolower(names(donnees_datatable)))]\n# On remplace / par - dans les dates\ndonnees_datatable[, (varDates) := lapply(.SD, function(x) gsub(\"/\", \"-\", x)), .SDcols = varDates]\n# On exprime les dates en format Date\ndonnees_datatable[, (varDates) := lapply(.SD, lubridate::dmy), .SDcols = varDates]\n\n# Date de sortie du dispositif\ndonnees_datatable[, date_sortie := date_entree + lubridate::days(duree)]\n\n# Format de la base\nclass(donnees_datatable)\n\n\n\nDuckdb est un serveur SQL séparé de la session R. Les calculs sont effectués en dehors de R et l’espace mémoire est distinct de celui de R. Au lieu d’accéder directement aux données, il faut passer par un objet connection qui contient l’adresse du serveur, un peu comme lorsque l’on se connecte à un serveur web. Ici en particulier, il est nécessaire de transférer les données vers duckdb.\n\n# Ouvrir une connexion au serveur duckdb\ncon &lt;- DBI::dbConnect(duckdb::duckdb()); \n\n# On \"copie\" les données dans une table du nom table_duckdb\ncon %&gt;% duckdb::duckdb_register(name = \"table_duckdb\", df = donnees_tidyverse)\n\ncon %&gt;% tbl(\"table_duckdb\")\n\n# Source:   table&lt;table_duckdb&gt; [?? x 16]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1021-azure:R 4.2.0/:memory:]\n   identifiant sexe  csp   niveau     date_naissance date_entree duree note_contenu note_formateur note_moyens note_accompagnement\n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;date&gt;         &lt;date&gt;      &lt;int&gt;        &lt;int&gt;          &lt;int&gt;       &lt;int&gt;               &lt;int&gt;\n 1 173         2     1     Qualifié   1998-06-17     2021-01-01    308           12              6          17                   4\n 2 173         2     1     Qualifié   1998-06-17     2022-01-01    365            6             NA          12                   7\n 3 173         2     1     Qualifié   1998-06-17     2022-01-06    185            8             10          11                   1\n 4 173         2     1     Non quali… 1998-06-17     2023-01-02    365           14             15          15                  10\n 5 174         1     1     Qualifié   1984-12-08     2021-08-17    183           17             18          20                  15\n 6 175         1     1     Qualifié   1989-09-16     2022-12-21    730            5              5           8                   4\n 7 198         2     3     Non quali… 1987-03-17     2022-07-28     30           10             10          10                  16\n 8 198         2     3     Qualifié   1987-03-17     2022-11-17    164           11              7           6                  14\n 9 198         2     3     Qualifié   1987-03-17     2023-02-21    365            9             20           3                   4\n10 168         1     2     Qualifié   2002-07-30     2019-09-04    365           18             11          20                  13\n# ℹ more rows\n# ℹ 5 more variables: note_materiel &lt;int&gt;, poids_sondage &lt;dbl&gt;, cspf &lt;chr&gt;, sexef &lt;chr&gt;, date_sortie &lt;date&gt;\n\n# Fermer la connexion au serveur duckdb\nDBI::dbDisconnect(con, shutdown = TRUE)\n\nPour la suite, on suppose que la connexion est ouverte sous le nom con, et que les données sont accessibles par la requête requete_duckdb. Le code modifiera la requête, mais pas la table dans le serveur SQL.\n\ncon &lt;- DBI::dbConnect(duckdb::duckdb()); \ncon %&gt;% duckdb::duckdb_register(name = \"table_duckdb\", df = donnees_tidyverse)\nrequete_duckdb &lt;- con %&gt;% tbl(\"table_duckdb\")\n\nN.B. Duckdb est envisagé pour des traitements sans charger des données en mémoire, par exemple en lisant directement un fichier .parquet sur le disque dur. Dans ce cas, les opérations sont effectuées à la volée, mais n’affectent pas les fichiers source.",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#chemin-du-bureau-de-lutilisateur",
    "href": "01-aide_memoire_r_sas.html#chemin-du-bureau-de-lutilisateur",
    "title": "Aide-mémoire SAS - R",
    "section": "3.1 Chemin du bureau de l’utilisateur",
    "text": "3.1 Chemin du bureau de l’utilisateur\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On vide la log */\ndm \"log; clear; \";\n/* On récupère déjà l'identifiant de l'utilisateur (systèmes Windows) */\n%let user = &sysuserid;\n/* Chemin proprement dit */\n%let bureau = C:\\Users\\&user.\\Desktop;\nlibname bur \"&bureau.\";\n\n\n\n# On récupère déjà l'identifiant de l'utilisateur\nuser &lt;- Sys.getenv(\"USERNAME\")\nchemin &lt;- file.path(\"C:/Users\", user, \"Desktop\")\n\n\n\n\n# On récupère déjà l'identifiant de l'utilisateur\nuser &lt;- Sys.getenv(\"USERNAME\")\nchemin &lt;- file.path(\"C:/Users\", user, \"Desktop\")\n\n\n\n\n# On récupère déjà l'identifiant de l'utilisateur\nuser &lt;- Sys.getenv(\"USERNAME\")\nchemin &lt;- file.path(\"C:/Users\", user, \"Desktop\")\n\n\n\n\n# On récupère déjà l'identifiant de l'utilisateur\nuser &lt;- Sys.getenv(\"USERNAME\")\nchemin &lt;- file.path(\"C:/Users\", user, \"Desktop\")",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#affichage-de-lannée",
    "href": "01-aide_memoire_r_sas.html#affichage-de-lannée",
    "title": "Aide-mémoire SAS - R",
    "section": "3.2 Affichage de l’année",
    "text": "3.2 Affichage de l’année\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Année courante */\n%let an = %sysfunc(year(%sysfunc(today())));\n/* & (esperluette) indique à SAS qu'il doit remplacer an par sa valeur définie par le %let */\n%put Année : &an.;\n/* Autre possibilité */\ndata _null_;call symput('annee', strip(year(today())));run;\n%put Année (autre méthode) : &annee.;\n/* Année passée */\n%put Année passée : %eval(&an. - 1);\n\n\n\n# Année courante\nannee &lt;- lubridate::year(Sys.Date())\nsprintf(\"Année : %04d\", annee)\nprint(paste0(\"Année : \", annee))\n# Année passée\nannee_1 &lt;- annee - 1\npaste0(\"Année passée: \", annee_1)\n\n\n\n\n# Année courante\nannee &lt;- lubridate::year(Sys.Date())\nsprintf(\"Année : %04d\", annee)\nprint(paste0(\"Année : \", annee))\n# Année passée\nannee_1 &lt;- annee - 1\npaste0(\"Année passée: \", annee_1)\n\n\n\n\n# Année courante\nannee &lt;- lubridate::year(Sys.Date())\nsprintf(\"Année : %04d\", annee)\nprint(paste0(\"Année : \", annee))\n# Année passée\nannee_1 &lt;- annee - 1\npaste0(\"Année passée: \", annee_1)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#construction-des-instructions-if-else",
    "href": "01-aide_memoire_r_sas.html#construction-des-instructions-if-else",
    "title": "Aide-mémoire SAS - R",
    "section": "3.3 Construction des instructions if / else",
    "text": "3.3 Construction des instructions if / else\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%macro Annee(an);\n  %if &an. &gt;= 2024 %then %put Nous sommes en 2024 ou après !;\n  %else %put Nous sommes avant 2024 !;\n%mend Annee;\n%Annee(&an.);\n\n\n\n# Construction incorrecte ! Le else doit être sur la même ligne que le {\n#if (annee &gt;= 2024) {\n#  print(\"Nous sommes en 2024 ou après\")\n#}\n#else {\n#  print(\"Nous sommes en 2023 ou avant\")\n#}\n## Construction correcte ! Le else doit être sur la même ligne que le {\nif (annee &gt;= 2024) {\n  print(\"Nous sommes en 2024 ou après\")\n} else {\n  print(\"Nous sommes avant 2024 !\")\n}\n\n\n\n\n# Construction incorrecte ! Le else doit être sur la même ligne que le {\n#if (annee &gt;= 2024) {\n#  print(\"Nous sommes en 2024 ou après\")\n#}\n#else {\n#  print(\"Nous sommes en 2024 ou avant\")\n#}\n## Construction correcte ! Le else doit être sur la même ligne que le {\nif (annee &gt;= 2024) {\n  print(\"Nous sommes en 2024 ou après\")\n} else {\n  print(\"Nous sommes avant 2024 !\")\n}\n\n\n\n\n# Construction incorrecte ! Le else doit être sur la même ligne que le {\n#if (annee &gt;= 2024) {\n#  print(\"Nous sommes en 2024 ou après\")\n#}\n#else {\n#  print(\"Nous sommes avant 2024\")\n#}\n## Construction correcte ! Le else doit être sur la même ligne que le {\nif (annee &gt;= 2024) {\n  print(\"Nous sommes en 2024 ou après\")\n} else {\n  print(\"Nous sommes avant 2024 !\")\n}",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#répertoire-de-travail",
    "href": "01-aide_memoire_r_sas.html#répertoire-de-travail",
    "title": "Aide-mémoire SAS - R",
    "section": "3.4 Répertoire de travail",
    "text": "3.4 Répertoire de travail\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Afficher le répertoire de travail par défaut (la Work) */\n%let chemin_work = %sysfunc(pathname(work));\n%put &chemin_work.;\nproc sql;\n  select path from dictionary.libnames where libname = \"WORK\";\nquit;\n/* Définir le répertoire de travail, si besoin */\n/* libname \"nom du répertoire\";\n\n\n\n# Afficher le répertoire de travail\ngetwd()\n\n# Définir le répertoire de travail, si besoin\n#setwd(dir=\"nom du répertoire\")\n\n\n\n\n# Afficher le répertoire de travail\ngetwd()\n\n# Définir le répertoire de travail, si besoin\n#setwd(dir=\"nom du répertoire\")\n\n\n\n\n# Afficher le répertoire de travail\ngetwd()\n\n# Définir le répertoire de travail, si besoin\n#setwd(dir=\"nom du répertoire\")",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#autres-points-à-connaître",
    "href": "01-aide_memoire_r_sas.html#autres-points-à-connaître",
    "title": "Aide-mémoire SAS - R",
    "section": "3.5 Autres points à connaître",
    "text": "3.5 Autres points à connaître\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Mise en garde : certains codes SAS pourraient aussi avec profit être écrits en langage SAS IML (Interactive Matrix Language).\n   Cet aide-mémoire n'ayant pas vocation à être un dictionnaire SAS, cette méthode d'écriture n'est pas proposée ici. */\n\n\n\n# Le pipe peut aussi être utilisé avec R-Base et data.table\n# Le pipe permet d'enchaîner des opérations sur une même base\n1:10 |&gt; sum()\n# R-Base est réputé plus lent que ses concurrents, ce qui est souvent vrai.\n# Mais certaines fonctions en R-Base être très rapides (rowsum, rowSums, tapply, etc.)\n\n\n\n\n# tidyverse promeut l'utilisation du pipe (%&gt;%), qui permet d'enchaîner des opérations sur une même base modifiée successivement.\n# 2 types de pipes existent, le pipe de magrittr (%&gt;%) et le pipe de R-Base (|&gt;, à partir de la version 4.1)\n# Les fonctionnalités simples des deux opérateurs sont identiques, mais il existe des différences.\n# Le tidyverse peut s'utiliser sans pipe, mais le pipe simplifie la gestion des programmes.\n# Les autres environnements (R-Base, data.table) peuvent aussi se présenter avec le pipe\n# Dans cet aide-mémoire, le pipe de magrittr (%&gt;%) est privilégié.\n\n# À FAIRE :\n# - expliquer les différences entre le pipe de magrittr et de R-Base\n\n# Documentation de tidyverse (dplyr et tidyr)\nvignette(\"dplyr\")\n\n\n\n\n# Principe de base de data.table\n#dt[i, j, by]\n# i : sélection de lignes (instructions )\n# j : sélection et manipulation de colonnes\n# by : groupements",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#avoir-une-vue-densemble-des-données",
    "href": "01-aide_memoire_r_sas.html#avoir-une-vue-densemble-des-données",
    "title": "Aide-mémoire SAS - R",
    "section": "4.1 Avoir une vue d’ensemble des données",
    "text": "4.1 Avoir une vue d’ensemble des données\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Statistiques globales sur les variables numériques */\nproc means data = donnees_sas n mean median min p10 p25 median p75 p90 max;var _numeric_;run;\n/* Statistiques globales sur les variables caractères */\nproc freq data = donnees_sas;tables _character_ / missing;run;\n\n\n\n# Informations sur les variables\nstr(donnees_rbase)\n# Statistiques descriptives des variables de la base\nsummary(donnees_rbase)\nlibrary(Hmisc)\nHmisc::describe(donnees_rbase)\n# Visualiser la base de données\nView(donnees_rbase)\n\n\n\n\n# Informations sur les variables\ndonnees_tidyverse %&gt;% str()\ndonnees_tidyverse %&gt;% glimpse()\n# Statistiques descriptives des variables de la base\ndonnees_tidyverse %&gt;% summary()\n# Visualiser la base de données\ndonnees_tidyverse %&gt;% View()\n\n\n\n\n# Informations sur les variables\nstr(donnees_datatable)\n# Statistiques descriptives des variables de la base\nsummary(donnees_datatable)\n# Visualiser la base de données\nView(donnees_datatable)\n\n\n\nOn accède aux données du serveur SQL DuckDB au travers de l’objet requete_duckdb, qui est une requête (avec l’adresse du serveur) et non pas un dataframe ou un tibble. Comme l’accès n’est pas direct, la plupart des fonctions du tidyverse fonctionnent, mais opèrent sur “l’adresse du serveur DuckDB” au lieu d’opérer sur les valeurs (nombres, chaînes de caractères). A part glimpse, la plupart des fonctions ne renvoient pas un résultat exploitable.\n\n# Informations sur les variables\n# requete_duckdb %&gt;% str() \nrequete_duckdb %&gt;% glimpse() # préférer glimpse()\n\nRows: ??\nColumns: 16\nDatabase: DuckDB v0.9.2 [unknown@Linux 6.5.0-1021-azure:R 4.2.0/:memory:]\n$ identifiant         &lt;chr&gt; \"173\", \"173\", \"173\", \"173\", \"174\", \"175\", \"198\", \"198\", \"198\", \"168\", \"211\", \"278\", \"347\", \"112\", \"1…\n$ sexe                &lt;chr&gt; \"2\", \"2\", \"2\", \"2\", \"1\", \"1\", \"2\", \"2\", \"2\", \"1\", \"2\", \"1\", \"2\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", …\n$ csp                 &lt;chr&gt; \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"3\", \"3\", \"3\", \"2\", \"3\", \"5\", \"5\", \"3\", \"3\", \"3\", \"4\", \"4\", \"4\", \"4\", …\n$ niveau              &lt;chr&gt; \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifi…\n$ date_naissance      &lt;date&gt; 1998-06-17, 1998-06-17, 1998-06-17, 1998-06-17, 1984-12-08, 1989-09-16, 1987-03-17, 1987-03-17, 198…\n$ date_entree         &lt;date&gt; 2021-01-01, 2022-01-01, 2022-01-06, 2023-01-02, 2021-08-17, 2022-12-21, 2022-07-28, 2022-11-17, 202…\n$ duree               &lt;int&gt; 308, 365, 185, 365, 183, 730, 30, 164, 365, 365, 135, 365, 180, 212, 365, 365, 365, 365, 364, 364, 3…\n$ note_contenu        &lt;int&gt; 12, 6, 8, 14, 17, 5, 10, 11, 9, 18, 16, 14, 12, 3, 7, 9, NA, NA, 12, 12, 12, 10, 10, 9, 13, 13, 13\n$ note_formateur      &lt;int&gt; 6, NA, 10, 15, 18, 5, 10, 7, 20, 11, 16, 10, 5, 10, 13, NA, 10, NA, 11, 11, 11, 10, 10, 7, 10, 10, 10\n$ note_moyens         &lt;int&gt; 17, 12, 11, 15, 20, 8, 10, 6, 3, 20, 15, 6, 7, 11, 8, NA, NA, 11, 10, 10, 10, 10, 10, 8, 12, 12, 12\n$ note_accompagnement &lt;int&gt; 4, 7, 1, 10, 15, 4, 16, 14, 4, 13, 12, 8, 11, 9, 19, NA, NA, NA, 12, 12, 12, 10, 10, 13, 18, 18, 18\n$ note_materiel       &lt;int&gt; 19, 14, 9, 8, 12, 9, 8, 13, 17, 15, 9, 12, 12, 8, 2, NA, NA, NA, 13, 13, 13, 10, 10, 16, 10, 10, 10\n$ poids_sondage       &lt;dbl&gt; 117.1, 98.3, 214.6, 84.7, 65.9, 148.2, 89.6, 100.3, 49.3, 148.2, 86.4, 99.2, 105.6, 123.1, 137.4, 18…\n$ cspf                &lt;chr&gt; \"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\", \"Employé\", \"Employé\", \"Employé\", \"Profession i…\n$ sexef               &lt;chr&gt; \"Femme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Femme\", \"…\n$ date_sortie         &lt;date&gt; 2021-11-05, 2023-01-01, 2022-07-10, 2024-01-02, 2022-02-16, 2024-12-20, 2022-08-27, 2023-04-30, 2024…\n\n# requete_duckdb %&gt;% summary()\n# requete_duckdb %&gt;% View()",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#extraire-les-x-premières-lignes-de-la-base-10-par-défaut",
    "href": "01-aide_memoire_r_sas.html#extraire-les-x-premières-lignes-de-la-base-10-par-défaut",
    "title": "Aide-mémoire SAS - R",
    "section": "4.2 Extraire les x premières lignes de la base (10 par défaut)",
    "text": "4.2 Extraire les x premières lignes de la base (10 par défaut)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let x = 10;\nproc print data = donnees_sas (firstobs = 1 obs = &x.);run;\n/* Ou alors */\ndata Lignes&x.;set donnees_sas (firstobs = 1 obs = &x.);proc print;run;\n\n\n\nx &lt;- 10\ndonnees_rbase[1:x, ]\nhead(donnees_rbase, x)\n\n\n\n\nx &lt;- 10\ndonnees_tidyverse %&gt;% \n  slice(1:x)\n\n\n\n\ndonnees_datatable[, head(.SD, 10)]\ndonnees_datatable[, .SD[1:10]]\nhead(donnees_datatable, 10)\n\n\n\nDuckDB affiche les dix premières lignes par défaut lorsque l’on évalue une requête, comme indiqué dans le code ci-dessous.\n\nrequete_duckdb\n\n# Source:   table&lt;table_duckdb&gt; [?? x 16]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1021-azure:R 4.2.0/:memory:]\n   identifiant sexe  csp   niveau     date_naissance date_entree duree note_contenu note_formateur note_moyens note_accompagnement\n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;date&gt;         &lt;date&gt;      &lt;int&gt;        &lt;int&gt;          &lt;int&gt;       &lt;int&gt;               &lt;int&gt;\n 1 173         2     1     Qualifié   1998-06-17     2021-01-01    308           12              6          17                   4\n 2 173         2     1     Qualifié   1998-06-17     2022-01-01    365            6             NA          12                   7\n 3 173         2     1     Qualifié   1998-06-17     2022-01-06    185            8             10          11                   1\n 4 173         2     1     Non quali… 1998-06-17     2023-01-02    365           14             15          15                  10\n 5 174         1     1     Qualifié   1984-12-08     2021-08-17    183           17             18          20                  15\n 6 175         1     1     Qualifié   1989-09-16     2022-12-21    730            5              5           8                   4\n 7 198         2     3     Non quali… 1987-03-17     2022-07-28     30           10             10          10                  16\n 8 198         2     3     Qualifié   1987-03-17     2022-11-17    164           11              7           6                  14\n 9 198         2     3     Qualifié   1987-03-17     2023-02-21    365            9             20           3                   4\n10 168         1     2     Qualifié   2002-07-30     2019-09-04    365           18             11          20                  13\n# ℹ more rows\n# ℹ 5 more variables: note_materiel &lt;int&gt;, poids_sondage &lt;dbl&gt;, cspf &lt;chr&gt;, sexef &lt;chr&gt;, date_sortie &lt;date&gt;\n\n# Ceci est équivalent au code suivant\n# requete_duckdb %&gt;% print(n=10)\n\nAttention, comme il n’y a pas d’ordre en SQL, il faut ordonner les lignes si on veut un résultat reproductible. C’est une opération qui peut être couteuse en temps CPU.\n\nrequete_duckdb %&gt;% arrange(duree) %&gt;% print()\n\n# Source:     SQL [?? x 16]\n# Database:   DuckDB v0.9.2 [unknown@Linux 6.5.0-1021-azure:R 4.2.0/:memory:]\n# Ordered by: duree\n   identifiant sexe  csp   niveau     date_naissance date_entree duree note_contenu note_formateur note_moyens note_accompagnement\n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;date&gt;         &lt;date&gt;      &lt;int&gt;        &lt;int&gt;          &lt;int&gt;       &lt;int&gt;               &lt;int&gt;\n 1 198         2     3     Non quali… 1987-03-17     2022-07-28     30           10             10          10                  16\n 2 689         1     1     &lt;NA&gt;       2000-12-01     2017-11-06    123            9              7           8                  13\n 3 211         2     3     Non quali… NA             2021-12-17    135           16             16          15                  12\n 4 765         1     4     Non quali… 1995-12-26     2020-04-17    160           13             10          12                  18\n 5 765         1     4     Non quali… 1995-12-26     2020-04-17    160           13             10          12                  18\n 6 765         1     4     Non quali… 1995-12-26     2020-04-17    160           13             10          12                  18\n 7 198         2     3     Qualifié   1987-03-17     2022-11-17    164           11              7           6                  14\n 8 347         2     5     Qualifié   1955-09-13     NA            180           12              5           7                  11\n 9 174         1     1     Qualifié   1984-12-08     2021-08-17    183           17             18          20                  15\n10 173         2     1     Qualifié   1998-06-17     2022-01-06    185            8             10          11                   1\n# ℹ more rows\n# ℹ 5 more variables: note_materiel &lt;int&gt;, poids_sondage &lt;dbl&gt;, cspf &lt;chr&gt;, sexef &lt;chr&gt;, date_sortie &lt;date&gt;\n\n\nL’objet requete_duckdb est bien une requête (i.e. une liste à deux éléments) même si on peut en afficher le résultat avec la fonction print. Notamment, les informations restent dans la mémoire de DuckDB. Il faut demander explicitement le transfert du résultat vers la session R avec la fonction collect(). On obtient alors un objet de type data.frame ou au lieu de tbl_duckdb_connection.\n\nclass(requete_duckdb)\n\n[1] \"tbl_duckdb_connection\" \"tbl_dbi\"               \"tbl_sql\"               \"tbl_lazy\"              \"tbl\"                  \n\nresultat_tibble &lt;- requete_duckdb %&gt;% collect()\nclass(resultat_tibble)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\nLa fonction collect() transfère l’ensemble des données. Pour obtenir uniquement 10 lignes, il faut utiliser l’une des fonctions slice_* (cf documentation). On conseille slice_min ou slice_max qui indiquent explicitement l’ordre utilisé.\n\nrequete_duckdb %&gt;% slice_max(duree, n=4, with_ties=FALSE) # with_ties = TRUE retourne les cas d'égalité, donc plus de 4 lignes\n\n# Source:   SQL [4 x 16]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1021-azure:R 4.2.0/:memory:]\n  identifiant sexe  csp   niveau      date_naissance date_entree duree note_contenu note_formateur note_moyens note_accompagnement\n  &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;       &lt;date&gt;         &lt;date&gt;      &lt;int&gt;        &lt;int&gt;          &lt;int&gt;       &lt;int&gt;               &lt;int&gt;\n1 175         1     1     Qualifié    1989-09-16     2022-12-21    730            5              5           8                   4\n2 173         2     1     Qualifié    1998-06-17     2022-01-01    365            6             NA          12                   7\n3 173         2     1     Non qualif… 1998-06-17     2023-01-02    365           14             15          15                  10\n4 198         2     3     Qualifié    1987-03-17     2023-02-21    365            9             20           3                   4\n# ℹ 5 more variables: note_materiel &lt;int&gt;, poids_sondage &lt;dbl&gt;, cspf &lt;chr&gt;, sexef &lt;chr&gt;, date_sortie &lt;date&gt;\n\n\nEn DuckDB et/ou sur un serveur SQL, on déconseille les fonctions head (qui ne respecte pas toujours l’ordre indiqué par arrange) ou top_n (superseded). La fonction slice en fonctionne pas : elle ne peut pas respecter l’ordre.",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#extraire-les-x-dernières-lignes-de-la-base",
    "href": "01-aide_memoire_r_sas.html#extraire-les-x-dernières-lignes-de-la-base",
    "title": "Aide-mémoire SAS - R",
    "section": "4.3 Extraire les x dernières lignes de la base",
    "text": "4.3 Extraire les x dernières lignes de la base\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let x = 10;\nproc sql noprint;select count(*) into :total_lignes from donnees_sas;quit;\n%let deb = %eval(&total_lignes. - &x. + 1);\ndata Lignes_&x.;set donnees_sas (firstobs = &deb. obs = &total_lignes.);run;\n\n\n\nx &lt;- 5\ntail(donnees_rbase, x)\n\n   identifiant sexe csp       niveau date_naissance date_entree duree note_contenu note_formateur note_moyens note_accompagnement\n23         187    2   2     Qualifié     1986-12-05  2023-01-01   364           10             10          10                  10\n24         689    1   1         &lt;NA&gt;     2000-12-01  2017-11-06   123            9              7           8                  13\n25         765    1   4 Non qualifié     1995-12-26  2020-04-17   160           13             10          12                  18\n26         765    1   4 Non qualifié     1995-12-26  2020-04-17   160           13             10          12                  18\n27         765    1   4 Non qualifié     1995-12-26  2020-04-17   160           13             10          12                  18\n   note_materiel poids_sondage                     cspf sexef date_sortie\n23            10         234.1 Profession intermédiaire Femme  2023-12-31\n24            16         189.3                    Cadre Homme  2018-03-09\n25            10          45.9                  Ouvrier Homme  2020-09-24\n26            10          45.9                  Ouvrier Homme  2020-09-24\n27            10          45.9                  Ouvrier Homme  2020-09-24\n\n\nAlternativement\n\ndonnees_rbase[ ( nrow(donnees_rbase) - x ) : nrow(donnees_rbase), ]\n\nLes parenthèses sont importantes. Comparer les deux expressions ! Bon exemple du recycling\n\n( nrow(donnees_rbase) - x ) : nrow(donnees_rbase)\n\n[1] 22 23 24 25 26 27\n\nnrow(donnees_rbase) - x : nrow(donnees_rbase)\n\n [1] 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0\n\n\n\n\n\ndonnees_tidyverse %&gt;% \n  slice( (n()-5) : n())\n\n# A tibble: 6 × 16\n  identifiant sexe  csp   niveau      date_naissance date_entree duree note_contenu note_formateur note_moyens note_accompagnement\n  &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;       &lt;date&gt;         &lt;date&gt;      &lt;int&gt;        &lt;int&gt;          &lt;int&gt;       &lt;int&gt;               &lt;int&gt;\n1 187         2     2     Qualifié    1986-12-05     2022-01-01    364           10             10          10                  10\n2 187         2     2     Qualifié    1986-12-05     2023-01-01    364           10             10          10                  10\n3 689         1     1     &lt;NA&gt;        2000-12-01     2017-11-06    123            9              7           8                  13\n4 765         1     4     Non qualif… 1995-12-26     2020-04-17    160           13             10          12                  18\n5 765         1     4     Non qualif… 1995-12-26     2020-04-17    160           13             10          12                  18\n6 765         1     4     Non qualif… 1995-12-26     2020-04-17    160           13             10          12                  18\n# ℹ 5 more variables: note_materiel &lt;int&gt;, poids_sondage &lt;dbl&gt;, cspf &lt;chr&gt;, sexef &lt;chr&gt;, date_sortie &lt;date&gt;\n\n\n\n\n\ntail(donnees_datatable, 5)\n\n   identifiant   sexe    csp       niveau date_naissance date_entree duree note_contenu note_formateur note_moyens\n        &lt;char&gt; &lt;char&gt; &lt;char&gt;       &lt;char&gt;         &lt;Date&gt;      &lt;Date&gt; &lt;num&gt;        &lt;num&gt;          &lt;num&gt;       &lt;num&gt;\n1:         187      2      2     Qualifié     1986-12-05  2023-01-01   364           10             10          10\n2:         689      1      1         &lt;NA&gt;     2000-12-01  2017-11-06   123            9              7           8\n3:         765      1      4 Non qualifié     1995-12-26  2020-04-17   160           13             10          12\n4:         765      1      4 Non qualifié     1995-12-26  2020-04-17   160           13             10          12\n5:         765      1      4 Non qualifié     1995-12-26  2020-04-17   160           13             10          12\n   note_accompagnement note_materiel poids_sondage                     cspf  sexef date_sortie\n                 &lt;num&gt;         &lt;num&gt;         &lt;num&gt;                   &lt;char&gt; &lt;char&gt;      &lt;Date&gt;\n1:                  10            10         234.1 Profession intermédiaire  Femme  2023-12-31\n2:                  13            16         189.3                    Cadre  Homme  2018-03-09\n3:                  18            10          45.9                  Ouvrier  Homme  2020-09-24\n4:                  18            10          45.9                  Ouvrier  Homme  2020-09-24\n5:                  18            10          45.9                  Ouvrier  Homme  2020-09-24\n\n\nAlternativement\n\n\n   identifiant   sexe    csp       niveau date_naissance date_entree duree note_contenu note_formateur note_moyens\n        &lt;char&gt; &lt;char&gt; &lt;char&gt;       &lt;char&gt;         &lt;Date&gt;      &lt;Date&gt; &lt;num&gt;        &lt;num&gt;          &lt;num&gt;       &lt;num&gt;\n1:         187      2      2     Qualifié     1986-12-05  2023-01-01   364           10             10          10\n2:         689      1      1         &lt;NA&gt;     2000-12-01  2017-11-06   123            9              7           8\n3:         765      1      4 Non qualifié     1995-12-26  2020-04-17   160           13             10          12\n4:         765      1      4 Non qualifié     1995-12-26  2020-04-17   160           13             10          12\n5:         765      1      4 Non qualifié     1995-12-26  2020-04-17   160           13             10          12\n   note_accompagnement note_materiel poids_sondage                     cspf  sexef date_sortie\n                 &lt;num&gt;         &lt;num&gt;         &lt;num&gt;                   &lt;char&gt; &lt;char&gt;      &lt;Date&gt;\n1:                  10            10         234.1 Profession intermédiaire  Femme  2023-12-31\n2:                  13            16         189.3                    Cadre  Homme  2018-03-09\n3:                  18            10          45.9                  Ouvrier  Homme  2020-09-24\n4:                  18            10          45.9                  Ouvrier  Homme  2020-09-24\n5:                  18            10          45.9                  Ouvrier  Homme  2020-09-24\n\n\n\n\nMêmes remarques que pour les premières lignes : il n’y a pas d’ordre a priori en SQL. On conseille slice_min ou slice_max qui indiquent explicitement l’ordre utilisé, et l’on déconseille slice et tail.\n\nrequete_duckdb %&gt;% slice_min(duree, n=5, with_ties=FALSE) # with_ties = TRUE retourne les cas d'égalité, donc plus de 5 lignes\n\n# Source:   SQL [5 x 16]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1021-azure:R 4.2.0/:memory:]\n  identifiant sexe  csp   niveau      date_naissance date_entree duree note_contenu note_formateur note_moyens note_accompagnement\n  &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;       &lt;date&gt;         &lt;date&gt;      &lt;int&gt;        &lt;int&gt;          &lt;int&gt;       &lt;int&gt;               &lt;int&gt;\n1 198         2     3     Non qualif… 1987-03-17     2022-07-28     30           10             10          10                  16\n2 689         1     1     &lt;NA&gt;        2000-12-01     2017-11-06    123            9              7           8                  13\n3 211         2     3     Non qualif… NA             2021-12-17    135           16             16          15                  12\n4 765         1     4     Non qualif… 1995-12-26     2020-04-17    160           13             10          12                  18\n5 765         1     4     Non qualif… 1995-12-26     2020-04-17    160           13             10          12                  18\n# ℹ 5 more variables: note_materiel &lt;int&gt;, poids_sondage &lt;dbl&gt;, cspf &lt;chr&gt;, sexef &lt;chr&gt;, date_sortie &lt;date&gt;",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#nombre-de-lignes-et-de-colonnes-dans-la-base",
    "href": "01-aide_memoire_r_sas.html#nombre-de-lignes-et-de-colonnes-dans-la-base",
    "title": "Aide-mémoire SAS - R",
    "section": "4.4 Nombre de lignes et de colonnes dans la base",
    "text": "4.4 Nombre de lignes et de colonnes dans la base\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Nombre de lignes */\nproc sql;select count(*) as Nb_Lignes from donnees_sas;quit;\nproc sql;\n  select count(*) as Nb_Lignes, count(distinct identifiant) as Nb_Identifiants\n  from donnees_sas;\nquit;\n/* Liste des variables de la base dans la base Var */\nproc contents data = donnees_sas out = Var noprint;run;\n/* Nombre de colonnes */\nproc sql;select count(*) as Nb_Colonnes from Var;run;\n\n\n\nsprintf(\"Nombre de lignes : %d | Nombre de colonnes : %d\", dim(donnees_rbase)[1], dim(donnees_rbase)[2])\nsprintf(\"Nombre de lignes : %d | Nombre de colonnes : %d\", nrow(donnees_rbase), ncol(donnees_rbase))\n\n\n\n\nsprintf(\"Nombre de lignes : %d | Nombre de colonnes : %d\",\n        donnees_tidyverse %&gt;% nrow(),\n        donnees_tidyverse %&gt;% ncol())\n# Nombre de lignes\ndonnees_tidyverse %&gt;% nrow()\n# Nombre de colonnes\ndonnees_tidyverse %&gt;% ncol()\n\n\n\n\ndim(donnees_datatable) ; dim(donnees_datatable)[1] ; dim(donnees_datatable)[2]\ndim(donnees_datatable) ; nrow(donnees_datatable) ; ncol(donnees_datatable)\nsprintf(\"Nombre de lignes : %d | Nombre de colonnes : %d\", dim(donnees_datatable)[1], dim(donnees_datatable)[2])\n\n\n\nDuckdb/SQL ne connaît pas le nombre de lignes sans un calcul. Il faut faire count().\n\n#Nombre de lignes\nrequete_duckdb %&gt;% nrow() # retourne NA\n\n[1] NA\n\nrequete_duckdb %&gt;% count() # correct\n\n# Source:   SQL [1 x 1]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1021-azure:R 4.2.0/:memory:]\n      n\n  &lt;dbl&gt;\n1    27\n\n#Nombre de colonnes\nrequete_duckdb %&gt;%  ncol()\n\n[1] 16",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#liste-des-variables-de-la-base",
    "href": "01-aide_memoire_r_sas.html#liste-des-variables-de-la-base",
    "title": "Aide-mémoire SAS - R",
    "section": "4.5 Liste des variables de la base",
    "text": "4.5 Liste des variables de la base\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Par ordre d'apparition dans la base */\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql;select name into :nom_col separated by \" \" from Var order by varnum;run;\n/* On affiche les noms des variables */\n%put Liste des variables : &nom_col.;\n/* Par ordre alphabétique */\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql;select name into :nom_col separated by \" \" from Var;run;\n/* On affiche les noms des variables */\n%put Liste des variables : &nom_col.;\n\n\n\n# Liste des variables par ordre d'apparition dans la base\nnames(donnees_rbase)\ncolnames(donnees_rbase)\n# Liste des variables par ordre alphabétique\nls(donnees_rbase)\nsort(colnames(donnees_rbase))\n\n\n\n\n# Liste des variables par ordre d'apparition dans la base\ndonnees_tidyverse %&gt;% colnames()\n# Liste des variables par ordre alphabétique\ndonnees_tidyverse %&gt;% colnames() %&gt;% sort()\n\n\n\n\n# Liste des variables par ordre d'apparition dans la base\ncolnames(donnees_datatable)\n# Liste des variables par ordre alphabétique\nsort(colnames(donnees_datatable))\n\n\n\n\nrequete_duckdb %&gt;% colnames()\n\n [1] \"identifiant\"         \"sexe\"                \"csp\"                 \"niveau\"              \"date_naissance\"     \n [6] \"date_entree\"         \"duree\"               \"note_contenu\"        \"note_formateur\"      \"note_moyens\"        \n[11] \"note_accompagnement\" \"note_materiel\"       \"poids_sondage\"       \"cspf\"                \"sexef\"              \n[16] \"date_sortie\"",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#nombre-didentifiants-uniques-et-nombre-de-lignes-dans-la-base",
    "href": "01-aide_memoire_r_sas.html#nombre-didentifiants-uniques-et-nombre-de-lignes-dans-la-base",
    "title": "Aide-mémoire SAS - R",
    "section": "4.6 Nombre d’identifiants uniques et nombre de lignes dans la base",
    "text": "4.6 Nombre d’identifiants uniques et nombre de lignes dans la base\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc sql;\n  select count(*) as Nb_Lignes, count(distinct identifiant) as Nb_Identifiants_Uniques\n  from donnees_sas;\nquit;\n\n\n\nsprintf(\"La base de données contient %d lignes et %d identifiants uniques !\",\n        nrow(donnees_rbase),\n        length(unique(donnees_rbase$identifiant)))\n\n\n\n\nsprintf(\"La base de données contient %d lignes et %d identifiants uniques !\",\n        donnees_tidyverse %&gt;% nrow(),\n        donnees_tidyverse %&gt;% select(identifiant) %&gt;%\n          n_distinct()\n        )\n# Autre solution pour le nombre d'identifiants uniques\ndonnees_tidyverse %&gt;% select(identifiant) %&gt;% n_distinct()\ndonnees_tidyverse %&gt;% distinct(identifiant) %&gt;% nrow()\n\n\n\n\nsprintf(\"La base de données contient %d lignes et %d identifiants uniques !\",\n        nrow(donnees_datatable),\n        donnees_datatable[, uniqueN(identifiant)])\n# Identifiants uniques\ndonnees_datatable[, uniqueN(identifiant)]\n\n\n\n\nrequete_duckdb %&gt;% nrow()\n\n[1] NA\n\nrequete_duckdb %&gt;% distinct(identifiant) %&gt;% count()\n\n# Source:   SQL [1 x 1]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1021-azure:R 4.2.0/:memory:]\n      n\n  &lt;dbl&gt;\n1    14\n\n\nNote : on a vu que nrow ne fonctionne pas en DuckDB.",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#quelle-est-la-position-de-la-variable-date_entree",
    "href": "01-aide_memoire_r_sas.html#quelle-est-la-position-de-la-variable-date_entree",
    "title": "Aide-mémoire SAS - R",
    "section": "4.7 Quelle est la position de la variable date_entree ?",
    "text": "4.7 Quelle est la position de la variable date_entree ?\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let var = date_entree;\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql;\n  select varnum as Position from Var where lowcase(NAME) = \"&var.\";\nrun;\n\n\n\nvariable &lt;- \"date_entree\"\npos &lt;- match(variable, names(donnees_rbase))\nsprintf(\"La variable %s se trouve en colonne n°%s !\", variable, pos)\n\n\n\n\nvariable &lt;- \"date_entree\"\npos &lt;- match(variable, donnees_tidyverse %&gt;% colnames())\nsprintf(\"La variable %s se trouve en colonne n°%s !\", variable, pos)\n\n\n\n\nvariable &lt;- \"date_entree\"\npos &lt;- match(variable, names(donnees_datatable))\nsprintf(\"La variable %s se trouve en colonne n°%s !\", variable, pos)\n\n\n\n\nvariable &lt;- \"date_entree\"\npos &lt;- match(variable, requete_duckdb %&gt;% colnames())\nsprintf(\"La variable %s se trouve en colonne n°%s !\", variable, pos)\n\n[1] \"La variable date_entree se trouve en colonne n°6 !\"\n\nrequete_duckdb %&gt;% select(pos) %&gt;% print(n=4)\n\n# Source:   SQL [?? x 1]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1021-azure:R 4.2.0/:memory:]\n  date_entree\n  &lt;date&gt;     \n1 2021-01-01 \n2 2022-01-01 \n3 2022-01-06 \n4 2023-01-02 \n# ℹ more rows",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#format-des-variables",
    "href": "01-aide_memoire_r_sas.html#format-des-variables",
    "title": "Aide-mémoire SAS - R",
    "section": "4.8 Format des variables",
    "text": "4.8 Format des variables\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc contents data = donnees_sas;run;\n\n/* On supprime la base Var temporaire */\nproc datasets lib = Work nolist;delete Var;run;\n\n\n\nsapply(donnees_rbase, class)\n\n\n\n\npurrr::map(donnees_tidyverse, class)\nclass(donnees_tidyverse)\n\n\n\n\ndonnees_datatable[, lapply(.SD, class)]\n\n\n\nOn ne peut pas appliquer directement la fonction class sur un objet de type connection. Cependant, DuckDB affiche le type des variables dans un print. On peut également appliquer la fonction class sur un extrait des données (après collect).\n\npurrr::map(requete_duckdb %&gt;% select(c(1,2)) %&gt;% head() %&gt;% collect(), class)\n\n$identifiant\n[1] \"character\"\n\n$sexe\n[1] \"character\"\n\nclass(requete_duckdb)\n\n[1] \"tbl_duckdb_connection\" \"tbl_dbi\"               \"tbl_sql\"               \"tbl_lazy\"              \"tbl\"",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#selection-de-colonnes-par-position",
    "href": "01-aide_memoire_r_sas.html#selection-de-colonnes-par-position",
    "title": "Aide-mémoire SAS - R",
    "section": "5.1 Selection de colonnes par position",
    "text": "5.1 Selection de colonnes par position\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let pos = 1;\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql noprint;\n  select name into :nom_col separated by \" \"\n  from Var\n  where varnum = &pos.;\nrun;\ndata Colonnes;set donnees_sas (keep = &nom_col.);run;\nproc datasets lib = Work nolist;delete Var;run;\n\n\n\npos &lt;- 1\n# Résultat sous forme de vecteur caractère\nid &lt;- donnees_rbase[[pos]] ; class(id)\nid &lt;- donnees_rbase[, pos] ; class(id)\n# Résultat sous forme de data.frame\nid &lt;- donnees_rbase[pos] ; class(id)\nid &lt;- donnees_rbase[, pos, drop = FALSE] ; class(id)\n\n\n\n\n# Sous forme de vecteur\nid &lt;- donnees_tidyverse %&gt;% pull(1)\nclass(id)\npos &lt;- 1\nid &lt;- donnees_tidyverse %&gt;% pull(all_of(pos))\nclass(id)\n# Sous forme de tibble\nid &lt;- donnees_tidyverse %&gt;% select(1)\nclass(id)\npos &lt;- 1\nid &lt;- donnees_tidyverse %&gt;% select(all_of(pos))\nclass(id)\n\n\n\n\npos &lt;- 1\n# Résultat sous forme de vecteur caractère\nid &lt;- donnees_datatable[[pos]] ; class(id)\n# Résultat sous forme de data.table\nid &lt;- donnees_datatable[pos] ; class(id)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#selection-de-colonnes-par-nom",
    "href": "01-aide_memoire_r_sas.html#selection-de-colonnes-par-nom",
    "title": "Aide-mémoire SAS - R",
    "section": "5.2 Selection de colonnes par nom",
    "text": "5.2 Selection de colonnes par nom\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata Colonnes;set donnees_sas (keep = identifiant);run;\ndata Colonnes;set donnees_sas;keep identifiant;run;\n\n\n\n# Résultat sous forme de vecteur caractère\nid &lt;- donnees_rbase$identifiant ; class(id)\nid &lt;- donnees_rbase[[\"identifiant\"]] ; class(id)\nid &lt;- donnees_rbase[, \"identifiant\"] ; class(id)\n# Résultat sous forme de data.frame\nclass(donnees_rbase[, \"identifiant\"])\n# Attention, utilisation du drop = FALSE étrange\n# En fait, l'affectation par [] a pour option par défaut drop = TRUE. Ce qui implique que si l'affectation renvoie\n# un data.frame d'1 seule colonne, l'objet sera transformé en objet plus simple (vecteur en l'occurrence)\nclass(donnees_rbase[, \"identifiant\", drop = FALSE])\nid &lt;- donnees_rbase[\"identifiant\"] ; class(id)\nid &lt;- donnees_rbase[, \"identifiant\", drop = FALSE] ; class(id)\n\n\n\n\n# Sous forme de vecteur\nid &lt;- donnees_tidyverse %&gt;% pull(identifiant)\nid &lt;- donnees_tidyverse %&gt;% pull(\"identifiant\")\n# Sous forme de tibble\nid &lt;- donnees_tidyverse %&gt;% select(identifiant)\nid &lt;- donnees_tidyverse %&gt;% select(\"identifiant\")\n\n\n\n\n# Résultat sous forme de vecteur caractère\nid &lt;- donnees_datatable$identifiant ; class(id)\nid &lt;- donnees_datatable[[\"identifiant\"]] ; class(id)\nid &lt;- donnees_datatable[, identifiant] ; class(id)\n# Résultat sous forme de data.table\nid &lt;- donnees_datatable[, \"identifiant\"] ; class(id)\nid &lt;- donnees_datatable[, .(\"identifiant\")] ; class(id)\nid &lt;- donnees_datatable[, list(\"identifiant\")] ; class(id)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#selection-de-colonnes-par-variable",
    "href": "01-aide_memoire_r_sas.html#selection-de-colonnes-par-variable",
    "title": "Aide-mémoire SAS - R",
    "section": "5.3 Selection de colonnes par variable",
    "text": "5.3 Selection de colonnes par variable\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let var = identifiant Sexe note_contenu;\ndata Colonnes;\n  /* Sélection de colonnes */\n  set donnees_sas (keep = &var.);\n  /* Selection de colonnes */\n  keep &var.;\nrun;\n\n\n\nvariable &lt;- \"identifiant\"\n# Résultat sous forme de vecteur caractère\nid &lt;- donnees_rbase[, variable] ; class(id)\nid &lt;- donnees_rbase[[variable]] ; class(id)\n# Résultat sous forme de data.frame\nid &lt;- donnees_rbase[variable] ; class(id)\nid &lt;- donnees_rbase[, variable, drop = FALSE] ; class(id)\n\n\n\n\nvariable &lt;- \"identifiant\"\n# Sous forme de vecteur\nid &lt;- donnees_tidyverse %&gt;% pull(all_of(variable))\n# Sous forme de tibble\nid &lt;- donnees_tidyverse %&gt;% select(all_of(variable))\n\n\n\n\n# Résultat sous forme de vecteur caractère\nvariable &lt;- \"identifiant\"\nid &lt;- donnees_datatable[[variable]] ; class(id)\n# Résultat sous forme de data.table\nid &lt;- donnees_datatable[, .(variable)] ; class(id)\nid &lt;- donnees_datatable[, list(variable)] ; class(id)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sauf-certaines-variables",
    "href": "01-aide_memoire_r_sas.html#sauf-certaines-variables",
    "title": "Aide-mémoire SAS - R",
    "section": "5.4 Sauf certaines variables",
    "text": "5.4 Sauf certaines variables\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let var = identifiant Sexe note_contenu;\ndata Colonnes;set donnees_sas (drop = &var.);run;\n\n\n\n# Ne fonctionne pas !\nvariable &lt;- c(\"identifiant\", \"identifiant\", \"sexe\", \"note_contenu\")\n#exclusion_var &lt;- donnees_rbase[, -c(variable)]\nexclusion_var &lt;- donnees_rbase[, setdiff(names(donnees_rbase), variable)]\n\n\n\n\nvariable &lt;- c(\"identifiant\", \"identifiant\", \"sexe\", \"note_contenu\")\nexclusion_var &lt;- donnees_tidyverse %&gt;% select(!all_of(variable))\nexclusion_var &lt;- donnees_tidyverse %&gt;% select(-all_of(variable))\n\n\n\n\nvariable &lt;- c(\"identifiant\", \"identifiant\", \"sexe\", \"note_contenu\")\n# Ne fonctionne pas !\n#exclusion_var &lt;- donnees_datatable[, -c(variable)]\nexclusion_var &lt;- donnees_datatable[, setdiff(names(donnees_datatable), variable)]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-la-3e-colonne",
    "href": "01-aide_memoire_r_sas.html#sélectionner-la-3e-colonne",
    "title": "Aide-mémoire SAS - R",
    "section": "5.5 Sélectionner la 3e colonne",
    "text": "5.5 Sélectionner la 3e colonne\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql noprint;\n  select name into :nom_col separated by \" \"\n  from Var\n  where varnum = 3;\nrun;\ndata Col3;set donnees_sas (keep = &nom_col.);run;\n\n\n\ncol3 &lt;- donnees_rbase[, 3]\ncol3 &lt;- donnees_rbase[3]\n\n\n\n\ncol3 &lt;- donnees_tidyverse %&gt;% pull(3)\ncol3 &lt;- donnees_tidyverse %&gt;% select(3)\n\n\n\n\ncol3 &lt;- donnees_datatable[, 3]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-plusieurs-colonnes",
    "href": "01-aide_memoire_r_sas.html#sélectionner-plusieurs-colonnes",
    "title": "Aide-mémoire SAS - R",
    "section": "5.6 Sélectionner plusieurs colonnes",
    "text": "5.6 Sélectionner plusieurs colonnes\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let var = identifiant note_contenu sexe;\ndata Colonnes;set donnees_sas (keep = &var.);run;\nproc sql;\n  create table Colonnes as\n  select %sysfunc(tranwrd(&var., %str( ), %str(, )))\n  from donnees_sas;\nquit;\n\n\n\ncols &lt;- c(\"identifiant\", \"note_contenu\", \"sexe\")\ncolonnes &lt;- donnees_rbase[, cols]\n\n\n\n\ncols &lt;- c(\"identifiant\", \"note_contenu\", \"sexe\")\n# Plusieurs possibilités\ncolonnes &lt;- donnees_tidyverse %&gt;% select(all_of(cols))\ncolonnes &lt;- donnees_tidyverse %&gt;% select(any_of(cols))\ncolonnes &lt;- donnees_tidyverse %&gt;% select({{cols}})\ncolonnes &lt;- donnees_tidyverse %&gt;% select(!!cols)\n\n\n\n\ncols &lt;- c(\"identifiant\", \"note_contenu\", \"sexe\")\n# Plusieurs écritures possibles\n# Peut-être l'écriture la plus simple, à privilégier\ncolonnes &lt;- donnees_datatable[, mget(cols)]\n# Ecriture cohérente avec la logique data.table\ncolonnes &lt;- donnees_datatable[, .SD, .SDcols = cols]\n# Ecriture un peu contre-intuitve. Attention ! L'écriture est bien ..cols, et non ..(cols) !!\n# Les syntaxes donnees_datatable[, ..(cols)] et donnees_datatable[, .(cols)] ne fonctionnent pas\ncolonnes &lt;- donnees_datatable[, ..cols]\n# Ecriture avec with = FALSE : désactive la possibilité de se référer à des colonnes sans les guillemets\n# Avec with = FALSE : désactive la possibilité de se référer à des colonnes sans les guillemets\ncolonnes &lt;- donnees_datatable[, cols, with = FALSE]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-les-colonnes-qui-débutent-par-le-mot-note",
    "href": "01-aide_memoire_r_sas.html#sélectionner-les-colonnes-qui-débutent-par-le-mot-note",
    "title": "Aide-mémoire SAS - R",
    "section": "5.7 Sélectionner les colonnes qui débutent par le mot Note",
    "text": "5.7 Sélectionner les colonnes qui débutent par le mot Note\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* 1ère solution */\ndata Selection_Variables;set donnees_sas (keep = Note:);run;\n/* 2e solution */\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql;\n  select name into :var_notes separated by \" \"\n  from Var where substr(upcase(name), 1, 4) = \"NOTE\" order by varnum;\nrun;\nproc datasets lib = Work nolist;delete Var;run;\ndata donnees_sas_Notes;set donnees_sas (keep = &var_notes.);run;\n\n\n\nvarNotes &lt;- donnees_rbase[grepl(\"^note\", names(donnees_rbase))]\nvarNotes &lt;- donnees_rbase[substr(tolower(names(donnees_rbase)), 1, 4) == \"note\"]\n\n\n\n\nvarNotes &lt;- donnees_tidyverse %&gt;% select(starts_with(\"note\"))\n\n\n\n\n# 1ère méthode\ncols &lt;- names(donnees_datatable)[substr(names(donnees_datatable), 1, 4) == \"note\"]\nsel &lt;- donnees_datatable[, .SD, .SDcols = cols]\n# 2e méthode\nsel &lt;- donnees_datatable[, .SD, .SDcols = patterns(\"^note\")]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-les-colonnes-qui-ne-débutent-pas-par-le-mot-note",
    "href": "01-aide_memoire_r_sas.html#sélectionner-les-colonnes-qui-ne-débutent-pas-par-le-mot-note",
    "title": "Aide-mémoire SAS - R",
    "section": "5.8 Sélectionner les colonnes qui ne débutent pas par le mot Note",
    "text": "5.8 Sélectionner les colonnes qui ne débutent pas par le mot Note\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata Selection_Variables;set donnees_sas (drop = Note:);run;\n\n\n\nvarNotes &lt;- donnees_rbase[! grepl(\"^note\", names(donnees_rbase))]\nvarNotes &lt;- donnees_rbase[substr(tolower(names(donnees_rbase)), 1, 4) != \"note\"]\n\n\n\n\nvarNotes &lt;- donnees_tidyverse %&gt;% select(-starts_with(\"note\"))\nvarNotes &lt;- donnees_tidyverse %&gt;% select(!starts_with(\"note\"))\n\n\n\n\ncols &lt;- names(donnees_datatable)[substr(names(donnees_datatable), 1, 4) == \"note\"]\nsel &lt;- donnees_datatable[, .SD, .SDcols = -cols]\nsel &lt;- donnees_datatable[, .SD, .SDcols = -patterns(\"^note\")]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-lensemble-des-variables-numériques-de-la-base",
    "href": "01-aide_memoire_r_sas.html#sélectionner-lensemble-des-variables-numériques-de-la-base",
    "title": "Aide-mémoire SAS - R",
    "section": "5.9 Sélectionner l’ensemble des variables numériques de la base",
    "text": "5.9 Sélectionner l’ensemble des variables numériques de la base\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata Colonnes;set donnees_sas (keep = _numeric_);run;\n\n\n\nvarNumeriques &lt;- donnees_rbase[, sapply(donnees_rbase, is.numeric), drop = FALSE]\n\n\n\n\nvarNumeriques &lt;- donnees_tidyverse %&gt;% select_if(is.numeric)\nvarNumeriques &lt;- donnees_tidyverse %&gt;% select(where(is.numeric))\n\n\n\n\nsel &lt;- donnees_datatable[, .SD, .SDcols = is.numeric]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-lensemble-des-variables-de-format-date",
    "href": "01-aide_memoire_r_sas.html#sélectionner-lensemble-des-variables-de-format-date",
    "title": "Aide-mémoire SAS - R",
    "section": "5.10 Sélectionner l’ensemble des variables de format “Date”",
    "text": "5.10 Sélectionner l’ensemble des variables de format “Date”\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql noprint;\n  select name into :nom_col separated by \" \"\n  from Var where format not in (\"$\", \"\");\nrun;\ndata Colonnes;set donnees_sas (keep = &nom_col.);run;\nproc datasets lib = Work nolist;delete Var;run;\n\n\n\nvarDates &lt;- donnees_rbase[, sapply(donnees_rbase, is.Date), drop = FALSE]\nvarDates &lt;- Filter(is.Date, donnees_rbase)\n\n\n\n\nvarDates &lt;- donnees_tidyverse %&gt;% select_if(is.Date)\nvarDates &lt;- donnees_tidyverse %&gt;% select(where(is.Date))\n\n\n\n\nvar_dates &lt;- donnees_datatable[, .SD, .SDcols = is.Date]\n\n# Sélection de lignes",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-des-lignes",
    "href": "01-aide_memoire_r_sas.html#sélectionner-des-lignes",
    "title": "Aide-mémoire SAS - R",
    "section": "5.11 Sélectionner des lignes",
    "text": "5.11 Sélectionner des lignes\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* 3e ligne */\ndata Ligne3;set donnees_sas (firstobs = 3 obs = 3);run;\n\n/* Sélection des 3 premières lignes et des 3 premières colonnes de la base */\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql noprint;\n  select name into :nom_col separated by \" \" from Var\n  where 1 &lt;= varnum &lt;= 3;\nrun;\ndata Top3;\n  set donnees_sas (firstobs = 1 obs = 3 keep = &nom_col.);\nrun;\nproc datasets lib = Work nolist;delete Var;run;\n\n/* Sélection de lignes */\n/* Entrées en 2023 */\ndata En2023;\n  set donnees_sas (where = (year(date_entree) = 2023));\nrun;\ndata Avant2023_femme;\n  set donnees_sas (where = (year(date_entree) &lt; 2023 and sexe = 2));\nrun;\n\n\n\n# Sélection des 3 premières lignes et des 3 premières colonnes de la base\ntop3 &lt;- donnees_rbase[1:3, 1:3]\n\n# 3e ligne\nligne3 &lt;- donnees_rbase[3, ]\n\n# Sélection de lignes\n# Entrées en 2023\n# ATTENTION, solution qui ne fonctionne pas toujours bien ! En effet, les valeurs manquantes sont sélectionnées !\nen2023 &lt;- donnees_rbase[lubridate::year(donnees_rbase$date_entree) == 2023, ]\n# Bonnes écritures, qui excluent les valeurs manquantes\nen2023 &lt;- donnees_rbase[lubridate::year(donnees_rbase$date_entree) %in% c(2023), ]\nen2023 &lt;- donnees_rbase[which(lubridate::year(donnees_rbase$date_entree) == 2023), ]\nen2023 &lt;- subset(donnees_rbase, lubridate::year(donnees_rbase$date_entree) == 2023)\n\n\n\n\n# Sélection des 3 premières lignes et des 3 premières colonnes de la base\ntop3 &lt;- donnees_tidyverse %&gt;% slice(1:3) %&gt;% select(1:3)\n\n# 3e ligne\nligne3 &lt;- donnees_tidyverse %&gt;% slice(3)\n\n# Sélection de lignes\n# Entrées en 2023\nen2023 &lt;- donnees_tidyverse %&gt;% filter(lubridate::year(date_entree) == 2023)\n\n\n\n\ntop3 &lt;- donnees_datatable[1:3, 1:3]\n\n# 3e ligne\nligne3 &lt;- donnees_datatable[3, ]\nligne3 &lt;- donnees_datatable[3]\n\n# Sélection de lignes\n# Entrées en 2023\n# Pas de problème avec les valeurs manquantes comme pour la syntaxe en R-Base\nen2023 &lt;- donnees_datatable[lubridate::year(date_entree) == 2023, ]\nen2023 &lt;- donnees_datatable[lubridate::year(date_entree) == 2023]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélection-sur-de-multiples-conditions",
    "href": "01-aide_memoire_r_sas.html#sélection-sur-de-multiples-conditions",
    "title": "Aide-mémoire SAS - R",
    "section": "5.12 Sélection sur de multiples conditions",
    "text": "5.12 Sélection sur de multiples conditions\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Ecriture incorrecte. Les valeurs manquantes sont considérées comme des nombres négatifs faibles, et inférieurs à 2023. */\n/* Ils sont sélectionnés dans le code suivant : */\ndata Avant2023_Femme;\n  set donnees_sas (where = (year(date_entree) &lt; 2023 and sexe = 2));\nrun;\n/* Ecriture correcte */\ndata Avant2023_Femme;\n  set donnees_sas (where = (year(date_entree) &lt; 2023 and not missing(date_entree) and sexe = 2));\nrun;\n\n\n\navant2023_femme &lt;- subset(donnees_rbase, lubridate::year(date_entree) &lt; 2023 & sexe == \"2\")\n\n\n\n\navant2023_femme &lt;- donnees_tidyverse %&gt;% \n  filter(lubridate::year(date_entree) &lt; 2023 & sexe == \"2\")\n\n\n\n\navant2023_femme &lt;- donnees_datatable[lubridate::year(date_entree) &lt; 2023 & sexe == \"2\"]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélection-de-ligne-par-référence-lignes-de-lidentifiant-087",
    "href": "01-aide_memoire_r_sas.html#sélection-de-ligne-par-référence-lignes-de-lidentifiant-087",
    "title": "Aide-mémoire SAS - R",
    "section": "5.13 Sélection de ligne par référence : lignes de l’identifiant 087",
    "text": "5.13 Sélection de ligne par référence : lignes de l’identifiant 087\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let var = identifiant;\n%let sel = 087;\ndata Selection;\n  set donnees_sas;\n  if &var. in (\"&sel.\");\nrun;\n\n\n\nvariable &lt;- \"identifiant\"\nsel &lt;- \"087\"\ndonnees_rbase[donnees_rbase[, variable] %in% sel, ]\n\n\n\n\ndonnees_tidyverse %&gt;% filter(identifiant %in% c(\"087\")) %&gt;% select(identifiant)\ndonnees_tidyverse %&gt;% filter(identifiant == \"087\") %&gt;% select(identifiant)\n# Essayons désormais par variables\nvariable &lt;- \"identifiant\"\nsel &lt;- \"087\"\n# À FAIRE : peut-on faire plus simplement ?\ndonnees_tidyverse %&gt;% filter(get(variable) %in% sel) %&gt;% select(all_of(variable))\n\n\n\n\nvariable &lt;- \"identifiant\"\nsel &lt;- \"087\"\ndonnees_datatable[donnees_datatable[[variable]] %chin% sel, ]\ndonnees_datatable[donnees_datatable[[variable]] %chin% sel, ]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélection-de-lignes-et-de-variables",
    "href": "01-aide_memoire_r_sas.html#sélection-de-lignes-et-de-variables",
    "title": "Aide-mémoire SAS - R",
    "section": "5.14 Sélection de lignes et de variables",
    "text": "5.14 Sélection de lignes et de variables\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let cols = identifiant note_contenu sexe;\ndata Femmes;\n  set donnees_sas (where = (Sexe = 2) keep = &cols.);\nrun;\ndata Femmes;\n  set donnees_sas;\n  if Sexe = 2;\n  keep &cols.;\nrun;\n\n/* Par nom ou par variable */\n%let var = identifiant Sexe note_contenu;\ndata Femmes;\n  /* Sélection de colonnes */\n  set donnees_sas (keep = &var.);\n  /* Sélection de lignes respectant une certaine condition */\n  if Sexe = \"2\";\n  /* Création de colonne */\n  note2 = note_contenu / 20 * 5;\n  /* Suppression de colonnes */\n  drop Sexe;\n  /* Selection de colonnes */\n  keep identifiant Sexe note_contenu;\nrun;\n\n\n\ncols &lt;- c(\"identifiant\", \"note_contenu\", \"sexe\", \"date_naissance\")\nfemmes &lt;- donnees_rbase[donnees_rbase$sexe %in% c(\"2\"), cols]\n\n\n\n\ncols &lt;- c(\"identifiant\", \"note_contenu\", \"sexe\", \"date_naissance\")\nfemmes &lt;- donnees_tidyverse %&gt;% filter(sexe == \"2\") %&gt;% select(all_of(cols))\nfemmes &lt;- donnees_tidyverse %&gt;% filter(sexe == \"2\") %&gt;% select({{cols}})\n\n\n\n\ncols &lt;- c(\"identifiant\", \"note_contenu\", \"sexe\", \"date_naissance\")\nfemmes &lt;- donnees_datatable[sexe == \"2\", ..cols]\n\n\n\n\n# À FAIRE : compléter\n#requete_duckdb %&gt;% filter(sexe == \"2\")",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#renommer-des-variables",
    "href": "01-aide_memoire_r_sas.html#renommer-des-variables",
    "title": "Aide-mémoire SAS - R",
    "section": "6.1 Renommer des variables",
    "text": "6.1 Renommer des variables\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata donnees_sas;\n  set donnees_sas (rename = (sexe = sexe2));\n  rename sexe2 = sexe;\nrun;\n\n\n\n# On renomme la variable sexe en sexe_red\nnames(donnees_rbase)[names(donnees_rbase) == \"sexe\"] &lt;- \"sexe_red\"\n# On la renomme en sexe\nnames(donnees_rbase)[names(donnees_rbase) == \"sexe_red\"] &lt;- \"sexe\"\n\n\n\n\n# On renomme la variable sexe en sexe_red\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  rename(sexe_red = sexe)\n# On la renomme en sexe\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  rename(sexe = sexe_red)\n\n\n\n\n# On renomme la variable sexe en sexe_red\nnames(donnees_datatable)[names(donnees_datatable) == \"sexe\"] &lt;- \"sexe_red\"\n# On la renomme en sexe\nnames(donnees_datatable)[names(donnees_datatable) == \"sexe_red\"] &lt;- \"sexe\"\n# Autre solution\n# En data.table, les instructions débutant par set modifient les éléments par référence, c'est-à-dire sans copie.\n# Ceci est plus efficace pour manipuler des données volumineuses.\nsetnames(donnees_datatable, \"sexe\", \"sexe_red\")\nsetnames(donnees_datatable, \"sexe_red\", \"sexe\")\n\n\n\n\n# On renomme la variable sexe en sexe_red\nrequete_duckdb %&gt;% rename(sexe_red = sexe)\n\n# Source:   SQL [?? x 16]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1021-azure:R 4.2.0/:memory:]\n   identifiant sexe_red csp   niveau  date_naissance date_entree duree note_contenu note_formateur note_moyens note_accompagnement\n   &lt;chr&gt;       &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt;   &lt;date&gt;         &lt;date&gt;      &lt;int&gt;        &lt;int&gt;          &lt;int&gt;       &lt;int&gt;               &lt;int&gt;\n 1 173         2        1     Qualif… 1998-06-17     2021-01-01    308           12              6          17                   4\n 2 173         2        1     Qualif… 1998-06-17     2022-01-01    365            6             NA          12                   7\n 3 173         2        1     Qualif… 1998-06-17     2022-01-06    185            8             10          11                   1\n 4 173         2        1     Non qu… 1998-06-17     2023-01-02    365           14             15          15                  10\n 5 174         1        1     Qualif… 1984-12-08     2021-08-17    183           17             18          20                  15\n 6 175         1        1     Qualif… 1989-09-16     2022-12-21    730            5              5           8                   4\n 7 198         2        3     Non qu… 1987-03-17     2022-07-28     30           10             10          10                  16\n 8 198         2        3     Qualif… 1987-03-17     2022-11-17    164           11              7           6                  14\n 9 198         2        3     Qualif… 1987-03-17     2023-02-21    365            9             20           3                   4\n10 168         1        2     Qualif… 2002-07-30     2019-09-04    365           18             11          20                  13\n# ℹ more rows\n# ℹ 5 more variables: note_materiel &lt;int&gt;, poids_sondage &lt;dbl&gt;, cspf &lt;chr&gt;, sexef &lt;chr&gt;, date_sortie &lt;date&gt;",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#formater-les-modalités-des-valeurs",
    "href": "01-aide_memoire_r_sas.html#formater-les-modalités-des-valeurs",
    "title": "Aide-mémoire SAS - R",
    "section": "6.2 Formater les modalités des valeurs",
    "text": "6.2 Formater les modalités des valeurs\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Utilisation des formats */\nproc format;\n  /* Variable discrète */\n  value sexef\n  1 = \"Homme\"\n  2 = \"Femme\";\n\n  /* Variable continue */\n  value agef\n  low-&lt;26 = \"1. De 15 à 25 ans\"\n  26&lt;-&lt;50 = \"2. De 26 à 49 ans\"\n  50-high = \"3. 50 ans ou plus\";\n\n  /* Variable caractère */\n  value $ cspf\n  '1' = \"Cadre\"\n  '2' = \"Profession intermédiaire\"\n  '3' = \"Employé\"\n  '4' = \"Ouvrier\"\n  '5' = \"Retraité\";\nrun;\n\n\n\nsexef &lt;- c(\"1\" = \"Homme\", \"2\" = \"Femme\")\ncspf &lt;- c(\"1\" = \"Cadre\", \"2\" = \"Profession intermédiaire\", \"3\" = \"Employé\", \"4\" = \"Ouvrier\", \"5\" = \"Retraité\")\n\n\n\n\nsexef_format &lt;- c(\"1\" = \"Homme\", \"2\" = \"Femme\")\ncspf_format &lt;- c(\"1\" = \"Cadre\", \"2\" = \"Profession intermédiaire\", \"3\" = \"Employé\", \"4\" = \"Ouvrier\", \"5\" = \"Retraité\")\n\n\n\n\nsexeform &lt;- c(\"1\" = \"Homme\", \"2\" = \"Femme\")\ncspform &lt;- c(\"1\" = \"Cadre\", \"2\" = \"Profession intermédiaire\", \"3\" = \"Employé\", \"4\" = \"Ouvrier\", \"5\" = \"Retraité\")\n\n\n\nPréférer case_match quand il s’agit de valeurs déterminées.\n\nrequete_duckdb %&gt;% \n  mutate(sexef = case_when(\n    sexef==\"1\" ~ \"Homme\",\n    sexef==\"2\" ~ \"Femme\",\n    .default = sexef),\n         cspf = case_match(csp,\n    \"1\" ~ \"Cadre\",\n    \"2\" ~ \"Profession intermédiaire\",\n    \"3\" ~ \"Employé\",\n    \"4\" ~ \"Ouvrier\",\n    \"5\" ~ \"Retraité\",\n    .default = csp)) %&gt;% \n  select(Sexe, sexef, csp, cspf)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#utiliser-les-formats",
    "href": "01-aide_memoire_r_sas.html#utiliser-les-formats",
    "title": "Aide-mémoire SAS - R",
    "section": "6.3 Utiliser les formats",
    "text": "6.3 Utiliser les formats\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata donnees_sas;\n  set donnees_sas;\n  /* Exprimer dans le format sexef (Hommes / Femmes) */\n  format Sexef $25.;\n  Sexef = put(Sexe, sexef.);\n  /* On exprime la CSP en texte dans une variable CSPF avec le format */\n  format CSPF $25.;\n  CSPF = put(CSP, $cspf.);\nrun;\n\n\n\n# On exprime CSP et sexe en formaté\ndonnees_rbase$cspf &lt;- cspf[donnees_rbase$csp]\ndonnees_rbase$sexef &lt;- sexef[donnees_rbase$sexe]\n\n\n\n\n# On exprime CSP et sexe en formaté\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(sexef = sexef_format[sexe],\n         cspf = cspf_format[csp])\n\n# Autre solution\n# Les éventuelles valeurs manquantes sont conservées en NA\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(\n    sexef = case_when(\n      sexe == \"1\" ~ \"Homme\",\n      sexe == \"2\" ~ \"Femme\",\n      TRUE        ~ sexe),\n    cspf = case_when(\n      csp == \"1\" ~ \"Cadre\",\n      csp == \"2\" ~ \"Profession intermédiaire\",\n      csp == \"3\" ~ \"Employé\",\n      csp == \"4\" ~ \"Ouvrier\",\n      csp == \"5\" ~ \"Retraité\",\n      TRUE       ~ csp)\n    )\n# Syntaxe pour attribuer une valeur aux NA\nvaleurAuxNA &lt;- donnees_tidyverse %&gt;% \n  mutate(sexef = case_when(\n    sexe == \"1\" ~ \"Homme\",\n    sexe == \"2\" ~ \"Femme\",\n    is.na(x)    ~ \"Inconnu\",\n    TRUE        ~ sexe))\n\n\n\n\n# On exprime CSP et sexe en formaté\ndonnees_datatable[, `:=` (cspf = cspform[csp], sexef = sexeform[sexe])]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#transformer-le-format-dune-variable",
    "href": "01-aide_memoire_r_sas.html#transformer-le-format-dune-variable",
    "title": "Aide-mémoire SAS - R",
    "section": "6.4 Transformer le format d’une variable",
    "text": "6.4 Transformer le format d’une variable\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata donnees_sas;\n  set donnees_sas;\n  /* Transformer la variable Sexe en caractère */\n  Sexe_car = put(Sexe, $1.);\n  /* Transformer la variable Sexe_car en numérique */\n  Sexe_num = input(Sexe_car, 1.);\n  /* Transformer une date d'un format caractère à un format Date */\n  format date $10.;\n  date = \"01/01/2000\";\n  format date_sas yymmdd10.;\n  date_sas = input(date, ddmmyy10.);\nrun;\n\n\n\n# Transformer la variable sexe en numérique\ndonnees_rbase$sexe_numerique &lt;- as.numeric(donnees_rbase$sexe)\n# Transformer la variable sexe_numerique en caractère\ndonnees_rbase$sexe_caractere &lt;- as.character(donnees_rbase$sexe_numerique)\n# Transformer une date d'un format caractère à un format Date\ndonnees_rbase$date_r &lt;- lubridate::dmy(\"01/01/2000\")\n\n\n\n\n# Transformer la variable sexe en numérique\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%  \n  mutate(sexe_numerique = as.numeric(sexe))\n\n# Transformer la variable sexe_numerique en caractère\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  mutate(sexe_caractere = as.character(sexe_numerique))\n\n# Transformer une date d'un format caractère à un format Date\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%  \n  mutate(date_r = lubridate::dmy(\"01/01/2000\"))\n\n\n\n\n# Transformer la variable sexe en numérique\ndonnees_datatable[, sexe_numerique := as.numeric(sexe)]\n# Transformer la variable sexe_numerique en caractère\ndonnees_datatable[, sexe_caractere := as.numeric(sexe_numerique)]\n# Transformer une date d'un format caractère à un format Date\ndonnees_datatable[, date_r := lubridate::dmy(\"01/01/2000\")]\n\n\n\n\n# À FAIRE\n#enNumerique &lt;- c(\"Duree\", \"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\")\n#enDate &lt;- c('Date_naissance', 'Date_entree')\n#\n#requete_duckdb %&gt;%  \n#  mutate_at(enNumerique, as.integer) %&gt;% \n#  mutate(poids_sondage=as.numeric(poids_sondage)) %&gt;%\n#  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %&gt;% # strptime est une fonction duckdb\n#  select(enDate, Duree, Note_Contenu)\n#\n\nNote : duckdb fait des conversions de type implicitement, mais seulement les conversions incontestables. Il faudra souvent préciser le type des variables.",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#création-et-suppressions-de-plusieurs-variables",
    "href": "01-aide_memoire_r_sas.html#création-et-suppressions-de-plusieurs-variables",
    "title": "Aide-mémoire SAS - R",
    "section": "6.5 Création et suppressions de plusieurs variables",
    "text": "6.5 Création et suppressions de plusieurs variables\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Manipulation de colonnes par référence */\ndata Creation;\n  set donnees_sas;\n  note_contenu2 = note_contenu / 20 * 5;\n  note_formateur2 = note_formateur / 20 * 5;\n  /* Suppression des variables créées */\n  drop note_contenu2 note_formateur2;\nrun;\n\n/* Par nom ou par variable */\n%let var = identifiant Sexe note_contenu;\ndata Femmes;\n  /* Sélection de colonnes */\n  set donnees_sas (keep = &var.);\n  /* Sélection de lignes respectant une certaine condition */\n  if Sexe = \"2\";\n  /* Création de colonne */\n  note2 = note_contenu / 20 * 5;\n  /* Suppression de colonnes */\n  drop note2;\n  /* Selection de colonnes */\n  keep identifiant Sexe note_contenu;\nrun;\n\n\n\ndonnees_rbase$note2 &lt;- donnees_rbase$note_contenu / 20 * 5\n# Le with permet de s'affranchir des expressions \"donnees_rbase$\"\nwith(donnees_rbase, note2 &lt;- note_contenu / 20 * 5)\ndonnees_rbase &lt;- transform(donnees_rbase, note2 = note_contenu / 20 * 5)\n# On ne peut pas utiliser transform pour des variables récemment créées\n#donnees_rbase &lt;- transform(donnees_rbase, note3 = note_contenu ** 2, note3 = log(note3))\n\n# Suppression de variables\ndonnees_rbase$note2 &lt;- NULL\n\n# Création et suppressions de plusieurs variables\ndonnees_rbase &lt;- transform(donnees_rbase, note_contenu2 = note_contenu / 20 * 5, note_formateur2 = note_formateur / 20 * 5)\n# Suppression des variables créées\nvariable &lt;- c(\"note_contenu2\", \"note_formateur2\")\ndonnees_rbase[, variable] &lt;- NULL\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(note2 = note_contenu / 20 * 5)\n\n# Suppression de variables\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  select(-note2)\n\n# Création et suppressions de plusieurs variables\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(note_contenu2 = note_contenu / 20 * 5,\n         note_formateur2 = note_formateur / 20 * 5)\n\n# Suppression des variables créées\nvariable &lt;- c(\"note_contenu2\", \"note_formateur2\")\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  select(-all_of(variable))\n\n\n\n\n# Création de variables\ndonnees_datatable[, note2 := note_contenu / 20 * 5]\n\n# Suppression de variables\ndonnees_datatable[, note2 := NULL]\n\n# Création et suppressions de plusieurs variables\ndonnees_datatable[, c(\"note_contenu2\", \"note_formateur2\") := list(note_contenu / 20 * 5, note_formateur / 20 * 5)]\ndonnees_datatable[, `:=` (note_contenu2 = note_contenu / 20 * 5, note_formateur2 = note_formateur / 20 * 5)]\n# Suppression des variables créées\ndonnees_datatable[, c(\"note_contenu2\", \"note_formateur2\") := NULL]\n# Ou par référence extérieure\nvariable &lt;- c(\"note_contenu2\", \"note_formateur2\")\ndonnees_datatable[, `:=` (note_contenu2 = note_contenu / 20 * 5, note_formateur2 = note_formateur / 20 * 5)]\ndonnees_datatable[, (variable) := NULL]\n\n\n\n\n# À FAIRE : à compléter !\n# Création de la colonne note2\nrequete_duckdb %&gt;% \n  mutate(note2 = as.integer(Note_Contenu) / 20 * 5) %&gt;% \n  select(note2)\n\n# Suppression de colonnes\n#requete_duckdb %&gt;% select(- CSP, -contains(\"Date\"), -starts_with(\"Note\"))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#on-souhaite-réexprimer-toutes-les-notes-sur-100-et-non-sur-20",
    "href": "01-aide_memoire_r_sas.html#on-souhaite-réexprimer-toutes-les-notes-sur-100-et-non-sur-20",
    "title": "Aide-mémoire SAS - R",
    "section": "6.6 On souhaite réexprimer toutes les notes sur 100 et non sur 20",
    "text": "6.6 On souhaite réexprimer toutes les notes sur 100 et non sur 20\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let notes = Note_Contenu   Note_Formateur Note_Moyens     Note_Accompagnement     Note_Materiel;\n/* On supprime d'abord les doubles blancs entre les variables */\n%let notes = %sysfunc(compbl(&notes.));\n/* on affiche les notes dans la log de SAS */\n%put &notes;\n/* 1ère solution : avec les array */\n/* Les variables sont modifiées dans cet exemple */\ndata Sur100_1;\n  set donnees_sas;\n  array variables (*) &notes.;\n  do increment = 1 to dim(variables);\n    variables[increment] = variables[increment] / 20 * 100;\n  end; \n  drop increment;\nrun;\n/* 2e solution : avec une macro */\n/* De nouvelles variables sont ajoutées dans cet exemple */\ndata donnees_sas;\n  set donnees_sas;\n  %macro Sur100;\n    %do i = 1 %to %sysfunc(countw(&notes.));\n      %let note = %scan(&notes., &i.);\n      &note._100 = &note. / 20 * 100;\n    %end;\n  %mend Sur100;\n  %Sur100;\nrun;\n\n\n\nnotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nnotes &lt;- names(donnees_rbase)[grepl(\"^note\", names(donnees_rbase))]\n# Les variables sont modifiées dans cet exemple\nsur100 &lt;- donnees_rbase[, notes] / 20 * 100\n# On  souhaite conserver les notes sur 100 dans d'autres variables, suffixées par _100\ndonnees_rbase[, paste0(notes, \"_100\")] &lt;- donnees_rbase[, notes] / 20 * 100\n\n\n\n\n# Les variables sont modifiées dans cet exemple\nsur100 &lt;- donnees_tidyverse %&gt;% \n  mutate(across(starts_with(\"note\"), ~ .x / 20 * 100))\n\n# On  souhaite conserver les notes sur 100 dans d'autres variables, suffixées par _100\nnotes &lt;- names(donnees_tidyverse)[grepl(\"^note\", names(donnees_tidyverse))]\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(across(starts_with(\"note\"), ~ .x / 20 * 100, .names = \"{.col}_100\"))\n\n\n\n\nnotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nnotes &lt;- names(donnees_datatable)[grepl(\"^note\", names(donnees_datatable))]\n# Les variables sont modifiées dans cet exemple\nsur100 &lt;- copy(donnees_datatable)\nsur100 &lt;- sur100[, (notes) := lapply(.SD, function(x) x / 20 * 100), .SDcols = notes]\nsur100 &lt;- sur100[, (notes) := lapply(.SD, function(x) x / 20 * 100), .SD = notes]\n# Ou encore, plus simple\n# Dans cet exemple, les notes dans la base donnees_datatable ne sont pas changées\nsur100 &lt;- sur100[, lapply(.SD, function(x) x / 20 * 100), .SDcols = patterns(\"^note\")]\n# On  souhaite conserver les notes sur 20 dans d'autres variables, suffixées par _20\ndonnees_datatable[, (paste0(notes, \"_100\")) := lapply(.SD, function(x) x / 20 * 100), .SDcols = notes]\n\n\n\n\nrequete_duckdb %&gt;% \n  mutate(across(starts_with(\"note\"), ~ as.numeric(.x)/20*100)) %&gt;% \n  select(starts_with(\"note\"))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#création-de-variables-avec-des-conditions",
    "href": "01-aide_memoire_r_sas.html#création-de-variables-avec-des-conditions",
    "title": "Aide-mémoire SAS - R",
    "section": "6.7 Création de variables avec des conditions",
    "text": "6.7 Création de variables avec des conditions\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata Civilite;\n  set donnees_sas;\n  /* 1ère solution */\n  format Civilite $20.;\n  if      Sexe = 2 then Civilite = \"Mme\";\n  else if Sexe = 1 then Civilite = \"Mr\";\n  else                  Civilite = \"Inconnu\";\n  /* 2e solution (do - end) */\n  if      Sexe = 2 then do;\n    Civilite2 = \"Femme\";\n  end;\n  else if Sexe = 1 then do;\n    Civilite2 = \"Homme\";\n  end;\n  else do;\n    Civilite2 = \"Inconnu\";\n  end;\n  /* 3e solution */\n  format Civilite3 $20.;\n  select;\n    when      (Sexe = 2) Civilite3 = \"Femme\";\n    when      (Sexe = 1) Civilite3 = \"Homme\";\n    otherwise            Civilite3 = \"Inconnu\";\n  end;\n  keep Sexe Civilite Civilite2 Civilite3;run;\nrun;\n\n\n\ndonnees_rbase$civilite &lt;- ifelse(donnees_rbase$sexe == \"2\", \"Mme\", \n                           ifelse(donnees_rbase$sexe == \"1\", \"M\", \n                                  \"Inconnu\"))\n# Autre solution\ndonnees_rbase$civilite &lt;- \"Inconnu\"\ndonnees_rbase$civilite[donnees_rbase$sexe == \"1\"] &lt;- \"M\"\ndonnees_rbase$civilite[donnees_rbase$sexe == \"2\"] &lt;- \"Mme\"\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  mutate(civilite = case_when(sexe == \"2\" ~ \"Mme\",\n                              sexe == \"1\" ~ \"M\",\n                              TRUE        ~ \"Inconnu\")\n)\n\n\n\n\ndonnees_datatable[, civilite := fcase(sexe == \"2\", \"Mme\",\n                                      sexe == \"1\", \"M.\",\n                                      is.na(sexe), \"Inconnu\")]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#manipuler-les-dates",
    "href": "01-aide_memoire_r_sas.html#manipuler-les-dates",
    "title": "Aide-mémoire SAS - R",
    "section": "6.8 Manipuler les dates",
    "text": "6.8 Manipuler les dates\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On utilise ici %sysevalf et non %eval pour des calculs avec des macro-variables non entières */\n%let sixmois = %sysevalf(365.25/2);\n%put sixmois : &sixmois.;\ndata donnees_sas;\n  set donnees_sas;\n  /* Âge à l'entrée dans le dispositif */\n  Age = intck('year', date_naissance, date_entree);\n  /* Âge formaté */\n  Agef = put(Age, agef.);\n  /* Date de sortie du dispositif : ajout de la durée à la date d'entrée */\n  format date_sortie ddmmyy10.;\n  date_sortie = intnx('day', date_entree, duree);  \n  /* La durée du contrat est-elle inférieure à 6 mois ? */\n  Duree_Inf_6_mois = (Duree &lt; &sixmois. & Duree ne .);\n  /* Deux manières de créer une date */\n  format Decembre_31_&an._a Decembre_31_&an._b ddmmyy10.;\n  Decembre_31_&an._a = \"31dec&an.\"d;\n  /* mdy pour month, day, year (pas d'autre alternative, ymd par exemple n'existe pas) */\n  Decembre_31_&an._b = mdy(12, 31, &an.); \n  /* Date 6 mois après la sortie */\n  format Date_6mois ddmmyy10.;\n  Date_6mois = intnx('month', date_sortie, 6);\nrun;\n/* Ventilation pondérée (cf. infra) */\nproc freq data = donnees_sas;tables apres_31_decembre;weight poids_sondage;run;\n\n\n\n# Âge à l'entrée dans le dispositif\ndonnees_rbase$age &lt;- floor(lubridate::time_length(difftime(donnees_rbase$date_entree, donnees_rbase$date_naissance), \"years\"))\n# Âge formaté\ndonnees_rbase$agef[donnees_rbase$age &lt; 26]                           &lt;- \"1. De 15 à 25 ans\"\n# 26 &lt;= donnees_rbase$age &lt; 50 ne fonctionne pas, il faut passer en 2 étapes\ndonnees_rbase$agef[26 &lt;= donnees_rbase$age & donnees_rbase$age &lt; 50] &lt;- \"2. De 26 à 49 ans\"\ndonnees_rbase$agef[donnees_rbase$age &gt;= 50]                          &lt;- \"3. 50 ans ou plus\"\n# Autre solution\n# L'option right = TRUE implique que les bornes sont ]0; 25] / ]25; 49] / ]49; Infini[\nagef &lt;- cut(donnees_rbase$age, \n            breaks = c(0, 25, 49, Inf),\n            right = TRUE,\n            labels = c(\"1. De 15 à 25 ans\", \"2. De 26 à 49 ans\", \"3. 50 ans ou plus\"), \n            ordered_result = TRUE)\n\n# Manipuler les dates\nsixmois &lt;- 365.25/2\n# La durée du contrat est-elle inférieure à 6 mois ?\ndonnees_rbase$duree_inf_6_mois &lt;- ifelse(donnees_rbase$duree &lt; sixmois, 1, 0)\n# Date de sortie du dispositif\ndonnees_rbase$date_sortie &lt;- donnees_rbase$date_entree + lubridate::days(donnees_rbase$duree)\n\n# Pour créer une date\nas.Date(paste0(annee,\"-12-31\"), origin = \"1970-01-01\")\nlubridate::ymd(paste0(annee,\"-12-31\"))\n\n# Date 6 mois après la sortie\ndonnees_rbase$date_6mois &lt;- donnees_rbase$date_sortie + lubridate::month(6)\n\n\n\n\n# Âge à l'entrée dans le dispositif\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(age = as.period(interval(start = date_naissance, end = date_entree))$year)\n# Âge formaté\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  mutate(agef = case_when(\n    age &lt; 26             ~ \"1. De 15 à 25 ans\",\n    age &gt;= 26 & age &lt; 50 ~ \"2. De 26 à 49 ans\",\n    age &gt;= 50            ~ \"3. 50 ans ou plus\")\n    )\n\n\n# Manipuler les dates\nsixmois &lt;- 365.25/2\n# La durée du contrat est-elle inférieure à 6 mois ?\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(duree_inf_6_mois = case_when(duree &lt;  sixmois ~ 1,\n                                      duree &gt;= sixmois ~ 0))\ndonnees_tidyverse %&gt;% pull(duree_inf_6_mois) %&gt;% table()\n\n# Date de sortie du dispositif\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(date_sortie = date_entree + lubridate::days(duree))\n\n# Pour créer une date\nas.Date(paste0(annee,\"-12-31\"))\nlubridate::ymd(paste0(annee,\"-12-31\"))\n\n# Date 6 mois après la sortie\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(date_6mois = date_sortie + lubridate::month(6))\n\n\n\n\n# Âge à l'entrée dans le dispositif\ndonnees_datatable[, age := floor(lubridate::time_length(difftime(donnees_datatable$date_entree, donnees_datatable$date_naissance), \"years\"))]\n\n# Âge formaté\ndonnees_datatable[, agef := fcase(age &lt; 26,             \"1. De 15 à 25 ans\",\n                                  26 &lt;= age & age &lt; 50, \"2. De 26 à 49 ans\",\n                                  age &gt;= 50,            \"3. 50 ans ou plus\")]\n\n# Manipuler les dates\nsixmois &lt;- 365.25/2\n# La durée du contrat est-elle inférieure à 6 mois ?\ndonnees_datatable[, duree_inf_6_mois := ifelse(duree &gt;= sixmois, 1, 0)]\ndonnees_datatable[, duree_inf_6_mois := fifelse(duree &gt;= sixmois, 1, 0)]\ndonnees_datatable[, duree_inf_6_mois := fcase(duree &gt;= sixmois, 1,\n                                              duree &lt;  sixmois, 0)]\n# Date de sortie du dispositif\ndonnees_datatable[, date_sortie := date_entree + lubridate::days(duree)]\n\n# Pour créer une date\nas.Date(paste0(annee,\"-12-31\"))\nlubridate::ymd(paste0(annee,\"-12-31\"))\n\n# Date 6 mois après la sortie\ndonnees_datatable[, date_6mois := date_sortie + lubridate::month(6)]\n\n\n\n\n# Création de la colonne age \nrequete_duckdb %&gt;% \n  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %&gt;% # strptime est une fonction duckdb\n  mutate(age = year(age(Date_entree,Date_naissance))) %&gt;% \n  select(age)\n\n# Âge formaté\nrequete_duckdb %&gt;%\n  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %&gt;% # strptime est une fonction duckdb\n  mutate(age = year(age(Date_entree,Date_naissance))) %&gt;% \n  mutate(agef = case_when(\n    age &lt; 26 ~ \"1. De 15 à 25 ans\",\n    age &gt;= 26 | age &lt; 50 ~  \"2. De 26 à 49 ans\",\n    age &gt;= 50 ~ \"3. 50 ans ou plus\")) %&gt;% \n  select(age, agef)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#mettre-un-0-devant-un-nombre",
    "href": "01-aide_memoire_r_sas.html#mettre-un-0-devant-un-nombre",
    "title": "Aide-mémoire SAS - R",
    "section": "6.9 Mettre un 0 devant un nombre",
    "text": "6.9 Mettre un 0 devant un nombre\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata Zero_devant;\n  set donnees_sas (keep = date_entree);\n  /* Obtenir le mois et la date */\n  Mois = month(date_entree);\n  Annee = year(date_entree);\n  /* Mettre le mois sur 2 positions (avec un 0 devant si le mois &lt;= 9) : format prédéfini z2. */\n  Mois_a = put(Mois, z2.);\n  drop Mois;\n  rename Mois_a = Mois;\nrun;\n\n\n\n# Obtenir le mois et la date\ndonnees_rbase$mois &lt;- lubridate::month(donnees_rbase$date_entree)\ndonnees_rbase$annee &lt;- lubridate::year(donnees_rbase$date_entree)\n# Mettre le numéro du mois sur 2 positions (avec un 0 devant si le mois &lt;= 9)\ndonnees_rbase$mois &lt;- sprintf(\"%02d\", donnees_rbase$mois)\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(mois = sprintf(\"%02d\", lubridate::month(date_entree)))\n# Autre solution\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(mois = lubridate::month(date_entree),\n         mois = ifelse(str_length(mois) &lt; 2, paste0(\"0\", mois), mois))\n\n\n\n\n# Obtenir le mois et la date\ndonnees_datatable[, `:=`(mois = lubridate::month(date_entree), annee = lubridate::year(donnees_datatable$date_entree))]\n# Mettre le numéro du mois sur 2 positions (avec un 0 devant si le mois &lt;= 9)\ndonnees_datatable[, mois := sprintf(\"%02d\", mois)]\n\n\n\n\n# À FAIRE : pas exactement au bon endroit\n#requete_duckdb %&gt;% \n#  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %&gt;% # strptime est une fonction duckdb\n#  mutate(mois=lubridate::month(Date_entree),\n#         mois=ifelse(str_length(mois)&lt;2, paste0(\"0\", mois), mois)) %&gt;% \n#  select(mois, Date_entree)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#arrondir-une-valeur-numérique",
    "href": "01-aide_memoire_r_sas.html#arrondir-une-valeur-numérique",
    "title": "Aide-mémoire SAS - R",
    "section": "6.10 Arrondir une valeur numérique",
    "text": "6.10 Arrondir une valeur numérique\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata Arrondis;\n  set donnees_sas (keep = poids_sondage);\n  /* Arrondi à l'entier le plus proche */\n  poids_arrondi_0 = round(poids_sondage);\n  /* Arrondi à 1 chiffre après la virgule */\n  poids_arrondi_1 = round(poids_sondage, 0.1);\n  /* Arrondi à 2 chiffre après la virgule */\n  poids_arrondi_2 = round(poids_sondage, 0.2);\n  /* Arrondi à l'entier inférieur */\n  poids_inf = floor(poids_sondage);\n  /* Arrondi à l'entier supérieur */\n  poids_sup = ceil(poids_sondage);  \nrun;\n\n\n\n# Arrondi à l'entier le plus proche\npoids_arrondi_0 &lt;- round(donnees_rbase$poids_sondage, 0)\n# Arrondi à 1 chiffre après la virgule\npoids_arrondi_1 &lt;- round(donnees_rbase$poids_sondage, 1)\n# Arrondi à 2 chiffre après la virgule\npoids_arrondi_2 &lt;- round(donnees_rbase$poids_sondage, 2)\n# Arrondi à l'entier inférieur\npoids_inf &lt;- floor(donnees_rbase$poids_sondage)\n# Arrondi à l'entier supérieur\npoids_sup &lt;- ceiling(donnees_rbase$poids_sondage)\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  # Arrondi à l'entier le plus proche\n  mutate(poids_arrondi_0 = round(poids_sondage, 0)) %&gt;% \n  # Arrondi à 1 chiffre après la virgule\n  mutate(poids_arrondi_1 = round(poids_sondage, 1)) %&gt;% \n  # Arrondi à 2 chiffre après la virgule\n  mutate(poids_arrondi_2 = round(poids_sondage, 2)) %&gt;% \n  # Arrondi à l'entier inférieur\n  mutate(poids_inf = floor(poids_sondage)) %&gt;% \n  # Arrondi à l'entier supérieur\n  mutate(poids_sup = ceiling(poids_sondage))\ndonnees_tidyverse %&gt;% select(starts_with(\"poids\"))\n\n\n\n\n# Arrondi à l'entier le plus proche\ndonnees_datatable[, poids_arrondi_0 := round(poids_sondage, 0)]\n# Arrondi à 1 chiffre après la virgule\ndonnees_datatable[, poids_arrondi_1 := round(poids_sondage, 1)]\n# Arrondi à 2 chiffre après la virgule\ndonnees_datatable[, poids_arrondi_2 := round(poids_sondage, 2)]\n# Arrondi à l'entier inférieur\ndonnees_datatable[, poids_inf := floor(poids_sondage)]\n# Arrondi à l'entier supérieur\ndonnees_datatable[, poids_sup := ceiling(poids_sondage)]\n\n\n\n\nrequete_duckdb %&gt;% \n  mutate( # la fonction round de duckdb ne prend pas l'argument digits, mais la traduction fonctionne\n    poids_arrondi_0 = round(as.numeric(poids_sondage),0),\n    poids_arrondi_1 = round(as.numeric(poids_sondage),1),\n    poids_arrondi_2 = round(as.numeric(poids_sondage),-1),\n    poids_floor = floor(as.numeric(poids_sondage)),\n    poids_ceiling = ceiling(as.numeric(poids_sondage)),\n    ) %&gt;% \n  select(starts_with(\"poids\"))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#trier-les-colonnes-de-la-base",
    "href": "01-aide_memoire_r_sas.html#trier-les-colonnes-de-la-base",
    "title": "Aide-mémoire SAS - R",
    "section": "7.1 Trier les colonnes de la base",
    "text": "7.1 Trier les colonnes de la base\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On met identifiant, date_entree au début de la base */\n%let colTri = identifiant date_entree;\ndata donnees_sas;\n  retain &colTri.;\n  set donnees_sas;\nrun;\n/* Autre solution */\nproc sql;\n  create table donnees_sas as\n  /* Dans la proc SQL, les variables doivent être séparées par des virgules */\n  /* On remplace les blancs entre les mots par des virgules pour la proc SQL */\n  select %sysfunc(tranwrd(&colTri., %str( ), %str(, ))), * from donnees_sas;\nquit;\n/* Mettre la variable poids_sondage au début de la base */\ndata donnees_sas;\n  retain poids_sondage;\n  set donnees_sas;\nrun;\n/* Mettre la variable poids_sondage à la fin de la base */\nproc contents data = donnees_sas out = var;run;\nproc sql noprint;\n  select name into :var separated by \" \" from var\n  where lowcase(name) ne \"poids_sondage\" order by varnum;\nquit;\ndata donnees_sas;\n  retain &var. poids_sondage;\n  set donnees_sas;\nrun;\n\n\n\n# Mettre les variables identifiant, date_entree au début de la base\ncolTri &lt;- c(\"identifiant\", \"date_entree\")\ndonnees_rbase &lt;- donnees_rbase[, union(colTri, colnames(donnees_rbase))]\n# Autre possibilité, plus longue !\ndonnees_rbase &lt;- donnees_rbase[, c(colTri, setdiff(colnames(donnees_rbase), colTri))]\ndonnees_rbase &lt;- donnees_rbase[, c(colTri, colnames(donnees_rbase)[! colnames(donnees_rbase) %in% colTri])]\n# Mettre la variable poids_sondage au début de la base\ndonnees_rbase &lt;- donnees_rbase[, c(\"poids_sondage\", setdiff(colnames(donnees_rbase), \"poids_sondage\"))]\n# Mettre la variable poids_sondage à la fin de la base\ndonnees_rbase &lt;- donnees_rbase[, c(setdiff(colnames(donnees_rbase), \"poids_sondage\"), \"poids_sondage\")]\n\n\n\n\n# Mettre les variables identifiant, date_entree et date_sortie au début de la base\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  relocate(identifiant, date_entree)\n# Autres solutions\ncolTri &lt;- c(\"identifiant\", \"date_entree\")\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  relocate(all_of(colTri))\ndonnees_tidyverse_tri &lt;- donnees_tidyverse %&gt;% \n  select(all_of(colTri), everything())\n\n\n# Mettre la variable poids_sondage au début de la base\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  relocate(poids_sondage)\n# Mettre la variable poids_sondage à la fin de la base\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  relocate(poids_sondage, .after = last_col())\n\n\n\n\n# On met identifiant, date_entree au début\ncolTri &lt;- c(\"identifiant\", \"date_entree\")\ntri &lt;- union(colTri, colnames(donnees_datatable))\ndonnees_datatable &lt;- donnees_datatable[, ..tri]\n# En data.table, les instructions débutant par set modifient les éléments par référence, c'est-à-dire sans copie.\n# Ceci est plus efficace pour manipuler des données volumineuses.\nsetcolorder(donnees_datatable, colTri)\n\n# Mettre la variable poids_sondage au début de la base\nsetcolorder(donnees_datatable, union(\"poids_sondage\", colnames(donnees_datatable)))\n# Mettre la variable poids_sondage à la fin de la base\nsetcolorder(donnees_datatable, c(setdiff(colnames(donnees_datatable), \"poids_sondage\"), \"poids_sondage\"))\n\n\n\n\n# On met identifiant date_entree au début\nrequete_duckdb %&gt;% \n  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %&gt;% # strptime est une fonction duckdb\n  select(identifiant, date_entree, everything())\nrequete_duckdb %&gt;% \n  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %&gt;% # strptime est une fonction duckdb\n  relocate(identifiant, date_entree)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#trier-les-lignes-par-ordre-décroissant",
    "href": "01-aide_memoire_r_sas.html#trier-les-lignes-par-ordre-décroissant",
    "title": "Aide-mémoire SAS - R",
    "section": "7.2 Trier les lignes (par ordre décroissant",
    "text": "7.2 Trier les lignes (par ordre décroissant\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* 1ère possibilité */\nproc sort data = donnees_sas;by Identifiant Date_entree;run;\n/* 2e possibilité */\nproc sql;\n  create table Donnes as select * from donnees_sas\n  order by Identifiant, Date_entree;\nquit;\n/* Idem par ordre croissant d'identifiant et ordre décroissant de date d'entrée */\nproc sort data = donnees_sas;by Identifiant descending Date_entree;run;\nproc sql;\n  create table Donnes as select * from donnees_sas\n  order by Identifiant, Date_entree desc;\nquit;\n\n\n\n# Tri par ordre croissant\n# L'option na.last = FALSE (resp. TRUE) indique que les valeurs manquantes doivent figurer à la fin (resp. au début) du tri, que le tri\n# soit croissant ou décroissant\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]\n# Tri par ordre croissant de identifiant et décroissant de date_entree (- avant le nom de la variable)\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE, decreasing = c(FALSE, TRUE), method = \"radix\"), ]\n# Autre possibilité : - devant la variable (uniquement pour les variables numériques)\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, -donnees_rbase$duree, na.last = FALSE), ]\n\n\n\n\n# Tri par ordre croissant\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  arrange(identifiant, date_entree)\n# Tri par ordre croissant de identifiant et décroissant de date_entree\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  arrange(identifiant, desc(date_entree))\n\n\n\n\n# Tri par ordre croissant\n# L'option na.last = FALSE (resp. TRUE) indique que les valeurs manquantes doivent figurer à la fin (resp. au début) du tri, que le tri\n# soit croissant ou décroissant\ndonnees_datatable &lt;- donnees_datatable[order(identifiant, date_entree, na.last = FALSE)]\n# En data.table, les instructions débutant par set modifient les éléments par référence, c'est-à-dire sans copie.\n# Ceci est plus efficace pour manipuler des données volumineuses.\nsetorder(donnees_datatable, \"identifiant\", \"date_entree\", na.last = FALSE)\nsetorderv(donnees_datatable, cols = c(\"identifiant\", \"date_entree\"), order = c(1L, 1L), na.last = FALSE)\n# Tri par ordre croissant de identifiant et décroissant de date_entree (- avant le nom de la variable)\ndonnees_datatable &lt;- donnees_datatable[order(identifiant, -date_entree, na.last = FALSE)]\nsetorder(donnees_datatable, \"identifiant\", -\"date_entree\", na.last = FALSE)\nsetorderv(donnees_datatable, cols = c(\"identifiant\", \"date_entree\"), order = c(1L, -1L), na.last = FALSE)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#incidence-des-valeurs-manquantes-dans-les-tris",
    "href": "01-aide_memoire_r_sas.html#incidence-des-valeurs-manquantes-dans-les-tris",
    "title": "Aide-mémoire SAS - R",
    "section": "7.3 Incidence des valeurs manquantes dans les tris",
    "text": "7.3 Incidence des valeurs manquantes dans les tris\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Dans SAS, les valeurs manquantes sont considérées comme des valeurs négatives */\n/* Elles sont donc situées en premier dans un tri par ordre croissant ... */\nproc sort data = donnees_sas;by identifiant date_entree;run;proc print;run;\n/* ... et en dernier dans un tri par ordre décroissant */\nproc sort data = donnees_sas;by identifiant descending date_entree;run;\nproc print;run;\n\n\n\n# Les valeurs manquantes sont situées en dernier dans un tri par ordre croissant ou décroissant (car par défaut l'option na.last = TRUE) ...\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree), ]\n\n# SAS considère les valeurs manquantes comme des nombres négatifs faibles.\n# Pour mimer le tri par ordre croissant en SAS :\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]\n# Pour mimer le tri par ordre décroissant en SAS :\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree,\n                                     na.last = FALSE,\n                                     decreasing = c(FALSE, TRUE),\n                                     method = \"radix\"), ]\n\n\n\n\n# Attention, avec arrange, les variables manquantes (NA) sont toujours classées en dernier, même avec desc()\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  arrange(identifiant, date_entree)\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  arrange(identifiant, desc(date_entree))\n\n# Or, SAS considère les valeurs manquantes comme des nombres négatifs faibles.\n# Elles sont donc classées en premier dans un tri par ordre croissant, et en dernier dans un tri par ordre décroissant\n\n# Pour mimer le tri par ordre croissant en SAS : les valeurs manquantes de date_entree sont classées en premier\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  arrange(identifiant, !is.na(date_entree), date_entree)\n# Pour mimer le tri par ordre décroissant en SAS\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  arrange(identifiant, desc(date_entree))\n\n\n\n\n# Les valeurs manquantes sont situées en dernier dans un tri par ordre croissant ou décroissant (car par défaut l'option na.last = TRUE) ...\ndonnees_datatable &lt;- donnees_datatable[order(identifiant, date_entree)]\n# SAS considère les valeurs manquantes comme des nombres négatifs faibles.\n# Pour mimer le tri par ordre croissant en SAS :\nsetorderv(donnees_datatable, cols = c(\"identifiant\", \"date_entree\"), order = c(1L, 1L), na.last = FALSE)\n# Pour mimer le tri par ordre décroissant en SAS :\nsetorderv(donnees_datatable, cols = c(\"identifiant\", \"date_entree\"), order = c(1L, -1L), na.last = FALSE)\n\n\n\n\n# Les valeurs manquantes sont situées en dernier dans un tri par ordre croissant ou décroissant (car par défaut l'option na.last = TRUE) ...\nrequete_duckdb %&gt;% arrange(Identifiant, Note_Contenu) %&gt;% select(Identifiant, Note_Contenu)\n  \n# Pour mimer le tri SAS, il faut écrire :\n# Note : il faut faire select d'abord, sinon il y a une erreur quand \"! is.na()\" est dans la liste des colonnes\nrequete_duckdb %&gt;% select(Identifiant, Note_Contenu) %&gt;% arrange(Identifiant, ! is.na(Note_Contenu), Note_Contenu)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#trier-par-ordre-croissant-par-toutes-les-variables-de-la-base",
    "href": "01-aide_memoire_r_sas.html#trier-par-ordre-croissant-par-toutes-les-variables-de-la-base",
    "title": "Aide-mémoire SAS - R",
    "section": "7.4 Trier par ordre croissant par toutes les variables de la base",
    "text": "7.4 Trier par ordre croissant par toutes les variables de la base\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc sort data = donnees_sas;by _all_;run;\n\n\n\ntri_toutes_variables &lt;- donnees_rbase[order(colnames(donnees_rbase), na.last = FALSE)]\n\n\n\n\ntri_toutes_variables &lt;- donnees_tidyverse %&gt;% \n  arrange(pick(everything()))\ntri_toutes_variables &lt;- donnees_tidyverse %&gt;% \n  arrange(across(everything()))\n\n\n\n\ntri_toutes_variables &lt;- setorderv(donnees_datatable, na.last = FALSE)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#majuscule-minuscule",
    "href": "01-aide_memoire_r_sas.html#majuscule-minuscule",
    "title": "Aide-mémoire SAS - R",
    "section": "8.1 Majuscule, minuscule",
    "text": "8.1 Majuscule, minuscule\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Fonction tranwrd (TRANslate WoRD) */\ndata donnees_sas;\n  set donnees_sas;\n  /* Première lettre en majuscule */\n  Niveau = propcase(Niveau);\n  /* En majuscule */\n  CSP_majuscule = upcase(CSPF);\n  /* En minuscule */\n  CSP_minuscule = lowcase(CSPF);\n  /* Nombre de caractères dans une chaîne de caractères */\n  taille_id = length(identifiant);\nrun;\n\n\n\n# 1ère lettre en majuscule, autres lettres en minuscule\ndonnees_rbase$niveau &lt;- paste0(toupper(substr(donnees_rbase$niveau, 1, 1)), tolower(substr(donnees_rbase$niveau, 2, length(donnees_rbase$niveau))))\n\n# En majuscule\ndonnees_rbase$csp_maj &lt;- toupper(donnees_rbase$cspf)\n# En minuscule\ndonnees_rbase$csp_min &lt;- tolower(donnees_rbase$cspf)\n# Nombre de caractères dans une chaîne de caractères\ndonnees_rbase$taille_id &lt;- nchar(donnees_rbase$identifiant)\n\n\n\n\n# 1ère lettre en majuscule, autres lettres en minuscule\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%  \n  mutate(niveau = str_to_title(niveau))\n\n# En majuscule\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(csp_maj = toupper(cspf))\n# En minuscule\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(csp_maj = tolower(cspf))\n# Nombre de caractères dans une chaîne de caractères\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(taille_id = nchar(identifiant))\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(taille_id = str_split(identifiant, '') %&gt;% \n           lengths)\n\n\n\n\n# 1ère lettre en majuscule, autres lettres en minuscule\ndonnees_datatable[, niveau := paste0(toupper(substr(niveau, 1, 1)), tolower(substr(niveau, 2, length(niveau))))]\n\n# En majuscule\ndonnees_datatable[, csp_maj := toupper(cspf)]\n# En minuscule\ndonnees_datatable[, csp_min := tolower(cspf)]\n# Nombre de caractères dans une chaîne de caractères\ndonnees_datatable[, taille_id := nchar(identifiant)]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#remplacer-une-chaîne-de-caractères-par-une-autre",
    "href": "01-aide_memoire_r_sas.html#remplacer-une-chaîne-de-caractères-par-une-autre",
    "title": "Aide-mémoire SAS - R",
    "section": "8.2 Remplacer une chaîne de caractères par une autre",
    "text": "8.2 Remplacer une chaîne de caractères par une autre\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata A_Corriger;\n  infile cards dsd dlm='|';\n  format A_corriger $8.;\n  input A_corriger $;\n  cards;\n  Qualifie\n  qualifie\n  Qualifie\n  QUALIFIE\n;\nrun;\ndata A_Corriger;\n  set A_Corriger;\n  Corrige = lowcase(A_corriger);\n  Corrige = tranwrd(Corrige, \"qualifie\", \"Qualifié\");\nrun;\n\n\n\n# Le mot Qualifié n'a pas d'accent : on le corrige\naCorriger &lt;- c(\"Qualifie\", \"qualifie\", \"Qualifie\", \"QUALIFIE\")\n# [Q-q] permet de représenter Q ou q, et donc de prendre en compte Qualifie et qualifie\ngsub(\"[Q-q]ualifie\", \"Qualifié\", tolower(aCorriger))\n\n\n\n\n# Le mot Qualifié n'a pas d'accent : on le corrige\naCorriger &lt;- c(\"Qualifie\", \"qualifie\", \"Qualifie\", \"QUALIFIE\")\n# [Q-q] permet de représenter Q ou q, et donc de prendre en compte Qualifie et qualifie\naCorriger %&gt;% tolower() %&gt;% str_replace_all(\"[Q-q]ualifie\", \"Qualifié\")\n\n\n\n\n# Le mot Qualifié n'a pas d'accent : on le corrige\naCorriger &lt;- c(\"Qualifie\", \"qualifie\", \"Qualifie\", \"QUALIFIE\")\n# [Q-q] permet de représenter Q ou q, et donc de prendre en compte Qualifie et qualifie\ngsub(\"[Q-q]ualifie\", \"Qualifié\", tolower(aCorriger))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#manipuler-des-chaînes-de-caractères-1",
    "href": "01-aide_memoire_r_sas.html#manipuler-des-chaînes-de-caractères-1",
    "title": "Aide-mémoire SAS - R",
    "section": "8.3 Manipuler des chaînes de caractères",
    "text": "8.3 Manipuler des chaînes de caractères\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata Exemple_chaines;\n  Texte = \"              Ce   Texte   mériterait   d être   corrigé                  \";\n  Texte1 = \"Je m'appelle\";\n  Texte2 = \"SAS\";\n  Texte3 = \"Phrase à découper\";\n  /* Valeur manquante sous forme caractère */\n  Texte4 = \"\";\nrun;\ndata Exemple_chaines;\n  set Exemple_chaines;\n  /* Enlever les blancs au début et à la fin de la chaîne de caractère */\n  Enlever_Blancs_Initiaux = strip(Texte);\n  /* Enlever les doubles blancs dans la chaîne de caractères */\n  Enlever_Blancs_Entre = compbl(Enlever_Blancs_Initiaux);\n  /* Enlever doubles blancs */\n  /* REVOIR !!!!! */\n  Enlever_Doubles_Blancs = compress(Texte, \"  \", \"t\");\n  /* Trois méthodes pour concaténer des chaînes de caractères */\n  Concatener  = Texte1||\" \"||Texte2;\n  Concatener2 = Texte1!!\" \"!!Texte2;\n  Concatener3 = catx(\" \", Texte1, Texte2);\n  /* Effet des valeurs manquantes */\n  /* Le séparateur est enlevé lors d'une concaténation avec une chaîne de caractère vide */\n  Concatener4 = catx(\"-\", Texte4, Texte3);\n  /* Extraire les 2e, 3e et 4e caractère de Concatener */\n  /* 2 correspond à la position du 1er caractère à récupérer, 3 le nombre total de caractères à partir du point de départ */\n  extrait = substr(Concatener, 2, 3);\n  /* Transformer plusieurs caractères différents */\n  /* On transforme le é en e, le â en a, le î en i, ... */\n  chaine = \"éèêëàâçîô\";\n  chaine_sans_accent = translate(chaine, \"eeeeaacio\", \"éèêëàâçîô\");\nrun;\nproc print data = Exemple_chaines;run;\n\n\n\ntexte  &lt;- \"              Ce   Texte   mériterait   d être   corrigé                  \"\ntexte1 &lt;- \"Ce texte\"\ntexte2 &lt;- \"va être\"\ntexte3 &lt;- \"concaténé\"\n# Valeur manquante sous forme caractère\ntexte4 &lt;- \"\"\n\n# Enlever les blancs au début et à la fin de la chaîne de caractère\n# \"\\\\s+\" est une expression régulière indiquant 1 ou plusieurs espaces successifs\n# Le gsub remplace 1 ou plusieurs espaces successifs par un seul espace\n# trimws enlève les espaces au début et à la fin d'une chaîne de caractère \ntexte &lt;- gsub(\"\\\\s+\", \" \", trimws(texte))\n\n\n# Concaténer des chaînes de caractères\nconcatene &lt;- paste(texte1, texte2, texte3, sep = \" \")\npaste0(texte1, texte2, texte3)\n\n# Effet des valeurs manquantes : le délimiteur (ici -) apparaît avec la concaténation avec le caractère manquant\npaste(texte4, texte3, sep = \"-\")\n\n# Extraire les 2e, 3e et 4e caractères de Concatener\n# 2 correspond à la position du 1er caractère à récupérer, 5 la position du dernier caractère\nextrait &lt;- substr(concatene, 2, 5)\n\n# Transformer plusieurs caractères différents\nchaine &lt;- \"éèêëàâçîô\"\nchartr(\"éèêëàâçîô\", \"eeeeaacio\", chaine)\n\n\n\n\ntexte  &lt;- \"              Ce   Texte   mériterait   d être   corrigé                  \"\ntexte1 &lt;- \"Ce texte\"\ntexte2 &lt;- \"va être\"\ntexte3 &lt;- \"concaténé\"\n# Valeur manquante sous forme caractère\ntexte4 &lt;- \"\"\n\n# Enlever les blancs au début et à la fin de la chaîne de caractère\n# str_squish() supprime les espaces blancs au début et à la fin, et remplace tous les espaces blancs internes par un seul espace\ntexte &lt;- str_squish(texte)\n\n# Concaténer des chaînes de caractères\nconcatene &lt;- str_flatten(c(texte1, texte2, texte3), collapse = \" \")\n\n# Effet des valeurs manquantes : le délimiteur (ici -) apparaît avec la concaténation avec le caractère manquant\nstr_flatten(c(texte4, texte3), collapse = \"-\")\n\n# Extraire les 2e, 3e et 4e caractères de Concatener\n# 2 correspond à la position du 1er caractère à récupérer, 5 la position du dernier caractère\nextrait &lt;- str_sub(concatene, 2, 5)\n\n# Transformer plusieurs caractères différents\nchaine &lt;- \"éèêëàâçîô\"\nchartr(\"éèêëàâçîô\", \"eeeeaacio\", chaine)\n\n\n\n\ntexte  &lt;- \"              Ce   Texte   mériterait   d être   corrigé                  \"\ntexte1 &lt;- \"Je m'appelle\"\ntexte2 &lt;- \"R\"\n# Enlever les blancs au début et à la fin de la chaîne de caractère\n# \"\\\\s+\" est une expression régulière indiquant 1 ou plusieurs espaces successifs\n# Le gsub remplace 1 ou plusieurs espaces successifs par un seul espace\n# trimws enlève les espaces au début et à la fin d'une chaîne de caractère \ntexte &lt;- gsub(\"\\\\s+\", \" \", trimws(texte))\n# Concaténer des chaînes de caractères\npaste(texte1, texte2, sep = \" \")\npaste0(texte1, texte2)\n\n\n# Extraire les 2e, 3e et 4e caractères de texte\n# 2 correspond à la position du 1er caractère à récupérer, 5 la position du dernier caractère\nextrait &lt;- substr(texte, 2, 5)\n\n# Transformer plusieurs caractères différents\nchaine &lt;- \"éèêëàâçîô\"\nchartr(\"éèêëàâçîô\", \"eeeeaacio\", chaine)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#découper-une-chaîne-de-caractères-selon-un-caractère-donné",
    "href": "01-aide_memoire_r_sas.html#découper-une-chaîne-de-caractères-selon-un-caractère-donné",
    "title": "Aide-mémoire SAS - R",
    "section": "8.4 Découper une chaîne de caractères selon un caractère donné",
    "text": "8.4 Découper une chaîne de caractères selon un caractère donné\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Afficher tous les mots d'une phrase : découper une phrase selon les espaces pour isoler les mots */\ndata Mots;\n  delim = \" \";\n  Texte = \"Mon texte va être coupé !\";\n  /* Chaque mot dans une variable */\n  %macro Decouper;\n    %do i = 1 %to %sysfunc(countw(Texte, delim));\n      Mot&i. = scan(Texte, &i., delim);\n    %end;\n  %mend Decouper;\n  %Decouper;\n  /* Les mots empilés */\n  nb_mots = countw(Texte, delim);\n  do nb = 1 to nb_mots;\n    mots = scan(Texte, nb, delim);\n    output;\n  end;\nrun;\nproc print data = Mots;run;\n\n\n\n# Découper uen chaîne de caractères selon un caractère donné\n# Afficher tous les mots d'une phrase : découper une phrase selon les espaces pour isoler les mots\nchaine  &lt;- \"Mon texte va être coupé !\"\nunlist(strsplit(chaine, split = \" \"))\n\n\n\n\n# Découper une chaîne de caractères selon un caractère donné\n# Afficher tous les mots d'une phrase : découper une phrase selon les espaces pour isoler les mots\nchaine  &lt;- \"Mon texte va être coupé !\"\nstr_split(chaine, pattern = \" \") %&gt;% unlist()\n\n\n\n\n# Découper uen chaîne de caractères selon un caractère donné\n# Afficher tous les mots d'une phrase : découper une phrase selon les espaces pour isoler les mots\nchaine  &lt;- \"Mon texte va être coupé !\"\nunlist(strsplit(chaine, split = \" \"))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#inverser-une-chaîne-de-caractères",
    "href": "01-aide_memoire_r_sas.html#inverser-une-chaîne-de-caractères",
    "title": "Aide-mémoire SAS - R",
    "section": "8.5 Inverser une chaîne de caractères",
    "text": "8.5 Inverser une chaîne de caractères\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata Mots;\n  Texte = \"Mon texte va être coupé !\";\n  x = left(reverse(Texte));\nrun;\nproc print data = Mots;run;\n\n\n\ninverserTexte &lt;- function(x) {\n  sapply(\n    lapply(strsplit(x, NULL), rev),\n    paste, collapse = \"\")\n  }\ninverserTexte(chaine)\n\n\n\n\nlibrary(stringi)\nstringi::stri_reverse(chaine)\n\n\n\n\ninverserTexte &lt;- function(x) {\n  sapply(\n    lapply(strsplit(x, NULL), rev),\n    paste, collapse = \"\")\n}\ninverserTexte(chaine)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#numéroter-les-lignes",
    "href": "01-aide_memoire_r_sas.html#numéroter-les-lignes",
    "title": "Aide-mémoire SAS - R",
    "section": "9.1 Numéroter les lignes",
    "text": "9.1 Numéroter les lignes\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata donnees_sas;\n  set donnees_sas;\n  Num_observation = _n_;\nrun;\n/* Autre solution */\nproc sql noprint;select count(*) into :nbLignes from donnees_sas;quit;\ndata numLigne;do Num_observation = 1 to &nbLignes.;output;end;run;\ndata _NULL_;\n  set donnees_sas nobs = n;\n  call symputx('nbLignes', n);\nrun;\n%put Nombre de lignes : &nbLignes.;\n/* Le merge \"simple\" (sans by) va seulement concaténer les deux bases l'une à côté de l'autre */\ndata donnees_sas;\n  merge donnees_sas numLigne;\nrun;\n\n\n\n# Numéro de l'observation : 2 manières différentes\ndonnees_rbase$num_observation &lt;- row.names(donnees_rbase)\ndonnees_rbase$num_observation &lt;- seq(1 : nrow(donnees_rbase))\n\n# Numéro du contrat de chaque individu, contrat trié par date de survenue\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\ndonnees_rbase$un &lt;- 1\ndonnees_rbase$numero_contrat &lt;- ave(donnees_rbase$un, donnees_rbase$identifiant, FUN = cumsum)\ndonnees_rbase$un &lt;- NULL\n# Autre solution\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\ndonnees_rbase$numero_contrat &lt;- as.numeric(ave(donnees_rbase$identifiant, donnees_rbase$identifiant, FUN = seq_along))\n# Autre solution : order pour éviter le as.numeric\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\ndonnees_rbase$numero_contrat &lt;- ave(order(donnees_rbase$date_entree), donnees_rbase$identifiant, FUN = seq_along)\n#https://stackoverflow.com/questions/11996135/create-a-sequential-number-counter-for-rows-within-each-group-of-a-dataframe\n#https://stackoverflow.com/questions/13732062/what-are-examples-of-when-seq-along-works-but-seq-produces-unintended-results\n\n\n\n\n# Numéro de l'observation\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  mutate(num_observation = row_number())\n\n# Numéro du contrat de chaque individu, contrat trié par date de survenue\n# arrange() va permettre de trier les observations par identifiant et date d'entrée \ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  mutate(numero_contrat = row_number()) %&gt;% \n  ungroup()\n# À FAIRE : Dans group_by, à quoi sert le drop ?\n\n\n\n\n# Numéro de l'observation : 2 manières différentes\ndonnees_datatable[, num_observation := .I]\ndonnees_datatable[, num_observation := seq_len(.N)]\n\n# Numéro du contrat de chaque individu, contrat trié par date de survenue\nsetorder(donnees_datatable, \"identifiant\", \"date_entree\", na.last = FALSE)\ndonnees_datatable[, numero_contrat := rowid(identifiant)]\ndonnees_datatable[, numero_contrat := seq_len(.N), by = identifiant]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#numéro-de-contrat-par-individu",
    "href": "01-aide_memoire_r_sas.html#numéro-de-contrat-par-individu",
    "title": "Aide-mémoire SAS - R",
    "section": "9.2 Numéro de contrat par individu",
    "text": "9.2 Numéro de contrat par individu\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc sort data = donnees_sas;by identifiant date_entree;run;\n/* L'instruction options permet de ne pas afficher d'erreur si la variable numero_contrat n'existe pas */\noptions dkricond=nowarn dkrocond=nowarn;\ndata donnees_sas;\n  set donnees_sas (drop = numero_contrat);\n  by identifiant date_entree;\n  retain numero_contrat 0;\n  if first.identifiant then numero_contrat = 1;\n  else                      numero_contrat = numero_contrat + 1;\nrun;\noptions dkricond=warn dkrocond=warn;\n/* Pour trier les colonnes */\ndata donnees_sas;\n  retain identifiant date_entree numero_contrat numero_contrat;\n  set donnees_sas;\nrun;\n\n\n\n# 1ère ligne par identifiant\ndonnees_rbase[!duplicated(donnees_rbase$identifiant), , drop = FALSE]\n\n# Dernière ligne par identifiant\ndonnees_rbase[!duplicated(donnees_rbase$identifiant, fromLast = TRUE), , drop = FALSE]\n\n\n\n\n# 1ère ligne par identifiant\ndonnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;%\n  filter(row_number() == 1) %&gt;% \n  ungroup()\n# Autres solutions\ndonnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;%\n  slice(1) %&gt;% \n  ungroup()\ndonnees_tidyverse %&gt;%  \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;%\n  slice_head(n = 1) %&gt;% \n  ungroup()\ndonnees_tidyverse %&gt;%  \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;%\n  filter(row_number() == nth(row_number(), 1)) %&gt;%\n  ungroup()\n\n# Dernière ligne par identifiant\ndonnees_tidyverse %&gt;% \ngroup_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;%\n  filter(row_number() == n()) %&gt;% \n  ungroup()\n# Autres solutions\ndonnees_tidyverse %&gt;%  \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;%\n  slice(n()) %&gt;% \n  ungroup()\ndonnees_tidyverse %&gt;%  \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;%\n  filter(row_number() == nth(row_number(), -1)) %&gt;%\n  ungroup()\n\n\n\n\n# Extraire la 1ère ligne par identifiant\ndonnees_datatable[, .SD[1], by = identifiant]\n\n# Extraire la dernière ligne par identifiant\ndonnees_datatable[, .SD[.N], by = identifiant]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#le-premier-contrat-le-dernier-contrat-ni-le-premier-ni-le-dernier-contrat-de-chaque-individu",
    "href": "01-aide_memoire_r_sas.html#le-premier-contrat-le-dernier-contrat-ni-le-premier-ni-le-dernier-contrat-de-chaque-individu",
    "title": "Aide-mémoire SAS - R",
    "section": "9.3 Le premier contrat, le dernier contrat, ni le premier ni le dernier contrat de chaque individu …",
    "text": "9.3 Le premier contrat, le dernier contrat, ni le premier ni le dernier contrat de chaque individu …\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc sort data = donnees_sas;by identifiant date_entree;run;\ndata donnees_sas;\n  set donnees_sas;\n  by identifiant date_entree;\n  Premier_Contrat = (first.identifiant = 1);\n  Dernier_Contrat = (last.identifiant = 1);\n  Ni_Prem_Ni_Der  = (first.identifiant = 0 and last.identifiant = 0);\nrun;\n\n/* Créer une base avec les seuls premiers contrats, et une base avec les seuls derniers contrats */\nproc sort data = donnees_sas;by identifiant date_entree;run;\n/* Création de 2 bases en une seule étape */\ndata Premier_Contrat Dernier_Contrat;\n  set donnees_sas;\n  by identifiant date_entree;\n  if first.identifiant then output Premier_Contrat;\n  if last.identifiant then output Dernier_Contrat;\nrun;\n\n\n\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\ndonnees_rbase$premier_contrat &lt;- ifelse(!duplicated(donnees_rbase$identifiant, fromLast = FALSE), 1, 0)\ndonnees_rbase$dernier_contrat &lt;- ifelse(!duplicated(donnees_rbase$identifiant, fromLast = TRUE), 1, 0)\ndonnees_rbase$ni_prem_ni_der  &lt;- ifelse(! c(!duplicated(donnees_rbase$identifiant, fromLast = FALSE) | !duplicated(donnees_rbase$identifiant, fromLast = TRUE)), 1, 0)\n\n# Créer une base avec les seuls premiers contrats, et une base avec les seuls derniers contrats\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\npremier_contrat &lt;- donnees_rbase[!duplicated(donnees_rbase$identifiant, fromLast = FALSE), ]\ndernier_contrat &lt;- donnees_rbase[!duplicated(donnees_rbase$identifiant, fromLast = TRUE), ]\nni_prem_ni_der  &lt;- donnees_rbase[! (!duplicated(donnees_rbase$identifiant, fromLast = FALSE) | !duplicated(donnees_rbase$identifiant, fromLast = TRUE)), ]\n\n\n\n\n# Premier contrat\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  group_by(identifiant) %&gt;% \n  mutate(premier_contrat = ifelse(row_number() == 1, 1, 0)) %&gt;% \n  ungroup()\n# Dernier contrat\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  group_by(identifiant) %&gt;% \n  mutate(dernier_contrat = ifelse(row_number() == n(), 1, 0)) %&gt;% \n  ungroup()\n# Ni le premier, ni le dernier contrat\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  group_by(identifiant) %&gt;% \n  mutate(ni_prem_ni_der = ifelse( ! (row_number() == n() | row_number() == 1), 1, 0)) %&gt;% \n  ungroup()\n\n# Créer une base avec les seuls premiers contrats, et une base avec les seuls derniers contrats\n# Premier contrat\npremier_contrat &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  group_by(identifiant) %&gt;% \n  mutate(premier_contrat = ifelse(row_number() == 1, 1, 0)) %&gt;% \n  ungroup()\n# Dernier contrat\ndernier_contrat &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  group_by(identifiant) %&gt;% \n  mutate(dernier_contrat = ifelse(row_number() == n(), 1, 0)) %&gt;% \n  ungroup()\n# Ni le premier, ni le dernier contrat\nni_prem_ni_der &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  group_by(identifiant) %&gt;% \n  mutate(ni_prem_ni_der = ifelse( ! (row_number() == n() | row_number() == 1), 1, 0)) %&gt;% \n  ungroup()\n\n\n\n\ndonnees_datatable &lt;- donnees_datatable[order(identifiant, date_entree, na.last = FALSE)]\ndonnees_datatable[, premier_contrat := fifelse(!duplicated(identifiant, fromLast = FALSE), 1, 0)]\ndonnees_datatable[, dernier_contrat := fifelse(!duplicated(identifiant, fromLast = TRUE), 1, 0)]\ndonnees_datatable[, ni_prem_ni_der := fifelse(! c(!duplicated(identifiant, fromLast = FALSE) | !duplicated(identifiant, fromLast = TRUE)), 1, 0)]\n\n# Créer une base avec les seuls premiers contrats, et une base avec les seuls derniers contrats\ndonnees_datatable &lt;- donnees_datatable[order(identifiant, date_entree, na.last = FALSE)]\npremier_contrat &lt;- donnees_datatable[!duplicated(identifiant, fromLast = FALSE), ]\ndernier_contrat &lt;- donnees_datatable[!duplicated(identifiant, fromLast = TRUE), ]\nni_prem_ni_der  &lt;- donnees_datatable[! (!duplicated(identifiant, fromLast = FALSE) | !duplicated(identifiant, fromLast = TRUE)), ]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#les-2-premières-dernières-lignes-de-chaque-identifiant",
    "href": "01-aide_memoire_r_sas.html#les-2-premières-dernières-lignes-de-chaque-identifiant",
    "title": "Aide-mémoire SAS - R",
    "section": "9.4 Les 2 premières / dernières lignes de chaque identifiant",
    "text": "9.4 Les 2 premières / dernières lignes de chaque identifiant\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Les 2 premières lignes de chaque identifiant */\nproc sort data = donnees_sas;by identifiant numero_contrat;run;\nproc sql;\n  select * from donnees_sas group by identifiant\n  having numero_contrat &lt;= 2;\nquit;\n/* Les 2 dernières lignes de chaque identifiant */\nproc sort data = donnees_sas;by identifiant numero_contrat;run;\nproc sql;\n  select * from donnees_sas group by identifiant\n  having numero_contrat &gt;= count(*) - 1;\nquit;\n\n\n\n# 2 premières lignes par identifiant (le premier si une seule ligne)\n# Peut-on le faire en moins d'étapes ??? Avec head ?\ndonnees_rbase$a &lt;- 1\ndonnees_rbase$numero_contrat &lt;- ave(donnees_rbase$a, donnees_rbase$identifiant, FUN = cumsum)\ndeux_premieres_lignes &lt;- donnees_rbase[which(donnees_rbase$numero_contrat &lt;= 2), ]\ndonnees_rbase$a &lt;- NULL\n# REVOIR\n#donnees_rbase[ave(rep(TRUE, nrow(donnees_rbase)), donnees_rbase$identifiant, FUN = function(z) seq_along(z) == 2L)]\n#ind &lt;- donnees_rbase[ave(rep(TRUE, nrow(donnees_rbase)), donnees_rbase$identifiant, FUN = function(z) length(z) == 1L | seq_along(z) == 2L)]\n\n\n\n\n# Les deux premières lignes\ndeux_premieres_lignes &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  group_by(identifiant) %&gt;% \n  slice(1:2) %&gt;% \n  ungroup()\n# Les deux dernières lignes\ndeux_dernieres_lignes &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  group_by(identifiant) %&gt;% \n  slice(n() - 2) %&gt;% \n  ungroup()\n\n\n\n\ndeux_premieres_lignes &lt;- donnees_datatable[, .SD[1:2], by = identifiant]\ndeux_dernieres_lignes &lt;- donnees_datatable[, .SD[.N-2:.N], by = identifiant]\n# Version en R Base\n#https://stackoverflow.com/questions/14800161/select-the-top-n-values-by-group",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#e-ligne-de-lindividu-et-rien-si-lindividu-a-1-seule-ligne",
    "href": "01-aide_memoire_r_sas.html#e-ligne-de-lindividu-et-rien-si-lindividu-a-1-seule-ligne",
    "title": "Aide-mémoire SAS - R",
    "section": "9.5 2e ligne de l’individu (et rien si l’individu a 1 seule ligne)",
    "text": "9.5 2e ligne de l’individu (et rien si l’individu a 1 seule ligne)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc sort data = donnees_sas;by identifiant date_entree;run;\ndata donnees_sas;\n  set donnees_sas;\n  by identifiant date_entree;\n  retain numero_contrat 0;\n  if first.identifiant then numero_contrat = 1;\n  else                      numero_contrat = numero_contrat + 1;\nrun;\ndata Deuxieme_Contrat;\n  set donnees_sas;\n  if numero_contrat = 2;\nrun;\ndata Deuxieme_Contrat;\n  set donnees_sas (where = (numero_contrat = 2));\nrun;\n\n\n\n# Avec le numéro de contrat\ndeuxieme_ligne &lt;- donnees_rbase[donnees_rbase$numero_contrat == 2, ]\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\n# Autre solution\ndonnees_rbase[unlist(tapply(seq_len(nrow(donnees_rbase)), donnees_rbase$identifiant, function(x) x[length(x)-(length(x)-1)])), ]\n\n\n\n\ndonnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  filter(row_number() == 2) %&gt;% \n  ungroup()\n\n\n\n\ndeuxieme_ligne &lt;- donnees_datatable[, .SD[2], by = identifiant]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#lavant-dernière-ligne-de-lindividu-et-rien-si-lindividu-a-1-seul-contrat",
    "href": "01-aide_memoire_r_sas.html#lavant-dernière-ligne-de-lindividu-et-rien-si-lindividu-a-1-seul-contrat",
    "title": "Aide-mémoire SAS - R",
    "section": "9.6 L’avant-dernière ligne de l’individu (et rien si l’individu a 1 seul contrat)",
    "text": "9.6 L’avant-dernière ligne de l’individu (et rien si l’individu a 1 seul contrat)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Nécessite d'avoir le numéro du contrat */\nproc sql;\n  select * from donnees_sas group by identifiant\n  having numero_contrat = count(*) - 1;\nquit;\n\n\n\ndonnees_rbase[unlist(tapply(seq_len(nrow(donnees_rbase)), donnees_rbase$identifiant, function(x) x[length(x)-1])), ]\n\n\n\n\ndonnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  filter(row_number() == nth(row_number(), -2))\n\n\n\n\ndonnees_datatable[, .SD[.N-1], by = identifiant]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélection-par-groupement",
    "href": "01-aide_memoire_r_sas.html#sélection-par-groupement",
    "title": "Aide-mémoire SAS - R",
    "section": "9.7 Sélection par groupement",
    "text": "9.7 Sélection par groupement\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Personnes qui ont eu au moins une entrée en 2022 */\nproc sql;\n  select *\n  from donnees_sas\n  group by identifiant\n  having sum(year(date_entree) = 2022) &gt;= 1;\nquit;\n\n/* Personnes qui ont suivi à la fois une formation qualifiée et une formation non qualifiée */\nproc sql;\n  create table Qualif_Non_Qualif as\n  select *\n  from donnees_sas\n  group by identifiant\n  having sum(Niveau = \"Non qualifie\") &gt;= 1 and sum(Niveau = \"Non qualifie\") &gt;= 1;\nquit;\n\n/* Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins ayant débuté en 2022 */\nproc sql;\n  create table Deux_Contrats as\n  select *\n  from donnees_sas\n  group by identifiant\n  having count(*) = 2 and sum(year(date_entree) = 2022) &gt;= 1;\nquit;\n\n\n\n# Personnes qui ont eu au moins une entrée en 2022\nauMoins2022 &lt;- subset(donnees_rbase, identifiant %in% unique(identifiant[lubridate::year(date_entree) %in% c(2022)]))\n# Autre solution : ne semble possible que pour une seule variable\nauMoins2022 &lt;- donnees_rbase[with(donnees_rbase, ave(lubridate::year(date_entree) %in% c(2022), identifiant, FUN = any)), ]\n\n# Personnes qui ont suivi à la fois une formation qualifiée et une formation non qualifiée\nqualif_non_qualif &lt;- subset(\n  transform(donnees_rbase, \n            qualif     = ave(niveau, identifiant, FUN = function(x) sum(ifelse(x == \"Qualifié\", 1, 0), na.rm = TRUE)), \n            non_qualif = ave(niveau, identifiant, FUN = function(x) sum(ifelse(x == \"Non Qualifié\", 1, 0), na.rm = TRUE))),\n  qualif &gt;= 1 & non_qualif &gt;= 1)\n# https://stackoverflow.com/questions/49669862/how-to-group-by-in-base-r\n\n# Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins ayant débuté en 2022\ndeux_contrats &lt;- subset(\n  transform(donnees_rbase, \n            nb = ave(identifiant, identifiant, FUN = length), \n            an = ave(date_entree, identifiant, FUN = function(x) sum(ifelse(lubridate::year(x) == 2022, 1, 0), na.rm = TRUE))),\n  nb == 2 & an &gt;= 1)\n\n\n\n\n# Personnes qui ont eu au moins une entrée en 2022\nauMoins2022 &lt;- donnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;%\n  filter(any(lubridate::year(date_entree) == 2022))\n\n# Personnes qui ont suivi à la fois une formation qualifiée et une formation non qualifiée\nqualif_non_qualif &lt;- donnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;%\n  filter(any(niveau == \"Qualifié\")) %&gt;% \n  filter(any(niveau == \"Non qualifié\")) %&gt;% \n  ungroup()\n\n# Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins ayant débuté en 2022\ndeux_contrats &lt;- donnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;%\n  filter(n() == 2) %&gt;% \n  filter(any(lubridate::year(date_entree) == 2022)) %&gt;%\n  ungroup()\n\n\n\n\n# Personnes qui ont eu au moins une entrée en 2022\nauMoins2022 &lt;- donnees_datatable[, if(any(lubridate::year(date_entree) %in% 2022)) .SD, by = identifiant]\n# Autre solution\nauMoins2022 &lt;- donnees_datatable[, if (sum(lubridate::year(date_entree) == 2022, na.rm = TRUE) &gt; 0) .SD, by = identifiant]\n\n\n# Personnes qui ont suivi à la fois une formation qualifiée et une formation non qualifiée\n# Group by et Having de SQL\n# https://github.com/Rdatatable/data.table/issues/788\n# 1ère méthode\ndonnees_datatable[, `:=` (qualif = sum(fifelse(niveau == \"Qualifié\", 1, 0), na.rm = TRUE),\n                          non_qualif = sum(fifelse(niveau == \"Non qualifié\", 1, 0), na.rm = TRUE)),\n                by = identifiant][qualif &gt; 0 & non_qualif &gt; 0]\n# 2e méthode un peu plus simple\ndonnees_datatable[, `:=` (qualif = sum(niveau == \"Qualifié\", na.rm = TRUE), non_qualif = sum(niveau == \"Non qualifié\", na.rm = TRUE)), by = identifiant][qualif &gt; 0 & non_qualif &gt; 0]\n# 3e méthode, plus simple !!\ndonnees_datatable[, if (sum(niveau == \"Qualifié\", na.rm = TRUE) &gt; 0 & sum(niveau == \"Non qualifié\", na.rm = TRUE) &gt; 0) .SD, by = identifiant]\n\n# Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins ayant débuté en 2022\ndonnees_datatable[, if (.N == 2 & sum(lubridate::year(date_entree) == 2022, na.rm = TRUE) &gt;= 1) .SD, by = identifiant]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#ajouter-une-colonne-désignant-la-note-moyenne-de-note_contenu-par-individu",
    "href": "01-aide_memoire_r_sas.html#ajouter-une-colonne-désignant-la-note-moyenne-de-note_contenu-par-individu",
    "title": "Aide-mémoire SAS - R",
    "section": "9.8 Ajouter une colonne désignant la note moyenne de Note_Contenu par individu",
    "text": "9.8 Ajouter une colonne désignant la note moyenne de Note_Contenu par individu\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* 1ère solution */\nproc sort data = donnees_sas;by identifiant;run;\nproc means data = donnees_sas mean noprint;\n  var Note_Contenu;by identifiant;output out = Temp;\nrun;\ndata Temp;\n  set Temp (where = (_STAT_ = \"MEAN\"));\n  keep identifiant Note_Contenu;\n  rename Note_Contenu = Note_Contenu_Moyenne;\nrun;\ndata donnees_sas;\n  merge donnees_sas (in = a) Temp (in = b);\n  by identifiant;\n  if a;\nrun;\n/* 2e solution : plus souple */\n/* Pour supprimer la variable ajoutée lors de la 1ère solution */\ndata donnees_sas;\n  set donnees_sas (drop = Note_Contenu_Moyenne);\nrun;\nproc sql;\n  create table donnees_sas as\n  select *\n  from donnees_sas a left join\n       (select identifiant, mean(Note_Contenu) as Note_Contenu_Moyenne\n        from donnees_sas group by identifiant) b\n       on a.identifiant = b.identifiant\n  order by identifiant;\nquit;\n\n\n\ndonnees_rbase &lt;- transform(donnees_rbase, \n                           note_contenu_moyenne = ave(note_contenu, identifiant, FUN = mean, na.rm = TRUE), \n                           note_contenu_somme   = ave(note_contenu, identifiant, FUN = sum,  na.rm = TRUE))\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  group_by(identifiant) %&gt;%\n  mutate(note_contenu_moyenne = mean(note_contenu, na.rm = TRUE),\n         note_contenu_somme   = sum(note_contenu, na.rm = TRUE)) %&gt;% \n  ungroup()\n\n\n\n\ndonnees_datatable[, `:=` (note_contenu_moyenne = mean(note_contenu, na.rm = TRUE),\n                          note_contenu_somme = sum(note_contenu, na.rm = TRUE)), by = identifiant]\n# Moyenne de chaque note\nnotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\ndonnees_datatable[, paste0(notes, \"_m\") := lapply(.SD, mean, na.rm = TRUE), .SDcols = notes, keyby = identifiant]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#variable-retardée-lag",
    "href": "01-aide_memoire_r_sas.html#variable-retardée-lag",
    "title": "Aide-mémoire SAS - R",
    "section": "9.9 Variable retardée (lag)",
    "text": "9.9 Variable retardée (lag)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* La date de fin du contrat précédent (lag) */\nproc sort data = donnees_sas;by identifiant date_entree;run;\ndata donnees_sasBon;\n  set donnees_sas;\n  by identifiant date_entree;  \n  format Date_fin_1 ddmmyy10.;\n  Date_fin_1 = lag(Date_sortie);\n  if first.identifiant then Date_fin_1 = .;\nrun;\n\n/* ATTENTION au lag DANS UNE CONDITION IF (cf. document) */\nproc sort data = donnees_sas;by identifiant date_entree;run;\ndata Lag_Bon;\n  set donnees_sas (keep = identifiant date_entree date_sortie);\n  format date_sortie_1 lag_faux lag_bon ddmmyy10.;\n  /* Erreur */\n  if date_entree = lag(date_sortie) + 1 then lag_faux = lag(date_sortie) + 1;\n  /* Bonne écriture */\n  date_sortie_1 = lag(date_sortie);\n  if date_entree = date_sortie_1 + 1 then lag_bon = date_sortie_1 + 1;\nrun;\n\n\n\n# La date de fin du contrat précédent\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\n# Il n'existe pas de fonction lag dans le R de base (à notre connaissance)\n# Il faut soit utiliser un package, soit utiliser cette astuce\ndonnees_rbase$date_sortie_1 &lt;- c(as.Date(NA), donnees_rbase$date_sortie[ 1:(length(donnees_rbase$date_sortie) - 1)])\n# Peut-on aussi utiliser tail(..., -1) ?\n\n# La date du contrat futur (lead)\ndonnees_rbase$date_sortie__1 &lt;- c(donnees_rbase$date_sortie[ 2:(length(donnees_rbase$date_sortie))], as.Date(NA))\n\n# Autres solutions\n#https://stackoverflow.com/questions/3558988/basic-lag-in-r-vector-dataframe\n\n\n\n\n# La date de fin du contrat précédent\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  mutate(date_sortie_1 = lag(date_sortie))\n\n# La date du contrat futur (lead)\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  mutate(date_sortie__1 = lead(date_sortie))\n\n\n\n\n# La date de fin du contrat précédent\nsetorderv(donnees_datatable, cols = c(\"identifiant\", \"date_entree\"), order = c(1L, 1L), na.last = FALSE)\ndonnees_datatable[, date_sortie_1 := shift(.SD, n = 1, fill = NA, \"lag\"), .SDcols = \"date_sortie\"]\ndonnees_datatable[, .(date_sortie, date_sortie_1)]\n\n# La date du contrat futur (lead)\nsetorderv(donnees_datatable, cols = c(\"identifiant\", \"date_entree\"), order = c(1L, 1L), na.last = FALSE)\ndonnees_datatable[, date_sortie__1 := shift(.SD, n = 1, fill = NA, \"lead\"), .SDcols = \"date_sortie\"]\ndonnees_datatable[, .(date_sortie, date_sortie__1)]\n\n# Autres solutions\n#https://stackoverflow.com/questions/3558988/basic-lag-in-r-vector-dataframe",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#transposer-une-base",
    "href": "01-aide_memoire_r_sas.html#transposer-une-base",
    "title": "Aide-mémoire SAS - R",
    "section": "9.10 Transposer une base",
    "text": "9.10 Transposer une base\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On commence déjà par calculer un tableau croisé comptant les occurrences */\nproc freq data = donnees_sas;table Sexef * cspf / out = Nb;run;\nproc sort data = Nb;by cspf Sexef;run;\nproc print data = Nb;run;\n/* On transpose le tableau */\nproc transpose data = Nb out = transpose;by cspf;var count;id Sexef;run;\ndata transpose;set transpose (drop = _name_ _label_);run;\nproc print data = transpose;run;\n\n\n\n# On commence déjà par calculer un tableau croisé comptant les occurrences\n# as.data.frame.matrix est nécessaire, car le résultat de xtabs est un array\nnb &lt;- as.data.frame.matrix(xtabs( ~ cspf + sexef, data = donnees_rbase))\n# On transpose le tableau\nnb_transpose &lt;- as.data.frame(t(nb))\n\n\n\n\n# On commence déjà par calculer un tableau croisé comptant les occurrences\nnb &lt;- donnees_tidyverse %&gt;% \n  count(cspf, sexef) %&gt;% \n  spread(sexef, n)\n# On transpose le tableau\nnb_transpose &lt;- nb %&gt;% \n  rownames_to_column() %&gt;% \n  gather(variable, value, -rowname) %&gt;%  \n  spread(rowname, value)\n# Autre solution avec les packages janitor et sjmisc\nlibrary(janitor)\nnb &lt;- donnees_tidyverse %&gt;%\n  janitor::tabyl(cspf, sexef) %&gt;% \n  # colonne cspf comme nom de ligne\n  column_to_rownames(var=\"cspf\")\n\nlibrary(sjmisc)\nnb_transpose &lt;- nb %&gt;%\n  sjmisc::rotate_df()\n\n\n\n\n# Etablissement d'un tableau croisé comptant les occurrences\nnb &lt;- donnees_datatable[, .N, by = list(cspf, sexef)]\n# On transpose le tableau\ndata.table::dcast(nb, cspf ~ sexef, value.var = \"N\")",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#passer-dune-base-en-largeur-wide-à-une-base-en-longueur-long",
    "href": "01-aide_memoire_r_sas.html#passer-dune-base-en-largeur-wide-à-une-base-en-longueur-long",
    "title": "Aide-mémoire SAS - R",
    "section": "9.11 Passer d’une base en largeur (wide) à une base en longueur (long)",
    "text": "9.11 Passer d’une base en largeur (wide) à une base en longueur (long)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let notes = note_contenu note_formateur note_moyens note_accompagnement note_materiel;\nproc sort data = donnees_sas;by identifiant;run;\nproc means data = donnees_sas mean noprint;var &notes.;output out = Temp;by identifiant;run;\ndata Wide;\n  set Temp (where = (_STAT_ = \"MEAN\") drop = _TYPE_ _FREQ_);\n  keep identifiant &notes.;\n  drop _STAT_;\nrun;\n/* On passe de Wide à Long */\nproc transpose data = Wide out = Long;by Identifiant;var &notes.;run;\n\n\n\n# On souhaite mettre les notes en ligne et non en colonne\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nwide_rbase &lt;- aggregate(donnees_rbase[, varNotes], donnees_rbase[, \"identifiant\", drop = FALSE], mean, na.rm = TRUE)\nlong_rbase &lt;- reshape(data = wide_rbase,\n                varying = varNotes, \n                v.names = \"notes\",\n                timevar = \"type_note\", \n                times = varNotes,\n                new.row.names = NULL,\n                direction = \"long\")\nlong_rbase &lt;- long_rbase[order(long_rbase$identifiant), ]\nrow.names(long_rbase) &lt;- NULL\n\n\n\n\n# On souhaite mettre les notes en ligne et non en colonne\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nwide_tidyverse &lt;- donnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;% \n  summarise(across(all_of(varNotes), ~ mean(.x, na.rm = TRUE)))\n# On l'exprime en format long\n# Mise en garde : ne pas écrire value_to !\nlong_tidyverse &lt;- wide_tidyverse %&gt;% \n  pivot_longer(cols = !identifiant,\n               names_to = \"type_note\",\n               values_to = \"note\") %&gt;% \n  arrange(type_note, identifiant)\n\n\n\n\n# On souhaite mettre les notes en ligne et non en colonne\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nwide_datatable &lt;- donnees_datatable[, lapply(.SD, mean, na.rm = TRUE), keyby = identifiant, .SDcols = varNotes]\nlong_datatable &lt;- melt(wide_datatable,\n                       id.vars = c(\"identifiant\"),\n                       measure.vars = varNotes,\n                       variable.name = \"type_note\",\n                       value.name = \"note\")",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#passer-base-en-longueur-long-à-une-base-en-largeur-wide",
    "href": "01-aide_memoire_r_sas.html#passer-base-en-longueur-long-à-une-base-en-largeur-wide",
    "title": "Aide-mémoire SAS - R",
    "section": "9.12 Passer base en longueur (long) à une base en largeur (wide)",
    "text": "9.12 Passer base en longueur (long) à une base en largeur (wide)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On souhaite mettre les notes en ligne et non en colonne */\n/* On commence par calculer les notes moyennes par identifiant */\n%let notes = note_contenu note_formateur note_moyens note_accompagnement note_materiel;\nproc sort data = donnees_sas;by identifiant;run;\nproc means data = donnees_sas mean noprint;var &notes.;output out = Temp;by identifiant;run;\ndata Wide;\n  set Temp (where = (_STAT_ = \"MEAN\") drop = _TYPE_ _FREQ_);\n  keep identifiant &notes.;\n  drop _STAT_;\nrun;\n/* On passe de Wide à Long */\nproc transpose data = Wide out = Long;by Identifiant;var &notes.;run;\ndata Long;set Long (rename = (_NAME_ = Type_Note COL1 = Note));run;\n/* On passe de Long à Wide */\nproc transpose data = Long out = Wide;\n  by Identifiant;\n  var Note;\n  id Type_Note;\nrun;\n\n\n\n# Passer de long à wide : on souhaite revenir à la situation initiale\nwide_rbase &lt;- reshape(long_rbase, \n                timevar = \"type_note\",\n                idvar = c(\"identifiant\", \"id\"),\n                direction = \"wide\")\n#https://stats.oarc.ucla.edu/r/faq/how-can-i-reshape-my-data-in-r/\n\n\n\n\n# Passer de long à wide : on souhaite revenir à la situation initiale\n# Mise en garde : ne pas écrire value_from !\nwide_tidyverse &lt;- pivot_wider(long_tidyverse, \n                              names_from = type_note,\n                              values_from = note)\n\n\n\n\nwide_datatable &lt;- dcast(long_datatable, identifiant ~ type_note, value.var = \"note\")",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-les-lignes-avec-au-moins-une-note-10",
    "href": "01-aide_memoire_r_sas.html#sélectionner-les-lignes-avec-au-moins-une-note-10",
    "title": "Aide-mémoire SAS - R",
    "section": "10.1 Sélectionner les lignes avec au moins une note < 10",
    "text": "10.1 Sélectionner les lignes avec au moins une note &lt; 10\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\ndata Note_Inferieure_10;\n  set donnees_sas;\n  %macro Inf10;\n    %global temp;\n    %let temp = ;\n    %do i = 1 %to %sysfunc(countw(&notes.));\n      %let j = %scan(&notes., &i.);\n      &j._inf_10 = (&j. &lt; 10 and not missing(&j.));\n      %let temp = &temp. &j._inf_10;\n    %end;\n  %mend Inf10;\n  %Inf10;\n  if sum(of &temp.) &gt;= 1;\n  drop &temp.;\nrun;\n\n\n\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\ndonnees_rbase[apply(donnees_rbase[, varNotes], 1, function(x) any(x &lt; 10, na.rm = TRUE)), ]\n\n\n\n\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\ndonnees_tidyverse %&gt;%\n  filter(if_any(varNotes, ~ .x &lt; 10))\n# Autre solution\ndonnees_tidyverse %&gt;%\n  filter_at(varNotes, any_vars(. &lt; 10))\n\n\n\n\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nnote_moins_10 &lt;- donnees_datatable[donnees_datatable[, .I[rowSums(.SD &lt; 10, na.rm = TRUE) &gt;= 1], .SDcols = varNotes]]\n# Autre solution\n# Le Reduce(`|`, ...) permet d'appliquer la condition | (ou) à tous les élements de la ligne, qui sont une vérification d'un nb &lt; 10\nnote_moins_10 &lt;- donnees_datatable[donnees_datatable[, Reduce(`|`, lapply(.SD, `&lt;`, 10)), .SDcols = varNotes]]\n\n# https://arelbundock.com/posts/datatable_rowwise/",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-les-lignes-avec-toutes-les-notes-supérieurs-à-10",
    "href": "01-aide_memoire_r_sas.html#sélectionner-les-lignes-avec-toutes-les-notes-supérieurs-à-10",
    "title": "Aide-mémoire SAS - R",
    "section": "10.2 Sélectionner les lignes avec toutes les notes supérieurs à 10",
    "text": "10.2 Sélectionner les lignes avec toutes les notes supérieurs à 10\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\ndata Note_Sup_10;\n  set donnees_sas;\n  %macro Inf10;\n    %global temp;\n    %let temp = ;\n    %do i = 1 %to %sysfunc(countw(&notes.));\n      %let j = %scan(&notes., &i.);\n      &j._sup_10 = (&j. &gt;= 10);\n      %let temp = &temp. &j._sup_10;\n    %end;\n  %mend Inf10;\n  %Inf10;\n  a = sum(of &temp.);\n  b = %sysfunc(countw(&notes.));\n  if sum(of &temp.) = %sysfunc(countw(&notes.));\n  drop &temp.;\nrun;\n\n\n\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\n# À FAIRE : REVOIR LE PB DES VALEURS MANQUANTES !!!!\ndonnees_rbase[apply(donnees_rbase[, varNotes], 1, function(x) all(x &gt;= 10, na.rm = TRUE)), ]\n\n\n\n\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\ndonnees_tidyverse %&gt;%\n  filter(if_all(varNotes, ~ . &gt;= 10))\n# Autre solution\ndonnees_tidyverse %&gt;%\n  filter_at(varNotes, all_vars(. &gt;= 10))\n\n\n\n\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nnote_sup_10 &lt;- donnees_datatable[\n  donnees_datatable[, .I[rowSums(.SD &gt;= 10, na.rm = TRUE) == length(varNotes)], .SDcols = varNotes]]\n# Autre solution\nnote_sup_10 &lt;- donnees_datatable[donnees_datatable[, Reduce(`&`, lapply(.SD, `&gt;=`, 10)), .SDcols = varNotes]]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#moyenne-par-ligne",
    "href": "01-aide_memoire_r_sas.html#moyenne-par-ligne",
    "title": "Aide-mémoire SAS - R",
    "section": "10.3 Moyenne par ligne",
    "text": "10.3 Moyenne par ligne\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Pour chaque observation, 5 notes sont renseignées. On calcule la moyenne de ces 5 notes pour chaque ligne */\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\ndata donnees_sas;\n  set donnees_sas;\n  /* 1ère solution */\n  Note_moyenne    = mean(of &notes.);\n  /* 2e solution : l'équivalent des list-comprehension de Python en SAS */\n  %macro List_comprehension;\n    Note_moyenne2 = mean(of %do i = 1 %to %sysfunc(countw(&notes.));\n                          %let j = %scan(&notes., &i.);\n                          &j.\n                         %end;);;\n  %mend List_comprehension;\n  %List_comprehension;\nrun;\n/* Note moyenne (moyenne des moyennes), non pondérée et pondérée */\nproc means data = donnees_sas mean;var Note_moyenne;run;\nproc means data = donnees_sas mean;var Note_moyenne;weight poids_sondage;run;\n\n\n\n# Pour chaque observation, 5 notes sont renseignées. On calcule la moyenne de ces 5 notes pour chaque ligne\nvarNotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\n# apply permet d'appliquer une fonctions aux lignes (1) ou colonnes (2) d'un data.frame\ndonnees_rbase$note_moyenne &lt;- apply(donnees_rbase[, varNotes], 1, mean, na.rm = TRUE)\n# Autre possibilité\ndonnees_rbase$note_moyenne &lt;- rowMeans(donnees_rbase[, varNotes], na.rm = TRUE)\n# Note moyenne (moyenne des moyennes), non pondérée et pondérée\nmean(donnees_rbase$note_moyenne, na.rm = TRUE)\nweighted.mean(donnees_rbase$note_moyenne, donnees_rbase$poids_sondage, na.rm = TRUE)\n\n\n\n\n# Pour chaque observation, 5 notes sont renseignées. On calcule la moyenne de ces 5 notes pour chaque ligne\nvarNotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\n# Codes à privilégier\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  mutate(note_moyenne = rowMeans(pick(all_of(varNotes)), na.rm = TRUE))\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  mutate(note_moyenne = rowMeans(across(all_of(varNotes)), na.rm = TRUE))\n# Alternative très lente !\n# Noter l'utilisation de c_across pour traiter automatiquement plusieurs variables\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  rowwise() %&gt;% \n  mutate(note_moyenne = mean(c_across(all_of(varNotes)), na.rm = TRUE)) %&gt;% \n  ungroup()\n\n\n# Note moyenne (moyenne des moyennes) non pondérée\ndonnees_tidyverse %&gt;% pull(note_moyenne) %&gt;% mean(na.rm = TRUE)\ndonnees_tidyverse %&gt;% summarise(Moyenne = mean(note_moyenne, na.rm = TRUE))\n# Note moyenne (moyenne des moyennes) pondérée\ndonnees_tidyverse %&gt;% summarise(Moyenne_ponderee = weighted.mean(note_moyenne, poids_sondage, na.rm = TRUE))\n\n\n\n\n# Pour chaque observation, 5 notes sont renseignées. On calcule la moyenne de ces 5 notes pour chaque ligne\nvarNotes &lt;- c(\"note_contenu\",\"note_formateur\",\"note_moyens\",\"note_accompagnement\",\"note_materiel\")\n# On souhaite moyenner les notes par formation\ndonnees_datatable[, note_moyenne := rowMeans(.SD, na.rm = TRUE), .SDcols = varNotes]\n# Manière alternative, qui ne semble pas fonctionner\n#donnees_datatable[, note_moyenne := Reduce(function(...) sum(..., na.rm = TRUE), .SD),\n#                  .SDcols = varNotes,\n#                  by = 1:nrow(donnees_datatable)]\n#donnees_datatable[, do.call(function(x, y) sum(x, y, na.rm = TRUE), .SD), .SDcols = varNotes, by = 1:nrow(donnees_datatable)]\n\n# Note moyenne (moyenne des moyennes), non pondérée et pondérée\ndonnees_datatable[, mean(note_moyenne, na.rm = TRUE)]\ndonnees_datatable[, weighted.mean(note_moyenne, poids_sondage, na.rm = TRUE)]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#la-note-donnée-est-elle-supérieure-à-la-moyenne",
    "href": "01-aide_memoire_r_sas.html#la-note-donnée-est-elle-supérieure-à-la-moyenne",
    "title": "Aide-mémoire SAS - R",
    "section": "10.4 La note donnée est-elle supérieure à la moyenne ?",
    "text": "10.4 La note donnée est-elle supérieure à la moyenne ?\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On crée une macro-variable SAS à partir de la valeur de la moyenne */\nproc sql noprint;select mean(Note_moyenne) into :moyenne from donnees_sas;quit;\ndata donnees_sas;\n  set donnees_sas;\n  Note_Superieure_Moyenne = (Note_moyenne &gt; &moyenne.);\nrun;\nproc freq data = donnees_sas;tables Note_Superieure_Moyenne;run;\n\n\n\nmoyenne &lt;- mean(donnees_rbase$note_moyenne, na.rm = TRUE)\ndonnees_rbase$note_superieure_moyenne &lt;- ifelse(donnees_rbase$note_moyenne &gt; moyenne, 1, 0)\ntable(donnees_rbase$note_superieure_moyenne, useNA = \"always\")\n\n\n\n\nmoyenne &lt;- donnees_tidyverse %&gt;% pull(note_moyenne) %&gt;% mean(na.rm = TRUE)\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% mutate(note_superieure_moyenne = ifelse(note_moyenne &gt; moyenne, 1, 0))\ndonnees_tidyverse %&gt;% pull(note_superieure_moyenne) %&gt;% table(useNA = \"always\")\n\n\n\n\nmoyenne &lt;- donnees_datatable[, mean(note_moyenne, na.rm = TRUE)]\ndonnees_datatable[, note_superieure_moyenne := fcase(note_moyenne &gt;= moyenne, 1,\n                                                     note_moyenne &lt;  moyenne, 0)]\ntable(donnees_datatable$note_superieure_moyenne, useNA = \"always\")",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#moyenne-par-ligne-1",
    "href": "01-aide_memoire_r_sas.html#moyenne-par-ligne-1",
    "title": "Aide-mémoire SAS - R",
    "section": "10.5 Moyenne par ligne",
    "text": "10.5 Moyenne par ligne\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On souhaite affecter les pondérations suivantes aux notes :\nNote_Contenu : 30%, Note_Formateur : 20%, Note_Moyens : 25%, Note_Accompagnement : 15%, Note_Materiel : 10% */\n/* Voici une solution possible. Une alternative intéressante serait de passer par IML (non traité ici) */\n%let ponderation = 0.3 0.2 0.25 0.15 0.10;\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\ndata donnees_sas;\n  set donnees_sas;\n  %macro Somme_pond;\n    %global temp;\n    %let temp = ;\n    %do i = 1 %to %sysfunc(countw(&notes.));\n      %let k = %scan(&notes., &i.);\n      %let l = %scan(&ponderation., &i., %str( ));\n      &k._pond = &k. * &l.;\n      %let temp = &temp. &k._pond;\n    %end;\n  %mend Somme_pond;\n  %Somme_pond;\n  Note_moyenne_pond = sum(of &temp.);\n  drop &temp.;\nrun;\nproc means data = donnees_sas mean;var Note_moyenne_pond;run;\n\n\n\n# On calcule de nouveau cette moyenne, mais en pondérant\n# On souhaite affecter les pondérations suivantes aux notes :\n# note_contenu : 30%, note_formateur : 20%, note_moyens : 25%, note_accompagnement : 15%, note_materiel : 10%\nnotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nponderation &lt;- c(note_contenu = 30, note_formateur = 20, note_moyens = 25, note_accompagnement = 15, note_materiel = 10) / 100\nsum(ponderation)\ndonnees_rbase$note_moyennepond &lt;- apply(donnees_rbase[, notes], 1, function(x) weighted.mean(x, ponderation, na.rm = TRUE))\n# Autre manière, en exploitant le calcul matriciel\n# Ne fonctionne pas, du fait des NA\nas.matrix(donnees_rbase[, notes]) %*% as.matrix(ponderation)\n# Produit élément par élément\n# On peut procéder par produit matriciel\nas.matrix(donnees_rbase[, notes]) * matrix(t(as.matrix(ponderation)), nrow(donnees_rbase), 5)\n\n\n\n\n# On calcule de nouveau cette moyenne, mais en pondérant\n# On souhaite affecter les pondérations suivantes aux notes :\n# note_contenu : 30%, note_formateur : 20%, note_moyens : 25%, note_accompagnement : 15%, note_materiel : 10%\n# La fonction RowMeans ne fonctionne plus, cette fois !\nnotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nponderation &lt;- c(note_contenu = 30, note_formateur = 20, note_moyens = 25, note_accompagnement = 15, note_materiel = 10) / 100\nsum(ponderation)\n# Noter l'utilisation de c_across pour traiter automatiquement plusieurs variables\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  rowwise() %&gt;%\n  mutate(note_moyenne = weighted.mean(c_across(varNotes), ponderation, na.rm = TRUE)) %&gt;% \n  ungroup()\n\n\n\n\n## On souhaite affecter les pondérations suivantes aux notes :\n## note_contenu : 30%, note_formateur : 20%, note_moyens : 25%, note_accompagnement : 15%, note_materiel : 10%\nnotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nponderation &lt;- c(note_contenu = 30, note_formateur = 20, note_moyens = 25, note_accompagnement = 15, note_materiel = 10) / 100\ndonnees_datatable[, note_moyenne_pond := rowSums(mapply(FUN = `*`, .SD, ponderation), na.rm = TRUE), .SDcols = names(ponderation)]",
    "crumbs": [
      "Aide-mémoire"
    ]
  }
]