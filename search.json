[
  {
    "objectID": "04-specificites_sas_r.html",
    "href": "04-specificites_sas_r.html",
    "title": "Spécificités de SAS par rapport à R",
    "section": "",
    "text": "Voici une liste non-exhaustive de spécificités de SAS par rapport à R à connaître.",
    "crumbs": [
      "Spécificités de SAS et R"
    ]
  },
  {
    "objectID": "04-specificites_sas_r.html#logiciel-libre",
    "href": "04-specificites_sas_r.html#logiciel-libre",
    "title": "Spécificités de SAS par rapport à R",
    "section": "1 Logiciel libre",
    "text": "1 Logiciel libre\nDe par son statut de logiciel libre, de multiples extensions existent (packages). L’usage des packages :\n\npeut être un atout, car les packages permettent de réaliser plus facilement des choses complexes ;\npeut aussi être source de problèmes, d’abord de maintenance du fait des dépendances (une mise-à-jour peut casser les dépendances), ensuite du fait que des packages peuvent disparaître ou ne plus être maintenus au cours du temps, engendrant des coûts de maintenance de code ;\npeut engendrer des problèmes de rétrocompatibilité (un code écrit dans le passé ne fonctionne plus suite à une mise-à-jour) : il convient d’être conscient de ces considérations avant d’utiliser aveuglément des packages.",
    "crumbs": [
      "Spécificités de SAS et R"
    ]
  },
  {
    "objectID": "04-specificites_sas_r.html#gestion-de-la-mémoire",
    "href": "04-specificites_sas_r.html#gestion-de-la-mémoire",
    "title": "Spécificités de SAS par rapport à R",
    "section": "2 Gestion de la mémoire",
    "text": "2 Gestion de la mémoire\nLa gestion de la mémoire est différente entre les logiciels. R importe l’ensemble des données en mémoire vive, SAS en copie une partie sur le disque dur. Ceci a plusieurs implications pour le travail statistique :\n\nsi le volume des données excède la mémoire vive, il n’est pas possible de les traiter nativement en R. Il faut alors utiliser des stratégies alternatives ;\nil faut être parcimonieux sur le nombre de colonnes à inclure dans les bases de données en R. Par exemple, il vaut mieux recréer dans le programme les variables explicatives faciles à obtenir plutôt que les inclure dans la base de données, où elles occupent de la place et accaparent de la mémoire vive.\n\nQuelles solutions adopter dans le cas où les données à manipuler ne tiennent pas en mémoire vive de l’ordinateur ?\n\nchercher à réduire la taille de la base de données en supprimant des colonnes inutiles ;\nchercher à modifier le processus de production pour le rendre moins gourmand en mémoire ;\naugmenter la mémoire vive de son ordinateur ;\nutiliser les packages Arrow et DuckDb qui peuvent gérer des données excédant la mémoire vive.",
    "crumbs": [
      "Spécificités de SAS et R"
    ]
  },
  {
    "objectID": "Trucs et astuces en R.html",
    "href": "Trucs et astuces en R.html",
    "title": "Trucs et astuces en R",
    "section": "",
    "text": "Voici quelques trucs et astuces utiles à connaître sur R, issus en partie des livres The R Inferno et Advanced R, à consulter pour plus de détails.\n\n\n1 Effets des calculs en virgule flottante\n\nsqrt(2) ^ 2 == 2\n\n[1] FALSE\n\n1 / 49 * 49 == 1\n\n[1] FALSE\n\n.1 == .3 / 3\n\n[1] FALSE\n\nseq(0, 1, by=.1) == .3\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\nunique(c(.3, .4 - .1, .5 - .2, .6 - .3, .7 - .4))\n\n[1] 0.3 0.3 0.3\n\n\n\n\n2 Les types d’objet\n\n# En savoir plus sur ses données\ndata(\"cars\")\ntypeof(cars)\n\n[1] \"list\"\n\nclass(cars)\n\n[1] \"data.frame\"\n\nmode(cars)\n\n[1] \"list\"\n\nstr(cars)\n\n'data.frame':   50 obs. of  2 variables:\n $ speed: num  4 4 7 7 8 9 10 10 10 11 ...\n $ dist : num  2 10 4 22 16 10 18 26 34 17 ...\n\ndim(cars)\n\n[1] 50  2\n\nc(is.data.frame(cars), is.list(cars), is.vector(cars), is.array(cars))\n\n[1]  TRUE  TRUE FALSE FALSE\n\n\nNotation L\n\n# Notation L : imposer à R de créer un nombre sous format \"integer\", pour des raisons d'efficacité\nclass(1)\n\n[1] \"numeric\"\n\nclass(1L)\n\n[1] \"integer\"\n\n\n\n\n3 Les affectations\n\n# Importance des espaces\nx&lt;-3\n# S'agit-il de ?\nx &lt;- 3\n# Ou de ?\nx &lt; -3\n\n[1] FALSE\n\n# Il s'agit du premier cas !\nx\n\n[1] 3\n\n\n\n# Les {} permettent de réaliser une affectation (&lt;-) au sein d'un traitement plus complexe !\n# Exemple ici : sommer les positions paires multipliées par 2 et les positions impaires multipliées par 3\nsum({x &lt;- 1:6 ; x[1:length(x) %% 2 == 0] &lt;- x[1:length(x) %% 2 == 0] * 2 ; x[1:length(x) %% 2 != 0] &lt;- x[1:length(x) %% 2 != 0] * 3 ; x})\n\n[1] 51\n\n\n\n# Afficher ou non la valeur de l'objet affecté pendant l'affectation\nx &lt;- pi\n(x &lt;- pi)\n\n[1] 3.141593\n\n\n\n# Comparaisons multiples\nx &lt;- 0.5\n# Correct\n0 &lt; x & x &lt; 1\n# Incorrect\n0 &lt; x &lt; 1\n\nError: &lt;text&gt;:6:7: unexpected '&lt;'\n5: # Incorrect\n6: 0 &lt; x &lt;\n         ^\n\n\n\n# Ne pas confondre !\nseq(0:10)\n\n [1]  1  2  3  4  5  6  7  8  9 10 11\n\n0:10\n\n [1]  0  1  2  3  4  5  6  7  8  9 10\n\nseq(0, 10)\n\n [1]  0  1  2  3  4  5  6  7  8  9 10\n\n\n\n# Privilégier seq_len à : lorsqu'il y a un risque de 0\n# Fonctionnement identique\nn &lt;- 5\n1:n\n\n[1] 1 2 3 4 5\n\nseq_len(n)\n\n[1] 1 2 3 4 5\n\n# Problème avec les 0\nn &lt;- 0\n1:n\n\n[1] 1 0\n\nseq_len(n)\n\ninteger(0)\n\n\n\n# Préférer seq_along à : au cas où la taille de l'objet est 0\nx &lt;- c() ;length(x)\n\n[1] 0\n\nfor(i in 1:length(x)) print(i)\n\n[1] 1\n[1] 0\n\nfor(i in seq_along(x)) print(i)\nfor(i in seq(along=x)) print(i)\n\n\n# Equivalent des list-comprehensions de type Python en R\n# Somme des entiers de 1 à 1 000 multiples de 3 ou 5, en une ligne !\n# 4 manières de faire\nsum({l &lt;- 1:1000 ; l[l %% 3 == 0 | l %% 5 == 0]})\n\n[1] 234168\n\nsum({l &lt;- 1:1000 ; l[seq_along(l) %% 3 == 0 | seq_along(l) %% 5 == 0]})\n\n[1] 234168\n\nsum(l&lt;-(1:1000)[l %% 3 == 0 | l %% 5 == 0])\n\n[1] 234168\n\nsum((1:1000)[(1:1000 %% 3) == 0 | (1:1000 %% 5) == 0])\n\n[1] 234168\n\n\n\n# Opérations mathématiques\n# Infini\n1/0\n\n[1] Inf\n\n# Nan = not a number\n0/0\n\n[1] NaN\n\nlog(-1)\n\n[1] NaN\n\n\n\n\n4 Principe de vectorisation\nLa fonction s’applique à tous les éléments du vecteur !!\n\n# Exemple de vecteur\nvaleurs &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nvaleurs &lt;- 1:10\n\n\n# Valeurs au carré\nvaleurs ** 2\n\n [1]   1   4   9  16  25  36  49  64  81 100\n\n\n\n# logarithme des valeurs\nlog(valeurs)\n\n [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 1.7917595 1.9459101\n [8] 2.0794415 2.1972246 2.3025851\n\n\n\n# Maximum des valeurs\nmax(valeurs)\n\n[1] 10\n\n\n\n# Limite des valeurs\nrange(valeurs)\n\n[1]  1 10\n\n\n\n# Correct\nmean(valeurs)\n\n[1] 5.5\n\n\n\n# Correct\nmean(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))\n\n[1] 5.5\n\n\n\n# Inattendu\nmean(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n\n[1] 1\n\n\n\n# Attention aux parenthèses !\nn &lt;- 10\n# Inattendu ! Correspond à (1-1, 2-1, 3-1, ..., 10-1)\n1:n-1\n\n [1] 0 1 2 3 4 5 6 7 8 9\n\n# Correct\n1:(n-1)\n\n[1] 1 2 3 4 5 6 7 8 9\n\n\n\n# Minimum ou maximum élément par élément\nx1 &lt;- c(1, 2, 5, 6, 8)\nx2 &lt;- c(4, 0, 7, 2, 1)\n# Minimum : 2 possibilités\npmin(x1, x2)\n\n[1] 1 0 5 2 1\n\nmapply(min, x1, x2)\n\n[1] 1 0 5 2 1\n\n# Maximum : 2 possibilités\npmax(x1, x2)\n\n[1] 4 2 7 6 8\n\nmapply(max, x1, x2)\n\n[1] 4 2 7 6 8\n\n\n\n# Calculer (x - min) / (max - min) pour chaque élément x d'un vecteur\nx &lt;- c(1,2,3)\nsapply(x, function(xi, mn, mx) {(xi - mn) / (mx - mn)}, mn = min(x), mx = max(x))\n\n[1] 0.0 0.5 1.0\n\n\n\n\n5 Principe de coercion\nDans les comparaisons, les objets R sont successivement convertis en logical, integer, numeric, complex et character, jusqu’à ce que la comparaison puisse se faire.\n\n# TRUE / FALSE est transformé en integer (1 / 0)\nTRUE == 1\n\n[1] TRUE\n\nTRUE == 2\n\n[1] FALSE\n\nFALSE == 0\n\n[1] TRUE\n\n\n\n# TRUE est convertit en character\nTRUE == \"1\"\n\n[1] FALSE\n\n\n\n# 5 est convertit en character\n5 &lt; '7'\n\n[1] TRUE\n\n\n\n# 50 est convertit en character\n50 &lt; '7'\n\n[1] TRUE\n\n\n\n\n6 Principe de recycling\n\n# Fonctionne sans soulever de message d'erreur\nx &lt;- c(1, 2, 3)\ny &lt;- c(1, 2, 3, 4, 5, 6)\nx + y\n\n[1] 2 4 6 5 7 9\n\n\n\n# Fonctionne, mais Warning\nx &lt;- c(1, 2, 3)\ny &lt;- c(1, 2, 3, 4, 5, 6, 7)\nx + y\n\nWarning in x + y: longer object length is not a multiple of shorter object\nlength\n\n\n[1] 2 4 6 5 7 9 8\n\n\n\n\n7 Opérateurs de contrôle\n\n# Conditions if / else\nx &lt;- 1\n\n\n# Correct\nif (identical(x, 1)) {\nprint(\"x est égal à 1\")\n} else {\nprint(\"x est différent de 1\")\n}\n\n[1] \"x est égal à 1\"\n\n\n\n# Correct\nif (identical(x, 1)) {print(\"x est égal à 1\")\n} else {print(\"x est différent de 1\")}\n\n[1] \"x est égal à 1\"\n\n\n\n# Correct\nif (identical(x, 1)) print(\"x est égal à 1\") else\nprint(\"x est différent de 1\")\n\n[1] \"x est égal à 1\"\n\n\n\n# Correct\nif (identical(x, 1)) print(\"x est égal à 1\") else print(\"x est différent de 1\")\n\n[1] \"x est égal à 1\"\n\n\n\n# Incorrect\nif (identical(x, 1)) print(\"x est égal à 1\")\nelse print(\"x est différent de 1\")\n\nError: &lt;text&gt;:3:1: unexpected 'else'\n2: if (identical(x, 1)) print(\"x est égal à 1\")\n3: else\n   ^\n\n\n\n# Switch\n# Fonctions et conditions if / else\ncondition &lt;- function(langue = \"Français\") {\nif (langue == \"Français\") {\n\"salut\"\n} else if (langue == \"Anglais\") {\n\"hello\"\n} else if (langue == \"Russe\") {\n\"привет\"\n} else {\nstop(\"salut\")\n}\n}\ncondition(\"Anglais\")\n\n[1] \"hello\"\n\n\n\n# Autre possibilité avec switch, mais à réserver aux variables caractères !\ncondition &lt;- function(langue = \"Français\") {\nswitch(langue,\nFrançais = \"salut\",\nAnglais = \"hello\",\nRusse = \"привет\",\nstop(\"salut\")\n)\n}\ncondition(\"Français\")\n\n[1] \"salut\"\n\n\n\n# Penser au print\nfor(i in 1:5) i\nfor(i in 1:5) print(i)\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n\n\n\n# Différences print et cat\ncat(\"Salut !\\nComment vas-tu ?\")\n\nSalut !\nComment vas-tu ?\n\nprint(\"Salut !\\nComment vas-tu ?\")\n\n[1] \"Salut !\\nComment vas-tu ?\"\n\n\n\n\n8 Les valeurs manquantes\n\n# Transformer les valeurs manquantes en 0\nx &lt;- data.frame(X1 = c(1, NA, 2), X2 = c(NA, NA, 3))\nx\n\n  X1 X2\n1  1 NA\n2 NA NA\n3  2  3\n\nx[is.na(x)] &lt;- 0\nx\n\n  X1 X2\n1  1  0\n2  0  0\n3  2  3\n\n\n\n# Pour les valeurs manquantes, toujours utiliser is.na et non ==\nNA == c(3, 1, 3, NA)\n\n[1] NA NA NA NA\n\nis.na(c(3, 1, 3, NA))\n\n[1] FALSE FALSE FALSE  TRUE\n\n\n\n# Utiliser %in% et non == pour vérifier une appartenance à plusieurs variables\nx1 &lt;- 1:6\nx1 == c(1, 5)\n\n[1]  TRUE FALSE FALSE FALSE FALSE FALSE\n\nx1 %in% c(1, 5)\n\n[1]  TRUE FALSE FALSE FALSE  TRUE FALSE\n\n\n\n# Sélection de données en cas de valeurs manquantes\nxna &lt;- c(1, NA, 3, 2, 4, 2)\n\n\n# Avec ce code, les NA sont conservés\nxna[xna == 2]\n\n[1] NA  2  2\n\n\n\n# Code sans les NA\nxna[!is.na(xna) & xna == 2]\n\n[1] 2 2\n\n\n\n# Code compact sans les NA\nxna[which(xna == 2)]\n\n[1] 2 2\n\n\n\n# Incidence des NA dans le calcul de statistiques !\n# Besoin de l'instruction na.rm = TRUE pour en supprimer l'incidence\nx &lt;- c(1, 5, 6, NA, 8)\nmean(x)\n\n[1] NA\n\nmean(x, na.rm = TRUE)\n\n[1] 5\n\nmax(x)\n\n[1] NA\n\nmax(x, na.rm = TRUE)\n\n[1] 8\n\n\n\n# Une moyenne de NA donne NaN (Not a Number) avec na.rm = TRUE !\nmean(c(NA, NA, NA), na.rm = TRUE)\n\n[1] NaN\n\n# Et donne NA avec na.rm = FALSE !\nmean(c(NA, NA, NA), na.rm = FALSE)\n\n[1] NA\n\n\n\n\n9 Sélection d’éléments\n\n# Le 1er élément est numéroté 1 et non 0 comme dans Python\nx &lt;- 1:3\nx[c(0, 4)] &lt;- c(-1, 9)\n# Marche !!\nfor(i in 0:3) print(x[i])\n\nnumeric(0)\n[1] 1\n[1] 2\n[1] 3\n\n\n\n# Cas où les noms ne sont pas uniques\nx &lt;- c(a = 1, b = 2, a = 3)\nx[\"a\"]\n\na \n1 \n\nx[names(x) %in% \"a\"]\n\na a \n1 3 \n\n\n\n# Options drop = FALSE\nx &lt;- data.frame(X1 = c(1,2), X2 = c(3,4), x3 = c(5,6))\nis.data.frame(x[, c(1,2)])\n\n[1] TRUE\n\nis.data.frame(x[, c(1)])\n\n[1] FALSE\n\nis.data.frame(x[, c(1), drop = FALSE])\n\n[1] TRUE\n\n\n\n# Fonction subset\nx &lt;- data.frame(x1 = c(1,2), x2 = c(3,4), x3 = c(5,6))\nsubset(x, select = x1)\n\n  x1\n1  1\n2  2\n\nsubset(x, select = -x1)\n\n  x2 x3\n1  3  5\n2  4  6\n\n\n\n# Correct\nsubset(x, x1 == 1)\n\n  x1 x2 x3\n1  1  3  5\n\n\n\n# Incorrect\nsubset(x, x1 = 1)\n\n  x1 x2 x3\n1  1  3  5\n2  2  4  6\n\n\n\n# Référence à des noms de colonne non usuels\ndf &lt;- data.frame(x = rnorm(5), y = runif(5))\nnames(df) &lt;- 1:2\n\n# Correct\ndf$`1`\n\n# Incorrect\ndf$1\n\nError: &lt;text&gt;:9:4: unexpected numeric constant\n8: # Incorrect\n9: df$1\n      ^\n\n\n\n# Utilisation de assign pour assigner une valeur à un objet en le désignant sous forme caractère\nassign('objet', 3:5)\nobjet\n\n[1] 3 4 5\n\nfor(i in 1:5) assign(paste('objet', i, sep = '_'), i)\nobjet_5\n\n[1] 5\n\n\n\n\n10 Les listes\n\n# Ajouter un élément à une liste\nliste &lt;- list(1, 2)\n# Il faut passer par cette syntaxe\nliste &lt;- c(liste, list(3))\nliste\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n\n\n\n# Trier une liste\nliste &lt;- list(\"2\" = 2, \"0\" = 0, \"1\" = 1)\nliste\n\n$`2`\n[1] 2\n\n$`0`\n[1] 0\n\n$`1`\n[1] 1\n\nliste[order(names(liste))]\n\n$`0`\n[1] 0\n\n$`1`\n[1] 1\n\n$`2`\n[1] 2\n\n\n\n# Extraction de listes\nliste &lt;- list(nombres = 1:5, lettres = letters[1:5])\nliste$nombres\n\n[1] 1 2 3 4 5\n\n\n\n# On veut faire appel à un élement de la liste à partir d'une variable extérieure\nvar &lt;- \"nombres\"\n\n\n# Ne marche pas, car nombres est en caractère\nliste$var\n\nNULL\n\n\n\n# Fonctionne\nliste[[var]]\n\n[1] 1 2 3 4 5\n\n\n\n# Sélection dans une liste\nliste &lt;- list(nombres = 1:5, lettres = letters[1:5])\nliste[\"nombres\"]\n\n$nombres\n[1] 1 2 3 4 5\n\nis.list(liste[\"nombres\"])\n\n[1] TRUE\n\nliste[[\"nombres\"]]\n\n[1] 1 2 3 4 5\n\nis.list(liste[[\"nombres\"]])\n\n[1] FALSE\n\n\n\n# Suppression des éléments d'une liste\nliste &lt;- list(nombres = 1:5, lettres = letters[1:5])\nliste[-1]\n\n$lettres\n[1] \"a\" \"b\" \"c\" \"d\" \"e\"\n\nliste[\"nombres\"] &lt;- NULL\nliste\n\n$lettres\n[1] \"a\" \"b\" \"c\" \"d\" \"e\"\n\n\n\n\n11 Informations sur R\n\n# Informations sur la session de R\nsessionInfo()\nSys.info()\n.Platform\n\n# Version de R\nR.version.string\n\n# Lien vers le bureau de l'utilisateur\nfile.path(path.expand('~'), \"Desktop\")\n\n# Chemin de l'exécutable R est-il installé ?\nR.home(\"bin\")\n\n# Où sont installés les packages R\n.libPaths()\n\n\n\n12 Trucs et astuces divers\n\n# Créer un objet sous forme de code R !\ndata(\"mtcars\")\ndput(mtcars)\n\nstructure(list(mpg = c(21, 21, 22.8, 21.4, 18.7, 18.1, 14.3, \n24.4, 22.8, 19.2, 17.8, 16.4, 17.3, 15.2, 10.4, 10.4, 14.7, 32.4, \n30.4, 33.9, 21.5, 15.5, 15.2, 13.3, 19.2, 27.3, 26, 30.4, 15.8, \n19.7, 15, 21.4), cyl = c(6, 6, 4, 6, 8, 6, 8, 4, 4, 6, 6, 8, \n8, 8, 8, 8, 8, 4, 4, 4, 4, 8, 8, 8, 8, 4, 4, 4, 8, 6, 8, 4), \n    disp = c(160, 160, 108, 258, 360, 225, 360, 146.7, 140.8, \n    167.6, 167.6, 275.8, 275.8, 275.8, 472, 460, 440, 78.7, 75.7, \n    71.1, 120.1, 318, 304, 350, 400, 79, 120.3, 95.1, 351, 145, \n    301, 121), hp = c(110, 110, 93, 110, 175, 105, 245, 62, 95, \n    123, 123, 180, 180, 180, 205, 215, 230, 66, 52, 65, 97, 150, \n    150, 245, 175, 66, 91, 113, 264, 175, 335, 109), drat = c(3.9, \n    3.9, 3.85, 3.08, 3.15, 2.76, 3.21, 3.69, 3.92, 3.92, 3.92, \n    3.07, 3.07, 3.07, 2.93, 3, 3.23, 4.08, 4.93, 4.22, 3.7, 2.76, \n    3.15, 3.73, 3.08, 4.08, 4.43, 3.77, 4.22, 3.62, 3.54, 4.11\n    ), wt = c(2.62, 2.875, 2.32, 3.215, 3.44, 3.46, 3.57, 3.19, \n    3.15, 3.44, 3.44, 4.07, 3.73, 3.78, 5.25, 5.424, 5.345, 2.2, \n    1.615, 1.835, 2.465, 3.52, 3.435, 3.84, 3.845, 1.935, 2.14, \n    1.513, 3.17, 2.77, 3.57, 2.78), qsec = c(16.46, 17.02, 18.61, \n    19.44, 17.02, 20.22, 15.84, 20, 22.9, 18.3, 18.9, 17.4, 17.6, \n    18, 17.98, 17.82, 17.42, 19.47, 18.52, 19.9, 20.01, 16.87, \n    17.3, 15.41, 17.05, 18.9, 16.7, 16.9, 14.5, 15.5, 14.6, 18.6\n    ), vs = c(0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, \n    0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1), am = c(1, \n    1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, \n    0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1), gear = c(4, 4, 4, 3, \n    3, 3, 3, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, \n    3, 3, 4, 5, 5, 5, 5, 5, 4), carb = c(4, 4, 1, 1, 2, 1, 4, \n    2, 2, 4, 4, 3, 3, 3, 4, 4, 4, 1, 2, 1, 1, 2, 2, 4, 2, 1, \n    2, 2, 4, 6, 8, 2)), row.names = c(\"Mazda RX4\", \"Mazda RX4 Wag\", \n\"Datsun 710\", \"Hornet 4 Drive\", \"Hornet Sportabout\", \"Valiant\", \n\"Duster 360\", \"Merc 240D\", \"Merc 230\", \"Merc 280\", \"Merc 280C\", \n\"Merc 450SE\", \"Merc 450SL\", \"Merc 450SLC\", \"Cadillac Fleetwood\", \n\"Lincoln Continental\", \"Chrysler Imperial\", \"Fiat 128\", \"Honda Civic\", \n\"Toyota Corolla\", \"Toyota Corona\", \"Dodge Challenger\", \"AMC Javelin\", \n\"Camaro Z28\", \"Pontiac Firebird\", \"Fiat X1-9\", \"Porsche 914-2\", \n\"Lotus Europa\", \"Ford Pantera L\", \"Ferrari Dino\", \"Maserati Bora\", \n\"Volvo 142E\"), class = \"data.frame\")\n\n\n\n# En tidyverse, la fonction tribble peut être utile pour créer des bases lignes par lignes\nlibrary(tidyverse)\ntribble(\n  ~x, ~y,\n  \"a\",   1,\n  \"b\",   2\n)\n\n# A tibble: 2 × 2\n  x         y\n  &lt;chr&gt; &lt;dbl&gt;\n1 a         1\n2 b         2\n\n\n\n# Outils de debuggage\noptions(error = recover)\noptions(error=NULL)\n\n\n# Définir ses propres opérateurs\n# R reconnait le texte entre %% comme un opérateur binaire\n# Exemple, simplifier la fonction paste\n'%+%' &lt;- function(x, y) { paste(x, y, sep = \"\") }\n\"Groupe_\" %+% 0:9\n\n [1] \"Groupe_0\" \"Groupe_1\" \"Groupe_2\" \"Groupe_3\" \"Groupe_4\" \"Groupe_5\"\n [7] \"Groupe_6\" \"Groupe_7\" \"Groupe_8\" \"Groupe_9\"\n\n\n\n# Récupérer les éléments à la diagonale d'un dataframe\ndiag(as.matrix(mtcars))\n\n [1]  21.00   6.00 108.00 110.00   3.15   3.46  15.84   1.00   0.00   4.00\n[11]   4.00\n\n\n\n\n13 Le pipe sur R\nCet opérateur permet d’enchaîner les opérations et d’avoir un code plus lisible.\nIl existe différents types :\n\nLe pipe de Rbase : |&gt;\nLe pipe du tidyverse : %&gt;%\n\nLes deux pipes fonctionnent de la même manière mais diffèrent sur les points suivants :\n\n\n\n\n\n\n\n\nThème\n|&gt;\n%&gt;%\n\n\n\n\nPlaceholder (pour indiquer où placer l’objet)\n_\nx |&gt; f(y, a = _)\n.\nx %&gt;% f(y, a = .)\n\n\nPackage\nAucun : directement sur R\nMagrittr (pipe disponible lorsqu’on effectue library(tidyverse)) |\n\n\nFonction\nImpossible\nPossible\n\n\nTemps de calcul\nRapide\nPlus lent\n\n\nOpérateurs\n|&gt;\n%&gt;% %&lt;&gt;% %$% %!&gt;% %T&gt;%\n\n\n\nSource :\n\nhttps://larmarange.github.io/guide-R/manipulation/pipe.html#le-pipe-natif-de-r\n\n\n\n14 Conseils divers\nIl est conseillé d’éviter de nommer des variables temporaires var, car ce nom désigne la fonction R permettant de calculer une variance.\n\n# Exemple : variance d'un échantillon aléatoire de 1000 observations tiré d'une loi normale centrée réduite\nvar(rnorm(1000))\n\n[1] 1.0037",
    "crumbs": [
      "Trucs et astuces"
    ]
  },
  {
    "objectID": "02-avantages_inconvenients_env_R.html",
    "href": "02-avantages_inconvenients_env_R.html",
    "title": "Avantages et inconvénients des environnements R",
    "section": "",
    "text": "Environnements R\n          Avantages\n        Inconvénients\n\n\n\n\n       R base\n\nabsence de dépendance (ne s’appuie sur aucun package) : pas besoin d’installer un package, de gérer sa mise à jour, de craindre pour sa disparition\ngarantit la rétrocompatibilité du code : utile dans des environnements de production\ndans certains cas, se révèle la solution la plus simple\nparfois, la seule façon de faire\n\n\nne permet pas de gérer des bases de données plus volumineuses que la mémoire vive\nsyntaxe plus complexe que tidyverse et parfois incohérente\nsouvent moins rapide que les autres environnements\ndemande plus de connaissance sur le fonctionnement du langage R\ncertaines tâches sont plus simples à traiter avec les autres environnements\n\n\n\n       tidyverse\n\nplus simple à prendre en main\nsyntaxe plus simple que les autres environnements et cohérente\nlargement utilisé dans la communauté R\ntend à s’imposer comme la référence de la gestion de données sur R\nsyntaxe utilisée également dans les packages arrow / duckdb\n\n\nne permet pas de gérer des bases de données plus volumineuses que la mémoire vive\nglobalement moins rapide que data.table\ncertaines tâches sont plus difficiles à réaliser que dans les autres environnements\ndette technique importante : la syntaxe est plus souvent modifiée au gré des mises à jour du langage. Ainsi, la rétrocompatibilité est moins bien assurée, ce qui peut se révéler un problème dans un environnement de production\n\n\n\n       data.table\n\nfaible dépendance : garantit une rétrocompatibilité élevée, utile dans un environnement de production\nsyntaxe proche du R-Base\ngénéralement plus rapide que ses concurrents R-Base et tidyverse\nutile dans la gestion des grosses volumétries ou lorsque des considérations de vitesse d’exécution sont en jeu\n\n\nne permet pas de gérer des bases de données plus volumineuses que la mémoire vive\nsyntaxe parfois jugée comme plus difficile à maîtriser que celle du tidyverse\ncertaines tâches sont plus simples à traiter avec les autres environnements\nmoins utilisé que tidyverse, communauté plus réduite\n\n\n\n\n\n\n\n\n       duckdb\n\nbase de de données analytique open source. Se rapproche d’outils tels SQLite ou PostgreSQL\noptimisé pour des traitements de données orientées colonnes : plus performant pour les analyses statistiques que SQLite\nsimple d’utilisation par rapport à des outils comme PostgreSQL\npermet de gérer des bases de données plus volumineuses que la mémoire vive\npermet la syntaxe en SQL et en tidyverse, pratique pour ceux qui connaissent\ncompatible avec de nombreux autres langages (tel Python)\ntend à être plus rapide que ses concurrents\n\n\ncapacités très importantes pour gérer de très grosses volumétries, mais a ses limites face aux données les plus volumineuses\nà privilégier pour les données saturant ou excédant la mémoire vive, moins utile pour les données de taille petite ou moyenne\noutil plus récent : est susceptible de subir des changements dans les prochaines années\nla syntaxe tidyverse est largement, mais pas totalement prise en compte, et elle peut changer à la marge\ndocumentation officielle encore incomplète\noutil moins utilisé que les autres environnements, et surtout par des personnes ayant plus d’expérience\n\n\n\n\n\n\n\n\n       arrow\n\ntrès similaire à duckdb\nprojet plus ancien et plus mature que duckdb, moins de changements à attendre dans le futur\nmet à disposition le format de compression de données très utilisé parquet\n\n\ntrès similaires à duckdb\nmoins de fonctions standards du tidyverse prises en charge par rapport à duckdb\njointures de bases volumineuses moins performantes qu’avec duckdb\noffre moins de fonctionnalités que duckdb",
    "crumbs": [
      "Avantages et inconvénients des environnements R"
    ]
  },
  {
    "objectID": "03-mise_en_garde.html",
    "href": "03-mise_en_garde.html",
    "title": "Mise en garde",
    "section": "",
    "text": "1 Comment utiliser cet aide-mémoire ?\nSont présentés dans cet aide-mémoire des programmes statistiques courants pour la gestion de données statistiques, traduits dans les langages SAS et R (environnements R-Base, Tidyverse et data.table et Arrow/DuckDb). Ces tâches sont standards dans l’analyse statistique et réalisables en un petit nombre d’instructions.\nCet aide-mémoire vise à faciliter la traduction des programmes statistiques entre ces différents langages (de SAS vers R, et d’un environnement R à un autre), et leur appropriation.\nIl est présenté sous forme de tâches élémentaires statistiques (sélection de lignes ou de colonnes d’une base de données, repérage des doublons, etc.).\nQuatre grands environnements R sont traités : R-Base, Tidyverse et data.table et Arrow/DuckDb). Ils ne doivent pas être vus comme des concurrents, mais comme des compléments :\n\ncertaines tâches peuvent être plus ou moins facilement réalisées avec l’un ou l’autre ;\nils présentent chacun des avantages et des inconvénients ;\nils laissent le choix de la stratégie de codage.\n\nCe guide est destiné à vous permettre de jongler plus facilement entre les environnements.\nPlusieurs solutions pour réaliser la même tâche sont proposées dans ce guide :\n\ncertaines solutions peuvent être plus concises, mais moins claires ;\nd’autres plus ou moins rapides en fonction des données et des matériels et logiciels utilisés ;\ncertaines façons de procéder sont plus efficaces que d’autres en R, mais cela peut dépendre des données et du matériel utilisé.\n\nL’attention du lecteur est attirée sur le fait que :\n\nce guide n’est pas exhaustif. Ainsi, les environnements peuvent proposer des solutions ad-hoc simplifiant grandement la résolution de problèmes moins courants et qui ne sont pas présents dans les autres environnements (ex. des rolling joins de data.table) ;\nce guide ne traite pas de ces stratégies, et le lecteur est invité à se documenter sur les environnements pour en savoir plus ;\nl’exercice de traduction de SAS vers R peut s’apparenter à la traduction d’un texte en langue étrangère. De même qu’une traduction littérale d’un texte en peut parfois être de mauvaise qualité, la traduction littérale d’une masse de codes SAS en codes R au moyen de cet aide-mémoire peut produire des résultats décevants. En effet, toute bonne traduction nécessite au moins a minima d’adapter le code SAS à une “nouvelle langue”, celle de R. La partie sur les spécificités de SAS par rapport à R peut vous aider sur ce point.",
    "crumbs": [
      "Mise en garde"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html",
    "href": "01-aide_memoire_r_sas.html",
    "title": "Aide-mémoire SAS - R",
    "section": "",
    "text": "L’aide-mémoire a pour but de fournir des codes écrits en SAS et d’en donner la traduction en R de différentes manières possibles :\nLes codes traduits sont typiques de la production statistique ou la réalisation d’études descriptives.\nCe document s’adresse notamment aux utilisateurs de SAS qui veulent connaître la traduction du code SAS en R, aux utilisateurs de R qui ont besoin de comprendre le code SAS, ainsi qu’aux utilisateurs d’un environnement R qui sont intéressés par la traduction dans un autre environnement R.\nIl se veut complémentaire de la documentation en ligne en français Utilit’R, née à l’Insee (https://www.book.utilitr.org/). Le lecteur est invité à s’y référer pour obtenir des informations importantes sur l’utilisation de R et qui ne sont pas discutées dans ce document, comme l’importation de données en R (https://www.book.utilitr.org/03_fiches_thematiques/fiche_import_fichiers_plats).\nEnfin, si vous souhaitez collaborer à cet aide-mémoire ou nous faire part de votre avis, n’hésitez pas à nous contacter via nos adresses email.",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#installation-des-packages",
    "href": "01-aide_memoire_r_sas.html#installation-des-packages",
    "title": "Aide-mémoire SAS - R",
    "section": "1.1 Installation des packages",
    "text": "1.1 Installation des packages\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Sans objet pour SAS */\n\n\n\n# Les packages doivent au préalable être installés sur le disque dur\n# Pour installer un package :\n# install.packages(\"nom_du_package\")\n\n\n\n\n# Les packages doivent au préalable être installés sur le disque dur\n# Pour installer un package :\n# install.packages(\"nom_du_package\")\n\n\n\n\n# Les packages doivent au préalable être installés sur le disque dur\n# Pour installer un package :\n# install.packages(\"nom_du_package\")\n\n\n\n\n# Les packages doivent au préalable être installés sur le disque dur\n# Pour installer un package :\n# install.packages(\"nom_du_package\")",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#importation-des-packages-1",
    "href": "01-aide_memoire_r_sas.html#importation-des-packages-1",
    "title": "Aide-mémoire SAS - R",
    "section": "1.2 Importation des packages",
    "text": "1.2 Importation des packages\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Sans objet pour SAS */\n\n\n\n# Sans objet pour R-Base\n\n# Cependant, on importe le package lubridate pour faciliter la gestion des dates\nlibrary(lubridate)\n\n\n\n\n# Chargement des packages\n# Le tidyverse proprement dit\nlibrary(tidyverse)\n# Les packages importés par le tidyverse sont :\n# - dplyr (manipulation de données)\n# - tidyr (réorganisation de bases de données)\n# - readr (importation de données)\n# - purrr (permet de réaliser des boucles)\n# - tibble (format de données tibble, complémentaire du data.frame)\n# - stringr (manipulation de chaînes de caractères)\n# - ggplot2 (création de graphiques)\n# - forcats (gestion des formats \"factors\")\n\n# Pour manipuler les dates\nlibrary(lubridate)\n# Pour utiliser le pipe %&gt;%\nlibrary(magrittr)\n\n# Documentation de tidyverse\nvignette(\"dplyr\")\n\n\n\n\nlibrary(data.table)\n# Pour manipuler les dates\nlibrary(lubridate)\n\n# Documentation de data.table\n?'[.data.table'\n\n\n\n\n#library(duckdb)\n#library(arrow)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#mode-demploi-de-laide-mémoire",
    "href": "01-aide_memoire_r_sas.html#mode-demploi-de-laide-mémoire",
    "title": "Aide-mémoire SAS - R",
    "section": "2.1 Mode d’emploi de l’aide-mémoire",
    "text": "2.1 Mode d’emploi de l’aide-mémoire\nLes codes informatiques sont appliqués sur une base de données illustrative fictive. Cette base est importée à cette étape. Aussi, pour répliquer les codes sur sa machine, le lecteur doit d’abord exécuter le code d’importation de la base de données ci-dessous.\nLes codes sont majoritairement exécutables indépendamment les uns des autres.",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#création-dune-base-de-données-dexemple",
    "href": "01-aide_memoire_r_sas.html#création-dune-base-de-données-dexemple",
    "title": "Aide-mémoire SAS - R",
    "section": "2.2 Création d’une base de données d’exemple",
    "text": "2.2 Création d’une base de données d’exemple\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Données fictives sur des formations */\ndata donnees_sas;\n  infile cards dsd dlm='|';\n  format Identifiant $3. Sexe 1. CSP $1. Niveau $30. Date_naissance ddmmyy10. Date_entree ddmmyy10. Duree Note_Contenu Note_Formateur Note_Moyens\n         Note_Accompagnement Note_Materiel poids_sondage 4.1 CSPF $25. Sexef $5.;\n  input Identifiant $ Sexe CSP $ Niveau $ Date_naissance :ddmmyy10. Date_entree :ddmmyy10. Duree Note_Contenu Note_Formateur Note_Moyens\n        Note_Accompagnement Note_Materiel poids_sondage CSPF $ Sexef $;\n  cards;\n  173|2|1|Qualifié|17/06/1998|01/01/2021|308|12|6|17|4|19|117.1|Cadre|Femme\n  173|2|1|Qualifié|17/06/1998|01/01/2022|365|6||12|7|14|98.3|Cadre|Femme\n  173|2|1|Qualifié|17/06/1998|06/01/2022|185|8|10|11|1|9|214.6|Cadre|Femme\n  173|2|1|Non qualifié|17/06/1998|02/01/2023|365|14|15|15|10|8|84.7|Cadre|Femme\n  174|1|1|Qualifié|08/12/1984|17/08/2021|183|17|18|20|15|12|65.9|Cadre|Homme\n  175|1|1|Qualifié|16/09/1989|21/12/2022|730|5|5|8|4|9|148.2|Cadre|Homme\n  198|2|3|Non qualifié|17/03/1987|28/07/2022|30|10|10|10|16|8|89.6|Employé|Femme\n  198|2|3|Qualifié|17/03/1987|17/11/2022|164|11|7|6|14|13|100.3|Employé|Femme\n  198|2|3|Qualifié|17/03/1987|21/02/2023|365|9|20|3|4|17|49.3|Employé|Femme\n  168|1|2|Qualifié|30/07/2002|04/09/2019|365|18|11|20|13|15|148.2|Profession intermédiaire|Homme\n  211|2|3|Non qualifié||17/12/2021|135|16|16|15|12|9|86.4|Employé|Femme\n  278|1|5|Qualifié|10/08/1948|07/06/2018|365|14|10|6|8|12|99.2|Retraité|Homme\n  347|2|5|Qualifié|13/09/1955||180|12|5|7|11|12|105.6|Retraité|Femme\n  112|1|3|Non qualifié|13/09/2001|02/03/2022|212|3|10|11|9|8|123.1|Employé|Homme\n  112|1|3|Non qualifié|13/09/2001|01/03/2021|365|7|13|8|19|2|137.4|Employé|Homme\n  112|1|3|Qualifié|13/09/2001|01/12/2023|365|9|||||187.6|Employé|Homme\n  087|2|4|Non qualifié|||365||10||||87.3|Ouvrier|Femme\n  087|2|4|Non qualifié||31/10/2020|365|||11|||87.3|Ouvrier|Femme\n  099|1|4|Qualifié|06/06/1998|01/03/2021|364|12|11|10|12|13|169.3|Ouvrier|Homme\n  099|1|4|Qualifié|06/06/1998|01/03/2022|364|12|11|10|12|13|169.3|Ouvrier|Homme\n  099|1|4|Qualifié|06/06/1998|01/03/2023|364|12|11|10|12|13|169.3|Ouvrier|Homme\n  187|2|2|Qualifié|05/12/1986|01/01/2022|364|10|10|10|10|10|169.3|Profession intermédiaire|Femme\n  187|2|2|Qualifié|05/12/1986|01/01/2023|364|10|10|10|10|10|234.1|Profession intermédiaire|Femme\n  689|1|1||01/12/2000|06/11/2017|123|9|7|8|13|16|189.3|Cadre|Homme\n  765|1|4|Non qualifié|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9|Ouvrier|Homme\n  765|1|4|Non qualifié|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9|Ouvrier|Homme\n  765|1|4|Non qualifié|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9|Ouvrier|Homme\n  ;\nrun;\n\n/* Date de sortie du dispositif : ajout de la durée à la date d'entrée */\ndata donnees_sas;\n  set donnees_sas;\n  format date_sortie ddmmyy10.;\n  date_sortie = intnx('day', date_entree, duree);\nrun;\n\n\n\n# Données fictives sur des formations\ndonnees_rbase &lt;- data.frame(\n  Identifiant = c(\"173\", \"173\", \"173\", \"173\", \"174\", \"175\", \"198\", \"198\", \"198\", \"168\", \"211\", \"278\", \"347\", \"112\", \"112\", \"112\", \"087\", \"087\", \"099\", \"099\", \"099\", \"187\", \"187\", \"689\", \"765\", \"765\", \"765\"),\n  Sexe = c(\"2\", \"2\", \"2\", \"2\", \"1\", \"1\", \"2\", \"2\", \"2\", \"1\", \"2\", \"1\", \"2\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", \"1\", \"1\"),\n  CSP = c(\"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"3\", \"3\", \"3\", \"2\", \"3\", \"5\", \"5\", \"3\", \"3\", \"3\", \"4\", \"4\", \"4\", \"4\", \"4\", \"2\", \"2\", \"1\", \"4\", \"4\", \"4\"),\n  Niveau = c(\"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \n             \"Non qualifié\", \"Qualifié\", \"Non qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", NA, \"Non qualifié\", \"Non qualifié\", \"Non qualifié\"),\n  Date_naissance = c(\"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"08/12/1984\", \"16/09/1989\", \"17/03/1987\", \"17/03/1987\", \"17/03/1987\", \"30/07/2002\", NA, \"10/08/1948\", \n                     \"13/09/1955\", \"13/09/2001\", \"13/09/2001\", \"13/09/2001\", NA, NA, \"06/06/1998\", \"06/06/1998\", \"06/06/1998\", \"05/12/1986\", \"05/12/1986\", \"01/12/2000\", \"26/12/1995\", \"26/12/1995\", \"26/12/1995\"),\n  Date_entree = c(\"01/01/2021\", \"01/01/2022\", \"06/01/2022\", \"02/01/2023\", \"17/08/2021\", \"21/12/2022\", \"28/07/2022\", \"17/11/2022\", \"21/02/2023\", \"04/09/2019\", \"17/12/2021\", \"07/06/2018\", NA, \"02/03/2022\", \"01/03/2021\", \"01/12/2023\", NA, \n                  \"31/10/2020\", \"01/03/2021\", \"01/03/2022\", \"01/03/2023\", \"01/01/2022\", \"01/01/2023\", \"06/11/2017\", \"17/04/2020\", \"17/04/2020\", \"17/04/2020\"),\n  Duree = c(\"308\", \"365\", \"185\", \"365\", \"183\", \"730\", \"30\", \"164\", \"365\", \"365\", \"135\", \"365\", \"180\", \"212\", \"365\", \"365\", \"365\", \"365\", \"364\", \"364\", \"364\", \"364\", \"364\", \"123\", \"160\", \"160\", \"160\"),\n  Note_Contenu = c(\"12\", \"6\", \"8\", \"14\", \"17\", \"5\", \"10\", \"11\", \"9\", \"18\", \"16\", \"14\", \"12\", \"3\", \"7\", \"9\", NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"9\", \"13\", \"13\", \"13\"),\n  Note_Formateur = c(\"6\", NA, \"10\", \"15\", \"18\", \"5\", \"10\", \"7\", \"20\", \"11\", \"16\", \"10\", \"5\", \"10\", \"13\", NA, \"10\", NA, \"11\", \"11\", \"11\", \"10\", \"10\", \"7\", \"10\", \"10\", \"10\"),\n  Note_Moyens = c(\"17\", \"12\", \"11\", \"15\", \"20\", \"8\", \"10\", \"6\", \"3\", \"20\", \"15\", \"6\", \"7\", \"11\", \"8\", NA, NA, \"11\", \"10\", \"10\", \"10\", \"10\", \"10\", \"8\", \"12\", \"12\", \"12\"),\n  Note_Accompagnement = c(\"4\", \"7\", \"1\", \"10\", \"15\", \"4\", \"16\", \"14\", \"4\", \"13\", \"12\", \"8\", \"11\", \"9\", \"19\", NA, NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"13\", \"18\", \"18\", \"18\"),\n  Note_Materiel = c(\"19\", \"14\", \"9\", \"8\", \"12\", \"9\", \"8\", \"13\", \"17\", \"15\", \"9\", \"12\", \"12\", \"8\", \"2\", NA, NA, NA, \"13\", \"13\", \"13\", \"10\", \"10\", \"16\", \"10\", \"10\", \"10\"),\n  poids_sondage = c(\"117.1\", \"98.3\", \"214.6\", \"84.7\", \"65.9\", \"148.2\", \"89.6\", \"100.3\", \"49.3\", \"148.2\", \"86.4\", \"99.2\", \"105.6\", \"123.1\", \"137.4\", \"187.6\", \"87.3\", \"87.3\",\n                    \"169.3\", \"169.3\", \"169.3\", \"169.3\", \"234.1\", \"189.3\", \"45.9\", \"45.9\", \"45.9\"),\n  CSPF = c(\"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\",\"Cadre\", \"Employé\", \"Employé\", \"Employé\", \"Profession intermédiaire\", \"Employé\", \"Retraité\", \"Retraité\", \"Employé\",\n           \"Employé\", \"Employé\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Profession intermédiaire\", \"Profession intermédiaire\", \"Cadre\", \"Ouvrier\", \"Ouvrier\",\n           \"Ouvrier\"),\n  Sexef = c(\"Femme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Femme\", \"Homme\", \"Femme\", \"Homme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\",\n            \"Homme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Homme\", \"Homme\")\n)\n\n# Mise en forme des données\n\n# R est sensible à la casse, il est pertinent d'harmoniser les noms des variables en minuscule\n# Renommer les colonnes de la base\ncolnames(donnees_rbase) &lt;- tolower(colnames(donnees_rbase))\n# Autre possibilité\nsetNames(donnees_rbase, tolower(names(donnees_rbase)))\n\n# On a importé toutes les variables en format caractère\n# On convertit certaines variables en format numérique\nenNumerique &lt;- c(\"duree\", \"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\ndonnees_rbase[, enNumerique] &lt;- lapply(donnees_rbase[, enNumerique], as.integer)\ndonnees_rbase$poids_sondage &lt;- as.numeric(donnees_rbase$poids_sondage)\n\n# On récupère les variables dont le nom débute par le mot \"date\"\nenDate &lt;- names(donnees_rbase)[grepl(\"date\", tolower(names(donnees_rbase)))]\n# On remplace / par - dans les dates\ndonnees_rbase[, enDate] &lt;- lapply(donnees_rbase[, enDate], function(x) gsub(\"/\", \"-\", x))\n# On exprime les dates en format Date\ndonnees_rbase[, enDate] &lt;- lapply(donnees_rbase[, enDate], lubridate::dmy)\n\n# Date de sortie du dispositif\ndonnees_rbase$date_sortie &lt;- donnees_rbase$date_entree + lubridate::days(donnees_rbase$duree)\n\n\n\n\n# Données fictives sur des formations\ndonnees_tidyverse &lt;- tibble(\n  Identifiant = c(\"173\", \"173\", \"173\", \"173\", \"174\", \"175\", \"198\", \"198\", \"198\", \"168\", \"211\", \"278\", \"347\", \"112\", \"112\", \"112\", \"087\", \"087\", \"099\", \"099\", \"099\", \"187\", \"187\", \"689\", \"765\", \"765\", \"765\"),\n  Sexe = c(\"2\", \"2\", \"2\", \"2\", \"1\", \"1\", \"2\", \"2\", \"2\", \"1\", \"2\", \"1\", \"2\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", \"1\", \"1\"),\n  CSP = c(\"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"3\", \"3\", \"3\", \"2\", \"3\", \"5\", \"5\", \"3\", \"3\", \"3\", \"4\", \"4\", \"4\", \"4\", \"4\", \"2\", \"2\", \"1\", \"4\", \"4\", \"4\"),\n  Niveau = c(\"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \n             \"Non qualifié\", \"Qualifié\", \"Non qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", NA, \"Non qualifié\", \"Non qualifié\", \"Non qualifié\"),\n  Date_naissance = c(\"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"08/12/1984\", \"16/09/1989\", \"17/03/1987\", \"17/03/1987\", \"17/03/1987\", \"30/07/2002\", NA, \"10/08/1948\", \n                     \"13/09/1955\", \"13/09/2001\", \"13/09/2001\", \"13/09/2001\", NA, NA, \"06/06/1998\", \"06/06/1998\", \"06/06/1998\", \"05/12/1986\", \"05/12/1986\", \"01/12/2000\", \"26/12/1995\", \"26/12/1995\", \"26/12/1995\"),\n  Date_entree = c(\"01/01/2021\", \"01/01/2022\", \"06/01/2022\", \"02/01/2023\", \"17/08/2021\", \"21/12/2022\", \"28/07/2022\", \"17/11/2022\", \"21/02/2023\", \"04/09/2019\", \"17/12/2021\", \"07/06/2018\", NA, \"02/03/2022\", \"01/03/2021\", \"01/12/2023\", NA, \n                  \"31/10/2020\", \"01/03/2021\", \"01/03/2022\", \"01/03/2023\", \"01/01/2022\", \"01/01/2023\", \"06/11/2017\", \"17/04/2020\", \"17/04/2020\", \"17/04/2020\"),\n  Duree = c(\"308\", \"365\", \"185\", \"365\", \"183\", \"730\", \"30\", \"164\", \"365\", \"365\", \"135\", \"365\", \"180\", \"212\", \"365\", \"365\", \"365\", \"365\", \"364\", \"364\", \"364\", \"364\", \"364\", \"123\", \"160\", \"160\", \"160\"),\n  Note_Contenu = c(\"12\", \"6\", \"8\", \"14\", \"17\", \"5\", \"10\", \"11\", \"9\", \"18\", \"16\", \"14\", \"12\", \"3\", \"7\", \"9\", NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"9\", \"13\", \"13\", \"13\"),\n  Note_Formateur = c(\"6\", NA, \"10\", \"15\", \"18\", \"5\", \"10\", \"7\", \"20\", \"11\", \"16\", \"10\", \"5\", \"10\", \"13\", NA, \"10\", NA, \"11\", \"11\", \"11\", \"10\", \"10\", \"7\", \"10\", \"10\", \"10\"),\n  Note_Moyens = c(\"17\", \"12\", \"11\", \"15\", \"20\", \"8\", \"10\", \"6\", \"3\", \"20\", \"15\", \"6\", \"7\", \"11\", \"8\", NA, NA, \"11\", \"10\", \"10\", \"10\", \"10\", \"10\", \"8\", \"12\", \"12\", \"12\"),\n  Note_Accompagnement = c(\"4\", \"7\", \"1\", \"10\", \"15\", \"4\", \"16\", \"14\", \"4\", \"13\", \"12\", \"8\", \"11\", \"9\", \"19\", NA, NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"13\", \"18\", \"18\", \"18\"),\n  Note_Materiel = c(\"19\", \"14\", \"9\", \"8\", \"12\", \"9\", \"8\", \"13\", \"17\", \"15\", \"9\", \"12\", \"12\", \"8\", \"2\", NA, NA, NA, \"13\", \"13\", \"13\", \"10\", \"10\", \"16\", \"10\", \"10\", \"10\"),\n  poids_sondage = c(\"117.1\", \"98.3\", \"214.6\", \"84.7\", \"65.9\", \"148.2\", \"89.6\", \"100.3\", \"49.3\", \"148.2\", \"86.4\", \"99.2\", \"105.6\", \"123.1\", \"137.4\", \"187.6\", \"87.3\", \"87.3\",\n                    \"169.3\", \"169.3\", \"169.3\", \"169.3\", \"234.1\", \"189.3\", \"45.9\", \"45.9\", \"45.9\"),\n  CSPF = c(\"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\",\"Cadre\", \"Employé\", \"Employé\", \"Employé\", \"Profession intermédiaire\", \"Employé\", \"Retraité\", \"Retraité\", \"Employé\",\n           \"Employé\", \"Employé\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Profession intermédiaire\", \"Profession intermédiaire\", \"Cadre\", \"Ouvrier\", \"Ouvrier\",\n           \"Ouvrier\"),\n  Sexef = c(\"Femme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Femme\", \"Homme\", \"Femme\", \"Homme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\",\n            \"Homme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Homme\", \"Homme\")\n  \n)\n\n# Mise en forme des données\n\n# R est sensible à la casse, il est pertinent d'harmoniser les noms des variables en minuscule\n# Renommer les colonnes de la base en minuscule\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% rename_with(tolower)\n# Autre solution\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  magrittr::set_colnames(value = casefold(colnames(.), upper = FALSE))\n\n# On a importé toutes les variables en format caractère\n# On convertit certaines variables en format numérique\nenNumerique &lt;- c(\"duree\", \"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\n# On convertit certaines variables au format date\n# On récupère d'abord les variables dont le nom débute par le mot \"date\"\nenDate &lt;- names(donnees_tidyverse)[grepl(\"date\", tolower(names(donnees_tidyverse)))]\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%  \n  mutate_at(enNumerique, as.integer) %&gt;% \n  mutate(poids_sondage = as.numeric(poids_sondage)) %&gt;% \n  mutate_at(enDate, lubridate::dmy)\n\n# Date de sortie du dispositif\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(date_sortie = date_entree + lubridate::days(duree))\n\n\n\n\n# Données fictives sur des formations\ndonnees_datatable &lt;- data.table(\n  Identifiant = c(\"173\", \"173\", \"173\", \"173\", \"174\", \"175\", \"198\", \"198\", \"198\", \"168\", \"211\", \"278\", \"347\", \"112\", \"112\", \"112\", \"087\", \"087\", \"099\", \"099\", \"099\", \"187\", \"187\", \"689\", \"765\", \"765\", \"765\"),\n  Sexe = c(\"2\", \"2\", \"2\", \"2\", \"1\", \"1\", \"2\", \"2\", \"2\", \"1\", \"2\", \"1\", \"2\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", \"1\", \"1\"),\n  CSP = c(\"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"3\", \"3\", \"3\", \"2\", \"3\", \"5\", \"5\", \"3\", \"3\", \"3\", \"4\", \"4\", \"4\", \"4\", \"4\", \"2\", \"2\", \"1\", \"4\", \"4\", \"4\"),\n  Niveau = c(\"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \n             \"Non qualifié\", \"Qualifié\", \"Non qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", NA, \"Non qualifié\", \"Non qualifié\", \"Non qualifié\"),\n  Date_naissance = c(\"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"08/12/1984\", \"16/09/1989\", \"17/03/1987\", \"17/03/1987\", \"17/03/1987\", \"30/07/2002\", NA, \"10/08/1948\", \n                     \"13/09/1955\", \"13/09/2001\", \"13/09/2001\", \"13/09/2001\", NA, NA, \"06/06/1998\", \"06/06/1998\", \"06/06/1998\", \"05/12/1986\", \"05/12/1986\", \"01/12/2000\", \"26/12/1995\", \"26/12/1995\", \"26/12/1995\"),\n  Date_entree = c(\"01/01/2021\", \"01/01/2022\", \"06/01/2022\", \"02/01/2023\", \"17/08/2021\", \"21/12/2022\", \"28/07/2022\", \"17/11/2022\", \"21/02/2023\", \"04/09/2019\", \"17/12/2021\", \"07/06/2018\", NA, \"02/03/2022\", \"01/03/2021\", \"01/12/2023\", NA, \n                  \"31/10/2020\", \"01/03/2021\", \"01/03/2022\", \"01/03/2023\", \"01/01/2022\", \"01/01/2023\", \"06/11/2017\", \"17/04/2020\", \"17/04/2020\", \"17/04/2020\"),\n  Duree = c(\"308\", \"365\", \"185\", \"365\", \"183\", \"730\", \"30\", \"164\", \"365\", \"365\", \"135\", \"365\", \"180\", \"212\", \"365\", \"365\", \"365\", \"365\", \"364\", \"364\", \"364\", \"364\", \"364\", \"123\", \"160\", \"160\", \"160\"),\n  Note_Contenu = c(\"12\", \"6\", \"8\", \"14\", \"17\", \"5\", \"10\", \"11\", \"9\", \"18\", \"16\", \"14\", \"12\", \"3\", \"7\", \"9\", NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"9\", \"13\", \"13\", \"13\"),\n  Note_Formateur = c(\"6\", NA, \"10\", \"15\", \"18\", \"5\", \"10\", \"7\", \"20\", \"11\", \"16\", \"10\", \"5\", \"10\", \"13\", NA, \"10\", NA, \"11\", \"11\", \"11\", \"10\", \"10\", \"7\", \"10\", \"10\", \"10\"),\n  Note_Moyens = c(\"17\", \"12\", \"11\", \"15\", \"20\", \"8\", \"10\", \"6\", \"3\", \"20\", \"15\", \"6\", \"7\", \"11\", \"8\", NA, NA, \"11\", \"10\", \"10\", \"10\", \"10\", \"10\", \"8\", \"12\", \"12\", \"12\"),\n  Note_Accompagnement = c(\"4\", \"7\", \"1\", \"10\", \"15\", \"4\", \"16\", \"14\", \"4\", \"13\", \"12\", \"8\", \"11\", \"9\", \"19\", NA, NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"13\", \"18\", \"18\", \"18\"),\n  Note_Materiel = c(\"19\", \"14\", \"9\", \"8\", \"12\", \"9\", \"8\", \"13\", \"17\", \"15\", \"9\", \"12\", \"12\", \"8\", \"2\", NA, NA, NA, \"13\", \"13\", \"13\", \"10\", \"10\", \"16\", \"10\", \"10\", \"10\"),\n  poids_sondage = c(\"117.1\", \"98.3\", \"214.6\", \"84.7\", \"65.9\", \"148.2\", \"89.6\", \"100.3\", \"49.3\", \"148.2\", \"86.4\", \"99.2\", \"105.6\", \"123.1\", \"137.4\", \"187.6\", \"87.3\", \"87.3\",\n                    \"169.3\", \"169.3\", \"169.3\", \"169.3\", \"234.1\", \"189.3\", \"45.9\", \"45.9\", \"45.9\"),\n  CSPF = c(\"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\",\"Cadre\", \"Employé\", \"Employé\", \"Employé\", \"Profession intermédiaire\", \"Employé\", \"Retraité\", \"Retraité\", \"Employé\",\n           \"Employé\", \"Employé\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Profession intermédiaire\", \"Profession intermédiaire\", \"Cadre\", \"Ouvrier\", \"Ouvrier\",\n           \"Ouvrier\"),\n  Sexef = c(\"Femme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Femme\", \"Homme\", \"Femme\", \"Homme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\",\n            \"Homme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Homme\", \"Homme\")\n)\n\n# Mise en forme des données\n\n# Extraire les noms des variables de la base\n# R est sensible à la casse, il est pertinent d'harmoniser les noms des variables en minuscule\nnomCol &lt;- tolower(colnames(donnees_datatable))\n# Renommer les colonnes de la base\ncolnames(donnees_datatable) &lt;- tolower(colnames(donnees_datatable))\n\n# On convertit certaines variables en format 'numeric'\nenNumerique &lt;- c(\"duree\", \"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\n# Ne pas oublier le . devant SDcols !!!!\ndonnees_datatable[, lapply(.SD, as.integer), .SDcols = enNumerique]\n# Autre solution\n# En data.table, les instructions débutant par set modifient les éléments par référence, c'est-à-dire sans copie.\n# Ceci est plus efficace pour manipuler des données volumineuses.\nfor (j in enNumerique) {\n  set(donnees_datatable, j = j, value = as.numeric(donnees_datatable[[j]]))\n}\ndonnees_datatable[, poids_sondage := as.numeric(poids_sondage)]\n\n# On récupère les variables dont le nom débute par le mot \"date\"\nvarDates &lt;- names(donnees_datatable)[grepl(\"date\", tolower(names(donnees_datatable)))]\n# On remplace / par - dans les dates\ndonnees_datatable[, (varDates) := lapply(.SD, function(x) gsub(\"/\", \"-\", x)), .SDcols = varDates]\n# On exprime les dates en format Date\ndonnees_datatable[, (varDates) := lapply(.SD, lubridate::dmy), .SDcols = varDates]\n\n# Date de sortie du dispositif\ndonnees_datatable[, date_sortie := date_entree + lubridate::days(duree)]\n\n\n\nDuckdb est un serveur SQL séparé de la session R. Les calculs sont effectués en dehors de R et l’espace mémoire est distinct de celui de R. Au lieu d’accéder directement aux données, il faut passer par un objet connection qui contient l’adresse du serveur, un peu comme lorsque l’on se connecte à un serveur web. Ici en particulier, il est nécessaire de transférer les données vers duckdb.\n\n# Ouvrir une connexion au serveur duckdb\ncon &lt;- DBI::dbConnect(duckdb::duckdb()); \n\n# On \"copie\" les données dans une table du nom table_duckdb\ncon %&gt;% duckdb::duckdb_register(name = \"table_duckdb\", df = donnees_tidyverse)\n\ncon %&gt;% tbl(\"table_duckdb\")\n\n# Fermer la connexion au serveur duckdb\nDBI::dbDisconnect(con, shutdown = TRUE)\n\nPour la suite, on suppose que la connexion est ouverte sous le nom con, et que les données sont accessibles par la requête requete_duckdb. Le code modifiera la requête, mais pas la table dans le serveur SQL.\n\ncon &lt;- DBI::dbConnect(duckdb::duckdb()); \ncon %&gt;% duckdb::duckdb_register(name = \"table_duckdb\", df = donnees_tidyverse)\nrequete_duckdb &lt;- con %&gt;% tbl(\"table_duckdb\")\n\nN.B. Duckdb est envisagé pour des traitements sans charger des données en mémoire, par exemple en lisant directement un fichier .parquet sur le disque dur. Dans ce cas, les opérations sont effectuées à la volée, mais n’affectent pas les fichiers source.",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#manipulation-du-format-de-la-base-de-données",
    "href": "01-aide_memoire_r_sas.html#manipulation-du-format-de-la-base-de-données",
    "title": "Aide-mémoire SAS - R",
    "section": "2.3 Manipulation du format de la base de données",
    "text": "2.3 Manipulation du format de la base de données\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Sans objet pour SAS */\n\n\n\n# On vérifie que la base importée est bien un data.frame\nis.data.frame(donnees_rbase)\n\n# Format de la base\nclass(donnees_rbase)\n\n\n\n\n# On vérifie que la base importée est bien un tibble\nis_tibble(donnees_tidyverse)\n\n# Transformation en tibble, le format de Tidyverse\ndonnees_tidyverse &lt;- tibble::as_tibble(donnees_tidyverse)\n\n# Format de la base\nclass(donnees_tidyverse)\n\n\n\n\n# On vérifie que la base est bien un data.table\nis.data.table(donnees_datatable)\n\n# Transformation en data.frame\nsetDF(donnees_datatable)\nis.data.frame(donnees_datatable)\n\n# Transformation en data.table\n# En data.table, les instructions débutant par set modifient les éléments par référence, c'est-à-dire sans copie.\n# Ceci est plus efficace pour manipuler des données volumineuses.\nsetDT(donnees_datatable)\nis.data.table(donnees_datatable)\n# Autre possibilité\ndonnees_datatable &lt;- as.data.table(donnees_datatable)\n\n# Est-ce une liste ?\nis.list(donnees_datatable)\n\n# Format de la base\nclass(donnees_datatable)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#chemin-du-bureau-de-lutilisateur",
    "href": "01-aide_memoire_r_sas.html#chemin-du-bureau-de-lutilisateur",
    "title": "Aide-mémoire SAS - R",
    "section": "3.1 Chemin du bureau de l’utilisateur",
    "text": "3.1 Chemin du bureau de l’utilisateur\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On vide la log */\ndm \"log; clear; \";\n/* On récupère déjà l'identifiant de l'utilisateur (systèmes Windows) */\n%let user = &sysuserid;\n/* Chemin proprement dit */\n%let bureau = C:\\Users\\&user.\\Desktop;\nlibname bur \"&bureau.\";\n\n\n\n# On récupère déjà l'identifiant de l'utilisateur\nuser &lt;- Sys.getenv(\"USERNAME\")\n# Chemin proprement dit\nchemin &lt;- file.path(\"C:/Users\", user, \"Desktop\")\n\n\n\n\n# On récupère déjà l'identifiant de l'utilisateur\nuser &lt;- Sys.getenv(\"USERNAME\")\n# Chemin proprement dit\nchemin &lt;- file.path(\"C:/Users\", user, \"Desktop\")\n\n\n\n\n# On récupère déjà l'identifiant de l'utilisateur\nuser &lt;- Sys.getenv(\"USERNAME\")\n# Chemin proprement dit\nchemin &lt;- file.path(\"C:/Users\", user, \"Desktop\")",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#affichage-de-lannée",
    "href": "01-aide_memoire_r_sas.html#affichage-de-lannée",
    "title": "Aide-mémoire SAS - R",
    "section": "3.2 Affichage de l’année",
    "text": "3.2 Affichage de l’année\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Année courante */\n%let an = %sysfunc(year(%sysfunc(today())));\n/* & (esperluette) indique à SAS qu'il doit remplacer an par sa valeur définie par le %let */\n%put Année : &an.;\n/* Autre possibilité */\ndata _null_;call symput('annee', strip(year(today())));run;\n%put Année (autre méthode) : &annee.;\n/* Année passée */\n%put Année passée : %eval(&an. - 1);\n\n\n\n# Année courante\nannee &lt;- lubridate::year(Sys.Date())\nsprintf(\"Année : %04d\", annee)\nprint(paste0(\"Année : \", annee))\n# Année passée\nannee_1 &lt;- annee - 1\npaste0(\"Année passée: \", annee_1)\n\n\n\n\n# Année courante\nannee &lt;- lubridate::year(Sys.Date())\nsprintf(\"Année : %04d\", annee)\nprint(paste0(\"Année : \", annee))\n# Année passée\nannee_1 &lt;- annee - 1\npaste0(\"Année passée: \", annee_1)\n\n\n\n\n# Année courante\nannee &lt;- lubridate::year(Sys.Date())\nsprintf(\"Année : %04d\", annee)\nprint(paste0(\"Année : \", annee))\n# Année passée\nannee_1 &lt;- annee - 1\npaste0(\"Année passée: \", annee_1)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#construction-des-instructions-if-else",
    "href": "01-aide_memoire_r_sas.html#construction-des-instructions-if-else",
    "title": "Aide-mémoire SAS - R",
    "section": "3.3 Construction des instructions if / else",
    "text": "3.3 Construction des instructions if / else\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%macro Annee(an);\n  %if &an. &gt;= 2024 %then %put Nous sommes en 2024 ou après !;\n  %else %put Nous sommes avant 2024 !;\n%mend Annee;\n%Annee(&an.);\n\n\n\n# Construction incorrecte ! Le else doit être sur la même ligne que le {\n#if (annee &gt;= 2024) {\n#  print(\"Nous sommes en 2024 ou après\")\n#}\n#else {\n#  print(\"Nous sommes avant 2024\")\n#}\n## Construction correcte ! Le else doit être sur la même ligne que le {\nif (annee &gt;= 2024) {\n  print(\"Nous sommes en 2024 ou après\")\n} else {\n  print(\"Nous sommes avant 2024 !\")\n}\n\n\n\n\n# Construction incorrecte ! Le else doit être sur la même ligne que le {\n#if (annee &gt;= 2024) {\n#  print(\"Nous sommes en 2024 ou après\")\n#}\n#else {\n#  print(\"Nous sommes avant 2024\")\n#}\n## Construction correcte ! Le else doit être sur la même ligne que le {\nif (annee &gt;= 2024) {\n  print(\"Nous sommes en 2024 ou après\")\n} else {\n  print(\"Nous sommes avant 2024 !\")\n}\n\n\n\n\n# Construction incorrecte ! Le else doit être sur la même ligne que le {\n#if (annee &gt;= 2024) {\n#  print(\"Nous sommes en 2024 ou après\")\n#}\n#else {\n#  print(\"Nous sommes avant 2024\")\n#}\n## Construction correcte ! Le else doit être sur la même ligne que le {\nif (annee &gt;= 2024) {\n  print(\"Nous sommes en 2024 ou après\")\n} else {\n  print(\"Nous sommes avant 2024 !\")\n}",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#répertoire-de-travail",
    "href": "01-aide_memoire_r_sas.html#répertoire-de-travail",
    "title": "Aide-mémoire SAS - R",
    "section": "3.4 Répertoire de travail",
    "text": "3.4 Répertoire de travail\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Afficher le répertoire de travail par défaut (la Work) */\n%let chemin_work = %sysfunc(pathname(work));\n%put &chemin_work.;\nproc sql;\n  select path from dictionary.libnames where libname = \"WORK\";\nquit;\n/* Définir le répertoire de travail, si besoin */\n/* libname \"nom du répertoire\";\n\n\n\n# Afficher le répertoire de travail\ngetwd()\n\n# Définir le répertoire de travail, si besoin\n#setwd(dir=\"nom du répertoire\")\n\n\n\n\n# Afficher le répertoire de travail\ngetwd()\n\n# Définir le répertoire de travail, si besoin\n#setwd(dir=\"nom du répertoire\")\n\n\n\n\n# Afficher le répertoire de travail\ngetwd()\n\n# Définir le répertoire de travail, si besoin\n#setwd(dir=\"nom du répertoire\")",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#autres-points-à-connaître",
    "href": "01-aide_memoire_r_sas.html#autres-points-à-connaître",
    "title": "Aide-mémoire SAS - R",
    "section": "3.5 Autres points à connaître",
    "text": "3.5 Autres points à connaître\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Mise en garde : certains codes SAS pourraient aussi avec profit être écrits en langage SAS IML (Interactive Matrix Language).\n   Cet aide-mémoire n'ayant pas vocation à être un dictionnaire SAS, cette méthode d'écriture n'est pas proposée ici. */\n\n\n\n# Le pipe peut aussi être utilisé avec R-Base et data.table\n# Le pipe permet d'enchaîner des opérations sur une même base\n1:10 |&gt; sum()\n\n# R-Base est réputé plus lent que ses concurrents, ce qui est souvent vrai.\n# Mais certaines fonctions en R-Base être très rapides (rowsum, rowSums, tapply, etc.)\n\n\n\n\n# tidyverse promeut l'utilisation du pipe (%&gt;%), qui permet d'enchaîner des opérations sur une même base modifiée successivement.\n# 2 types de pipes existent, le pipe de magrittr (%&gt;%) et le pipe de R-Base (|&gt;, à partir de la version 4.1)\n# Les fonctionnalités simples des deux opérateurs sont identiques, mais il existe des différences.\n# Dans cet aide-mémoire, le pipe de magrittr (%&gt;%) est privilégié.\n\n# Le tidyverse peut s'utiliser sans pipe, mais le pipe simplifie la gestion des programmes.\n# Les autres environnements (R-Base, data.table) peuvent aussi se présenter avec le pipe.\n\n\n\n\n# Principe de base de data.table\n#dt[i, j, by]\n# i : sélection de lignes (instructions )\n# j : sélection et manipulation de colonnes\n# by : groupements",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#avoir-une-vue-densemble-des-données",
    "href": "01-aide_memoire_r_sas.html#avoir-une-vue-densemble-des-données",
    "title": "Aide-mémoire SAS - R",
    "section": "4.1 Avoir une vue d’ensemble des données",
    "text": "4.1 Avoir une vue d’ensemble des données\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Statistiques globales sur les variables numériques */\nproc means data = donnees_sas n mean median min p10 p25 median p75 p90 max;var _numeric_;run;\n/* Statistiques globales sur les variables caractères */\nproc freq data = donnees_sas;tables _character_ / missing;run;\n\n\n\n# Informations sur les variables\nstr(donnees_rbase)\n# Statistiques descriptives des variables de la base\nsummary(donnees_rbase)\nlibrary(Hmisc)\nHmisc::describe(donnees_rbase)\n# Visualiser la base de données\nView(donnees_rbase)\n\n\n\n\n# Informations sur les variables\ndonnees_tidyverse %&gt;% str()\ndonnees_tidyverse %&gt;% glimpse()\n# Statistiques descriptives des variables de la base\ndonnees_tidyverse %&gt;% summary()\n# Visualiser la base de données\ndonnees_tidyverse %&gt;% View()\n\n\n\n\n# Informations sur les variables\nstr(donnees_datatable)\n# Statistiques descriptives des variables de la base\nsummary(donnees_datatable)\n# Visualiser la base de données\nView(donnees_datatable)\n\n\n\nOn accède aux données du serveur SQL DuckDB au travers de l’objet requete_duckdb, qui est une requête (avec l’adresse du serveur) et non pas un dataframe ou un tibble. Comme l’accès n’est pas direct, la plupart des fonctions du tidyverse fonctionnent, mais opèrent sur “l’adresse du serveur DuckDB” au lieu d’opérer sur les valeurs (nombres, chaînes de caractères). A part glimpse, la plupart des fonctions ne renvoient pas un résultat exploitable.\n\n# Informations sur les variables\n# requete_duckdb %&gt;% str() \nrequete_duckdb %&gt;% glimpse() # préférer glimpse()\n# requete_duckdb %&gt;% summary()\n# requete_duckdb %&gt;% View()",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#extraire-les-x-premières-lignes-de-la-base-10-par-défaut",
    "href": "01-aide_memoire_r_sas.html#extraire-les-x-premières-lignes-de-la-base-10-par-défaut",
    "title": "Aide-mémoire SAS - R",
    "section": "4.2 Extraire les x premières lignes de la base (10 par défaut)",
    "text": "4.2 Extraire les x premières lignes de la base (10 par défaut)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let x = 10;\nproc print data = donnees_sas (firstobs = 1 obs = &x.);run;\n/* Ou alors */\ndata Lignes&x.;set donnees_sas (firstobs = 1 obs = &x.);proc print;run;\n\n\n\nx &lt;- 10\ndonnees_rbase[1:x, ]\nhead(donnees_rbase, x)\n\n\n\n\nx &lt;- 10\ndonnees_tidyverse %&gt;% \n  slice(1:x)\n\n\n\n\ndonnees_datatable[, first(.SD, 10)]\ndonnees_datatable[, .SD[1:10]]\nfirst(donnees_datatable, 10)\nhead(donnees_datatable, 10)\n\n\n\nDuckDB affiche les dix premières lignes par défaut lorsque l’on évalue une requête, comme indiqué dans le code ci-dessous.\n\nrequete_duckdb\n# Ceci est équivalent au code suivant\n# requete_duckdb %&gt;% print(n=10)\n\nAttention, comme il n’y a pas d’ordre en SQL, il faut ordonner les lignes si on veut un résultat reproductible. C’est une opération qui peut être couteuse en temps CPU.\n\nrequete_duckdb %&gt;% arrange(duree) %&gt;% print()\n\nL’objet requete_duckdb est bien une requête (i.e. une liste à deux éléments) même si on peut en afficher le résultat avec la fonction print. Notamment, les informations restent dans la mémoire de DuckDB. Il faut demander explicitement le transfert du résultat vers la session R avec la fonction collect(). On obtient alors un objet de type data.frame ou au lieu de tbl_duckdb_connection.\n\nclass(requete_duckdb)\nresultat_tibble &lt;- requete_duckdb %&gt;% collect()\nclass(resultat_tibble)\n\nLa fonction collect() transfère l’ensemble des données. Pour obtenir uniquement 10 lignes, il faut utiliser l’une des fonctions slice_* (cf documentation). On conseille slice_min ou slice_max qui indiquent explicitement l’ordre utilisé.\n\nrequete_duckdb %&gt;% slice_max(duree, n=4, with_ties=FALSE) # with_ties = TRUE retourne les cas d'égalité, donc plus de 4 lignes\n\nEn DuckDB et/ou sur un serveur SQL, on déconseille les fonctions head (qui ne respecte pas toujours l’ordre indiqué par arrange) ou top_n (superseded). La fonction slice en fonctionne pas : elle ne peut pas respecter l’ordre.",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#extraire-les-x-dernières-lignes-de-la-base-10-par-défaut",
    "href": "01-aide_memoire_r_sas.html#extraire-les-x-dernières-lignes-de-la-base-10-par-défaut",
    "title": "Aide-mémoire SAS - R",
    "section": "4.3 Extraire les x dernières lignes de la base (10 par défaut)",
    "text": "4.3 Extraire les x dernières lignes de la base (10 par défaut)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let x = 10;\nproc sql noprint;select count(*) into :total_lignes from donnees_sas;quit;\n%let deb = %eval(&total_lignes. - &x. + 1);\ndata Lignes_&x.;set donnees_sas (firstobs = &deb. obs = &total_lignes.);run;\n\n\n\nx &lt;- 10\ntail(donnees_rbase, x)\n\nAlternativement\n\ndonnees_rbase[ ( nrow(donnees_rbase) - x ) : nrow(donnees_rbase), ]\n\nLes parenthèses sont importantes. Comparer les deux expressions ! Bon exemple du recycling\n\n( nrow(donnees_rbase) - x ) : nrow(donnees_rbase)\nnrow(donnees_rbase) - x : nrow(donnees_rbase)\n\n\n\n\ndonnees_tidyverse %&gt;% \n  slice( (n()-10) : n())\n\n\n\n\ndonnees_datatable[, last(.SD, 10)]\nlast(donnees_datatable, 10)\ntail(donnees_datatable, 10)\n\nAlternativement\n\n\nMêmes remarques que pour les premières lignes : il n’y a pas d’ordre a priori en SQL. On conseille slice_min ou slice_max qui indiquent explicitement l’ordre utilisé, et l’on déconseille slice et tail.\n\nrequete_duckdb %&gt;% slice_min(duree, n=5, with_ties=FALSE) # with_ties = TRUE retourne les cas d'égalité, donc plus de 5 lignes",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#nombre-de-lignes-et-de-colonnes-dans-la-base",
    "href": "01-aide_memoire_r_sas.html#nombre-de-lignes-et-de-colonnes-dans-la-base",
    "title": "Aide-mémoire SAS - R",
    "section": "4.4 Nombre de lignes et de colonnes dans la base",
    "text": "4.4 Nombre de lignes et de colonnes dans la base\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Nombre de lignes */\nproc sql;select count(*) as Nb_Lignes from donnees_sas;quit;\nproc sql;\n  select count(*) as Nb_Lignes, count(distinct identifiant) as Nb_Identifiants\n  from donnees_sas;\nquit;\n/* Liste des variables de la base dans la base Var */\nproc contents data = donnees_sas out = Var noprint;run;\n/* Nombre de colonnes */\nproc sql;select count(*) as Nb_Colonnes from Var;run;\n\n\n\n# Les syntaxes dim(donnees_rbase)[1] et dim(donnees_rbase)[2] sont plus rapides que nrow() et ncol()\nsprintf(\"Nombre de lignes : %d | Nombre de colonnes : %d\", dim(donnees_rbase)[1], dim(donnees_rbase)[2])\nsprintf(\"Nombre de lignes : %d | Nombre de colonnes : %d\", nrow(donnees_rbase), ncol(donnees_rbase))\n\n\n\n\nsprintf(\"Nombre de lignes : %d | Nombre de colonnes : %d\",\n        donnees_tidyverse %&gt;% nrow(),\n        donnees_tidyverse %&gt;% ncol())\n# Nombre de lignes\ndonnees_tidyverse %&gt;% nrow()\n# Nombre de colonnes\ndonnees_tidyverse %&gt;% ncol()\n\n\n\n\n# Les syntaxes dim(donnees_rbase)[1] et dim(donnees_rbase)[2] sont plus rapides que nrow() et ncol()\ndim(donnees_datatable) ; dim(donnees_datatable)[1] ; dim(donnees_datatable)[2]\ndim(donnees_datatable) ; nrow(donnees_datatable) ; ncol(donnees_datatable)\nsprintf(\"Nombre de lignes : %d | Nombre de colonnes : %d\", dim(donnees_datatable)[1], dim(donnees_datatable)[2])\n\n\n\nDuckdb/SQL ne connaît pas le nombre de lignes sans un calcul. Il faut faire count().\n\n#Nombre de lignes\nrequete_duckdb %&gt;% nrow() # retourne NA\nrequete_duckdb %&gt;% count() # correct\n\n#Nombre de colonnes\nrequete_duckdb %&gt;%  ncol()",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#liste-des-variables-de-la-base",
    "href": "01-aide_memoire_r_sas.html#liste-des-variables-de-la-base",
    "title": "Aide-mémoire SAS - R",
    "section": "4.5 Liste des variables de la base",
    "text": "4.5 Liste des variables de la base\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Par ordre d'apparition dans la base */\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql;select name into :nom_col separated by \" \" from Var order by varnum;run;\n\n/* On affiche les noms des variables */\n%put Liste des variables : &nom_col.;\n\n/* Par ordre alphabétique */\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql;select name into :nom_col separated by \" \" from Var;run;\n\n/* On affiche les noms des variables */\n%put Liste des variables : &nom_col.;\n\n\n\n# Liste des variables par ordre d'apparition dans la base\nnames(donnees_rbase)\ncolnames(donnees_rbase)\n# Liste des variables par ordre alphabétique\nls(donnees_rbase)\nsort(colnames(donnees_rbase))\n\n\n\n\n# Liste des variables par ordre d'apparition dans la base\ndonnees_tidyverse %&gt;% colnames()\n# Liste des variables par ordre alphabétique\ndonnees_tidyverse %&gt;% colnames() %&gt;% sort()\n\n\n\n\n# Liste des variables par ordre d'apparition dans la base\ncolnames(donnees_datatable)\n# Liste des variables par ordre alphabétique\nsort(colnames(donnees_datatable))\n\n\n\n\nrequete_duckdb %&gt;% colnames()",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#nombre-didentifiants-uniques-et-nombre-de-lignes-dans-la-base",
    "href": "01-aide_memoire_r_sas.html#nombre-didentifiants-uniques-et-nombre-de-lignes-dans-la-base",
    "title": "Aide-mémoire SAS - R",
    "section": "4.6 Nombre d’identifiants uniques et nombre de lignes dans la base",
    "text": "4.6 Nombre d’identifiants uniques et nombre de lignes dans la base\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc sql;\n  select count(*) as Nb_Lignes, count(distinct identifiant) as Nb_Identifiants_Uniques\n  from donnees_sas;\nquit;\n\n\n\nsprintf(\"La base de données contient %d lignes et %d identifiants uniques !\",\n        nrow(donnees_rbase),\n        length(unique(donnees_rbase$identifiant)))\n\n\n\n\nsprintf(\"La base de données contient %d lignes et %d identifiants uniques !\",\n        donnees_tidyverse %&gt;% nrow(),\n        donnees_tidyverse %&gt;% select(identifiant) %&gt;%\n          n_distinct()\n        )\n# Autre solution pour le nombre d'identifiants uniques\ndonnees_tidyverse %&gt;% select(identifiant) %&gt;% n_distinct()\ndonnees_tidyverse %&gt;% distinct(identifiant) %&gt;% nrow()\n\n\n\n\nsprintf(\"La base de données contient %d lignes et %d identifiants uniques !\",\n        nrow(donnees_datatable),\n        donnees_datatable[, uniqueN(identifiant)])\n# Identifiants uniques\ndonnees_datatable[, uniqueN(identifiant)]\n\n\n\n\nrequete_duckdb %&gt;% nrow()\nrequete_duckdb %&gt;% distinct(identifiant) %&gt;% count()\n\nNote : on a vu que nrow ne fonctionne pas en DuckDB.",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#quelle-est-la-position-de-la-variable-date_entree",
    "href": "01-aide_memoire_r_sas.html#quelle-est-la-position-de-la-variable-date_entree",
    "title": "Aide-mémoire SAS - R",
    "section": "4.7 Quelle est la position de la variable date_entree ?",
    "text": "4.7 Quelle est la position de la variable date_entree ?\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let var = date_entree;\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql;\n  select varnum as Position from Var where lowcase(NAME) = \"&var.\";\nrun;\n\n\n\nvariable &lt;- \"date_entree\"\npos &lt;- match(variable, names(donnees_rbase))\nsprintf(\"La variable %s se trouve en colonne n°%s !\", variable, pos)\n\n\n\n\nvariable &lt;- \"date_entree\"\npos &lt;- match(variable, donnees_tidyverse %&gt;% colnames())\nsprintf(\"La variable %s se trouve en colonne n°%s !\", variable, pos)\n\n\n\n\nvariable &lt;- \"date_entree\"\npos &lt;- match(variable, names(donnees_datatable))\nsprintf(\"La variable %s se trouve en colonne n°%s !\", variable, pos)\n\n\n\n\nvariable &lt;- \"date_entree\"\npos &lt;- match(variable, requete_duckdb %&gt;% colnames())\nsprintf(\"La variable %s se trouve en colonne n°%s !\", variable, pos)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#afficher-le-type-des-variables",
    "href": "01-aide_memoire_r_sas.html#afficher-le-type-des-variables",
    "title": "Aide-mémoire SAS - R",
    "section": "5.1 Afficher le type des variables",
    "text": "5.1 Afficher le type des variables\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc contents data = donnees_sas;run;\n\n/* On supprime la base Var temporaire */\nproc datasets lib = Work nolist;delete Var;run;\n\n\n\nsapply(donnees_rbase, class)\n\n\n\n\npurrr::map(donnees_tidyverse, class)\nclass(donnees_tidyverse)\n\n\n\n\ndonnees_datatable[, lapply(.SD, class)]\n\n\n\nOn ne peut pas appliquer directement la fonction class sur un objet de type connection. Cependant, DuckDB affiche le type des variables dans un print. On peut également appliquer la fonction class sur un extrait des données (après collect).\n\npurrr::map(requete_duckdb %&gt;% select(c(1,2)) %&gt;% head() %&gt;% collect(), class)\nclass(requete_duckdb)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#convertir-le-type-dune-seule-variable",
    "href": "01-aide_memoire_r_sas.html#convertir-le-type-dune-seule-variable",
    "title": "Aide-mémoire SAS - R",
    "section": "5.2 Convertir le type d’une seule variable",
    "text": "5.2 Convertir le type d’une seule variable\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata donnees_sas;\n  set donnees_sas;\n  /* Transformer la variable Sexe en caractère */\n  Sexe_car = put(Sexe, $1.);\n  /* Transformer la variable Sexe_car en numérique */\n  Sexe_num = input(Sexe_car, 1.);\n  /* Transformer une date d'un format caractère à un format Date */\n  format date $10.;\n  date = \"01/01/2000\";\n  format date_sas yymmdd10.;\n  date_sas = input(date, ddmmyy10.);\nrun;\n\n\n\n# Transformer la variable sexe en numérique\ndonnees_rbase$sexe_numerique &lt;- as.numeric(donnees_rbase$sexe)\n# Transformer la variable sexe_numerique en caractère\ndonnees_rbase$sexe_caractere &lt;- as.character(donnees_rbase$sexe_numerique)\n# Transformer une date d'un format caractère à un format Date\ndonnees_rbase$date_r &lt;- lubridate::dmy(\"01/01/2000\")\n\n\n\n\n# Transformer la variable sexe en numérique\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%  \n  mutate(sexe_numerique = as.numeric(sexe))\n\n# Transformer la variable sexe_numerique en caractère\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  mutate(sexe_caractere = as.character(sexe_numerique))\n\n# Transformer une date d'un format caractère à un format Date\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%  \n  mutate(date_r = lubridate::dmy(\"01/01/2000\"))\n\n\n\n\n# Transformer la variable sexe en numérique\ndonnees_datatable[, sexe_numerique := as.numeric(sexe)]\n# Transformer la variable sexe_numerique en caractère\ndonnees_datatable[, sexe_caractere := as.numeric(sexe_numerique)]\n# Transformer une date d'un format caractère à un format Date\ndonnees_datatable[, date_r := lubridate::dmy(\"01/01/2000\")]\n\n\n\n\nrequete_duckdb %&gt;%  \n  mutate(sexe_numerique = as.numeric(sexe)) %&gt;% # Transformer la variable sexe en numérique\n  mutate(sexe_caractere = as.character(sexe_numerique)) %&gt;% # Transformer la variable sexe_numerique en caractère\n  select(starts_with(\"sexe\")) %&gt;% print(n=5)\n\nEn DuckDB, plusieurs syntaxes sont possibles pour transformer une chaîne de caractères en date. Sauf lorsque la chaîne de caractères n’est pas au format YYYY-MM-DD. On conseille de passer par la fonction strptime de DuckDB pour indiquer le format de la date.\n\n# Transformer une date d'un format caractère à un format Date\nrequete_duckdb %&gt;%  \n  mutate(date_0 = as.Date(\"2000-01-01\")) %&gt;% \n  mutate(date_1 = as.Date(strptime(\"01/01/2000\",\"%d/%m/%Y\"))) %&gt;% \n  # mutate(date_r = lubridate::dmy(\"01/01/2000\")) %&gt;% # no known SQL translation\n  select(starts_with(\"date\")) %&gt;% print(n=5)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#convertir-le-type-de-plusieurs-variables",
    "href": "01-aide_memoire_r_sas.html#convertir-le-type-de-plusieurs-variables",
    "title": "Aide-mémoire SAS - R",
    "section": "5.3 Convertir le type de plusieurs variables",
    "text": "5.3 Convertir le type de plusieurs variables\n\narrow/duckdb\n\n\n\nenNumerique &lt;- c(\"duree\", \"note_contenu\", \"note_formateur\")\nenDate &lt;- c('date_naissance', 'date_entree')\n\nrequete_duckdb %&gt;%  \n  mutate_at(enNumerique, as.integer) %&gt;% \n  mutate_at(enDate, as.character) %&gt;% \n  mutate_at(enDate, ~ as.Date(strptime(.,'%Y-%m-%d'))) %&gt;% # strptime est une fonction duckdb\n  select(enNumerique, enDate) %&gt;% print(n=5)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#selection-de-colonnes-par-position",
    "href": "01-aide_memoire_r_sas.html#selection-de-colonnes-par-position",
    "title": "Aide-mémoire SAS - R",
    "section": "6.1 Selection de colonnes par position",
    "text": "6.1 Selection de colonnes par position\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let pos = 1;\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql noprint;\n  select name into :nom_col separated by \" \"\n  from Var\n  where varnum = &pos.;\nrun;\ndata Colonnes;set donnees_sas (keep = &nom_col.);run;\nproc datasets lib = Work nolist;delete Var;run;\n\n\n\npos &lt;- 1\n# Résultat sous forme de vecteur caractère\nid &lt;- donnees_rbase[[pos]] ; class(id)\nid &lt;- donnees_rbase[, pos] ; class(id)\n# Résultat sous forme de data.frame\nid &lt;- donnees_rbase[pos] ; class(id)\nid &lt;- donnees_rbase[, pos, drop = FALSE] ; class(id)\n\n\n\n\n# Sous forme de vecteur\nid &lt;- donnees_tidyverse %&gt;% pull(1)\nclass(id)\npos &lt;- 1\nid &lt;- donnees_tidyverse %&gt;% pull(all_of(pos))\nclass(id)\n# Sous forme de tibble\nid &lt;- donnees_tidyverse %&gt;% select(1)\nclass(id)\npos &lt;- 1\nid &lt;- donnees_tidyverse %&gt;% select(all_of(pos))\nclass(id)\n\n\n\n\npos &lt;- 1\n# Résultat sous forme de vecteur caractère\nid &lt;- donnees_datatable[[pos]] ; class(id)\n# Résultat sous forme de data.table\nid &lt;- donnees_datatable[pos] ; class(id)\n\n\n\nEn DuckDB, il y a une vraie différence entre select et pull. Dans le premier cas, les calculs restent du côté DuckDB, et c’est donc le moteur SQL qui continue à exécuter les calculs. Avec pull, le résultat est un tibble et les données sont transférées à la session R.\n\nrequete_duckdb %&gt;% select(3)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#selection-de-colonnes-par-nom",
    "href": "01-aide_memoire_r_sas.html#selection-de-colonnes-par-nom",
    "title": "Aide-mémoire SAS - R",
    "section": "6.2 Selection de colonnes par nom",
    "text": "6.2 Selection de colonnes par nom\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata Colonnes;set donnees_sas (keep = identifiant);run;\ndata Colonnes;set donnees_sas;keep identifiant;run;\n\n\n\n# Résultat sous forme de vecteur caractère\nid &lt;- donnees_rbase$identifiant ; class(id)\nid &lt;- donnees_rbase[[\"identifiant\"]] ; class(id)\nid &lt;- donnees_rbase[, \"identifiant\"] ; class(id)\n# Résultat sous forme de data.frame\nclass(donnees_rbase[, \"identifiant\"])\n# Attention, utilisation du drop = FALSE étrange\n# En fait, l'affectation par [] a pour option par défaut drop = TRUE. Ce qui implique que si l'affectation renvoie\n# un data.frame d'1 seule colonne, l'objet sera transformé en objet plus simple (vecteur en l'occurrence)\nclass(donnees_rbase[, \"identifiant\", drop = FALSE])\nid &lt;- donnees_rbase[\"identifiant\"] ; class(id)\nid &lt;- donnees_rbase[, \"identifiant\", drop = FALSE] ; class(id)\n\n\n\n\n# Sous forme de vecteur\nid &lt;- donnees_tidyverse %&gt;% pull(identifiant)\nid &lt;- donnees_tidyverse %&gt;% pull(\"identifiant\")\n# Sous forme de tibble\nid &lt;- donnees_tidyverse %&gt;% select(identifiant)\nid &lt;- donnees_tidyverse %&gt;% select(\"identifiant\")\n\n\n\n\n# Résultat sous forme de vecteur caractère\nid &lt;- donnees_datatable$identifiant ; class(id)\nid &lt;- donnees_datatable[[\"identifiant\"]] ; class(id)\nid &lt;- donnees_datatable[, identifiant] ; class(id)\n# Résultat sous forme de data.table\nid &lt;- donnees_datatable[, \"identifiant\"] ; class(id)\nid &lt;- donnees_datatable[, .(\"identifiant\")] ; class(id)\nid &lt;- donnees_datatable[, list(\"identifiant\")] ; class(id)\n\n\n\n\nrequete_duckdb %&gt;% select(identifiant)\nrequete_duckdb %&gt;% select(\"identifiant\")\nrequete_duckdb %&gt;% select(any_of(\"identifiant\"))\n\nNote : on déconseille l’utilisation de select sur des chaînes de caractère : certaines fonction du tidyvers nécessient de passer par les opérateurs any_of ou all_of pour ce genre d’opérations (distinct par exemple).",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#selection-de-colonnes-par-un-vecteur-contenant-des-chaînes-de-caractères",
    "href": "01-aide_memoire_r_sas.html#selection-de-colonnes-par-un-vecteur-contenant-des-chaînes-de-caractères",
    "title": "Aide-mémoire SAS - R",
    "section": "6.3 Selection de colonnes par un vecteur contenant des chaînes de caractères",
    "text": "6.3 Selection de colonnes par un vecteur contenant des chaînes de caractères\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let var = identifiant Sexe note_contenu;\ndata Colonnes;\n  /* Sélection de colonnes */\n  set donnees_sas (keep = &var.);\n  /* Selection de colonnes */\n  keep &var.;\nrun;\n\n\n\nvariable &lt;- \"identifiant\"\n# Résultat sous forme de vecteur caractère\nid &lt;- donnees_rbase[, variable] ; class(id)\nid &lt;- donnees_rbase[[variable]] ; class(id)\n# Résultat sous forme de data.frame\nid &lt;- donnees_rbase[variable] ; class(id)\nid &lt;- donnees_rbase[, variable, drop = FALSE] ; class(id)\n\n\n\n\nvariable &lt;- \"identifiant\"\n# Sous forme de vecteur\nid &lt;- donnees_tidyverse %&gt;% pull(all_of(variable))\n# Sous forme de tibble\nid &lt;- donnees_tidyverse %&gt;% select(all_of(variable))\n\n\n\n\n# Résultat sous forme de vecteur caractère\nvariable &lt;- \"identifiant\"\nid &lt;- donnees_datatable[[variable]] ; class(id)\n# Résultat sous forme de data.table\nid &lt;- donnees_datatable[, .(variable)] ; class(id)\nid &lt;- donnees_datatable[, list(variable)] ; class(id)\n\n\n\n\nvariable &lt;- c(\"identifiant\",\"duree\")\nrequete_duckdb %&gt;% select(any_of(variable))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sauf-certaines-variables",
    "href": "01-aide_memoire_r_sas.html#sauf-certaines-variables",
    "title": "Aide-mémoire SAS - R",
    "section": "6.4 Sauf certaines variables",
    "text": "6.4 Sauf certaines variables\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let var = identifiant Sexe note_contenu;\ndata Colonnes;set donnees_sas (drop = &var.);run;\n\n\n\nvariable &lt;- c(\"identifiant\", \"sexe\", \"note_contenu\")\n# Ne fonctionne pas !\n#exclusion_var &lt;- donnees_rbase[, -c(variable)]\nexclusion_var &lt;- donnees_rbase[, setdiff(names(donnees_rbase), variable)]\n\n\n\n\nvariable &lt;- c(\"identifiant\", \"sexe\", \"note_contenu\")\nexclusion_var &lt;- donnees_tidyverse %&gt;% select(!all_of(variable))\nexclusion_var &lt;- donnees_tidyverse %&gt;% select(-all_of(variable))\n\n\n\n\nvariable &lt;- c(\"identifiant\", \"sexe\", \"note_contenu\")\nexclusion_var &lt;- donnees_datatable[, !..variable]\n\n\n\nLes opérateurs - et ! fonctionnent.\n\nrequete_duckdb %&gt;% select(!identifiant)\nrequete_duckdb %&gt;% select(-all_of(variable))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-la-3e-colonne",
    "href": "01-aide_memoire_r_sas.html#sélectionner-la-3e-colonne",
    "title": "Aide-mémoire SAS - R",
    "section": "6.5 Sélectionner la 3e colonne",
    "text": "6.5 Sélectionner la 3e colonne\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql noprint;\n  select name into :nom_col separated by \" \"\n  from Var\n  where varnum = 3;\nrun;\ndata Col3;set donnees_sas (keep = &nom_col.);run;\n\n\n\ncol3 &lt;- donnees_rbase[, 3]\ncol3 &lt;- donnees_rbase[3]\n\n\n\n\ncol3 &lt;- donnees_tidyverse %&gt;% pull(3)\ncol3 &lt;- donnees_tidyverse %&gt;% select(3)\n\n\n\n\ncol3 &lt;- donnees_datatable[, 3]\n\n\n\n\nrequete_duckdb %&gt;% select(3)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-plusieurs-colonnes",
    "href": "01-aide_memoire_r_sas.html#sélectionner-plusieurs-colonnes",
    "title": "Aide-mémoire SAS - R",
    "section": "6.6 Sélectionner plusieurs colonnes",
    "text": "6.6 Sélectionner plusieurs colonnes\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let var = identifiant note_contenu sexe;\ndata Colonnes;set donnees_sas (keep = &var.);run;\nproc sql;\n  create table Colonnes as\n  select %sysfunc(tranwrd(&var., %str( ), %str(, )))\n  from donnees_sas;\nquit;\n\n\n\ncols &lt;- c(\"identifiant\", \"note_contenu\", \"sexe\")\ncolonnes &lt;- donnees_rbase[, cols]\n\n\n\n\ncols &lt;- c(\"identifiant\", \"note_contenu\", \"sexe\")\n# Plusieurs possibilités\ncolonnes &lt;- donnees_tidyverse %&gt;% select(all_of(cols))\ncolonnes &lt;- donnees_tidyverse %&gt;% select(any_of(cols))\ncolonnes &lt;- donnees_tidyverse %&gt;% select({{cols}})\ncolonnes &lt;- donnees_tidyverse %&gt;% select(!!cols)\n\n\n\n\ncols &lt;- c(\"identifiant\", \"note_contenu\", \"sexe\")\n# Plusieurs écritures possibles\n# Peut-être l'écriture la plus simple, à privilégier\ncolonnes &lt;- donnees_datatable[, mget(cols)]\n# Ecriture cohérente avec la logique data.table\ncolonnes &lt;- donnees_datatable[, .SD, .SDcols = cols]\n# Ecriture un peu contre-intuitve. Attention ! L'écriture est bien ..cols, et non ..(cols) !!\n# Les syntaxes donnees_datatable[, ..(cols)] et donnees_datatable[, .(cols)] ne fonctionnent pas\ncolonnes &lt;- donnees_datatable[, ..cols]\n# Ecriture avec with = FALSE : désactive la possibilité de se référer à des colonnes sans les guillemets\n# Avec with = FALSE : désactive la possibilité de se référer à des colonnes sans les guillemets\ncolonnes &lt;- donnees_datatable[, cols, with = FALSE]\n\n\n\n\ncols &lt;- c(\"identifiant\", \"note_contenu\", \"sexe\")\n# Plusieurs possibilités\nrequete_duckdb %&gt;% select(all_of(cols))\nrequete_duckdb %&gt;% select(any_of(cols))\nrequete_duckdb %&gt;% select({{cols}})\nrequete_duckdb %&gt;% select(!!cols)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-les-colonnes-qui-débutent-par-le-mot-note",
    "href": "01-aide_memoire_r_sas.html#sélectionner-les-colonnes-qui-débutent-par-le-mot-note",
    "title": "Aide-mémoire SAS - R",
    "section": "6.7 Sélectionner les colonnes qui débutent par le mot Note",
    "text": "6.7 Sélectionner les colonnes qui débutent par le mot Note\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* 1ère solution */\ndata Selection_Variables;set donnees_sas (keep = Note:);run;\n/* 2e solution */\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql;\n  select name into :var_notes separated by \" \"\n  from Var where substr(upcase(name), 1, 4) = \"NOTE\" order by varnum;\nrun;\nproc datasets lib = Work nolist;delete Var;run;\ndata donnees_sas_Notes;set donnees_sas (keep = &var_notes.);run;\n\n\n\nvarNotes &lt;- donnees_rbase[grepl(\"^note\", names(donnees_rbase))]\nvarNotes &lt;- donnees_rbase[substr(tolower(names(donnees_rbase)), 1, 4) == \"note\"]\n\n\n\n\nvarNotes &lt;- donnees_tidyverse %&gt;% select(starts_with(\"note\"))\n\n\n\n\n# 1ère méthode\ncols &lt;- names(donnees_datatable)[substr(names(donnees_datatable), 1, 4) == \"note\"]\nsel &lt;- donnees_datatable[, .SD, .SDcols = cols]\n# 2e méthode\nsel &lt;- donnees_datatable[, .SD, .SDcols = patterns(\"^note\")]\n\n\n\n\nrequete_duckdb %&gt;% select(starts_with(\"note\"))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-les-colonnes-qui-ne-débutent-pas-par-le-mot-note",
    "href": "01-aide_memoire_r_sas.html#sélectionner-les-colonnes-qui-ne-débutent-pas-par-le-mot-note",
    "title": "Aide-mémoire SAS - R",
    "section": "6.8 Sélectionner les colonnes qui ne débutent pas par le mot Note",
    "text": "6.8 Sélectionner les colonnes qui ne débutent pas par le mot Note\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata Selection_Variables;set donnees_sas (drop = Note:);run;\n\n\n\nvarNotes &lt;- donnees_rbase[! grepl(\"^note\", names(donnees_rbase))]\nvarNotes &lt;- donnees_rbase[substr(tolower(names(donnees_rbase)), 1, 4) != \"note\"]\n\n\n\n\nvarNotes &lt;- donnees_tidyverse %&gt;% select(-starts_with(\"note\"))\nvarNotes &lt;- donnees_tidyverse %&gt;% select(!starts_with(\"note\"))\n\n\n\n\ncols &lt;- names(donnees_datatable)[substr(names(donnees_datatable), 1, 4) == \"note\"]\nsel &lt;- donnees_datatable[, .SD, .SDcols = -cols]\nsel &lt;- donnees_datatable[, .SD, .SDcols = -patterns(\"^note\")]\n\n\n\n\nrequete_duckdb %&gt;% select(-starts_with(\"note\"))\nrequete_duckdb %&gt;% select(!starts_with(\"note\"))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-lensemble-des-variables-numériques-de-la-base",
    "href": "01-aide_memoire_r_sas.html#sélectionner-lensemble-des-variables-numériques-de-la-base",
    "title": "Aide-mémoire SAS - R",
    "section": "6.9 Sélectionner l’ensemble des variables numériques de la base",
    "text": "6.9 Sélectionner l’ensemble des variables numériques de la base\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata Colonnes;set donnees_sas (keep = _numeric_);run;\n\n\n\nvarNumeriques &lt;- donnees_rbase[, sapply(donnees_rbase, is.numeric), drop = FALSE]\n\n\n\n\nvarNumeriques &lt;- donnees_tidyverse %&gt;% select_if(is.numeric)\nvarNumeriques &lt;- donnees_tidyverse %&gt;% select(where(is.numeric))\n\n\n\n\nsel &lt;- donnees_datatable[, .SD, .SDcols = is.numeric]\n\n\n\n\nrequete_duckdb %&gt;% select_if(is.numeric)\n# requete_duckdb %&gt;% select(where(is.numeric))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-lensemble-des-variables-de-format-date",
    "href": "01-aide_memoire_r_sas.html#sélectionner-lensemble-des-variables-de-format-date",
    "title": "Aide-mémoire SAS - R",
    "section": "6.10 Sélectionner l’ensemble des variables de format “Date”",
    "text": "6.10 Sélectionner l’ensemble des variables de format “Date”\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql noprint;\n  select name into :nom_col separated by \" \"\n  from Var where format not in (\"$\", \"\");\nrun;\ndata Colonnes;set donnees_sas (keep = &nom_col.);run;\nproc datasets lib = Work nolist;delete Var;run;\n\n\n\nvarDates &lt;- donnees_rbase[, sapply(donnees_rbase, is.Date), drop = FALSE]\nvarDates &lt;- Filter(is.Date, donnees_rbase)\n\n\n\n\nvarDates &lt;- donnees_tidyverse %&gt;% select_if(is.Date)\nvarDates &lt;- donnees_tidyverse %&gt;% select(where(is.Date))\n\n\n\n\nvar_dates &lt;- donnees_datatable[, .SD, .SDcols = is.Date]\n\n\n\n\nrequete_duckdb %&gt;% select_if(is.Date)\n# requete_duckdb %&gt;% select(where(is.Date))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-des-lignes",
    "href": "01-aide_memoire_r_sas.html#sélectionner-des-lignes",
    "title": "Aide-mémoire SAS - R",
    "section": "6.11 Sélectionner des lignes",
    "text": "6.11 Sélectionner des lignes\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* 3e ligne */\ndata Ligne3;set donnees_sas (firstobs = 3 obs = 3);run;\n\n/* Sélection des 3 premières lignes et des 3 premières colonnes de la base */\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql noprint;\n  select name into :nom_col separated by \" \" from Var\n  where 1 &lt;= varnum &lt;= 3;\nrun;\ndata Top3;\n  set donnees_sas (firstobs = 1 obs = 3 keep = &nom_col.);\nrun;\nproc datasets lib = Work nolist;delete Var;run;\n\n/* Sélection de lignes */\n/* Entrées en 2023 */\ndata En2023;\n  set donnees_sas (where = (year(date_entree) = 2023));\nrun;\ndata Avant2023_femme;\n  set donnees_sas (where = (year(date_entree) &lt; 2023 and sexe = 2));\nrun;\n\n\n\n# Sélection des 3 premières lignes et des 3 premières colonnes de la base\ntop3 &lt;- donnees_rbase[1:3, 1:3]\n\n# 3e ligne\nligne3 &lt;- donnees_rbase[3, ]\n\n# Sélection de lignes\n# Entrées en 2023\n# ATTENTION, solution qui ne fonctionne pas toujours bien ! En effet, les valeurs manquantes sont sélectionnées !\nen2023 &lt;- donnees_rbase[lubridate::year(donnees_rbase$date_entree) == 2023, ]\n# Bonnes écritures, qui excluent les valeurs manquantes\nen2023 &lt;- donnees_rbase[lubridate::year(donnees_rbase$date_entree) %in% c(2023), ]\nen2023 &lt;- donnees_rbase[which(lubridate::year(donnees_rbase$date_entree) == 2023), ]\nen2023 &lt;- subset(donnees_rbase, lubridate::year(donnees_rbase$date_entree) == 2023)\n\n\n\n\n# Sélection des 3 premières lignes et des 3 premières colonnes de la base\ntop3 &lt;- donnees_tidyverse %&gt;% slice(1:3) %&gt;% select(1:3)\n\n# 3e ligne\nligne3 &lt;- donnees_tidyverse %&gt;% slice(3)\n\n# Sélection de lignes\n# Entrées en 2023\nen2023 &lt;- donnees_tidyverse %&gt;% filter(lubridate::year(date_entree) == 2023)\n\n\n\n\ntop3 &lt;- donnees_datatable[1:3, 1:3]\n\n# 3e ligne\nligne3 &lt;- donnees_datatable[3, ]\nligne3 &lt;- donnees_datatable[3]\n\n# Sélection de lignes\n# Entrées en 2023\n# Pas de problème avec les valeurs manquantes comme pour la syntaxe en R-Base\nen2023 &lt;- donnees_datatable[lubridate::year(date_entree) == 2023, ]\nen2023 &lt;- donnees_datatable[lubridate::year(date_entree) == 2023]\n\n\n\nDuckDB, moteur SQL, ne respecte pas l’ordre des lignes. Il faut passer par un filtre ou choisir explicitement un ordre.\n\nrequete_duckdb %&gt;% filter(lubridate::year(date_entree) == 2023)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélection-sur-de-multiples-conditions",
    "href": "01-aide_memoire_r_sas.html#sélection-sur-de-multiples-conditions",
    "title": "Aide-mémoire SAS - R",
    "section": "6.12 Sélection sur de multiples conditions",
    "text": "6.12 Sélection sur de multiples conditions\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Ecriture incorrecte. Les valeurs manquantes sont considérées comme des nombres négatifs faibles, et inférieurs à 2023. */\n/* Ils sont sélectionnés dans le code suivant : */\ndata Avant2023_Femme;\n  set donnees_sas (where = (year(date_entree) &lt; 2023 and sexe = 2));\nrun;\n/* Ecriture correcte */\ndata Avant2023_Femme;\n  set donnees_sas (where = (year(date_entree) &lt; 2023 and not missing(date_entree) and sexe = 2));\nrun;\n\n\n\navant2023_femme &lt;- subset(donnees_rbase, lubridate::year(date_entree) &lt; 2023 & sexe == \"2\")\n\n\n\n\navant2023_femme &lt;- donnees_tidyverse %&gt;% \n  filter(lubridate::year(date_entree) &lt; 2023 & sexe == \"2\")\n\n\n\n\navant2023_femme &lt;- donnees_datatable[lubridate::year(date_entree) &lt; 2023 & sexe == \"2\"]\n\n\n\n\nrequete_duckdb %&gt;% \n  filter(lubridate::year(date_entree) &lt; 2023 & sexe == \"2\")",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélection-de-ligne-par-référence-lignes-de-lidentifiant-087",
    "href": "01-aide_memoire_r_sas.html#sélection-de-ligne-par-référence-lignes-de-lidentifiant-087",
    "title": "Aide-mémoire SAS - R",
    "section": "6.13 Sélection de ligne par référence : lignes de l’identifiant 087",
    "text": "6.13 Sélection de ligne par référence : lignes de l’identifiant 087\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let var = identifiant;\n%let sel = 087;\ndata Selection;\n  set donnees_sas;\n  if &var. in (\"&sel.\");\nrun;\n\n\n\nvariable &lt;- \"identifiant\"\nsel &lt;- \"087\"\ndonnees_rbase[donnees_rbase[, variable] %in% sel, ]\n\n\n\n\ndonnees_tidyverse %&gt;% filter(identifiant %in% c(\"087\")) %&gt;% select(identifiant)\ndonnees_tidyverse %&gt;% filter(identifiant == \"087\") %&gt;% select(identifiant)\n# Essayons désormais par variables\nvariable &lt;- \"identifiant\"\nsel &lt;- \"087\"\n# À FAIRE : peut-on faire plus simplement ?\ndonnees_tidyverse %&gt;% filter(get(variable) %in% sel) %&gt;% select(all_of(variable))\n\n\n\n\nvariable &lt;- \"identifiant\"\nsel &lt;- \"087\"\ndonnees_datatable[donnees_datatable[[variable]] %chin% sel, ]\ndonnees_datatable[donnees_datatable[[variable]] %chin% sel, ]\n\n\n\n\nrequete_duckdb %&gt;% filter(identifiant %in% c(\"087\")) %&gt;% select(identifiant)\nrequete_duckdb %&gt;% filter(identifiant == \"087\") %&gt;% select(identifiant)\n# Essayons désormais par variables\nvariable &lt;- \"identifiant\"\nsel &lt;- \"087\"\n# À FAIRE : peut-on faire plus simplement ?\nrequete_duckdb %&gt;% filter(.data[[variable]] %in% sel) %&gt;% select(all_of(variable))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélection-de-lignes-et-de-variables",
    "href": "01-aide_memoire_r_sas.html#sélection-de-lignes-et-de-variables",
    "title": "Aide-mémoire SAS - R",
    "section": "6.14 Sélection de lignes et de variables",
    "text": "6.14 Sélection de lignes et de variables\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let cols = identifiant note_contenu sexe;\ndata Femmes;\n  set donnees_sas (where = (Sexe = 2) keep = &cols.);\nrun;\ndata Femmes;\n  set donnees_sas;\n  if Sexe = 2;\n  keep &cols.;\nrun;\n\n/* Par nom ou par variable */\n%let var = identifiant Sexe note_contenu;\ndata Femmes;\n  /* Sélection de colonnes */\n  set donnees_sas (keep = &var.);\n  /* Sélection de lignes respectant une certaine condition */\n  if Sexe = \"2\";\n  /* Création de colonne */\n  note2 = note_contenu / 20 * 5;\n  /* Suppression de colonnes */\n  drop Sexe;\n  /* Selection de colonnes */\n  keep identifiant Sexe note_contenu;\nrun;\n\n\n\ncols &lt;- c(\"identifiant\", \"note_contenu\", \"sexe\", \"date_naissance\")\nfemmes &lt;- donnees_rbase[donnees_rbase$sexe %in% c(\"2\"), cols]\n\n\n\n\ncols &lt;- c(\"identifiant\", \"note_contenu\", \"sexe\", \"date_naissance\")\nfemmes &lt;- donnees_tidyverse %&gt;% filter(sexe == \"2\") %&gt;% select(all_of(cols))\nfemmes &lt;- donnees_tidyverse %&gt;% filter(sexe == \"2\") %&gt;% select({{cols}})\n\n\n\n\ncols &lt;- c(\"identifiant\", \"note_contenu\", \"sexe\", \"date_naissance\")\nfemmes &lt;- donnees_datatable[sexe == \"2\", ..cols]\n\n\n\n\ncols &lt;- c(\"identifiant\", \"note_contenu\", \"sexe\", \"date_naissance\")\nrequete_duckdb %&gt;% filter(sexe == \"2\") %&gt;% select(all_of(cols))\nrequete_duckdb %&gt;% filter(sexe == \"2\") %&gt;% select({{cols}})",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#renommer-des-variables",
    "href": "01-aide_memoire_r_sas.html#renommer-des-variables",
    "title": "Aide-mémoire SAS - R",
    "section": "7.1 Renommer des variables",
    "text": "7.1 Renommer des variables\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata donnees_sas;\n  set donnees_sas (rename = (sexe = sexe2));\n  rename sexe2 = sexe;\nrun;\n\n\n\n# On renomme la variable sexe en sexe_red\nnames(donnees_rbase)[names(donnees_rbase) == \"sexe\"] &lt;- \"sexe_red\"\n# On la renomme en sexe\nnames(donnees_rbase)[names(donnees_rbase) == \"sexe_red\"] &lt;- \"sexe\"\n\n\n\n\n# On renomme la variable sexe en sexe_red\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  rename(sexe_red = sexe)\n# On la renomme en sexe\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  rename(sexe = sexe_red)\n\n\n\n\n# On renomme la variable sexe en sexe_red\nnames(donnees_datatable)[names(donnees_datatable) == \"sexe\"] &lt;- \"sexe_red\"\n# On la renomme en sexe\nnames(donnees_datatable)[names(donnees_datatable) == \"sexe_red\"] &lt;- \"sexe\"\n# Autre solution\n# En data.table, les instructions débutant par set modifient les éléments par référence, c'est-à-dire sans copie.\n# Ceci est plus efficace pour manipuler des données volumineuses.\nsetnames(donnees_datatable, \"sexe\", \"sexe_red\")\nsetnames(donnees_datatable, \"sexe_red\", \"sexe\")\n\n\n\n\n# On renomme la variable sexe en sexe_red\nrequete_duckdb %&gt;% rename(sexe_red = sexe)\n# On la renomme en sexe\nrequete_duckdb %&gt;% rename(sexe = sexe_red)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#formater-les-modalités-des-valeurs",
    "href": "01-aide_memoire_r_sas.html#formater-les-modalités-des-valeurs",
    "title": "Aide-mémoire SAS - R",
    "section": "7.2 Formater les modalités des valeurs",
    "text": "7.2 Formater les modalités des valeurs\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Utilisation des formats */\nproc format;\n  /* Variable discrète */\n  value sexef\n  1 = \"Homme\"\n  2 = \"Femme\";\n\n  /* Variable continue */\n  value agef\n  low-&lt;26 = \"1. De 15 à 25 ans\"\n  26&lt;-&lt;50 = \"2. De 26 à 49 ans\"\n  50-high = \"3. 50 ans ou plus\";\n\n  /* Variable caractère */\n  value $ cspf\n  '1' = \"Cadre\"\n  '2' = \"Profession intermédiaire\"\n  '3' = \"Employé\"\n  '4' = \"Ouvrier\"\n  '5' = \"Retraité\";\nrun;\n\n\n\nsexef &lt;- c(\"1\" = \"Homme\", \"2\" = \"Femme\")\ncspf &lt;- c(\"1\" = \"Cadre\", \"2\" = \"Profession intermédiaire\", \"3\" = \"Employé\", \"4\" = \"Ouvrier\", \"5\" = \"Retraité\")\n\n\n\n\nsexef_format &lt;- c(\"1\" = \"Homme\", \"2\" = \"Femme\")\ncspf_format &lt;- c(\"1\" = \"Cadre\", \"2\" = \"Profession intermédiaire\", \"3\" = \"Employé\", \"4\" = \"Ouvrier\", \"5\" = \"Retraité\")\n\n\n\n\nsexeform &lt;- c(\"1\" = \"Homme\", \"2\" = \"Femme\")\ncspform &lt;- c(\"1\" = \"Cadre\", \"2\" = \"Profession intermédiaire\", \"3\" = \"Employé\", \"4\" = \"Ouvrier\", \"5\" = \"Retraité\")\n\n\n\nPréférer case_match quand il s’agit de valeurs déterminées.\n\nrequete_duckdb %&gt;% \n  mutate(sexef = case_when(\n    sexef==\"1\" ~ \"Homme\",\n    sexef==\"2\" ~ \"Femme\",\n    .default = sexef),\n         cspf = case_match(csp,\n    \"1\" ~ \"Cadre\",\n    \"2\" ~ \"Profession intermédiaire\",\n    \"3\" ~ \"Employé\",\n    \"4\" ~ \"Ouvrier\",\n    \"5\" ~ \"Retraité\",\n    .default = csp)) %&gt;% \n  select(Sexe, sexef, csp, cspf)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#utiliser-les-formats",
    "href": "01-aide_memoire_r_sas.html#utiliser-les-formats",
    "title": "Aide-mémoire SAS - R",
    "section": "7.3 Utiliser les formats",
    "text": "7.3 Utiliser les formats\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata donnees_sas;\n  set donnees_sas;\n  /* Exprimer dans le format sexef (Hommes / Femmes) */\n  format Sexef $25.;\n  Sexef = put(Sexe, sexef.);\n  /* On exprime la CSP en texte dans une variable CSPF avec le format */\n  format CSPF $25.;\n  CSPF = put(CSP, $cspf.);\nrun;\n\n\n\n# On exprime CSP et sexe en formaté\ndonnees_rbase$cspf &lt;- cspf[donnees_rbase$csp]\ndonnees_rbase$sexef &lt;- sexef[donnees_rbase$sexe]\n\n\n\n\n# On exprime CSP et sexe en formaté\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(sexef = sexef_format[sexe],\n         cspf = cspf_format[csp])\n\n# Autre solution\n# Les éventuelles valeurs manquantes sont conservées en NA\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(\n    sexef = case_when(\n      sexe == \"1\" ~ \"Homme\",\n      sexe == \"2\" ~ \"Femme\",\n      TRUE        ~ sexe),\n    cspf = case_when(\n      csp == \"1\" ~ \"Cadre\",\n      csp == \"2\" ~ \"Profession intermédiaire\",\n      csp == \"3\" ~ \"Employé\",\n      csp == \"4\" ~ \"Ouvrier\",\n      csp == \"5\" ~ \"Retraité\",\n      TRUE       ~ csp)\n    )\n# Syntaxe pour attribuer une valeur aux NA\nvaleurAuxNA &lt;- donnees_tidyverse %&gt;% \n  mutate(sexef = case_when(\n    sexe == \"1\" ~ \"Homme\",\n    sexe == \"2\" ~ \"Femme\",\n    is.na(x)    ~ \"Inconnu\",\n    TRUE        ~ sexe))\n\n\n\n\n# On exprime CSP et sexe en formaté\ndonnees_datatable[, `:=` (cspf = cspform[csp], sexef = sexeform[sexe])]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#transformer-le-format-dune-variable",
    "href": "01-aide_memoire_r_sas.html#transformer-le-format-dune-variable",
    "title": "Aide-mémoire SAS - R",
    "section": "7.4 Transformer le format d’une variable",
    "text": "7.4 Transformer le format d’une variable\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata donnees_sas;\n  set donnees_sas;\n  /* Transformer la variable Sexe en caractère */\n  Sexe_car = put(Sexe, $1.);\n  /* Transformer la variable Sexe_car en numérique */\n  Sexe_num = input(Sexe_car, 1.);\n  /* Transformer une date d'un format caractère à un format Date */\n  format date $10.;\n  date = \"01/01/2000\";\n  format date_sas yymmdd10.;\n  date_sas = input(date, ddmmyy10.);\nrun;\n\n\n\n# Transformer la variable sexe en numérique\ndonnees_rbase$sexe_numerique &lt;- as.numeric(donnees_rbase$sexe)\n# Transformer la variable sexe_numerique en caractère\ndonnees_rbase$sexe_caractere &lt;- as.character(donnees_rbase$sexe_numerique)\n# Transformer une date d'un format caractère à un format Date\ndonnees_rbase$date_r &lt;- lubridate::dmy(\"01/01/2000\")\n\n\n\n\n# Transformer la variable sexe en numérique\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%  \n  mutate(sexe_numerique = as.numeric(sexe))\n\n# Transformer la variable sexe_numerique en caractère\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  mutate(sexe_caractere = as.character(sexe_numerique))\n\n# Transformer une date d'un format caractère à un format Date\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%  \n  mutate(date_r = lubridate::dmy(\"01/01/2000\"))\n\n\n\n\n# Transformer la variable sexe en numérique\ndonnees_datatable[, sexe_numerique := as.numeric(sexe)]\n# Transformer la variable sexe_numerique en caractère\ndonnees_datatable[, sexe_caractere := as.numeric(sexe_numerique)]\n# Transformer une date d'un format caractère à un format Date\ndonnees_datatable[, date_r := lubridate::dmy(\"01/01/2000\")]\n\n\n\n\n# À FAIRE\n#enNumerique &lt;- c(\"Duree\", \"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\")\n#enDate &lt;- c('Date_naissance', 'Date_entree')\n#\n#requete_duckdb %&gt;%  \n#  mutate_at(enNumerique, as.integer) %&gt;% \n#  mutate(poids_sondage=as.numeric(poids_sondage)) %&gt;%\n#  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %&gt;% # strptime est une fonction duckdb\n#  select(enDate, Duree, Note_Contenu)\n#\n\nNote : duckdb fait des conversions de type implicitement, mais seulement les conversions incontestables. Il faudra souvent préciser le type des variables.",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#création-et-suppressions-de-plusieurs-variables",
    "href": "01-aide_memoire_r_sas.html#création-et-suppressions-de-plusieurs-variables",
    "title": "Aide-mémoire SAS - R",
    "section": "7.5 Création et suppressions de plusieurs variables",
    "text": "7.5 Création et suppressions de plusieurs variables\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Manipulation de colonnes par référence */\ndata Creation;\n  set donnees_sas;\n  note_contenu2 = note_contenu / 20 * 5;\n  note_formateur2 = note_formateur / 20 * 5;\n  /* Suppression des variables créées */\n  drop note_contenu2 note_formateur2;\nrun;\n\n/* Par nom ou par variable */\n%let var = identifiant Sexe note_contenu;\ndata Femmes;\n  /* Sélection de colonnes */\n  set donnees_sas (keep = &var.);\n  /* Sélection de lignes respectant une certaine condition */\n  if Sexe = \"2\";\n  /* Création de colonne */\n  note2 = note_contenu / 20 * 5;\n  /* Suppression de colonnes */\n  drop note2;\n  /* Selection de colonnes */\n  keep identifiant Sexe note_contenu;\nrun;\n\n\n\ndonnees_rbase$note2 &lt;- donnees_rbase$note_contenu / 20 * 5\n# Le with permet de s'affranchir des expressions \"donnees_rbase$\"\nwith(donnees_rbase, note2 &lt;- note_contenu / 20 * 5)\ndonnees_rbase &lt;- transform(donnees_rbase, note2 = note_contenu / 20 * 5)\n# On ne peut pas utiliser transform pour des variables récemment créées\n#donnees_rbase &lt;- transform(donnees_rbase, note3 = note_contenu ** 2, note3 = log(note3))\n\n# Suppression de variables\ndonnees_rbase$note2 &lt;- NULL\n\n# Création et suppressions de plusieurs variables\ndonnees_rbase &lt;- transform(donnees_rbase, note_contenu2 = note_contenu / 20 * 5, note_formateur2 = note_formateur / 20 * 5)\n# Suppression des variables créées\nvariable &lt;- c(\"note_contenu2\", \"note_formateur2\")\ndonnees_rbase[, variable] &lt;- NULL\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(note2 = note_contenu / 20 * 5)\n\n# Suppression de variables\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  select(-note2)\n\n# Création et suppressions de plusieurs variables\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(note_contenu2 = note_contenu / 20 * 5,\n         note_formateur2 = note_formateur / 20 * 5)\n\n# Suppression des variables créées\nvariable &lt;- c(\"note_contenu2\", \"note_formateur2\")\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  select(-all_of(variable))\n\n\n\n\n# Création de variables\ndonnees_datatable[, note2 := note_contenu / 20 * 5]\n\n# Suppression de variables\ndonnees_datatable[, note2 := NULL]\n\n# Création et suppressions de plusieurs variables\ndonnees_datatable[, c(\"note_contenu2\", \"note_formateur2\") := list(note_contenu / 20 * 5, note_formateur / 20 * 5)]\ndonnees_datatable[, `:=` (note_contenu2 = note_contenu / 20 * 5, note_formateur2 = note_formateur / 20 * 5)]\n# Suppression des variables créées\ndonnees_datatable[, c(\"note_contenu2\", \"note_formateur2\") := NULL]\n# Ou par référence extérieure\nvariable &lt;- c(\"note_contenu2\", \"note_formateur2\")\ndonnees_datatable[, `:=` (note_contenu2 = note_contenu / 20 * 5, note_formateur2 = note_formateur / 20 * 5)]\ndonnees_datatable[, (variable) := NULL]\n\n\n\n\n# À FAIRE : à compléter !\n# Création de la colonne note2\nrequete_duckdb %&gt;% \n  mutate(note2 = as.integer(Note_Contenu) / 20 * 5) %&gt;% \n  select(note2)\n\n# Suppression de colonnes\n#requete_duckdb %&gt;% select(- CSP, -contains(\"Date\"), -starts_with(\"Note\"))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#on-souhaite-réexprimer-toutes-les-notes-sur-100-et-non-sur-20",
    "href": "01-aide_memoire_r_sas.html#on-souhaite-réexprimer-toutes-les-notes-sur-100-et-non-sur-20",
    "title": "Aide-mémoire SAS - R",
    "section": "7.6 On souhaite réexprimer toutes les notes sur 100 et non sur 20",
    "text": "7.6 On souhaite réexprimer toutes les notes sur 100 et non sur 20\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let notes = Note_Contenu   Note_Formateur Note_Moyens     Note_Accompagnement     Note_Materiel;\n/* On supprime d'abord les doubles blancs entre les variables */\n%let notes = %sysfunc(compbl(&notes.));\n/* on affiche les notes dans la log de SAS */\n%put &notes;\n/* 1ère solution : avec les array */\n/* Les variables sont modifiées dans cet exemple */\ndata Sur100_1;\n  set donnees_sas;\n  array variables (*) &notes.;\n  do increment = 1 to dim(variables);\n    variables[increment] = variables[increment] / 20 * 100;\n  end; \n  drop increment;\nrun;\n/* 2e solution : avec une macro */\n/* De nouvelles variables sont ajoutées dans cet exemple */\ndata donnees_sas;\n  set donnees_sas;\n  %macro Sur100;\n    %do i = 1 %to %sysfunc(countw(&notes.));\n      %let note = %scan(&notes., &i.);\n      &note._100 = &note. / 20 * 100;\n    %end;\n  %mend Sur100;\n  %Sur100;\nrun;\n\n\n\nnotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nnotes &lt;- names(donnees_rbase)[grepl(\"^note\", names(donnees_rbase))]\n# Les variables sont modifiées dans cet exemple\nsur100 &lt;- donnees_rbase[, notes] / 20 * 100\n# On  souhaite conserver les notes sur 100 dans d'autres variables, suffixées par _100\ndonnees_rbase[, paste0(notes, \"_100\")] &lt;- donnees_rbase[, notes] / 20 * 100\n\n\n\n\n# Les variables sont modifiées dans cet exemple\nsur100 &lt;- donnees_tidyverse %&gt;% \n  mutate(across(starts_with(\"note\"), ~ .x / 20 * 100))\n\n# On  souhaite conserver les notes sur 100 dans d'autres variables, suffixées par _100\nnotes &lt;- names(donnees_tidyverse)[grepl(\"^note\", names(donnees_tidyverse))]\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(across(starts_with(\"note\"), ~ .x / 20 * 100, .names = \"{.col}_100\"))\n\n\n\n\nnotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nnotes &lt;- names(donnees_datatable)[grepl(\"^note\", names(donnees_datatable))]\n# Les variables sont modifiées dans cet exemple\nsur100 &lt;- copy(donnees_datatable)\nsur100 &lt;- sur100[, (notes) := lapply(.SD, function(x) x / 20 * 100), .SDcols = notes]\nsur100 &lt;- sur100[, (notes) := lapply(.SD, function(x) x / 20 * 100), .SD = notes]\n# Ou encore, plus simple\n# Dans cet exemple, les notes dans la base donnees_datatable ne sont pas changées\nsur100 &lt;- sur100[, lapply(.SD, function(x) x / 20 * 100), .SDcols = patterns(\"^note\")]\n# On  souhaite conserver les notes sur 20 dans d'autres variables, suffixées par _20\ndonnees_datatable[, (paste0(notes, \"_100\")) := lapply(.SD, function(x) x / 20 * 100), .SDcols = notes]\n\n\n\n\nrequete_duckdb %&gt;% \n  mutate(across(starts_with(\"note\"), ~ as.numeric(.x)/20*100)) %&gt;% \n  select(starts_with(\"note\"))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#création-de-variables-avec-des-conditions",
    "href": "01-aide_memoire_r_sas.html#création-de-variables-avec-des-conditions",
    "title": "Aide-mémoire SAS - R",
    "section": "7.7 Création de variables avec des conditions",
    "text": "7.7 Création de variables avec des conditions\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata Civilite;\n  set donnees_sas;\n  /* 1ère solution */\n  format Civilite $20.;\n  if      Sexe = 2 then Civilite = \"Mme\";\n  else if Sexe = 1 then Civilite = \"Mr\";\n  else                  Civilite = \"Inconnu\";\n  /* 2e solution (do - end) */\n  if      Sexe = 2 then do;\n    Civilite2 = \"Femme\";\n  end;\n  else if Sexe = 1 then do;\n    Civilite2 = \"Homme\";\n  end;\n  else do;\n    Civilite2 = \"Inconnu\";\n  end;\n  /* 3e solution */\n  format Civilite3 $20.;\n  select;\n    when      (Sexe = 2) Civilite3 = \"Femme\";\n    when      (Sexe = 1) Civilite3 = \"Homme\";\n    otherwise            Civilite3 = \"Inconnu\";\n  end;\n  keep Sexe Civilite Civilite2 Civilite3;run;\nrun;\n\n\n\ndonnees_rbase$civilite &lt;- ifelse(donnees_rbase$sexe == \"2\", \"Mme\", \n                           ifelse(donnees_rbase$sexe == \"1\", \"M\", \n                                  \"Inconnu\"))\n# Autre solution\ndonnees_rbase$civilite &lt;- \"Inconnu\"\ndonnees_rbase$civilite[donnees_rbase$sexe == \"1\"] &lt;- \"M\"\ndonnees_rbase$civilite[donnees_rbase$sexe == \"2\"] &lt;- \"Mme\"\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  mutate(civilite = case_when(sexe == \"2\" ~ \"Mme\",\n                              sexe == \"1\" ~ \"M\",\n                              TRUE        ~ \"Inconnu\")\n)\n\n\n\n\ndonnees_datatable[, civilite := fcase(sexe == \"2\", \"Mme\",\n                                      sexe == \"1\", \"M.\",\n                                      is.na(sexe), \"Inconnu\")]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#manipuler-les-dates",
    "href": "01-aide_memoire_r_sas.html#manipuler-les-dates",
    "title": "Aide-mémoire SAS - R",
    "section": "7.8 Manipuler les dates",
    "text": "7.8 Manipuler les dates\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On utilise ici %sysevalf et non %eval pour des calculs avec des macro-variables non entières */\n%let sixmois = %sysevalf(365.25/2);\n%put sixmois : &sixmois.;\ndata donnees_sas;\n  set donnees_sas;\n  /* Âge à l'entrée dans le dispositif */\n  Age = intck('year', date_naissance, date_entree);\n  /* Âge formaté */\n  Agef = put(Age, agef.);\n  /* Date de sortie du dispositif : ajout de la durée à la date d'entrée */\n  format date_sortie ddmmyy10.;\n  date_sortie = intnx('day', date_entree, duree);  \n  /* La durée du contrat est-elle inférieure à 6 mois ? */\n  Duree_Inf_6_mois = (Duree &lt; &sixmois. & Duree ne .);\n  /* Deux manières de créer une date */\n  format Decembre_31_&an._a Decembre_31_&an._b ddmmyy10.;\n  Decembre_31_&an._a = \"31dec&an.\"d;\n  /* mdy pour month, day, year (pas d'autre alternative, ymd par exemple n'existe pas) */\n  Decembre_31_&an._b = mdy(12, 31, &an.); \n  /* Date 6 mois après la sortie */\n  format Date_6mois ddmmyy10.;\n  Date_6mois = intnx('month', date_sortie, 6);\nrun;\n/* Ventilation pondérée (cf. infra) */\nproc freq data = donnees_sas;tables apres_31_decembre;weight poids_sondage;run;\n\n\n\n# Âge à l'entrée dans le dispositif\ndonnees_rbase$age &lt;- floor(lubridate::time_length(difftime(donnees_rbase$date_entree, donnees_rbase$date_naissance), \"years\"))\n# Âge formaté\ndonnees_rbase$agef[donnees_rbase$age &lt; 26]                           &lt;- \"1. De 15 à 25 ans\"\n# 26 &lt;= donnees_rbase$age &lt; 50 ne fonctionne pas, il faut passer en 2 étapes\ndonnees_rbase$agef[26 &lt;= donnees_rbase$age & donnees_rbase$age &lt; 50] &lt;- \"2. De 26 à 49 ans\"\ndonnees_rbase$agef[donnees_rbase$age &gt;= 50]                          &lt;- \"3. 50 ans ou plus\"\n# Autre solution\n# L'option right = TRUE implique que les bornes sont ]0; 25] / ]25; 49] / ]49; Infini[\nagef &lt;- cut(donnees_rbase$age, \n            breaks = c(0, 25, 49, Inf),\n            right = TRUE,\n            labels = c(\"1. De 15 à 25 ans\", \"2. De 26 à 49 ans\", \"3. 50 ans ou plus\"), \n            ordered_result = TRUE)\n\n# Manipuler les dates\nsixmois &lt;- 365.25/2\n# La durée du contrat est-elle inférieure à 6 mois ?\ndonnees_rbase$duree_inf_6_mois &lt;- ifelse(donnees_rbase$duree &lt; sixmois, 1, 0)\n# Date de sortie du dispositif\ndonnees_rbase$date_sortie &lt;- donnees_rbase$date_entree + lubridate::days(donnees_rbase$duree)\n\n# Pour créer une date\nas.Date(paste0(annee,\"-12-31\"), origin = \"1970-01-01\")\nlubridate::ymd(paste0(annee,\"-12-31\"))\n\n# Date 6 mois après la sortie\ndonnees_rbase$date_6mois &lt;- donnees_rbase$date_sortie + lubridate::month(6)\n\n\n\n\n# Âge à l'entrée dans le dispositif\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(age = as.period(interval(start = date_naissance, end = date_entree))$year)\n# Âge formaté\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  mutate(agef = case_when(\n    age &lt; 26             ~ \"1. De 15 à 25 ans\",\n    age &gt;= 26 & age &lt; 50 ~ \"2. De 26 à 49 ans\",\n    age &gt;= 50            ~ \"3. 50 ans ou plus\")\n    )\n\n\n# Manipuler les dates\nsixmois &lt;- 365.25/2\n# La durée du contrat est-elle inférieure à 6 mois ?\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(duree_inf_6_mois = case_when(duree &lt;  sixmois ~ 1,\n                                      duree &gt;= sixmois ~ 0))\ndonnees_tidyverse %&gt;% pull(duree_inf_6_mois) %&gt;% table()\n\n# Date de sortie du dispositif\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(date_sortie = date_entree + lubridate::days(duree))\n\n# Pour créer une date\nas.Date(paste0(annee,\"-12-31\"))\nlubridate::ymd(paste0(annee,\"-12-31\"))\n\n# Date 6 mois après la sortie\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(date_6mois = date_sortie + lubridate::month(6))\n\n\n\n\n# Âge à l'entrée dans le dispositif\ndonnees_datatable[, age := floor(lubridate::time_length(difftime(donnees_datatable$date_entree, donnees_datatable$date_naissance), \"years\"))]\n\n# Âge formaté\ndonnees_datatable[, agef := fcase(age &lt; 26,             \"1. De 15 à 25 ans\",\n                                  26 &lt;= age & age &lt; 50, \"2. De 26 à 49 ans\",\n                                  age &gt;= 50,            \"3. 50 ans ou plus\")]\n\n# Manipuler les dates\nsixmois &lt;- 365.25/2\n# La durée du contrat est-elle inférieure à 6 mois ?\ndonnees_datatable[, duree_inf_6_mois := ifelse(duree &gt;= sixmois, 1, 0)]\ndonnees_datatable[, duree_inf_6_mois := fifelse(duree &gt;= sixmois, 1, 0)]\ndonnees_datatable[, duree_inf_6_mois := fcase(duree &gt;= sixmois, 1,\n                                              duree &lt;  sixmois, 0)]\n# Date de sortie du dispositif\ndonnees_datatable[, date_sortie := date_entree + lubridate::days(duree)]\n\n# Pour créer une date\nas.Date(paste0(annee,\"-12-31\"))\nlubridate::ymd(paste0(annee,\"-12-31\"))\n\n# Date 6 mois après la sortie\ndonnees_datatable[, date_6mois := date_sortie + lubridate::month(6)]\n\n\n\n\n# Création de la colonne age \nrequete_duckdb %&gt;% \n  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %&gt;% # strptime est une fonction duckdb\n  mutate(age = year(age(Date_entree,Date_naissance))) %&gt;% \n  select(age)\n\n# Âge formaté\nrequete_duckdb %&gt;%\n  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %&gt;% # strptime est une fonction duckdb\n  mutate(age = year(age(Date_entree,Date_naissance))) %&gt;% \n  mutate(agef = case_when(\n    age &lt; 26 ~ \"1. De 15 à 25 ans\",\n    age &gt;= 26 | age &lt; 50 ~  \"2. De 26 à 49 ans\",\n    age &gt;= 50 ~ \"3. 50 ans ou plus\")) %&gt;% \n  select(age, agef)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#mettre-un-0-devant-un-nombre",
    "href": "01-aide_memoire_r_sas.html#mettre-un-0-devant-un-nombre",
    "title": "Aide-mémoire SAS - R",
    "section": "7.9 Mettre un 0 devant un nombre",
    "text": "7.9 Mettre un 0 devant un nombre\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata Zero_devant;\n  set donnees_sas (keep = date_entree);\n  /* Obtenir le mois et la date */\n  Mois = month(date_entree);\n  Annee = year(date_entree);\n  /* Mettre le mois sur 2 positions (avec un 0 devant si le mois &lt;= 9) : format prédéfini z2. */\n  Mois_a = put(Mois, z2.);\n  drop Mois;\n  rename Mois_a = Mois;\nrun;\n\n\n\n# Obtenir le mois et la date\ndonnees_rbase$mois &lt;- lubridate::month(donnees_rbase$date_entree)\ndonnees_rbase$annee &lt;- lubridate::year(donnees_rbase$date_entree)\n# Mettre le numéro du mois sur 2 positions (avec un 0 devant si le mois &lt;= 9)\ndonnees_rbase$mois &lt;- sprintf(\"%02d\", donnees_rbase$mois)\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(mois = sprintf(\"%02d\", lubridate::month(date_entree)))\n# Autre solution\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(mois = lubridate::month(date_entree),\n         mois = ifelse(str_length(mois) &lt; 2, paste0(\"0\", mois), mois))\n\n\n\n\n# Obtenir le mois et la date\ndonnees_datatable[, `:=`(mois = lubridate::month(date_entree), annee = lubridate::year(donnees_datatable$date_entree))]\n# Mettre le numéro du mois sur 2 positions (avec un 0 devant si le mois &lt;= 9)\ndonnees_datatable[, mois := sprintf(\"%02d\", mois)]\n\n\n\n\n# À FAIRE : pas exactement au bon endroit\n#requete_duckdb %&gt;% \n#  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %&gt;% # strptime est une fonction duckdb\n#  mutate(mois=lubridate::month(Date_entree),\n#         mois=ifelse(str_length(mois)&lt;2, paste0(\"0\", mois), mois)) %&gt;% \n#  select(mois, Date_entree)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#arrondir-une-valeur-numérique",
    "href": "01-aide_memoire_r_sas.html#arrondir-une-valeur-numérique",
    "title": "Aide-mémoire SAS - R",
    "section": "7.10 Arrondir une valeur numérique",
    "text": "7.10 Arrondir une valeur numérique\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata Arrondis;\n  set donnees_sas (keep = poids_sondage);\n  /* Arrondi à l'entier le plus proche */\n  poids_arrondi_0 = round(poids_sondage);\n  /* Arrondi à 1 chiffre après la virgule */\n  poids_arrondi_1 = round(poids_sondage, 0.1);\n  /* Arrondi à 2 chiffre après la virgule */\n  poids_arrondi_2 = round(poids_sondage, 0.2);\n  /* Arrondi à l'entier inférieur */\n  poids_inf = floor(poids_sondage);\n  /* Arrondi à l'entier supérieur */\n  poids_sup = ceil(poids_sondage);  \nrun;\n\n\n\n# Arrondi à l'entier le plus proche\npoids_arrondi_0 &lt;- round(donnees_rbase$poids_sondage, 0)\n# Arrondi à 1 chiffre après la virgule\npoids_arrondi_1 &lt;- round(donnees_rbase$poids_sondage, 1)\n# Arrondi à 2 chiffre après la virgule\npoids_arrondi_2 &lt;- round(donnees_rbase$poids_sondage, 2)\n# Arrondi à l'entier inférieur\npoids_inf &lt;- floor(donnees_rbase$poids_sondage)\n# Arrondi à l'entier supérieur\npoids_sup &lt;- ceiling(donnees_rbase$poids_sondage)\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  # Arrondi à l'entier le plus proche\n  mutate(poids_arrondi_0 = round(poids_sondage, 0)) %&gt;% \n  # Arrondi à 1 chiffre après la virgule\n  mutate(poids_arrondi_1 = round(poids_sondage, 1)) %&gt;% \n  # Arrondi à 2 chiffre après la virgule\n  mutate(poids_arrondi_2 = round(poids_sondage, 2)) %&gt;% \n  # Arrondi à l'entier inférieur\n  mutate(poids_inf = floor(poids_sondage)) %&gt;% \n  # Arrondi à l'entier supérieur\n  mutate(poids_sup = ceiling(poids_sondage))\ndonnees_tidyverse %&gt;% select(starts_with(\"poids\"))\n\n\n\n\n# Arrondi à l'entier le plus proche\ndonnees_datatable[, poids_arrondi_0 := round(poids_sondage, 0)]\n# Arrondi à 1 chiffre après la virgule\ndonnees_datatable[, poids_arrondi_1 := round(poids_sondage, 1)]\n# Arrondi à 2 chiffre après la virgule\ndonnees_datatable[, poids_arrondi_2 := round(poids_sondage, 2)]\n# Arrondi à l'entier inférieur\ndonnees_datatable[, poids_inf := floor(poids_sondage)]\n# Arrondi à l'entier supérieur\ndonnees_datatable[, poids_sup := ceiling(poids_sondage)]\n\n\n\n\nrequete_duckdb %&gt;% \n  mutate( # la fonction round de duckdb ne prend pas l'argument digits, mais la traduction fonctionne\n    poids_arrondi_0 = round(as.numeric(poids_sondage),0),\n    poids_arrondi_1 = round(as.numeric(poids_sondage),1),\n    poids_arrondi_2 = round(as.numeric(poids_sondage),-1),\n    poids_floor = floor(as.numeric(poids_sondage)),\n    poids_ceiling = ceiling(as.numeric(poids_sondage)),\n    ) %&gt;% \n  select(starts_with(\"poids\"))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#trier-les-colonnes-de-la-base",
    "href": "01-aide_memoire_r_sas.html#trier-les-colonnes-de-la-base",
    "title": "Aide-mémoire SAS - R",
    "section": "8.1 Trier les colonnes de la base",
    "text": "8.1 Trier les colonnes de la base\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On met identifiant, date_entree au début de la base */\n%let colTri = identifiant date_entree;\ndata donnees_sas;\n  retain &colTri.;\n  set donnees_sas;\nrun;\n/* Autre solution */\nproc sql;\n  create table donnees_sas as\n  /* Dans la proc SQL, les variables doivent être séparées par des virgules */\n  /* On remplace les blancs entre les mots par des virgules pour la proc SQL */\n  select %sysfunc(tranwrd(&colTri., %str( ), %str(, ))), * from donnees_sas;\nquit;\n/* Mettre la variable poids_sondage au début de la base */\ndata donnees_sas;\n  retain poids_sondage;\n  set donnees_sas;\nrun;\n/* Mettre la variable poids_sondage à la fin de la base */\nproc contents data = donnees_sas out = var;run;\nproc sql noprint;\n  select name into :var separated by \" \" from var\n  where lowcase(name) ne \"poids_sondage\" order by varnum;\nquit;\ndata donnees_sas;\n  retain &var. poids_sondage;\n  set donnees_sas;\nrun;\n\n\n\n# Mettre les variables identifiant, date_entree au début de la base\ncolTri &lt;- c(\"identifiant\", \"date_entree\")\ndonnees_rbase &lt;- donnees_rbase[, union(colTri, colnames(donnees_rbase))]\n# Autre possibilité, plus longue !\ndonnees_rbase &lt;- donnees_rbase[, c(colTri, setdiff(colnames(donnees_rbase), colTri))]\ndonnees_rbase &lt;- donnees_rbase[, c(colTri, colnames(donnees_rbase)[! colnames(donnees_rbase) %in% colTri])]\n# Mettre la variable poids_sondage au début de la base\ndonnees_rbase &lt;- donnees_rbase[, c(\"poids_sondage\", setdiff(colnames(donnees_rbase), \"poids_sondage\"))]\n# Mettre la variable poids_sondage à la fin de la base\ndonnees_rbase &lt;- donnees_rbase[, c(setdiff(colnames(donnees_rbase), \"poids_sondage\"), \"poids_sondage\")]\n\n\n\n\n# Mettre les variables identifiant, date_entree et date_sortie au début de la base\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  relocate(identifiant, date_entree)\n# Autres solutions\ncolTri &lt;- c(\"identifiant\", \"date_entree\")\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  relocate(all_of(colTri))\ndonnees_tidyverse_tri &lt;- donnees_tidyverse %&gt;% \n  select(all_of(colTri), everything())\n\n\n# Mettre la variable poids_sondage au début de la base\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  relocate(poids_sondage)\n# Mettre la variable poids_sondage à la fin de la base\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  relocate(poids_sondage, .after = last_col())\n\n\n\n\n# On met identifiant, date_entree au début\ncolTri &lt;- c(\"identifiant\", \"date_entree\")\ntri &lt;- union(colTri, colnames(donnees_datatable))\ndonnees_datatable &lt;- donnees_datatable[, ..tri]\n# En data.table, les instructions débutant par set modifient les éléments par référence, c'est-à-dire sans copie.\n# Ceci est plus efficace pour manipuler des données volumineuses.\nsetcolorder(donnees_datatable, colTri)\n\n# Mettre la variable poids_sondage au début de la base\nsetcolorder(donnees_datatable, union(\"poids_sondage\", colnames(donnees_datatable)))\n# Mettre la variable poids_sondage à la fin de la base\nsetcolorder(donnees_datatable, c(setdiff(colnames(donnees_datatable), \"poids_sondage\"), \"poids_sondage\"))\n\n\n\n\n# On met identifiant date_entree au début\nrequete_duckdb %&gt;% \n  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %&gt;% # strptime est une fonction duckdb\n  select(identifiant, date_entree, everything())\nrequete_duckdb %&gt;% \n  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %&gt;% # strptime est une fonction duckdb\n  relocate(identifiant, date_entree)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#trier-les-lignes-par-ordre-décroissant",
    "href": "01-aide_memoire_r_sas.html#trier-les-lignes-par-ordre-décroissant",
    "title": "Aide-mémoire SAS - R",
    "section": "8.2 Trier les lignes (par ordre décroissant",
    "text": "8.2 Trier les lignes (par ordre décroissant\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* 1ère possibilité */\nproc sort data = donnees_sas;by Identifiant Date_entree;run;\n/* 2e possibilité */\nproc sql;\n  create table Donnes as select * from donnees_sas\n  order by Identifiant, Date_entree;\nquit;\n/* Idem par ordre croissant d'identifiant et ordre décroissant de date d'entrée */\nproc sort data = donnees_sas;by Identifiant descending Date_entree;run;\nproc sql;\n  create table Donnes as select * from donnees_sas\n  order by Identifiant, Date_entree desc;\nquit;\n\n\n\n# Tri par ordre croissant\n# L'option na.last = FALSE (resp. TRUE) indique que les valeurs manquantes doivent figurer à la fin (resp. au début) du tri, que le tri\n# soit croissant ou décroissant\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]\n# Tri par ordre croissant de identifiant et décroissant de date_entree (- avant le nom de la variable)\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE, decreasing = c(FALSE, TRUE), method = \"radix\"), ]\n# Autre possibilité : - devant la variable (uniquement pour les variables numériques)\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, -donnees_rbase$duree, na.last = FALSE), ]\n\n\n\n\n# Tri par ordre croissant\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  arrange(identifiant, date_entree)\n# Tri par ordre croissant de identifiant et décroissant de date_entree\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  arrange(identifiant, desc(date_entree))\n\n\n\n\n# Tri par ordre croissant\n# L'option na.last = FALSE (resp. TRUE) indique que les valeurs manquantes doivent figurer à la fin (resp. au début) du tri, que le tri\n# soit croissant ou décroissant\ndonnees_datatable &lt;- donnees_datatable[order(identifiant, date_entree, na.last = FALSE)]\n# En data.table, les instructions débutant par set modifient les éléments par référence, c'est-à-dire sans copie.\n# Ceci est plus efficace pour manipuler des données volumineuses.\nsetorder(donnees_datatable, \"identifiant\", \"date_entree\", na.last = FALSE)\nsetorderv(donnees_datatable, cols = c(\"identifiant\", \"date_entree\"), order = c(1L, 1L), na.last = FALSE)\n# Tri par ordre croissant de identifiant et décroissant de date_entree (- avant le nom de la variable)\ndonnees_datatable &lt;- donnees_datatable[order(identifiant, -date_entree, na.last = FALSE)]\nsetorder(donnees_datatable, \"identifiant\", -\"date_entree\", na.last = FALSE)\nsetorderv(donnees_datatable, cols = c(\"identifiant\", \"date_entree\"), order = c(1L, -1L), na.last = FALSE)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#incidence-des-valeurs-manquantes-dans-les-tris",
    "href": "01-aide_memoire_r_sas.html#incidence-des-valeurs-manquantes-dans-les-tris",
    "title": "Aide-mémoire SAS - R",
    "section": "8.3 Incidence des valeurs manquantes dans les tris",
    "text": "8.3 Incidence des valeurs manquantes dans les tris\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Dans SAS, les valeurs manquantes sont considérées comme des valeurs négatives */\n/* Elles sont donc situées en premier dans un tri par ordre croissant ... */\nproc sort data = donnees_sas;by identifiant date_entree;run;proc print;run;\n/* ... et en dernier dans un tri par ordre décroissant */\nproc sort data = donnees_sas;by identifiant descending date_entree;run;\nproc print;run;\n\n\n\n# Les valeurs manquantes sont situées en dernier dans un tri par ordre croissant ou décroissant (car par défaut l'option na.last = TRUE) ...\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree), ]\n\n# SAS considère les valeurs manquantes comme des nombres négatifs faibles.\n# Pour mimer le tri par ordre croissant en SAS :\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]\n# Pour mimer le tri par ordre décroissant en SAS :\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree,\n                                     na.last = FALSE,\n                                     decreasing = c(FALSE, TRUE),\n                                     method = \"radix\"), ]\n\n\n\n\n# Attention, avec arrange, les variables manquantes (NA) sont toujours classées en dernier, même avec desc()\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  arrange(identifiant, date_entree)\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  arrange(identifiant, desc(date_entree))\n\n# Or, SAS considère les valeurs manquantes comme des nombres négatifs faibles.\n# Elles sont donc classées en premier dans un tri par ordre croissant, et en dernier dans un tri par ordre décroissant\n\n# Pour mimer le tri par ordre croissant en SAS : les valeurs manquantes de date_entree sont classées en premier\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  arrange(identifiant, !is.na(date_entree), date_entree)\n# Pour mimer le tri par ordre décroissant en SAS\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  arrange(identifiant, desc(date_entree))\n\n\n\n\n# Les valeurs manquantes sont situées en dernier dans un tri par ordre croissant ou décroissant (car par défaut l'option na.last = TRUE) ...\ndonnees_datatable &lt;- donnees_datatable[order(identifiant, date_entree)]\n# SAS considère les valeurs manquantes comme des nombres négatifs faibles.\n# Pour mimer le tri par ordre croissant en SAS :\nsetorderv(donnees_datatable, cols = c(\"identifiant\", \"date_entree\"), order = c(1L, 1L), na.last = FALSE)\n# Pour mimer le tri par ordre décroissant en SAS :\nsetorderv(donnees_datatable, cols = c(\"identifiant\", \"date_entree\"), order = c(1L, -1L), na.last = FALSE)\n\n\n\n\n# Les valeurs manquantes sont situées en dernier dans un tri par ordre croissant ou décroissant (car par défaut l'option na.last = TRUE) ...\nrequete_duckdb %&gt;% arrange(Identifiant, Note_Contenu) %&gt;% select(Identifiant, Note_Contenu)\n  \n# Pour mimer le tri SAS, il faut écrire :\n# Note : il faut faire select d'abord, sinon il y a une erreur quand \"! is.na()\" est dans la liste des colonnes\nrequete_duckdb %&gt;% select(Identifiant, Note_Contenu) %&gt;% arrange(Identifiant, ! is.na(Note_Contenu), Note_Contenu)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#trier-par-ordre-croissant-par-toutes-les-variables-de-la-base",
    "href": "01-aide_memoire_r_sas.html#trier-par-ordre-croissant-par-toutes-les-variables-de-la-base",
    "title": "Aide-mémoire SAS - R",
    "section": "8.4 Trier par ordre croissant par toutes les variables de la base",
    "text": "8.4 Trier par ordre croissant par toutes les variables de la base\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc sort data = donnees_sas;by _all_;run;\n\n\n\ntri_toutes_variables &lt;- donnees_rbase[order(colnames(donnees_rbase), na.last = FALSE)]\n\n\n\n\ntri_toutes_variables &lt;- donnees_tidyverse %&gt;% \n  arrange(pick(everything()))\ntri_toutes_variables &lt;- donnees_tidyverse %&gt;% \n  arrange(across(everything()))\n\n\n\n\ntri_toutes_variables &lt;- setorderv(donnees_datatable, na.last = FALSE)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#majuscule-minuscule",
    "href": "01-aide_memoire_r_sas.html#majuscule-minuscule",
    "title": "Aide-mémoire SAS - R",
    "section": "9.1 Majuscule, minuscule",
    "text": "9.1 Majuscule, minuscule\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Fonction tranwrd (TRANslate WoRD) */\ndata donnees_sas;\n  set donnees_sas;\n  /* Première lettre en majuscule */\n  Niveau = propcase(Niveau);\n  /* En majuscule */\n  CSP_majuscule = upcase(CSPF);\n  /* En minuscule */\n  CSP_minuscule = lowcase(CSPF);\n  /* Nombre de caractères dans une chaîne de caractères */\n  taille_id = length(identifiant);\nrun;\n\n\n\n# 1ère lettre en majuscule, autres lettres en minuscule\ndonnees_rbase$niveau &lt;- paste0(toupper(substr(donnees_rbase$niveau, 1, 1)), tolower(substr(donnees_rbase$niveau, 2, length(donnees_rbase$niveau))))\n\n# En majuscule\ndonnees_rbase$csp_maj &lt;- toupper(donnees_rbase$cspf)\n# En minuscule\ndonnees_rbase$csp_min &lt;- tolower(donnees_rbase$cspf)\n# Nombre de caractères dans une chaîne de caractères\ndonnees_rbase$taille_id &lt;- nchar(donnees_rbase$identifiant)\n\n\n\n\n# 1ère lettre en majuscule, autres lettres en minuscule\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%  \n  mutate(niveau = str_to_title(niveau))\n\n# En majuscule\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(csp_maj = toupper(cspf))\n# En minuscule\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(csp_maj = tolower(cspf))\n# Nombre de caractères dans une chaîne de caractères\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(taille_id = nchar(identifiant))\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(taille_id = str_split(identifiant, '') %&gt;% \n           lengths)\n\n\n\n\n# 1ère lettre en majuscule, autres lettres en minuscule\ndonnees_datatable[, niveau := paste0(toupper(substr(niveau, 1, 1)), tolower(substr(niveau, 2, length(niveau))))]\n\n# En majuscule\ndonnees_datatable[, csp_maj := toupper(cspf)]\n# En minuscule\ndonnees_datatable[, csp_min := tolower(cspf)]\n# Nombre de caractères dans une chaîne de caractères\ndonnees_datatable[, taille_id := nchar(identifiant)]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#remplacer-une-chaîne-de-caractères-par-une-autre",
    "href": "01-aide_memoire_r_sas.html#remplacer-une-chaîne-de-caractères-par-une-autre",
    "title": "Aide-mémoire SAS - R",
    "section": "9.2 Remplacer une chaîne de caractères par une autre",
    "text": "9.2 Remplacer une chaîne de caractères par une autre\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata A_Corriger;\n  infile cards dsd dlm='|';\n  format A_corriger $8.;\n  input A_corriger $;\n  cards;\n  Qualifie\n  qualifie\n  Qualifie\n  QUALIFIE\n;\nrun;\ndata A_Corriger;\n  set A_Corriger;\n  Corrige = lowcase(A_corriger);\n  Corrige = tranwrd(Corrige, \"qualifie\", \"Qualifié\");\nrun;\n\n\n\n# Le mot Qualifié n'a pas d'accent : on le corrige\naCorriger &lt;- c(\"Qualifie\", \"qualifie\", \"Qualifie\", \"QUALIFIE\")\n# [Q-q] permet de représenter Q ou q, et donc de prendre en compte Qualifie et qualifie\ngsub(\"[Q-q]ualifie\", \"Qualifié\", tolower(aCorriger))\n\n\n\n\n# Le mot Qualifié n'a pas d'accent : on le corrige\naCorriger &lt;- c(\"Qualifie\", \"qualifie\", \"Qualifie\", \"QUALIFIE\")\n# [Q-q] permet de représenter Q ou q, et donc de prendre en compte Qualifie et qualifie\naCorriger %&gt;% tolower() %&gt;% str_replace_all(\"[Q-q]ualifie\", \"Qualifié\")\n\n\n\n\n# Le mot Qualifié n'a pas d'accent : on le corrige\naCorriger &lt;- c(\"Qualifie\", \"qualifie\", \"Qualifie\", \"QUALIFIE\")\n# [Q-q] permet de représenter Q ou q, et donc de prendre en compte Qualifie et qualifie\ngsub(\"[Q-q]ualifie\", \"Qualifié\", tolower(aCorriger))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#manipuler-des-chaînes-de-caractères-1",
    "href": "01-aide_memoire_r_sas.html#manipuler-des-chaînes-de-caractères-1",
    "title": "Aide-mémoire SAS - R",
    "section": "9.3 Manipuler des chaînes de caractères",
    "text": "9.3 Manipuler des chaînes de caractères\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata Exemple_chaines;\n  Texte = \"              Ce   Texte   mériterait   d être   corrigé                  \";\n  Texte1 = \"Je m'appelle\";\n  Texte2 = \"SAS\";\n  Texte3 = \"Phrase à découper\";\n  /* Valeur manquante sous forme caractère */\n  Texte4 = \"\";\nrun;\ndata Exemple_chaines;\n  set Exemple_chaines;\n  /* Enlever les blancs au début et à la fin de la chaîne de caractère */\n  Enlever_Blancs_Initiaux = strip(Texte);\n  /* Enlever les doubles blancs dans la chaîne de caractères */\n  Enlever_Blancs_Entre = compbl(Enlever_Blancs_Initiaux);\n  /* Enlever doubles blancs */\n  /* REVOIR !!!!! */\n  Enlever_Doubles_Blancs = compress(Texte, \"  \", \"t\");\n  /* Trois méthodes pour concaténer des chaînes de caractères */\n  Concatener  = Texte1||\" \"||Texte2;\n  Concatener2 = Texte1!!\" \"!!Texte2;\n  Concatener3 = catx(\" \", Texte1, Texte2);\n  /* Effet des valeurs manquantes */\n  /* Le séparateur est enlevé lors d'une concaténation avec une chaîne de caractère vide */\n  Concatener4 = catx(\"-\", Texte4, Texte3);\n  /* Extraire les 2e, 3e et 4e caractère de Concatener */\n  /* 2 correspond à la position du 1er caractère à récupérer, 3 le nombre total de caractères à partir du point de départ */\n  extrait = substr(Concatener, 2, 3);\n  /* Transformer plusieurs caractères différents */\n  /* On transforme le é en e, le â en a, le î en i, ... */\n  chaine = \"éèêëàâçîô\";\n  chaine_sans_accent = translate(chaine, \"eeeeaacio\", \"éèêëàâçîô\");\nrun;\nproc print data = Exemple_chaines;run;\n\n\n\ntexte  &lt;- \"              Ce   Texte   mériterait   d être   corrigé                  \"\ntexte1 &lt;- \"Ce texte\"\ntexte2 &lt;- \"va être\"\ntexte3 &lt;- \"concaténé\"\n# Valeur manquante sous forme caractère\ntexte4 &lt;- \"\"\n\n# Enlever les blancs au début et à la fin de la chaîne de caractère\n# \"\\\\s+\" est une expression régulière indiquant 1 ou plusieurs espaces successifs\n# Le gsub remplace 1 ou plusieurs espaces successifs par un seul espace\n# trimws enlève les espaces au début et à la fin d'une chaîne de caractère \ntexte &lt;- gsub(\"\\\\s+\", \" \", trimws(texte))\n\n\n# Concaténer des chaînes de caractères\nconcatene &lt;- paste(texte1, texte2, texte3, sep = \" \")\npaste0(texte1, texte2, texte3)\n\n# Effet des valeurs manquantes : le délimiteur (ici -) apparaît avec la concaténation avec le caractère manquant\npaste(texte4, texte3, sep = \"-\")\n\n# Extraire les 2e, 3e et 4e caractères de Concatener\n# 2 correspond à la position du 1er caractère à récupérer, 5 la position du dernier caractère\nextrait &lt;- substr(concatene, 2, 5)\n\n# Transformer plusieurs caractères différents\nchaine &lt;- \"éèêëàâçîô\"\nchartr(\"éèêëàâçîô\", \"eeeeaacio\", chaine)\n\n\n\n\ntexte  &lt;- \"              Ce   Texte   mériterait   d être   corrigé                  \"\ntexte1 &lt;- \"Ce texte\"\ntexte2 &lt;- \"va être\"\ntexte3 &lt;- \"concaténé\"\n# Valeur manquante sous forme caractère\ntexte4 &lt;- \"\"\n\n# Enlever les blancs au début et à la fin de la chaîne de caractère\n# str_squish() supprime les espaces blancs au début et à la fin, et remplace tous les espaces blancs internes par un seul espace\ntexte &lt;- str_squish(texte)\n\n# Concaténer des chaînes de caractères\nconcatene &lt;- str_flatten(c(texte1, texte2, texte3), collapse = \" \")\n\n# Effet des valeurs manquantes : le délimiteur (ici -) apparaît avec la concaténation avec le caractère manquant\nstr_flatten(c(texte4, texte3), collapse = \"-\")\n\n# Extraire les 2e, 3e et 4e caractères de Concatener\n# 2 correspond à la position du 1er caractère à récupérer, 5 la position du dernier caractère\nextrait &lt;- str_sub(concatene, 2, 5)\n\n# Transformer plusieurs caractères différents\nchaine &lt;- \"éèêëàâçîô\"\nchartr(\"éèêëàâçîô\", \"eeeeaacio\", chaine)\n\n\n\n\ntexte  &lt;- \"              Ce   Texte   mériterait   d être   corrigé                  \"\ntexte1 &lt;- \"Je m'appelle\"\ntexte2 &lt;- \"R\"\n# Enlever les blancs au début et à la fin de la chaîne de caractère\n# \"\\\\s+\" est une expression régulière indiquant 1 ou plusieurs espaces successifs\n# Le gsub remplace 1 ou plusieurs espaces successifs par un seul espace\n# trimws enlève les espaces au début et à la fin d'une chaîne de caractère \ntexte &lt;- gsub(\"\\\\s+\", \" \", trimws(texte))\n# Concaténer des chaînes de caractères\npaste(texte1, texte2, sep = \" \")\npaste0(texte1, texte2)\n\n\n# Extraire les 2e, 3e et 4e caractères de texte\n# 2 correspond à la position du 1er caractère à récupérer, 5 la position du dernier caractère\nextrait &lt;- substr(texte, 2, 5)\n\n# Transformer plusieurs caractères différents\nchaine &lt;- \"éèêëàâçîô\"\nchartr(\"éèêëàâçîô\", \"eeeeaacio\", chaine)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#découper-une-chaîne-de-caractères-selon-un-caractère-donné",
    "href": "01-aide_memoire_r_sas.html#découper-une-chaîne-de-caractères-selon-un-caractère-donné",
    "title": "Aide-mémoire SAS - R",
    "section": "9.4 Découper une chaîne de caractères selon un caractère donné",
    "text": "9.4 Découper une chaîne de caractères selon un caractère donné\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Afficher tous les mots d'une phrase : découper une phrase selon les espaces pour isoler les mots */\ndata Mots;\n  delim = \" \";\n  Texte = \"Mon texte va être coupé !\";\n  /* Chaque mot dans une variable */\n  %macro Decouper;\n    %do i = 1 %to %sysfunc(countw(Texte, delim));\n      Mot&i. = scan(Texte, &i., delim);\n    %end;\n  %mend Decouper;\n  %Decouper;\n  /* Les mots empilés */\n  nb_mots = countw(Texte, delim);\n  do nb = 1 to nb_mots;\n    mots = scan(Texte, nb, delim);\n    output;\n  end;\nrun;\nproc print data = Mots;run;\n\n\n\n# Découper uen chaîne de caractères selon un caractère donné\n# Afficher tous les mots d'une phrase : découper une phrase selon les espaces pour isoler les mots\nchaine  &lt;- \"Mon texte va être coupé !\"\nunlist(strsplit(chaine, split = \" \"))\n\n\n\n\n# Découper une chaîne de caractères selon un caractère donné\n# Afficher tous les mots d'une phrase : découper une phrase selon les espaces pour isoler les mots\nchaine  &lt;- \"Mon texte va être coupé !\"\nstr_split(chaine, pattern = \" \") %&gt;% unlist()\n\n\n\n\n# Découper uen chaîne de caractères selon un caractère donné\n# Afficher tous les mots d'une phrase : découper une phrase selon les espaces pour isoler les mots\nchaine  &lt;- \"Mon texte va être coupé !\"\nunlist(strsplit(chaine, split = \" \"))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#inverser-une-chaîne-de-caractères",
    "href": "01-aide_memoire_r_sas.html#inverser-une-chaîne-de-caractères",
    "title": "Aide-mémoire SAS - R",
    "section": "9.5 Inverser une chaîne de caractères",
    "text": "9.5 Inverser une chaîne de caractères\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata Mots;\n  Texte = \"Mon texte va être coupé !\";\n  x = left(reverse(Texte));\nrun;\nproc print data = Mots;run;\n\n\n\ninverserTexte &lt;- function(x) {\n  sapply(\n    lapply(strsplit(x, NULL), rev),\n    paste, collapse = \"\")\n  }\ninverserTexte(chaine)\n\n\n\n\nlibrary(stringi)\nstringi::stri_reverse(chaine)\n\n\n\n\ninverserTexte &lt;- function(x) {\n  sapply(\n    lapply(strsplit(x, NULL), rev),\n    paste, collapse = \"\")\n}\ninverserTexte(chaine)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#numéroter-les-lignes",
    "href": "01-aide_memoire_r_sas.html#numéroter-les-lignes",
    "title": "Aide-mémoire SAS - R",
    "section": "10.1 Numéroter les lignes",
    "text": "10.1 Numéroter les lignes\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata donnees_sas;\n  set donnees_sas;\n  Num_observation = _n_;\nrun;\n/* Autre solution */\nproc sql noprint;select count(*) into :nbLignes from donnees_sas;quit;\ndata numLigne;do Num_observation = 1 to &nbLignes.;output;end;run;\ndata _NULL_;\n  set donnees_sas nobs = n;\n  call symputx('nbLignes', n);\nrun;\n%put Nombre de lignes : &nbLignes.;\n/* Le merge \"simple\" (sans by) va seulement concaténer les deux bases l'une à côté de l'autre */\ndata donnees_sas;\n  merge donnees_sas numLigne;\nrun;\n\n\n\n# Numéro de l'observation : 2 manières différentes\ndonnees_rbase$num_observation &lt;- row.names(donnees_rbase)\ndonnees_rbase$num_observation &lt;- seq(1 : nrow(donnees_rbase))\n\n# Numéro du contrat de chaque individu, contrat trié par date de survenue\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\ndonnees_rbase$un &lt;- 1\ndonnees_rbase$numero_contrat &lt;- ave(donnees_rbase$un, donnees_rbase$identifiant, FUN = cumsum)\ndonnees_rbase$un &lt;- NULL\n# Autre solution\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\ndonnees_rbase$numero_contrat &lt;- as.numeric(ave(donnees_rbase$identifiant, donnees_rbase$identifiant, FUN = seq_along))\n# Autre solution : order pour éviter le as.numeric\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\ndonnees_rbase$numero_contrat &lt;- ave(order(donnees_rbase$date_entree), donnees_rbase$identifiant, FUN = seq_along)\n#https://stackoverflow.com/questions/11996135/create-a-sequential-number-counter-for-rows-within-each-group-of-a-dataframe\n#https://stackoverflow.com/questions/13732062/what-are-examples-of-when-seq-along-works-but-seq-produces-unintended-results\n\n\n\n\n# Numéro de l'observation\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  mutate(num_observation = row_number())\n\n# Numéro du contrat de chaque individu, contrat trié par date de survenue\n# arrange() va permettre de trier les observations par identifiant et date d'entrée \ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  mutate(numero_contrat = row_number()) %&gt;% \n  ungroup()\n# À FAIRE : Dans group_by, à quoi sert le drop ?\n\n\n\n\n# Numéro de l'observation : 2 manières différentes\ndonnees_datatable[, num_observation := .I]\ndonnees_datatable[, num_observation := seq_len(.N)]\n\n# Numéro du contrat de chaque individu, contrat trié par date de survenue\nsetorder(donnees_datatable, \"identifiant\", \"date_entree\", na.last = FALSE)\ndonnees_datatable[, numero_contrat := rowid(identifiant)]\ndonnees_datatable[, numero_contrat := seq_len(.N), by = identifiant]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#numéro-de-contrat-par-individu",
    "href": "01-aide_memoire_r_sas.html#numéro-de-contrat-par-individu",
    "title": "Aide-mémoire SAS - R",
    "section": "10.2 Numéro de contrat par individu",
    "text": "10.2 Numéro de contrat par individu\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc sort data = donnees_sas;by identifiant date_entree;run;\n/* L'instruction options permet de ne pas afficher d'erreur si la variable numero_contrat n'existe pas */\noptions dkricond=nowarn dkrocond=nowarn;\ndata donnees_sas;\n  set donnees_sas (drop = numero_contrat);\n  by identifiant date_entree;\n  retain numero_contrat 0;\n  if first.identifiant then numero_contrat = 1;\n  else                      numero_contrat = numero_contrat + 1;\nrun;\noptions dkricond=warn dkrocond=warn;\n/* Pour trier les colonnes */\ndata donnees_sas;\n  retain identifiant date_entree numero_contrat numero_contrat;\n  set donnees_sas;\nrun;\n\n\n\n# 1ère ligne par identifiant\ndonnees_rbase[!duplicated(donnees_rbase$identifiant), , drop = FALSE]\n\n# Dernière ligne par identifiant\ndonnees_rbase[!duplicated(donnees_rbase$identifiant, fromLast = TRUE), , drop = FALSE]\n\n\n\n\n# 1ère ligne par identifiant\ndonnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;%\n  filter(row_number() == 1) %&gt;% \n  ungroup()\n# Autres solutions\ndonnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;%\n  slice(1) %&gt;% \n  ungroup()\ndonnees_tidyverse %&gt;%  \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;%\n  slice_head(n = 1) %&gt;% \n  ungroup()\ndonnees_tidyverse %&gt;%  \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;%\n  filter(row_number() == nth(row_number(), 1)) %&gt;%\n  ungroup()\n\n# Dernière ligne par identifiant\ndonnees_tidyverse %&gt;% \ngroup_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;%\n  filter(row_number() == n()) %&gt;% \n  ungroup()\n# Autres solutions\ndonnees_tidyverse %&gt;%  \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;%\n  slice(n()) %&gt;% \n  ungroup()\ndonnees_tidyverse %&gt;%  \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;%\n  filter(row_number() == nth(row_number(), -1)) %&gt;%\n  ungroup()\n\n\n\n\n# Extraire la 1ère ligne par identifiant\ndonnees_datatable[, .SD[1], by = identifiant]\n\n# Extraire la dernière ligne par identifiant\ndonnees_datatable[, .SD[.N], by = identifiant]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#le-premier-contrat-le-dernier-contrat-ni-le-premier-ni-le-dernier-contrat-de-chaque-individu",
    "href": "01-aide_memoire_r_sas.html#le-premier-contrat-le-dernier-contrat-ni-le-premier-ni-le-dernier-contrat-de-chaque-individu",
    "title": "Aide-mémoire SAS - R",
    "section": "10.3 Le premier contrat, le dernier contrat, ni le premier ni le dernier contrat de chaque individu …",
    "text": "10.3 Le premier contrat, le dernier contrat, ni le premier ni le dernier contrat de chaque individu …\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc sort data = donnees_sas;by identifiant date_entree;run;\ndata donnees_sas;\n  set donnees_sas;\n  by identifiant date_entree;\n  Premier_Contrat = (first.identifiant = 1);\n  Dernier_Contrat = (last.identifiant = 1);\n  Ni_Prem_Ni_Der  = (first.identifiant = 0 and last.identifiant = 0);\nrun;\n\n/* Créer une base avec les seuls premiers contrats, et une base avec les seuls derniers contrats */\nproc sort data = donnees_sas;by identifiant date_entree;run;\n/* Création de 2 bases en une seule étape */\ndata Premier_Contrat Dernier_Contrat;\n  set donnees_sas;\n  by identifiant date_entree;\n  if first.identifiant then output Premier_Contrat;\n  if last.identifiant then output Dernier_Contrat;\nrun;\n\n\n\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\ndonnees_rbase$premier_contrat &lt;- ifelse(!duplicated(donnees_rbase$identifiant, fromLast = FALSE), 1, 0)\ndonnees_rbase$dernier_contrat &lt;- ifelse(!duplicated(donnees_rbase$identifiant, fromLast = TRUE), 1, 0)\ndonnees_rbase$ni_prem_ni_der  &lt;- ifelse(! c(!duplicated(donnees_rbase$identifiant, fromLast = FALSE) | !duplicated(donnees_rbase$identifiant, fromLast = TRUE)), 1, 0)\n\n# Créer une base avec les seuls premiers contrats, et une base avec les seuls derniers contrats\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\npremier_contrat &lt;- donnees_rbase[!duplicated(donnees_rbase$identifiant, fromLast = FALSE), ]\ndernier_contrat &lt;- donnees_rbase[!duplicated(donnees_rbase$identifiant, fromLast = TRUE), ]\nni_prem_ni_der  &lt;- donnees_rbase[! (!duplicated(donnees_rbase$identifiant, fromLast = FALSE) | !duplicated(donnees_rbase$identifiant, fromLast = TRUE)), ]\n\n\n\n\n# Premier contrat\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  group_by(identifiant) %&gt;% \n  mutate(premier_contrat = ifelse(row_number() == 1, 1, 0)) %&gt;% \n  ungroup()\n# Dernier contrat\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  group_by(identifiant) %&gt;% \n  mutate(dernier_contrat = ifelse(row_number() == n(), 1, 0)) %&gt;% \n  ungroup()\n# Ni le premier, ni le dernier contrat\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  group_by(identifiant) %&gt;% \n  mutate(ni_prem_ni_der = ifelse( ! (row_number() == n() | row_number() == 1), 1, 0)) %&gt;% \n  ungroup()\n\n# Créer une base avec les seuls premiers contrats, et une base avec les seuls derniers contrats\n# Premier contrat\npremier_contrat &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  group_by(identifiant) %&gt;% \n  mutate(premier_contrat = ifelse(row_number() == 1, 1, 0)) %&gt;% \n  ungroup()\n# Dernier contrat\ndernier_contrat &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  group_by(identifiant) %&gt;% \n  mutate(dernier_contrat = ifelse(row_number() == n(), 1, 0)) %&gt;% \n  ungroup()\n# Ni le premier, ni le dernier contrat\nni_prem_ni_der &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  group_by(identifiant) %&gt;% \n  mutate(ni_prem_ni_der = ifelse( ! (row_number() == n() | row_number() == 1), 1, 0)) %&gt;% \n  ungroup()\n\n\n\n\ndonnees_datatable &lt;- donnees_datatable[order(identifiant, date_entree, na.last = FALSE)]\ndonnees_datatable[, premier_contrat := fifelse(!duplicated(identifiant, fromLast = FALSE), 1, 0)]\ndonnees_datatable[, dernier_contrat := fifelse(!duplicated(identifiant, fromLast = TRUE), 1, 0)]\ndonnees_datatable[, ni_prem_ni_der := fifelse(! c(!duplicated(identifiant, fromLast = FALSE) | !duplicated(identifiant, fromLast = TRUE)), 1, 0)]\n\n# Créer une base avec les seuls premiers contrats, et une base avec les seuls derniers contrats\ndonnees_datatable &lt;- donnees_datatable[order(identifiant, date_entree, na.last = FALSE)]\npremier_contrat &lt;- donnees_datatable[!duplicated(identifiant, fromLast = FALSE), ]\ndernier_contrat &lt;- donnees_datatable[!duplicated(identifiant, fromLast = TRUE), ]\nni_prem_ni_der  &lt;- donnees_datatable[! (!duplicated(identifiant, fromLast = FALSE) | !duplicated(identifiant, fromLast = TRUE)), ]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#les-2-premières-dernières-lignes-de-chaque-identifiant",
    "href": "01-aide_memoire_r_sas.html#les-2-premières-dernières-lignes-de-chaque-identifiant",
    "title": "Aide-mémoire SAS - R",
    "section": "10.4 Les 2 premières / dernières lignes de chaque identifiant",
    "text": "10.4 Les 2 premières / dernières lignes de chaque identifiant\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Les 2 premières lignes de chaque identifiant */\nproc sort data = donnees_sas;by identifiant numero_contrat;run;\nproc sql;\n  select * from donnees_sas group by identifiant\n  having numero_contrat &lt;= 2;\nquit;\n/* Les 2 dernières lignes de chaque identifiant */\nproc sort data = donnees_sas;by identifiant numero_contrat;run;\nproc sql;\n  select * from donnees_sas group by identifiant\n  having numero_contrat &gt;= count(*) - 1;\nquit;\n\n\n\n# 2 premières lignes par identifiant (le premier si une seule ligne)\n# Peut-on le faire en moins d'étapes ??? Avec head ?\ndonnees_rbase$a &lt;- 1\ndonnees_rbase$numero_contrat &lt;- ave(donnees_rbase$a, donnees_rbase$identifiant, FUN = cumsum)\ndeux_premieres_lignes &lt;- donnees_rbase[which(donnees_rbase$numero_contrat &lt;= 2), ]\ndonnees_rbase$a &lt;- NULL\n# REVOIR\n#donnees_rbase[ave(rep(TRUE, nrow(donnees_rbase)), donnees_rbase$identifiant, FUN = function(z) seq_along(z) == 2L)]\n#ind &lt;- donnees_rbase[ave(rep(TRUE, nrow(donnees_rbase)), donnees_rbase$identifiant, FUN = function(z) length(z) == 1L | seq_along(z) == 2L)]\n\n\n\n\n# Les deux premières lignes\ndeux_premieres_lignes &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  group_by(identifiant) %&gt;% \n  slice(1:2) %&gt;% \n  ungroup()\n# Les deux dernières lignes\ndeux_dernieres_lignes &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  group_by(identifiant) %&gt;% \n  slice(n() - 2) %&gt;% \n  ungroup()\n\n\n\n\ndeux_premieres_lignes &lt;- donnees_datatable[, .SD[1:2], by = identifiant]\ndeux_dernieres_lignes &lt;- donnees_datatable[, .SD[.N-2:.N], by = identifiant]\n# Version en R Base\n#https://stackoverflow.com/questions/14800161/select-the-top-n-values-by-group",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#e-ligne-de-lindividu-et-rien-si-lindividu-a-1-seule-ligne",
    "href": "01-aide_memoire_r_sas.html#e-ligne-de-lindividu-et-rien-si-lindividu-a-1-seule-ligne",
    "title": "Aide-mémoire SAS - R",
    "section": "10.5 2e ligne de l’individu (et rien si l’individu a 1 seule ligne)",
    "text": "10.5 2e ligne de l’individu (et rien si l’individu a 1 seule ligne)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc sort data = donnees_sas;by identifiant date_entree;run;\ndata donnees_sas;\n  set donnees_sas;\n  by identifiant date_entree;\n  retain numero_contrat 0;\n  if first.identifiant then numero_contrat = 1;\n  else                      numero_contrat = numero_contrat + 1;\nrun;\ndata Deuxieme_Contrat;\n  set donnees_sas;\n  if numero_contrat = 2;\nrun;\ndata Deuxieme_Contrat;\n  set donnees_sas (where = (numero_contrat = 2));\nrun;\n\n\n\n# Avec le numéro de contrat\ndeuxieme_ligne &lt;- donnees_rbase[donnees_rbase$numero_contrat == 2, ]\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\n# Autre solution\ndonnees_rbase[unlist(tapply(seq_len(nrow(donnees_rbase)), donnees_rbase$identifiant, function(x) x[length(x)-(length(x)-1)])), ]\n\n\n\n\ndonnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  filter(row_number() == 2) %&gt;% \n  ungroup()\n\n\n\n\ndeuxieme_ligne &lt;- donnees_datatable[, .SD[2], by = identifiant]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#lavant-dernière-ligne-de-lindividu-et-rien-si-lindividu-a-1-seul-contrat",
    "href": "01-aide_memoire_r_sas.html#lavant-dernière-ligne-de-lindividu-et-rien-si-lindividu-a-1-seul-contrat",
    "title": "Aide-mémoire SAS - R",
    "section": "10.6 L’avant-dernière ligne de l’individu (et rien si l’individu a 1 seul contrat)",
    "text": "10.6 L’avant-dernière ligne de l’individu (et rien si l’individu a 1 seul contrat)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Nécessite d'avoir le numéro du contrat */\nproc sql;\n  select * from donnees_sas group by identifiant\n  having numero_contrat = count(*) - 1;\nquit;\n\n\n\ndonnees_rbase[unlist(tapply(seq_len(nrow(donnees_rbase)), donnees_rbase$identifiant, function(x) x[length(x)-1])), ]\n\n\n\n\ndonnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  filter(row_number() == nth(row_number(), -2))\n\n\n\n\ndonnees_datatable[, .SD[.N-1], by = identifiant]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélection-par-groupement",
    "href": "01-aide_memoire_r_sas.html#sélection-par-groupement",
    "title": "Aide-mémoire SAS - R",
    "section": "10.7 Sélection par groupement",
    "text": "10.7 Sélection par groupement\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Personnes qui ont eu au moins une entrée en 2022 */\nproc sql;\n  select *\n  from donnees_sas\n  group by identifiant\n  having sum(year(date_entree) = 2022) &gt;= 1;\nquit;\n\n/* Personnes qui ont suivi à la fois une formation qualifiée et une formation non qualifiée */\nproc sql;\n  create table Qualif_Non_Qualif as\n  select *\n  from donnees_sas\n  group by identifiant\n  having sum(Niveau = \"Non qualifie\") &gt;= 1 and sum(Niveau = \"Non qualifie\") &gt;= 1;\nquit;\n\n/* Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins ayant débuté en 2022 */\nproc sql;\n  create table Deux_Contrats as\n  select *\n  from donnees_sas\n  group by identifiant\n  having count(*) = 2 and sum(year(date_entree) = 2022) &gt;= 1;\nquit;\n\n\n\n# Personnes qui ont eu au moins une entrée en 2022\nauMoins2022 &lt;- subset(donnees_rbase, identifiant %in% unique(identifiant[lubridate::year(date_entree) %in% c(2022)]))\n# Autre solution : ne semble possible que pour une seule variable\nauMoins2022 &lt;- donnees_rbase[with(donnees_rbase, ave(lubridate::year(date_entree) %in% c(2022), identifiant, FUN = any)), ]\n\n# Personnes qui ont suivi à la fois une formation qualifiée et une formation non qualifiée\nqualif_non_qualif &lt;- subset(\n  transform(donnees_rbase, \n            qualif     = ave(niveau, identifiant, FUN = function(x) sum(ifelse(x == \"Qualifié\", 1, 0), na.rm = TRUE)), \n            non_qualif = ave(niveau, identifiant, FUN = function(x) sum(ifelse(x == \"Non Qualifié\", 1, 0), na.rm = TRUE))),\n  qualif &gt;= 1 & non_qualif &gt;= 1)\n# https://stackoverflow.com/questions/49669862/how-to-group-by-in-base-r\n\n# Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins ayant débuté en 2022\ndeux_contrats &lt;- subset(\n  transform(donnees_rbase, \n            nb = ave(identifiant, identifiant, FUN = length), \n            an = ave(date_entree, identifiant, FUN = function(x) sum(ifelse(lubridate::year(x) == 2022, 1, 0), na.rm = TRUE))),\n  nb == 2 & an &gt;= 1)\n\n\n\n\n# Personnes qui ont eu au moins une entrée en 2022\nauMoins2022 &lt;- donnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;%\n  filter(any(lubridate::year(date_entree) == 2022))\n\n# Personnes qui ont suivi à la fois une formation qualifiée et une formation non qualifiée\nqualif_non_qualif &lt;- donnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;%\n  filter(any(niveau == \"Qualifié\")) %&gt;% \n  filter(any(niveau == \"Non qualifié\")) %&gt;% \n  ungroup()\n\n# Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins ayant débuté en 2022\ndeux_contrats &lt;- donnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;%\n  filter(n() == 2) %&gt;% \n  filter(any(lubridate::year(date_entree) == 2022)) %&gt;%\n  ungroup()\n\n\n\n\n# Personnes qui ont eu au moins une entrée en 2022\nauMoins2022 &lt;- donnees_datatable[, if(any(lubridate::year(date_entree) %in% 2022)) .SD, by = identifiant]\n# Autre solution\nauMoins2022 &lt;- donnees_datatable[, if (sum(lubridate::year(date_entree) == 2022, na.rm = TRUE) &gt; 0) .SD, by = identifiant]\n\n\n# Personnes qui ont suivi à la fois une formation qualifiée et une formation non qualifiée\n# Group by et Having de SQL\n# https://github.com/Rdatatable/data.table/issues/788\n# 1ère méthode\ndonnees_datatable[, `:=` (qualif = sum(fifelse(niveau == \"Qualifié\", 1, 0), na.rm = TRUE),\n                          non_qualif = sum(fifelse(niveau == \"Non qualifié\", 1, 0), na.rm = TRUE)),\n                by = identifiant][qualif &gt; 0 & non_qualif &gt; 0]\n# 2e méthode un peu plus simple\ndonnees_datatable[, `:=` (qualif = sum(niveau == \"Qualifié\", na.rm = TRUE), non_qualif = sum(niveau == \"Non qualifié\", na.rm = TRUE)), by = identifiant][qualif &gt; 0 & non_qualif &gt; 0]\n# 3e méthode, plus simple !!\ndonnees_datatable[, if (sum(niveau == \"Qualifié\", na.rm = TRUE) &gt; 0 & sum(niveau == \"Non qualifié\", na.rm = TRUE) &gt; 0) .SD, by = identifiant]\n\n# Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins ayant débuté en 2022\ndonnees_datatable[, if (.N == 2 & sum(lubridate::year(date_entree) == 2022, na.rm = TRUE) &gt;= 1) .SD, by = identifiant]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#ajouter-une-colonne-désignant-la-note-moyenne-de-note_contenu-par-individu",
    "href": "01-aide_memoire_r_sas.html#ajouter-une-colonne-désignant-la-note-moyenne-de-note_contenu-par-individu",
    "title": "Aide-mémoire SAS - R",
    "section": "10.8 Ajouter une colonne désignant la note moyenne de Note_Contenu par individu",
    "text": "10.8 Ajouter une colonne désignant la note moyenne de Note_Contenu par individu\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* 1ère solution */\nproc sort data = donnees_sas;by identifiant;run;\nproc means data = donnees_sas mean noprint;\n  var Note_Contenu;by identifiant;output out = Temp;\nrun;\ndata Temp;\n  set Temp (where = (_STAT_ = \"MEAN\"));\n  keep identifiant Note_Contenu;\n  rename Note_Contenu = Note_Contenu_Moyenne;\nrun;\ndata donnees_sas;\n  merge donnees_sas (in = a) Temp (in = b);\n  by identifiant;\n  if a;\nrun;\n/* 2e solution : plus souple */\n/* Pour supprimer la variable ajoutée lors de la 1ère solution */\ndata donnees_sas;\n  set donnees_sas (drop = Note_Contenu_Moyenne);\nrun;\nproc sql;\n  create table donnees_sas as\n  select *\n  from donnees_sas a left join\n       (select identifiant, mean(Note_Contenu) as Note_Contenu_Moyenne\n        from donnees_sas group by identifiant) b\n       on a.identifiant = b.identifiant\n  order by identifiant;\nquit;\n\n\n\ndonnees_rbase &lt;- transform(donnees_rbase, \n                           note_contenu_moyenne = ave(note_contenu, identifiant, FUN = mean, na.rm = TRUE), \n                           note_contenu_somme   = ave(note_contenu, identifiant, FUN = sum,  na.rm = TRUE))\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  group_by(identifiant) %&gt;%\n  mutate(note_contenu_moyenne = mean(note_contenu, na.rm = TRUE),\n         note_contenu_somme   = sum(note_contenu, na.rm = TRUE)) %&gt;% \n  ungroup()\n\n\n\n\ndonnees_datatable[, `:=` (note_contenu_moyenne = mean(note_contenu, na.rm = TRUE),\n                          note_contenu_somme = sum(note_contenu, na.rm = TRUE)), by = identifiant]\n# Moyenne de chaque note\nnotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\ndonnees_datatable[, paste0(notes, \"_m\") := lapply(.SD, mean, na.rm = TRUE), .SDcols = notes, keyby = identifiant]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#variable-retardée-lag",
    "href": "01-aide_memoire_r_sas.html#variable-retardée-lag",
    "title": "Aide-mémoire SAS - R",
    "section": "10.9 Variable retardée (lag)",
    "text": "10.9 Variable retardée (lag)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* La date de fin du contrat précédent (lag) */\nproc sort data = donnees_sas;by identifiant date_entree;run;\ndata donnees_sasBon;\n  set donnees_sas;\n  by identifiant date_entree;  \n  format Date_fin_1 ddmmyy10.;\n  Date_fin_1 = lag(Date_sortie);\n  if first.identifiant then Date_fin_1 = .;\nrun;\n\n/* ATTENTION au lag DANS UNE CONDITION IF (cf. document) */\nproc sort data = donnees_sas;by identifiant date_entree;run;\ndata Lag_Bon;\n  set donnees_sas (keep = identifiant date_entree date_sortie);\n  format date_sortie_1 lag_faux lag_bon ddmmyy10.;\n  /* Erreur */\n  if date_entree = lag(date_sortie) + 1 then lag_faux = lag(date_sortie) + 1;\n  /* Bonne écriture */\n  date_sortie_1 = lag(date_sortie);\n  if date_entree = date_sortie_1 + 1 then lag_bon = date_sortie_1 + 1;\nrun;\n\n\n\n# La date de fin du contrat précédent\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\n# Il n'existe pas de fonction lag dans le R de base (à notre connaissance)\n# Il faut soit utiliser un package, soit utiliser cette astuce\ndonnees_rbase$date_sortie_1 &lt;- c(as.Date(NA), donnees_rbase$date_sortie[ 1:(length(donnees_rbase$date_sortie) - 1)])\n# Peut-on aussi utiliser tail(..., -1) ?\n\n# La date du contrat futur (lead)\ndonnees_rbase$date_sortie__1 &lt;- c(donnees_rbase$date_sortie[ 2:(length(donnees_rbase$date_sortie))], as.Date(NA))\n\n# Autres solutions\n#https://stackoverflow.com/questions/3558988/basic-lag-in-r-vector-dataframe\n\n\n\n\n# La date de fin du contrat précédent\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  mutate(date_sortie_1 = lag(date_sortie))\n\n# La date du contrat futur (lead)\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  mutate(date_sortie__1 = lead(date_sortie))\n\n\n\n\n# La date de fin du contrat précédent\nsetorderv(donnees_datatable, cols = c(\"identifiant\", \"date_entree\"), order = c(1L, 1L), na.last = FALSE)\ndonnees_datatable[, date_sortie_1 := shift(.SD, n = 1, fill = NA, \"lag\"), .SDcols = \"date_sortie\"]\ndonnees_datatable[, .(date_sortie, date_sortie_1)]\n\n# La date du contrat futur (lead)\nsetorderv(donnees_datatable, cols = c(\"identifiant\", \"date_entree\"), order = c(1L, 1L), na.last = FALSE)\ndonnees_datatable[, date_sortie__1 := shift(.SD, n = 1, fill = NA, \"lead\"), .SDcols = \"date_sortie\"]\ndonnees_datatable[, .(date_sortie, date_sortie__1)]\n\n# Autres solutions\n#https://stackoverflow.com/questions/3558988/basic-lag-in-r-vector-dataframe",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#transposer-une-base",
    "href": "01-aide_memoire_r_sas.html#transposer-une-base",
    "title": "Aide-mémoire SAS - R",
    "section": "10.10 Transposer une base",
    "text": "10.10 Transposer une base\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On commence déjà par calculer un tableau croisé comptant les occurrences */\nproc freq data = donnees_sas;table Sexef * cspf / out = Nb;run;\nproc sort data = Nb;by cspf Sexef;run;\nproc print data = Nb;run;\n/* On transpose le tableau */\nproc transpose data = Nb out = transpose;by cspf;var count;id Sexef;run;\ndata transpose;set transpose (drop = _name_ _label_);run;\nproc print data = transpose;run;\n\n\n\n# On commence déjà par calculer un tableau croisé comptant les occurrences\n# as.data.frame.matrix est nécessaire, car le résultat de xtabs est un array\nnb &lt;- as.data.frame.matrix(xtabs( ~ cspf + sexef, data = donnees_rbase))\n# On transpose le tableau\nnb_transpose &lt;- as.data.frame(t(nb))\n\n\n\n\n# On commence déjà par calculer un tableau croisé comptant les occurrences\nnb &lt;- donnees_tidyverse %&gt;% \n  count(cspf, sexef) %&gt;% \n  spread(sexef, n)\n# On transpose le tableau\nnb_transpose &lt;- nb %&gt;% \n  rownames_to_column() %&gt;% \n  gather(variable, value, -rowname) %&gt;%  \n  spread(rowname, value)\n# Autre solution avec les packages janitor et sjmisc\nlibrary(janitor)\nnb &lt;- donnees_tidyverse %&gt;%\n  janitor::tabyl(cspf, sexef) %&gt;% \n  # colonne cspf comme nom de ligne\n  column_to_rownames(var=\"cspf\")\n\nlibrary(sjmisc)\nnb_transpose &lt;- nb %&gt;%\n  sjmisc::rotate_df()\n\n\n\n\n# Etablissement d'un tableau croisé comptant les occurrences\nnb &lt;- donnees_datatable[, .N, by = list(cspf, sexef)]\n# On transpose le tableau\ndata.table::dcast(nb, cspf ~ sexef, value.var = \"N\")",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#passer-dune-base-en-largeur-wide-à-une-base-en-longueur-long",
    "href": "01-aide_memoire_r_sas.html#passer-dune-base-en-largeur-wide-à-une-base-en-longueur-long",
    "title": "Aide-mémoire SAS - R",
    "section": "10.11 Passer d’une base en largeur (wide) à une base en longueur (long)",
    "text": "10.11 Passer d’une base en largeur (wide) à une base en longueur (long)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let notes = note_contenu note_formateur note_moyens note_accompagnement note_materiel;\nproc sort data = donnees_sas;by identifiant;run;\nproc means data = donnees_sas mean noprint;var &notes.;output out = Temp;by identifiant;run;\ndata Wide;\n  set Temp (where = (_STAT_ = \"MEAN\") drop = _TYPE_ _FREQ_);\n  keep identifiant &notes.;\n  drop _STAT_;\nrun;\n/* On passe de Wide à Long */\nproc transpose data = Wide out = Long;by Identifiant;var &notes.;run;\n\n\n\n# On souhaite mettre les notes en ligne et non en colonne\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nwide_rbase &lt;- aggregate(donnees_rbase[, varNotes], donnees_rbase[, \"identifiant\", drop = FALSE], mean, na.rm = TRUE)\nlong_rbase &lt;- reshape(data = wide_rbase,\n                varying = varNotes, \n                v.names = \"notes\",\n                timevar = \"type_note\", \n                times = varNotes,\n                new.row.names = NULL,\n                direction = \"long\")\nlong_rbase &lt;- long_rbase[order(long_rbase$identifiant), ]\nrow.names(long_rbase) &lt;- NULL\n\n\n\n\n# On souhaite mettre les notes en ligne et non en colonne\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nwide_tidyverse &lt;- donnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;% \n  summarise(across(all_of(varNotes), ~ mean(.x, na.rm = TRUE)))\n# On l'exprime en format long\n# Mise en garde : ne pas écrire value_to !\nlong_tidyverse &lt;- wide_tidyverse %&gt;% \n  pivot_longer(cols = !identifiant,\n               names_to = \"type_note\",\n               values_to = \"note\") %&gt;% \n  arrange(type_note, identifiant)\n\n\n\n\n# On souhaite mettre les notes en ligne et non en colonne\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nwide_datatable &lt;- donnees_datatable[, lapply(.SD, mean, na.rm = TRUE), keyby = identifiant, .SDcols = varNotes]\nlong_datatable &lt;- melt(wide_datatable,\n                       id.vars = c(\"identifiant\"),\n                       measure.vars = varNotes,\n                       variable.name = \"type_note\",\n                       value.name = \"note\")",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#passer-base-en-longueur-long-à-une-base-en-largeur-wide",
    "href": "01-aide_memoire_r_sas.html#passer-base-en-longueur-long-à-une-base-en-largeur-wide",
    "title": "Aide-mémoire SAS - R",
    "section": "10.12 Passer base en longueur (long) à une base en largeur (wide)",
    "text": "10.12 Passer base en longueur (long) à une base en largeur (wide)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On souhaite mettre les notes en ligne et non en colonne */\n/* On commence par calculer les notes moyennes par identifiant */\n%let notes = note_contenu note_formateur note_moyens note_accompagnement note_materiel;\nproc sort data = donnees_sas;by identifiant;run;\nproc means data = donnees_sas mean noprint;var &notes.;output out = Temp;by identifiant;run;\ndata Wide;\n  set Temp (where = (_STAT_ = \"MEAN\") drop = _TYPE_ _FREQ_);\n  keep identifiant &notes.;\n  drop _STAT_;\nrun;\n/* On passe de Wide à Long */\nproc transpose data = Wide out = Long;by Identifiant;var &notes.;run;\ndata Long;set Long (rename = (_NAME_ = Type_Note COL1 = Note));run;\n/* On passe de Long à Wide */\nproc transpose data = Long out = Wide;\n  by Identifiant;\n  var Note;\n  id Type_Note;\nrun;\n\n\n\n# Passer de long à wide : on souhaite revenir à la situation initiale\nwide_rbase &lt;- reshape(long_rbase, \n                timevar = \"type_note\",\n                idvar = c(\"identifiant\", \"id\"),\n                direction = \"wide\")\n#https://stats.oarc.ucla.edu/r/faq/how-can-i-reshape-my-data-in-r/\n\n\n\n\n# Passer de long à wide : on souhaite revenir à la situation initiale\n# Mise en garde : ne pas écrire value_from !\nwide_tidyverse &lt;- pivot_wider(long_tidyverse, \n                              names_from = type_note,\n                              values_from = note)\n\n\n\n\nwide_datatable &lt;- dcast(long_datatable, identifiant ~ type_note, value.var = \"note\")",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-les-lignes-avec-au-moins-une-note-10",
    "href": "01-aide_memoire_r_sas.html#sélectionner-les-lignes-avec-au-moins-une-note-10",
    "title": "Aide-mémoire SAS - R",
    "section": "11.1 Sélectionner les lignes avec au moins une note < 10",
    "text": "11.1 Sélectionner les lignes avec au moins une note &lt; 10\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\ndata Note_Inferieure_10;\n  set donnees_sas;\n  %macro Inf10;\n    %global temp;\n    %let temp = ;\n    %do i = 1 %to %sysfunc(countw(&notes.));\n      %let j = %scan(&notes., &i.);\n      &j._inf_10 = (&j. &lt; 10 and not missing(&j.));\n      %let temp = &temp. &j._inf_10;\n    %end;\n  %mend Inf10;\n  %Inf10;\n  if sum(of &temp.) &gt;= 1;\n  drop &temp.;\nrun;\n\n\n\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\ndonnees_rbase[apply(donnees_rbase[, varNotes], 1, function(x) any(x &lt; 10, na.rm = TRUE)), ]\n\n\n\n\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\ndonnees_tidyverse %&gt;%\n  filter(if_any(varNotes, ~ .x &lt; 10))\n# Autre solution\ndonnees_tidyverse %&gt;%\n  filter_at(varNotes, any_vars(. &lt; 10))\n\n\n\n\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nnote_moins_10 &lt;- donnees_datatable[donnees_datatable[, .I[rowSums(.SD &lt; 10, na.rm = TRUE) &gt;= 1], .SDcols = varNotes]]\n# Autre solution\n# Le Reduce(`|`, ...) permet d'appliquer la condition | (ou) à tous les élements de la ligne, qui sont une vérification d'un nb &lt; 10\nnote_moins_10 &lt;- donnees_datatable[donnees_datatable[, Reduce(`|`, lapply(.SD, `&lt;`, 10)), .SDcols = varNotes]]\n\n# https://arelbundock.com/posts/datatable_rowwise/",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-les-lignes-avec-toutes-les-notes-supérieurs-à-10",
    "href": "01-aide_memoire_r_sas.html#sélectionner-les-lignes-avec-toutes-les-notes-supérieurs-à-10",
    "title": "Aide-mémoire SAS - R",
    "section": "11.2 Sélectionner les lignes avec toutes les notes supérieurs à 10",
    "text": "11.2 Sélectionner les lignes avec toutes les notes supérieurs à 10\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\ndata Note_Sup_10;\n  set donnees_sas;\n  %macro Inf10;\n    %global temp;\n    %let temp = ;\n    %do i = 1 %to %sysfunc(countw(&notes.));\n      %let j = %scan(&notes., &i.);\n      &j._sup_10 = (&j. &gt;= 10);\n      %let temp = &temp. &j._sup_10;\n    %end;\n  %mend Inf10;\n  %Inf10;\n  a = sum(of &temp.);\n  b = %sysfunc(countw(&notes.));\n  if sum(of &temp.) = %sysfunc(countw(&notes.));\n  drop &temp.;\nrun;\n\n\n\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\n# À FAIRE : REVOIR LE PB DES VALEURS MANQUANTES !!!!\ndonnees_rbase[apply(donnees_rbase[, varNotes], 1, function(x) all(x &gt;= 10, na.rm = TRUE)), ]\n\n\n\n\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\ndonnees_tidyverse %&gt;%\n  filter(if_all(varNotes, ~ . &gt;= 10))\n# Autre solution\ndonnees_tidyverse %&gt;%\n  filter_at(varNotes, all_vars(. &gt;= 10))\n\n\n\n\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nnote_sup_10 &lt;- donnees_datatable[\n  donnees_datatable[, .I[rowSums(.SD &gt;= 10, na.rm = TRUE) == length(varNotes)], .SDcols = varNotes]]\n# Autre solution\nnote_sup_10 &lt;- donnees_datatable[donnees_datatable[, Reduce(`&`, lapply(.SD, `&gt;=`, 10)), .SDcols = varNotes]]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#moyenne-par-ligne",
    "href": "01-aide_memoire_r_sas.html#moyenne-par-ligne",
    "title": "Aide-mémoire SAS - R",
    "section": "11.3 Moyenne par ligne",
    "text": "11.3 Moyenne par ligne\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Pour chaque observation, 5 notes sont renseignées. On calcule la moyenne de ces 5 notes pour chaque ligne */\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\ndata donnees_sas;\n  set donnees_sas;\n  /* 1ère solution */\n  Note_moyenne    = mean(of &notes.);\n  /* 2e solution : l'équivalent des list-comprehension de Python en SAS */\n  %macro List_comprehension;\n    Note_moyenne2 = mean(of %do i = 1 %to %sysfunc(countw(&notes.));\n                          %let j = %scan(&notes., &i.);\n                          &j.\n                         %end;);;\n  %mend List_comprehension;\n  %List_comprehension;\nrun;\n/* Note moyenne (moyenne des moyennes), non pondérée et pondérée */\nproc means data = donnees_sas mean;var Note_moyenne;run;\nproc means data = donnees_sas mean;var Note_moyenne;weight poids_sondage;run;\n\n\n\n# Pour chaque observation, 5 notes sont renseignées. On calcule la moyenne de ces 5 notes pour chaque ligne\nvarNotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\n# apply permet d'appliquer une fonctions aux lignes (1) ou colonnes (2) d'un data.frame\ndonnees_rbase$note_moyenne &lt;- apply(donnees_rbase[, varNotes], 1, mean, na.rm = TRUE)\n# Autre possibilité\ndonnees_rbase$note_moyenne &lt;- rowMeans(donnees_rbase[, varNotes], na.rm = TRUE)\n# Note moyenne (moyenne des moyennes), non pondérée et pondérée\nmean(donnees_rbase$note_moyenne, na.rm = TRUE)\nweighted.mean(donnees_rbase$note_moyenne, donnees_rbase$poids_sondage, na.rm = TRUE)\n\n\n\n\n# Pour chaque observation, 5 notes sont renseignées. On calcule la moyenne de ces 5 notes pour chaque ligne\nvarNotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\n# Codes à privilégier\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  mutate(note_moyenne = rowMeans(pick(all_of(varNotes)), na.rm = TRUE))\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  mutate(note_moyenne = rowMeans(across(all_of(varNotes)), na.rm = TRUE))\n# Alternative très lente !\n# Noter l'utilisation de c_across pour traiter automatiquement plusieurs variables\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  rowwise() %&gt;% \n  mutate(note_moyenne = mean(c_across(all_of(varNotes)), na.rm = TRUE)) %&gt;% \n  ungroup()\n\n\n# Note moyenne (moyenne des moyennes) non pondérée\ndonnees_tidyverse %&gt;% pull(note_moyenne) %&gt;% mean(na.rm = TRUE)\ndonnees_tidyverse %&gt;% summarise(Moyenne = mean(note_moyenne, na.rm = TRUE))\n# Note moyenne (moyenne des moyennes) pondérée\ndonnees_tidyverse %&gt;% summarise(Moyenne_ponderee = weighted.mean(note_moyenne, poids_sondage, na.rm = TRUE))\n\n\n\n\n# Pour chaque observation, 5 notes sont renseignées. On calcule la moyenne de ces 5 notes pour chaque ligne\nvarNotes &lt;- c(\"note_contenu\",\"note_formateur\",\"note_moyens\",\"note_accompagnement\",\"note_materiel\")\n# On souhaite moyenner les notes par formation\ndonnees_datatable[, note_moyenne := rowMeans(.SD, na.rm = TRUE), .SDcols = varNotes]\n# Manière alternative, qui ne semble pas fonctionner\n#donnees_datatable[, note_moyenne := Reduce(function(...) sum(..., na.rm = TRUE), .SD),\n#                  .SDcols = varNotes,\n#                  by = 1:nrow(donnees_datatable)]\n#donnees_datatable[, do.call(function(x, y) sum(x, y, na.rm = TRUE), .SD), .SDcols = varNotes, by = 1:nrow(donnees_datatable)]\n\n# Note moyenne (moyenne des moyennes), non pondérée et pondérée\ndonnees_datatable[, mean(note_moyenne, na.rm = TRUE)]\ndonnees_datatable[, weighted.mean(note_moyenne, poids_sondage, na.rm = TRUE)]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#la-note-donnée-est-elle-supérieure-à-la-moyenne",
    "href": "01-aide_memoire_r_sas.html#la-note-donnée-est-elle-supérieure-à-la-moyenne",
    "title": "Aide-mémoire SAS - R",
    "section": "11.4 La note donnée est-elle supérieure à la moyenne ?",
    "text": "11.4 La note donnée est-elle supérieure à la moyenne ?\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On crée une macro-variable SAS à partir de la valeur de la moyenne */\nproc sql noprint;select mean(Note_moyenne) into :moyenne from donnees_sas;quit;\ndata donnees_sas;\n  set donnees_sas;\n  Note_Superieure_Moyenne = (Note_moyenne &gt; &moyenne.);\nrun;\nproc freq data = donnees_sas;tables Note_Superieure_Moyenne;run;\n\n\n\nmoyenne &lt;- mean(donnees_rbase$note_moyenne, na.rm = TRUE)\ndonnees_rbase$note_superieure_moyenne &lt;- ifelse(donnees_rbase$note_moyenne &gt; moyenne, 1, 0)\ntable(donnees_rbase$note_superieure_moyenne, useNA = \"always\")\n\n\n\n\nmoyenne &lt;- donnees_tidyverse %&gt;% pull(note_moyenne) %&gt;% mean(na.rm = TRUE)\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% mutate(note_superieure_moyenne = ifelse(note_moyenne &gt; moyenne, 1, 0))\ndonnees_tidyverse %&gt;% pull(note_superieure_moyenne) %&gt;% table(useNA = \"always\")\n\n\n\n\nmoyenne &lt;- donnees_datatable[, mean(note_moyenne, na.rm = TRUE)]\ndonnees_datatable[, note_superieure_moyenne := fcase(note_moyenne &gt;= moyenne, 1,\n                                                     note_moyenne &lt;  moyenne, 0)]\ntable(donnees_datatable$note_superieure_moyenne, useNA = \"always\")",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#moyenne-par-ligne-1",
    "href": "01-aide_memoire_r_sas.html#moyenne-par-ligne-1",
    "title": "Aide-mémoire SAS - R",
    "section": "11.5 Moyenne par ligne",
    "text": "11.5 Moyenne par ligne\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On souhaite affecter les pondérations suivantes aux notes :\nNote_Contenu : 30%, Note_Formateur : 20%, Note_Moyens : 25%, Note_Accompagnement : 15%, Note_Materiel : 10% */\n/* Voici une solution possible. Une alternative intéressante serait de passer par IML (non traité ici) */\n%let ponderation = 0.3 0.2 0.25 0.15 0.10;\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\ndata donnees_sas;\n  set donnees_sas;\n  %macro Somme_pond;\n    %global temp;\n    %let temp = ;\n    %do i = 1 %to %sysfunc(countw(&notes.));\n      %let k = %scan(&notes., &i.);\n      %let l = %scan(&ponderation., &i., %str( ));\n      &k._pond = &k. * &l.;\n      %let temp = &temp. &k._pond;\n    %end;\n  %mend Somme_pond;\n  %Somme_pond;\n  Note_moyenne_pond = sum(of &temp.);\n  drop &temp.;\nrun;\nproc means data = donnees_sas mean;var Note_moyenne_pond;run;\n\n\n\n# On calcule de nouveau cette moyenne, mais en pondérant\n# On souhaite affecter les pondérations suivantes aux notes :\n# note_contenu : 30%, note_formateur : 20%, note_moyens : 25%, note_accompagnement : 15%, note_materiel : 10%\nnotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nponderation &lt;- c(note_contenu = 30, note_formateur = 20, note_moyens = 25, note_accompagnement = 15, note_materiel = 10) / 100\nsum(ponderation)\ndonnees_rbase$note_moyennepond &lt;- apply(donnees_rbase[, notes], 1, function(x) weighted.mean(x, ponderation, na.rm = TRUE))\n# Autre manière, en exploitant le calcul matriciel\n# Ne fonctionne pas, du fait des NA\nas.matrix(donnees_rbase[, notes]) %*% as.matrix(ponderation)\n# Produit élément par élément\n# On peut procéder par produit matriciel\nas.matrix(donnees_rbase[, notes]) * matrix(t(as.matrix(ponderation)), nrow(donnees_rbase), 5)\n\n\n\n\n# On calcule de nouveau cette moyenne, mais en pondérant\n# On souhaite affecter les pondérations suivantes aux notes :\n# note_contenu : 30%, note_formateur : 20%, note_moyens : 25%, note_accompagnement : 15%, note_materiel : 10%\n# La fonction RowMeans ne fonctionne plus, cette fois !\nnotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nponderation &lt;- c(note_contenu = 30, note_formateur = 20, note_moyens = 25, note_accompagnement = 15, note_materiel = 10) / 100\nsum(ponderation)\n# Noter l'utilisation de c_across pour traiter automatiquement plusieurs variables\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  rowwise() %&gt;%\n  mutate(note_moyenne = weighted.mean(c_across(varNotes), ponderation, na.rm = TRUE)) %&gt;% \n  ungroup()\n\n\n\n\n## On souhaite affecter les pondérations suivantes aux notes :\n## note_contenu : 30%, note_formateur : 20%, note_moyens : 25%, note_accompagnement : 15%, note_materiel : 10%\nnotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nponderation &lt;- c(note_contenu = 30, note_formateur = 20, note_moyens = 25, note_accompagnement = 15, note_materiel = 10) / 100\ndonnees_datatable[, note_moyenne_pond := rowSums(mapply(FUN = `*`, .SD, ponderation), na.rm = TRUE), .SDcols = names(ponderation)]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#repérer-les-valeurs-manquantes-variables-âge-et-niveau",
    "href": "01-aide_memoire_r_sas.html#repérer-les-valeurs-manquantes-variables-âge-et-niveau",
    "title": "Aide-mémoire SAS - R",
    "section": "12.1 Repérer les valeurs manquantes (variables Âge et Niveau)",
    "text": "12.1 Repérer les valeurs manquantes (variables Âge et Niveau)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata Missing;\n  set donnees_sas;\n  /* 1ère solution */\n  if missing(age) or missing(Niveau) then missing1 = 1;else missing1 = 0;\n  /* 2e solution */\n  if age = . or Niveau = '' then missing2 = 1;else missing2 = 0;\n  keep Age Niveau Missing1 Missing2;\nrun;\n\n\n\ndonnees_rbase$manquant &lt;- ifelse(is.na(donnees_rbase$age) | is.na(donnees_rbase$niveau), 1, 0)\n# Mauvaise méthode pour repérer les valeurs manquantes\nageManquant &lt;- donnees_rbase[donnees_rbase$age == NA,  ]\n# Bonne méthode pour repérer les valeurs manquantes\nageManquant &lt;- donnees_rbase[is.na(donnees_rbase$age), ]\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(manquant = ifelse(is.na(age) | is.na(niveau), 1, 0))\n\n# Mauvaise méthode pour repérer les valeurs manquantes\nageManquant &lt;- donnees_tidyverse %&gt;%\n  filter(age == NA)\n# Bonne méthode pour repérer les valeurs manquantes\nageManquant &lt;- donnees_tidyverse %&gt;%\n  filter(is.na(age))\n\n\n\n\ndonnees_datatable[, manquant := fifelse(is.na(donnees_datatable$age) | is.na(donnees_datatable$niveau), 1, 0)]\nageManquant &lt;- donnees_datatable[age == NA] # Faux\nageManquant &lt;- donnees_datatable[is.na(age)] # Correct",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#nombre-et-proportion-de-valeurs-manquantes-par-variable",
    "href": "01-aide_memoire_r_sas.html#nombre-et-proportion-de-valeurs-manquantes-par-variable",
    "title": "Aide-mémoire SAS - R",
    "section": "12.2 Nombre et proportion de valeurs manquantes par variable",
    "text": "12.2 Nombre et proportion de valeurs manquantes par variable\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Pour les variables numériques ou date */\n/* Partie \"Missing Values\" en bas du tableau consacré à la variable */\nproc univariate data = donnees_sas;var _numeric_;run;\n\n/* Pour l'ensemble des variables */\n/* Une solution possible */\n%macro Iteration(base = donnees_sas);\n  %local nbVar;\n  proc contents data = donnees_sas out = ListeVar noprint;run;\n  proc sql noprint;select count(*) into :nbVar from ListeVar;quit;\n  %do i = 1 %to &nbVar.;\n    data _null_;\n      set ListeVar (firstobs = &i. obs = &i.);\n      call symput('var', name);\n    run;\n    proc sql;\n      select max(\"&var.\") as Variable, sum(missing(&var.)) as Manquants, sum(missing(&var.)) / count(*) * 100 as Prop_Manquants\n      from &base.;\n    quit;\n  %end;\n  proc datasets lib = work nolist;delete ListeVar;run;\n%mend Iteration;\n%Iteration;\n\n\n\n# Pour les variables numériques ou date\napply(is.na(\n  donnees_rbase[sapply(donnees_rbase, function(x) is.numeric(x) | lubridate::is.Date(x))]\n  ), 2, mean) * 100\n# Autres solutions\nsapply(\n  donnees_rbase[sapply(donnees_rbase, function(x) is.numeric(x) | lubridate::is.Date(x))],\n  function(x) mean(is.na(x)) * 100)\nsapply(\n  donnees_rbase[sapply(donnees_rbase, function(x) is.numeric(x) | lubridate::is.Date(x))],\n  function(x) sum(is.na(x)) / length(x) * 100)\n\n# Pour l'ensemble des variables\ncolMeans(is.na(donnees_rbase)) * 100\napply(is.na(donnees_rbase), 2, mean) * 100\n\n\n\n\n# Pour les variables numériques ou date\ndonnees_tidyverse %&gt;%\n  summarise(across(where(~ is.numeric(.x) | lubridate::is.Date(.x)),\n                   list(~sum(is.na(.x)), ~mean(is.na(.x)))))\ndonnees_tidyverse %&gt;%\n  summarise(across(where(~ is.numeric(.x) | lubridate::is.Date(.x)),\n                   list(~sum(is.na(.x)), ~sum(is.na(.x)) / length(.x))))\n\n# Pour l'ensemble des variables\ndonnees_tidyverse %&gt;%\n  summarise(across(everything(), ~mean(is.na(.x))))\n# Autres solutions\ndonnees_tidyverse %&gt;% map(~ mean(is.na(.)) * 100)\n# Obsolète\ndonnees_tidyverse %&gt;% summarise_each(funs(mean(is.na(.)) * 100))\n\n\n\n\n# Pour les variables numériques ou date\ndonnees_datatable[, lapply(.SD, function(x) mean(is.na(x)) * 100), .SDcols = function(x) c(lubridate::is.Date(x) | is.numeric(x))]\n# Pour l'ensemble des variables\ndonnees_datatable[, lapply(.SD, function(x) mean(is.na(x)) * 100)]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#incidence-des-valeurs-manquantes",
    "href": "01-aide_memoire_r_sas.html#incidence-des-valeurs-manquantes",
    "title": "Aide-mémoire SAS - R",
    "section": "12.3 Incidence des valeurs manquantes",
    "text": "12.3 Incidence des valeurs manquantes\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* En SAS, les valeurs manquantes sont des nombres négatifs faibles */\ndata Valeur_Manquante;\n  set donnees_sas;\n  /* Lorsque Age est manquant (missing), Jeune_Correct vaut 0 mais Jeune_Incorrect vaut 1 */\n  /* En effet, pour SAS, un Age manquant est une valeur inférieure à 0, donc bien inférieure à 25.\n     Donc la variable Jeune_Incorrect vaut bien 1 pour les âges inconnus */\n  Jeune_Incorrect = (Age &lt;= 25);\n  Jeune_Correct   = (0 &lt;= Age &lt;= 25);\nrun;\nproc print data = Valeur_Manquante (keep  = Age Jeune_Correct Jeune_Incorrect\n                                    where = (missing(Age)));\nrun;\nproc freq data = Valeur_Manquante;tables Jeune_Incorrect Jeune_Correct;run;\n\n\n\nmean(donnees_rbase$note_formateur)\nmean(donnees_rbase$note_formateur, na.rm = TRUE)\n\n\n\n\ndonnees_tidyverse %&gt;% pull(note_formateur) %&gt;% mean()\ndonnees_tidyverse %&gt;% pull(note_formateur) %&gt;% mean(na.rm = TRUE)\n# Attention, en tidyverse, les syntaxes suivantes ne fonctionnent pas !\n# NE PAS ECRIRE !\n# donnees_tidyverse %&gt;% mean(note_formateur)\n# donnees_tidyverse %&gt;% mean(note_formateur, na.rm = TRUE)\n\n\n\n\ndonnees_datatable[, mean(note_formateur)]\ndonnees_datatable[, mean(note_formateur, na.rm = TRUE)]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#remplacer-toutes-les-valeurs-numériques-manquantes-par-0",
    "href": "01-aide_memoire_r_sas.html#remplacer-toutes-les-valeurs-numériques-manquantes-par-0",
    "title": "Aide-mémoire SAS - R",
    "section": "12.4 Remplacer toutes les valeurs numériques manquantes par 0",
    "text": "12.4 Remplacer toutes les valeurs numériques manquantes par 0\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On sélectionne toutes les variables numériques */\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql noprint;\n  select name into :nom_col separated by \" \" from Var where format = \"\";\nrun;\ndata donnees_sas_sans_missing;\n  set donnees_sas;\n  %macro Missing;\n    %local i var;\n    %do i = 1 %to %sysfunc(countw(&nom_col.));\n      %let var = %scan(&nom_col., &i);\n      if missing(&var.) then &var. = 0;\n    %end;\n  %mend Missing;\n  %Missing;\nrun;\nproc datasets lib = Work nolist;delete Var;run;\n\n\n\n# Dans le cas des dates, la valeur manquante a été remplacée par 1970-01-01\ndonnees_rbase_sans_na &lt;- donnees_rbase\ndonnees_rbase_sans_na[is.na(donnees_rbase_sans_na)] &lt;- 0\n# On remplace seulement les valeurs numériques par 0\ndonnees_rbase_sans_na &lt;- donnees_rbase\nvarNumeriques &lt;- names(donnees_rbase)[unlist(lapply(donnees_rbase, is.numeric))]\ndonnees_rbase_sans_na[, varNumeriques][is.na(donnees_rbase_sans_na[, varNumeriques])] &lt;- 0\n# Autre solution, avec replace\ndonnees_rbase_sans_na[, varNumeriques] &lt;- lapply(donnees_rbase_sans_na[, varNumeriques],\n                                                 function(x) {replace(x, is.na(x), 0)})\n\n\n\n\n# On remplace seulement les valeurs numériques par 0\ndonnees_tidyverse_sans_na &lt;- donnees_tidyverse %&gt;% \n  mutate(across(where(is.numeric), ~tidyr::replace_na(.x, 0)))\n# Autres façons d'écrire les fonctions anonymes\n# La méthode complète\ndonnees_tidyverse_sans_na &lt;- donnees_tidyverse %&gt;% \n  mutate(across(where(is.numeric), function(x) tidyr::replace_na(x, 0)))\n# Une autre façon de raccourcir (depuis R 4.1)\n# \\(x) est un raccourci pour function(x)\ndonnees_tidyverse_sans_na &lt;- donnees_tidyverse %&gt;% \n  mutate(across(where(is.numeric), \\(x) tidyr::replace_na(x, 0)))\n# Autre solution\ndonnees_tidyverse_sans_na &lt;- donnees_tidyverse %&gt;%\n  purrr::modify_if(is.numeric, ~tidyr::replace_na(.x, 0))\n\n\n\n\ndonnees_datatable_sans_na &lt;- copy(donnees_datatable)\nsetnafill(donnees_datatable[, .SD, .SDcols = is.numeric], fill = 0)\n# Autre solution\ndonnees_datatable_sans_na &lt;- copy(donnees_datatable)\ncols &lt;- colnames(donnees_datatable_sans_na[, .SD, .SDcols = is.numeric])\ndonnees_datatable_sans_na[, (cols) := lapply(.SD, function(x) fifelse(is.na(x), 0, x)), .SDcols = cols]\n# Ensemble des colonnes\ndonnees_datatable_sans_na &lt;- copy(donnees_datatable)\ndonnees_datatable_sans_na[is.na(donnees_datatable_sans_na)] &lt;- 0",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#remplacer-les-valeurs-manquantes-dune-seule-variable-par-0",
    "href": "01-aide_memoire_r_sas.html#remplacer-les-valeurs-manquantes-dune-seule-variable-par-0",
    "title": "Aide-mémoire SAS - R",
    "section": "12.5 Remplacer les valeurs manquantes d’une seule variable par 0",
    "text": "12.5 Remplacer les valeurs manquantes d’une seule variable par 0\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let var = note_contenu;\ndata donnees_sas_sans_missing;\n  set donnees_sas;\n  if missing(&var.) then &var. = 0;\n  /* Ou alors */\n  if &var. = . then &var. = 0;\n  /* Ou encore */\n  if note_contenu = . then note_contenu = 0;\nrun;\n\n\n\nvariable &lt;- \"note_contenu\"\ndonnees_rbase_sans_na &lt;- donnees_rbase\ndonnees_rbase_sans_na[, variable][is.na(donnees_rbase_sans_na[, variable])] &lt;- 0\ndonnees_rbase_sans_na[, variable] &lt;- replace(donnees_rbase_sans_na[, variable],\n                                             is.na(donnees_rbase_sans_na[, variable]), 0)\n# Ou alors\ndonnees_rbase_sans_na &lt;- donnees_rbase\ndonnees_rbase_sans_na$note_contenu[is.na(donnees_rbase_sans_na$note_contenu)] &lt;- 0\n\n\n\n\nvariable &lt;- \"note_contenu\"\ndonnees_tidyverse_sans_na &lt;- donnees_tidyverse %&gt;% \n  mutate(across(variable,  ~tidyr::replace_na(.x, 0)))\n# Ou alors\ndonnees_tidyverse_sans_na &lt;- donnees_tidyverse %&gt;% \n  mutate(note_contenu = tidyr::replace_na(note_contenu, 0))\n\n\n\n\nvariable &lt;- \"note_contenu\"\ndonnees_datatable[, replace(.SD, is.na(.SD), 0), .SDcols = variable]\ndonnees_datatable[, lapply(.SD, function(x) fifelse(is.na(x), 0, x)), .SDcols = variable]\ndonnees_datatable[, lapply(.SD, \\(x) fifelse(is.na(x), 0, x)), .SDcols = variable]\n# Ou alors\ndonnees_datatable[, replace(.SD, is.na(.SD), 0), .SDcols = \"note_contenu\"]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#doublons-pour-toutes-les-colonnes",
    "href": "01-aide_memoire_r_sas.html#doublons-pour-toutes-les-colonnes",
    "title": "Aide-mémoire SAS - R",
    "section": "13.1 Doublons pour toutes les colonnes",
    "text": "13.1 Doublons pour toutes les colonnes\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On extraie tous les doublons, pas la première occurrence */\n\n/* On récupère déjà la dernière variable de la base (on en aura besoin plus loin) */\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql noprint;\n  select name into :derniere_var\n  from Var\n  where varnum = (select max(varnum) from Var);\nquit;\nproc sort data = donnees_sas;by &nom_col.;run;\ndata Doublons;\n  set donnees_sas;\n  by &nom_col.;\n  if not (first.&derniere_var. and last.&derniere_var.);\nrun;\n\n\n\n# On extraie tous les doublons, pas la première occurrence\ndoublons &lt;- donnees_rbase[duplicated(donnees_rbase), ]\n\n\n\n\n# On extraie tous les doublons, pas la première occurrence\ndoublons &lt;- donnees_tidyverse %&gt;%  \n  group_by_all() %&gt;% \n  filter(n() &gt; 1) %&gt;%\n  slice(-1) %&gt;%\n  ungroup()\n\n\n\n\n# On extraie tous les doublons, pas la première occurrence\ndoublons &lt;- donnees_datatable[duplicated(donnees_datatable), ]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#doublons-pour-une-ou-plusieurs-colonnes",
    "href": "01-aide_memoire_r_sas.html#doublons-pour-une-ou-plusieurs-colonnes",
    "title": "Aide-mémoire SAS - R",
    "section": "13.2 Doublons pour une ou plusieurs colonnes",
    "text": "13.2 Doublons pour une ou plusieurs colonnes\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On extraie tous les doublons, pas la première occurrence */\n%let var = identifiant;\nproc sort data = donnees_sas;by &var.;run;\ndata doublons;\n  set donnees_sas;\n  by &var.;\n  if not first.&var.;\nrun;\n\n\n\n# On extraie tous les doublons, pas la première occurrence\nvariable &lt;- \"identifiant\"\ndoublons &lt;- donnees_rbase[duplicated(donnees_rbase[, variable]), ]\n\n\n\n\n# On extraie tous les doublons, pas la première occurrence\nvariable &lt;- \"identifiant\"\ndoublons &lt;- donnees_tidyverse %&gt;%  \n  group_by(across(variable)) %&gt;% \n  filter(n() &gt; 1) %&gt;%\n  slice(-1) %&gt;%\n  ungroup()\n\n\n\n\n# On extraie tous les doublons, pas la première occurrence\nvariable &lt;- \"identifiant\"\ndoublons &lt;- donnees_datatable[duplicated(donnees_datatable[, ..variable]), ]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#récupérer-toutes-les-lignes-pour-les-identifiants-en-doublon",
    "href": "01-aide_memoire_r_sas.html#récupérer-toutes-les-lignes-pour-les-identifiants-en-doublon",
    "title": "Aide-mémoire SAS - R",
    "section": "13.3 Récupérer toutes les lignes pour les identifiants en doublon",
    "text": "13.3 Récupérer toutes les lignes pour les identifiants en doublon\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let var = identifiant;\n/* On groupe par la colonne identifiant, et si on aboutit à strictement plus d'une ligne, c'est un doublon */\nproc sql;\n  create table enDouble as\n  select * from donnees_sas\n  group by &var.\n  having count(*) &gt; 1;\nquit;\n\n\n\nvariable &lt;- \"identifiant\"\nenDouble &lt;- donnees_rbase[donnees_rbase[, variable] %in%\n                            donnees_rbase[duplicated(donnees_rbase[, variable]), variable]]\n\n\n\n\nvariable &lt;- \"identifiant\"\nenDouble &lt;- donnees_tidyverse %&gt;%  \n  group_by(across(variable)) %&gt;% \n  filter(n() &gt; 1) %&gt;%\n  ungroup()\n\n\n\n\nvariable &lt;- \"identifiant\"\nenDouble &lt;- donnees_datatable[donnees_datatable[[variable]] %chin%\n                                donnees_datatable[[variable]][duplicated(donnees_datatable[[variable]])], ]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#récupérer-toutes-les-lignes-pour-les-identifiants-sans-doublon",
    "href": "01-aide_memoire_r_sas.html#récupérer-toutes-les-lignes-pour-les-identifiants-sans-doublon",
    "title": "Aide-mémoire SAS - R",
    "section": "13.4 Récupérer toutes les lignes pour les identifiants sans doublon",
    "text": "13.4 Récupérer toutes les lignes pour les identifiants sans doublon\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let var = identifiant;\nproc sql;\n  create table sansDouble as\n  select * from donnees_sas\n  group by &var.\n  having count(*) = 1;\nquit;\n\n\n\nvariable &lt;- \"identifiant\"\nsansDouble &lt;- donnees_rbase[! donnees_rbase[, variable] %in%\n                              donnees_rbase[duplicated(donnees_rbase[, variable]), variable]]\n\n\n\n\nvariable &lt;- \"identifiant\"\nsansDouble &lt;- donnees_tidyverse %&gt;%  \n  group_by(across(variable)) %&gt;% \n  filter(n() == 1) %&gt;%\n  ungroup()\n\n\n\n\nvariable &lt;- \"identifiant\"\nsansDouble &lt;- donnees_datatable[! donnees_datatable[[variable]] %chin%\n                                  donnees_datatable[[variable]][duplicated(donnees_datatable[[variable]])], ]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#suppression-des-doublons-pour-lensemble-des-variables",
    "href": "01-aide_memoire_r_sas.html#suppression-des-doublons-pour-lensemble-des-variables",
    "title": "Aide-mémoire SAS - R",
    "section": "13.5 Suppression des doublons pour l’ensemble des variables",
    "text": "13.5 Suppression des doublons pour l’ensemble des variables\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* 1ère méthode */\nproc sort data = donnees_sas nodupkey;\n  by _all_;\nrun;\n/* 2e méthode, avec first. et last. (cf. infra) */\n/* On récupère déjà la dernière variable de la base (on en aura besoin plus loin) */\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql noprint;\n  select name into :derniere_var from Var\n  where varnum = (select max(varnum) from Var);\nquit;\nproc sql noprint;\n  select name into :nom_col separated by \" \" from Var order by varnum;\nquit;\n%put Dernière variable de la base : &derniere_var.;\nproc sort data = donnees_sas;by &nom_col.;run;\ndata sansDouble;\n  set donnees_sas;\n  by &nom_col.;\n  if first.&derniere_var.;\nrun;\n\n\n\ndonnees_rbase_sansdoublon &lt;- donnees_rbase[! duplicated(donnees_rbase), ]\n# Autre solution (équivalente à la solution first. de SAS)\ndonnees_rbase_sansdoublon &lt;- donnees_rbase[order(colnames(donnees_rbase), na.last = FALSE), ]\ndonnees_rbase_sansdoublon &lt;- donnees_rbase[!duplicated(donnees_rbase[, colnames(donnees_rbase)], fromLast = TRUE), ]\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  arrange(pick(everything())) %&gt;% \n  distinct()\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  arrange(across(everything())) %&gt;% \n  distinct()\n\n\n\n\ndonnees_datatable &lt;- unique(donnees_datatable)\ndonnees_datatable &lt;- donnees_datatable[! duplicated(donnees_datatable), ]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#suppression-des-doublons-pour-une-seule-variable",
    "href": "01-aide_memoire_r_sas.html#suppression-des-doublons-pour-une-seule-variable",
    "title": "Aide-mémoire SAS - R",
    "section": "13.6 Suppression des doublons pour une seule variable",
    "text": "13.6 Suppression des doublons pour une seule variable\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc sort data = donnees_sas;by _all_;run;\ndata sansDouble;\n  set donnees_sas;\n  by _all_;\n  if first.identifiant;\nrun;\n\n\n\ndonnees_rbase_sansdoublon &lt;- donnees_rbase[order(colnames(donnees_rbase), na.last = FALSE), ]\ndonnees_rbase_sansdoublon &lt;- donnees_rbase_sansdoublon[!duplicated(donnees_rbase_sansdoublon$identifiant), , drop = FALSE]\n\n\n\n\n# L'option .keep_all = TRUE est nécessaire \n# À FAIRE : REVOIR LE TRI PAR RAPPORT A SAS !!!\nsansDouble &lt;- donnees_tidyverse %&gt;% \n  arrange(pick(everything())) %&gt;% \n  distinct(identifiant, .keep_all = TRUE)\nsansDouble &lt;- donnees_tidyverse %&gt;% \n  arrange(across(everything())) %&gt;% \n  distinct(identifiant, .keep_all = TRUE)\n\n\n\n\nsetorderv(donnees_datatable, cols = colnames(donnees_datatable), na.last = FALSE)\nsansDouble &lt;- donnees_datatable[! duplicated(donnees_datatable[, c(\"identifiant\")]), ]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#identifiants-uniques",
    "href": "01-aide_memoire_r_sas.html#identifiants-uniques",
    "title": "Aide-mémoire SAS - R",
    "section": "13.7 Identifiants uniques",
    "text": "13.7 Identifiants uniques\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc sql;\n  create table id as select distinct identifiant from donnees_sas order by identifiant;\nquit;\n\n\n\nunique(donnees_rbase[\"identifiant\"])\n\n\n\n\ndonnees_tidyverse %&gt;%\n  distinct(identifiant)\n\n\n\n\nunique(donnees_datatable[, \"identifiant\"])",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#nombre-de-lignes-uniques-sans-doublon",
    "href": "01-aide_memoire_r_sas.html#nombre-de-lignes-uniques-sans-doublon",
    "title": "Aide-mémoire SAS - R",
    "section": "13.8 Nombre de lignes uniques, sans doublon",
    "text": "13.8 Nombre de lignes uniques, sans doublon\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql noprint;select name into :nom_col separated by \", \" from Var order by varnum;quit;\nproc sql;\n  select count(*) as Nb_Lignes_Uniques\n  from (select &nom_col., count(*) from donnees_sas group by &nom_col.);\nquit;\n\n\n\nnrow(unique(donnees_rbase))\n\n\n\n\ndonnees_tidyverse %&gt;%\n  distinct() %&gt;% \n  nrow()\n\n\n\n\n# À FAIRE : pas sûr de moi\nuniqueN(donnees_datatable)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#importation-de-bases-pour-les-jointures",
    "href": "01-aide_memoire_r_sas.html#importation-de-bases-pour-les-jointures",
    "title": "Aide-mémoire SAS - R",
    "section": "14.1 Importation de bases pour les jointures",
    "text": "14.1 Importation de bases pour les jointures\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On suppose que l'on dispose d'une base supplémentaire avec les diplômes des personnes */\ndata Diplome;\n  infile cards dsd dlm='|';\n  format Identifiant $3. Diplome $20.;\n  input Identifiant $ Diplome $;\n  cards;\n  173|Bac\n  168|Bep-Cap\n  112|Bep-Cap\n  087|Bac+2\n  689|Bac+2\n  765|Pas de diplôme\n  113|Bac\n  999|Bac\n  554|Bep-Cap\n  ;\nrun;\n/* On suppose que l'on dispose aussi d'une base supplémentaire indiquant la date d'une entrevue avec un conseiller */\ndata Entrevue;\n  infile cards dsd dlm='|';\n  format Identifiant $3. Date_entrevue ddmmyy10.;\n  input Identifiant $ Date_entrevue ddmmyy10.;\n  cards;\n  173|06/08/2021\n  168|17/10/2019\n  087|12/06/2021\n  689|28/03/2018\n  099|01/09/2022\n  765|01/10/2020\n  ;\nrun;\n/* On récupère un extrait de la base initiale */\ndata Jointure;\n  set donnees_sas (keep = Identifiant Sexe date_entree date_sortie);\nrun;\n\n\n\n# On suppose que l'on dispose d'une base supplémentaire avec les diplômes des personnes\ndiplome_rbase &lt;- data.frame(identifiant = c(\"173\", \"168\", \"112\", \"087\", \"689\", \"765\", \"113\", \"999\", \"554\"),\n                      diplome = c(\"Bac\", \"Bep-Cap\", \"Bep-Cap\", \"Bac+2\", \"Bac+2\", \"Pas de diplôme\", \"Bac\", \"Bac\", \"Bep-Cap\"))\n# On suppose que l'on dispose d'une base supplémentaire indiquant la date d'une entrevue avec un conseiller\nentrevue_rbase &lt;- data.frame(identifiant = c(\"173\", \"168\", \"087\", \"689\", \"099\", \"765\"),\n                       date_entrevue = c(\"06/08/2021\", \"17/10/2019\", \"12/06/2021\", \"28/03/2018\", \"01/09/2022\", \"01/10/2020\"))\nentrevue_rbase$date_entrevue &lt;- lubridate::dmy(entrevue_rbase$date_entrevue)\n# On récupère un extrait de la base initiale\njointure_rbase &lt;- donnees_rbase[, c(\"identifiant\", \"sexe\", \"date_entree\", \"date_sortie\")]\n\n\n\n\n# On suppose que l'on dispose d'une base supplémentaire avec les diplômes des personnes\ndiplome_tidyverse &lt;-tibble(identifiant = c(\"173\", \"168\", \"112\", \"087\", \"689\", \"765\", \"113\", \"999\", \"554\"),\n                      diplome = c(\"Bac\", \"Bep-Cap\", \"Bep-Cap\", \"Bac+2\", \"Bac+2\", \"Pas de diplôme\", \"Bac\", \"Bac\", \"Bep-Cap\"))\n# On suppose que l'on dispose d'une base supplémentaire indiquant la date d'une entrevue avec un conseiller\nentrevue_tidyverse &lt;- tibble(identifiant = c(\"173\", \"168\", \"087\", \"689\", \"099\", \"765\"),\n                       date_entrevue = c(\"06/08/2021\", \"17/10/2019\", \"12/06/2021\", \"28/03/2018\", \"01/09/2022\", \"01/10/2020\"))\nentrevue_tidyverse &lt;- entrevue_tidyverse %&gt;% \n  mutate(date_entrevue = lubridate::dmy(date_entrevue))\n# On récupère un extrait de la base initiale\nvariable &lt;- c(\"identifiant\", \"sexe\", \"date_entree\", \"date_sortie\")\njointure_tidyverse &lt;- donnees_tidyverse %&gt;%\n  select(variable)\n\n\n\n\n# On suppose que l'on dispose d'une base supplémentaire avec les diplômes des personnes\ndiplome_datatable &lt;- data.table(identifiant = c(\"173\", \"168\", \"112\", \"087\", \"689\", \"765\", \"113\", \"999\", \"554\"),\n                                diplome = c(\"Bac\", \"Bep-Cap\", \"Bep-Cap\", \"Bac+2\", \"Bac+2\", \"Pas de diplôme\", \"Bac\", \"Bac\", \"Bep-Cap\"))\n# On suppose que l'on dispose d'une base supplémentaire indiquant la date d'une entrevue avec un conseiller\nentrevue_datatable &lt;- data.table(identifiant = c(\"173\", \"168\", \"087\", \"689\", \"099\", \"765\"),\n                                 date_entrevue = c(\"06/08/2021\", \"17/10/2019\", \"12/06/2021\", \"28/03/2018\", \"01/09/2022\", \"01/10/2020\"))\nentrevue_datatable[, date_entrevue := lubridate::dmy(date_entrevue)]\n# On récupère un extrait de la base initiale\njointure_datatable &lt;- donnees_datatable[, c(\"identifiant\", \"sexe\", \"date_entree\", \"date_sortie\")]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#inner-join-les-seuls-identifiants-communs-aux-deux-bases",
    "href": "01-aide_memoire_r_sas.html#inner-join-les-seuls-identifiants-communs-aux-deux-bases",
    "title": "Aide-mémoire SAS - R",
    "section": "14.2 Inner join : les seuls identifiants communs aux deux bases",
    "text": "14.2 Inner join : les seuls identifiants communs aux deux bases\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Le tri préalable des bases de données à joindre par la variable de jointure est nécessaire avec la stratégie merge */\nproc sort data = Diplome;by identifiant;run;\nproc sort data = Jointure;by identifiant;run;\ndata Inner_Join1;\n  merge Jointure (in = a) Diplome (in = b);\n  by identifiant;\n  if a and b;\nrun;\n/* Le tri préalable des bases de données à joindre n'est pas nécessaire avec la jointure SQL */\nproc sql;\n  create table Inner_Join2 as\n  select * from Jointure a inner join Diplome b on a.identifiant = b.identifiant\n  order by a.identifiant;\nquit;\nproc print data = Inner_Join1 (obs = 10);run;\nproc sql;select count(*) from Inner_Join1;quit;\nproc sql;select count(*) from Inner_Join2;quit;\n\n\n\n# Sont appariés les identifiants communs aux deux bases\ninnerJoin &lt;- merge(jointure_rbase, diplome_rbase, by.x = \"identifiant\", by.y = \"identifiant\")\ndim(innerJoin)\n\n\n\n\n# Sont appariés les identifiants communs aux deux bases\ninnerJoin &lt;- jointure_tidyverse %&gt;% \n  inner_join(diplome_tidyverse, by = \"identifiant\")\ndim(innerJoin)\n# Autres solutions\ninnerJoin &lt;- jointure_tidyverse %&gt;% \n  inner_join(diplome_tidyverse, by = join_by(identifiant == identifiant))\ndim(innerJoin)\ninnerJoin &lt;- inner_join(jointure_tidyverse, diplome_tidyverse, by = \"identifiant\")\ndim(innerJoin)\n\n\n\n\ninnerJoin &lt;- merge(jointure_datatable, diplome_datatable, by.x = \"identifiant\", by.y = \"identifiant\")\ninnerJoin &lt;- jointure_datatable[diplome_datatable, nomatch = 0, on = list(identifiant == identifiant)]\ninnerJoin &lt;- jointure_datatable[diplome_datatable, nomatch = 0, on = .(identifiant == identifiant)]\ndim(innerJoin)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#left-join-les-identifiants-de-la-base-de-gauche",
    "href": "01-aide_memoire_r_sas.html#left-join-les-identifiants-de-la-base-de-gauche",
    "title": "Aide-mémoire SAS - R",
    "section": "14.3 Left join : les identifiants de la base de gauche",
    "text": "14.3 Left join : les identifiants de la base de gauche\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Le tri préalable des bases de données à joindre par la variable de jointure est nécessaire avec la stratégie merge */\nproc sort data = Diplome;by identifiant;run;\nproc sort data = Jointure;by identifiant;run;\ndata Left_Join1;\n  merge Jointure (in = a) Diplome (in = b);\n  by identifiant;\n  if a;\nrun;\n/* Le tri préalable des bases de données à joindre n'est pas nécessaire avec la jointure SQL */\nproc sql;\n  create table Left_Join2 as\n  select * from Jointure a left join Diplome b on a.identifiant = b.identifiant\n  order by a.identifiant;\nquit;\nproc print data = Left_Join1 (obs = 10);run;\nproc sql;select count(*) from Left_Join1;quit;\nproc sql;select count(*) from Left_Join2;quit;\n\n\n\n# Sont appariés tous les identifiants de la base de gauche, et les correspondants éventuels de la base de droite\nleftJoin &lt;- merge(jointure_rbase, diplome_rbase, by.x = \"identifiant\", by.y = \"identifiant\", all.x = TRUE)\ndim(leftJoin)\n\n\n\n\n# Sont appariés tous les identifiants de la base de gauche, et les correspondants éventuels de la base de droite\nleftJoin &lt;- jointure_tidyverse %&gt;% \n  left_join(diplome_tidyverse, by = \"identifiant\")\ndim(leftJoin)\n# Autres solutions\nleftJoin &lt;- jointure_tidyverse %&gt;% \n  left_join(diplome_tidyverse, by = join_by(identifiant == identifiant))\ndim(leftJoin)\nleftJoin &lt;- left_join(jointure_tidyverse, diplome_tidyverse, by = \"identifiant\")\ndim(leftJoin)\n\n\n\n\nleftJoin &lt;- merge(jointure_datatable, diplome_datatable, by.x = \"identifiant\", by.y = \"identifiant\", all.x = TRUE)\ndim(leftJoin)\nleftJoin &lt;- diplome_datatable[jointure_datatable, on = .(identifiant == identifiant)]\ndim(leftJoin)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#right-join-les-identifiants-de-la-base-de-droite",
    "href": "01-aide_memoire_r_sas.html#right-join-les-identifiants-de-la-base-de-droite",
    "title": "Aide-mémoire SAS - R",
    "section": "14.4 Right join : les identifiants de la base de droite",
    "text": "14.4 Right join : les identifiants de la base de droite\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Le tri préalable des bases de données à joindre par la variable de jointure est nécessaire avec la stratégie merge */\nproc sort data = Diplome;by identifiant;run;\nproc sort data = Jointure;by identifiant;run;\ndata Right_Join1;\n  merge Jointure (in = a) Diplome (in = b);\n  by identifiant;\n  if b;\nrun;\n/* Le tri préalable des bases de données à joindre n'est pas nécessaire avec la jointure SQL */\nproc sql;\n  create table Right_Join2 as\n  select * from Jointure a right join Diplome b on a.identifiant = b.identifiant\n  order by a.identifiant;\nquit;\nproc print data = Right_Join1 (obs = 10);run;\nproc sql;select count(*) from Right_Join1;quit;\nproc sql;select count(*) from Right_Join2;quit;\n\n\n\n# Sont appariés tous les identifiants de la base de droite et les correspondants éventuels de la base de gauche\nrightJoin &lt;- merge(jointure_rbase, diplome_rbase, by.x = \"identifiant\", by.y = \"identifiant\", all.y = TRUE)\ndim(rightJoin)\n\n\n\n\n# Sont appariés tous les identifiants de la base de droite et les correspondants éventuels de la base de gauche\nrightJoin &lt;- jointure_tidyverse %&gt;% \n  right_join(diplome_tidyverse, by = \"identifiant\")\ndim(rightJoin)\n# Autre solution\nrightJoin &lt;- jointure_tidyverse %&gt;% \n  right_join(diplome_tidyverse, by = join_by(identifiant == identifiant))\ndim(rightJoin)\nrightJoin &lt;- right_join(jointure_tidyverse, diplome_tidyverse, by = \"identifiant\")\ndim(rightJoin)\n\n\n\n\nrightJoin &lt;- merge(jointure_datatable, diplome_datatable, by.x = \"identifiant\", by.y = \"identifiant\", all.y = TRUE)\ndim(rightJoin)\nrightJoin &lt;- jointure_datatable[diplome_datatable, on = .(identifiant == identifiant)]\ndim(rightJoin)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#full-join-les-identifiants-des-deux-bases",
    "href": "01-aide_memoire_r_sas.html#full-join-les-identifiants-des-deux-bases",
    "title": "Aide-mémoire SAS - R",
    "section": "14.5 Full join : les identifiants des deux bases",
    "text": "14.5 Full join : les identifiants des deux bases\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Le tri préalable des bases de données à joindre par la variable de jointure est nécessaire avec la stratégie merge */\nproc sort data = Diplome;by identifiant;run;\nproc sort data = Jointure;by identifiant;run;\ndata Full_Join1;\n  merge Jointure (in = a) Diplome (in = b);\n  by identifiant;\n  if a or b;\nrun;\n/* Le tri préalable des bases de données à joindre n'est pas nécessaire avec la jointure SQL */\nproc sql;\n  create table Full_Join2 as\n  select coalesce(a.identifiant, b.identifiant) as Identifiant, *\n  from Jointure a full outer join Diplome b on a.identifiant = b.identifiant\n  order by calculated identifiant;\nquit;\nproc print data = Full_Join1 (obs = 10);run;\nproc sql;select count(*) from Full_Join1;quit;\nproc sql;select count(*) from Full_Join2;quit;\n\n\n\n# Sont appariés les identifiants des deux bases\nfullJoin &lt;- merge(jointure_rbase, diplome_rbase, by.x = \"identifiant\", by.y = \"identifiant\", all = TRUE)\ndim(fullJoin)\n\n\n\n\n# Sont appariés les identifiants des deux bases\nfullJoin &lt;- jointure_tidyverse %&gt;% \n  full_join(diplome_tidyverse, by = \"identifiant\")\ndim(fullJoin)\n# Autre solution\nfullJoin &lt;- jointure_tidyverse %&gt;% \n  full_join(diplome_tidyverse, by = join_by(identifiant == identifiant))\ndim(fullJoin)\nfullJoin &lt;- full_join(jointure_tidyverse, diplome_tidyverse, by = \"identifiant\")\ndim(fullJoin)\n\n\n\n\nfullJoin &lt;- merge(jointure_datatable, diplome_datatable, by.x = \"identifiant\", by.y = \"identifiant\", all = TRUE)\ndim(fullJoin)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#jointure-de-3-bases-ou-plus-en-une-seule-opération-inner-join",
    "href": "01-aide_memoire_r_sas.html#jointure-de-3-bases-ou-plus-en-une-seule-opération-inner-join",
    "title": "Aide-mémoire SAS - R",
    "section": "14.6 Jointure de 3 bases ou plus en une seule opération (inner join)",
    "text": "14.6 Jointure de 3 bases ou plus en une seule opération (inner join)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc sort data = Jointure;by identifiant;run;\nproc sort data = Diplome;by identifiant;run;\nproc sort data = Entrevue;by identifiant;run;\ndata Inner_Join3;\n  merge Jointure (in = a) Diplome (in = b) Entrevue (in = c);\n  by identifiant;\n  if a and b and c;\nrun;\n/* Le tri préalable des bases de données à joindre n'est pas nécessaire avec la jointure SQL */\nproc sql;\n  create table Inner_Join4 as\n  select * from Jointure a inner join Diplome b on a.identifiant = b.identifiant\n                           inner join Entrevue c on a.identifiant = c.identifiant\n  order by a.identifiant;\nquit;\nproc print data = Inner_Join4 (obs = 10);run;\nproc sql;select count(*) from Inner_Join3;quit;\nproc sql;select count(*) from Inner_Join4;quit;\n\n\n\n# Via un inner join\n# Utilisation de la fonction Reduce\n# Elle applique successivement (et non simultanément, comme do.call) à tous les éléments d'une liste une fonction\ninnerJoin2 &lt;- Reduce(function(x, y) merge(x, y, all = FALSE, by.x = \"identifiant\", by.y = \"identifiant\"),\n                     list(jointure_rbase, diplome_rbase, entrevue_rbase))\ndim(innerJoin2)\n\n\n\n\n# Via un inner join\n# Utilisation de la fonction reduce de purrr\n# Elle applique successivement (et non simultanément, comme do.call) à tous les éléments d'une liste une fonction\ninnerJoin2 &lt;- list(jointure_tidyverse, diplome_tidyverse, entrevue_tidyverse) %&gt;%\n  purrr::reduce(dplyr::inner_join, by = join_by(identifiant == identifiant))\ndim(innerJoin2)\n\n\n\n\n# Utilisation de la fonction Reduce : elle applique successivement (et non simultanément, comme do.call) à tous les éléments d'une liste une fonction\ninnerJoin2 &lt;- Reduce(function(x, y) merge(x, y, all = FALSE, by.x = \"identifiant\", by.y = \"identifiant\"),\n                    list(jointure_datatable, diplome_datatable, entrevue_datatable))\ndim(innerJoin2)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#jointure-sur-inégalités",
    "href": "01-aide_memoire_r_sas.html#jointure-sur-inégalités",
    "title": "Aide-mémoire SAS - R",
    "section": "14.7 Jointure sur inégalités",
    "text": "14.7 Jointure sur inégalités\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On associe l'entrevue au contrat au cours duquel elle a eu lieu */\nproc sql;\n  create table Inner_Join_Inegalite as\n  select *\n  from Jointure a inner join Entrevue b\n       on a.identifiant = b.identifiant and a.date_entree &lt;= b.date_entrevue &lt;= a.date_sortie\n  order by a.identifiant;\nquit;\nproc print data = Inner_Join_Inegalite (obs = 10);run;\nproc sql;select count(*) from Inner_Join_Inegalite;quit;\n\n\n\n# Ne semble pas natif en R-Base.\n# Une proposition indicative où on applique la sélection après la jointure, ce qui ne doit pas être très efficace ...\ninnerJoinInegalite &lt;- merge(jointure_rbase, entrevue_rbase, by = \"identifiant\")\ninnerJoinInegalite &lt;- with(innerJoinInegalite,\n                           innerJoinInegalite[which(date_entree &lt;= date_entrevue & date_entrevue &lt;= date_sortie), ])\ndim(innerJoinInegalite)\n\n\n\n\n# Ne semble pas natif en R-Base.\n# Une proposition indicative où on applique la sélection après la jointure, ce qui ne doit pas être très efficace ...\ninnerJoinInegalite &lt;- jointure_tidyverse %&gt;% \n  inner_join(entrevue_tidyverse, join_by(identifiant == identifiant,\n                                         date_entree &lt;= date_entrevue,\n                                         date_sortie &gt;= date_entrevue))\ndim(innerJoinInegalite)\n\n\n\n\n# Attention, l'ordre des conditions doit correspondre à l'ordre des bases dans la jointure !\n# Il semble que l'on soit forcé de spécifier tous les noms des colonnes, et ce qui est un peu problématique ...\n# À FAIRE : Peut-on faire plus simplement ??\ninnerJoinInegalite &lt;- jointure_datatable[entrevue_datatable,\n                                         .(identifiant, sexe, date_entree, date_sortie, date_entrevue),\n                                         on = .(identifiant, date_entree &lt;= date_entrevue, date_sortie &gt;= date_entrevue),\n                                         nomatch = 0L\n                                         ][order(identifiant)]\ndim(innerJoinInegalite)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#cross-join-toutes-les-combinaisons-possibles-de-csp-sexe-et-diplome",
    "href": "01-aide_memoire_r_sas.html#cross-join-toutes-les-combinaisons-possibles-de-csp-sexe-et-diplome",
    "title": "Aide-mémoire SAS - R",
    "section": "14.8 Cross join : toutes les combinaisons possibles de CSP, sexe et Diplome",
    "text": "14.8 Cross join : toutes les combinaisons possibles de CSP, sexe et Diplome\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc sql;\n  create table CrossJoin as\n  select *\n  from (select distinct CSPF from donnees_sas)  cross join\n       (select distinct Sexef from donnees_sas) cross join\n       (select distinct Diplome from Diplome)\n  order by CSPF, Sexef, Diplome;\nquit;\nproc sql;select count(*) from CrossJoin;quit;\n\n\n\n# Toutes les combinaisons possibles de CSP, sexe et diplome\ncrossJoin &lt;- unique(expand.grid(donnees_rbase$cspf, donnees_rbase$sexef, diplome_rbase$diplome))\ncolnames(crossJoin) &lt;- c(\"cspf\", \"sexef\", \"diplome\")\ndim(crossJoin)\n# Autre solution\ncrossJoin2 &lt;- unique(merge(donnees_rbase[, c(\"cspf\", \"sexef\")], diplome_rbase[, \"diplome\"], by = NULL))\ndim(crossJoin2)\n# https://stackoverflow.com/questions/10600060/how-to-do-cross-join-in-r\n\n\n\n\n# Toutes les combinaisons possibles de CSP, sexe et diplome\ncrossJoin &lt;- donnees_tidyverse %&gt;%\n  select(cspf, sexef) %&gt;% \n  cross_join(diplome_tidyverse %&gt;% select(diplome)) %&gt;% \n  distinct()\ndim(crossJoin)\n# Autre solution\ncrossJoin &lt;- cross_join(donnees_tidyverse %&gt;% select(cspf, sexef), diplome_tidyverse %&gt;% select(diplome)) %&gt;% \n  distinct()\ndim(crossJoin)\n# Autre solution\ncrossJoin &lt;- donnees_tidyverse %&gt;% \n  tidyr::expand(cspf, sexef, diplome_tidyverse$diplome) %&gt;%\n  distinct()\ndim(crossJoin)\n\n\n\n\ncrossJoin &lt;- data.table::CJ(donnees_datatable$cspf, donnees_datatable$sexef, diplome_datatable$diplome, unique = TRUE)\ncolnames(crossJoin) &lt;- c(\"cspf\", \"sexef\", \"diplome\")\ndim(crossJoin)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#juxtaposer-côte-à-côte-deux-bases-de-données",
    "href": "01-aide_memoire_r_sas.html#juxtaposer-côte-à-côte-deux-bases-de-données",
    "title": "Aide-mémoire SAS - R",
    "section": "14.9 Juxtaposer côte à côte deux bases de données",
    "text": "14.9 Juxtaposer côte à côte deux bases de données\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On va ajouter le numéro de la ligne */\nproc sql noprint;select count(*) into :tot from donnees_sas;run;\ndata Ajout;do Num_ligne = 1 to &tot.;output;end;run;\n/* Le merge sans by va juxtaposer côte à côte les bases */\ndata Concatener;merge Ajout donnees_sas;run;\n/* Si l'une des bases comprend plus de ligne que l'autre, ajout d'une ligne de valeurs manquantes */\nproc sql noprint;select count(*) + 1 into :tot from donnees_sas;run;\ndata Ajout;do Num_ligne = 1 to &tot.;output;end;run;\ndata Concatener;merge Ajout donnees_sas;run;\n\n\n\n# On va ajouter le numéro de la ligne\n# cbind si les deux bases comprennent le même nombre de lignes\najout &lt;- data.frame(num_ligne = seq_len(nrow(donnees_rbase)))\nconcatener &lt;- cbind(ajout, donnees_rbase)\n# Erreur si l'une des bases comprend plus de lignes que l'autre\najout &lt;- data.frame(num_ligne = seq_len(nrow(donnees_rbase) + 1))\n# donnees_rbase_ajout &lt;- cbind(ajout, donnees_rbase)\n# Proposition de solution\ncbind_alt &lt;- function(liste) {\n  # Nombre maximal de colonnes dans la liste de dataframes\n  maxCol &lt;- max(unlist(lapply(liste, nrow)))\n  # Ajout d'une colonne de valeurs manquantes pour toutes les bases ayant moins de ligne que le maximum\n  res &lt;- lapply(liste, function(x) {\n    for (i in seq_len(maxCol - nrow(x))) {\n      x[nrow(x) + i, ] &lt;- NA\n    }\n    return(x)\n  })\n  # On joint les résultats\n  return(do.call(cbind, res))\n}\nconcatener &lt;- cbind_alt(list(ajout, donnees_rbase))\n\n\n\n\n# On va ajouter le numéro de la ligne\n# cbind si les deux bases comprennent le même nombre de lignes\najout &lt;- tibble(num_ligne = seq_len(nrow(donnees_tidyverse)))\nconcatener &lt;- donnees_tidyverse %&gt;% bind_cols(ajout)\n# Ne fonctionne si l'une des bases comprend plus de lignes que l'autre !\najout &lt;- tibble(num_ligne = seq_len(nrow(donnees_tidyverse) + 1))\n#concatener &lt;- donnees_tidyverse %&gt;% bind_cols(ajout)\n# cf. solution proposée dans R-Base\ncbind_alt &lt;- function(liste) {\n  # Nombre maximal de colonnes dans la liste de dataframes\n  maxCol &lt;- max(unlist(lapply(liste, nrow)))\n  # Ajout d'une colonne de valeurs manquantes pour toutes les bases ayant moins de ligne que le maximum\n  res &lt;- lapply(liste, function(x) {\n    for (i in seq_len(maxCol - nrow(x))) {\n      x[nrow(x) + i, ] &lt;- NA\n    }\n    return(x)\n  })\n  # On joint les résultats\n  return(bind_cols(res))\n}\nconcatener &lt;- cbind_alt(list(ajout, donnees_tidyverse))\n\n\n\n\n# On va ajouter le numéro de la ligne\n# data.frame::cbind si les deux bases comprennent le même nombre de lignes\najout &lt;- data.table(num_ligne = seq_len(nrow(donnees_datatable)))\nconcatener &lt;- cbind(ajout, donnees_datatable)\n# Fonctionne aussi avec des bases comportement un nombre différent de lignes\n# Mais attention, le résultat n'est pas le même que sur SAS, il y a recycling\najout &lt;- data.table(num_ligne = seq_len(nrow(donnees_datatable) + 1))\nconcatener &lt;- cbind(ajout, donnees_datatable)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#empiler-deux-bases-de-données",
    "href": "01-aide_memoire_r_sas.html#empiler-deux-bases-de-données",
    "title": "Aide-mémoire SAS - R",
    "section": "14.10 Empiler deux bases de données",
    "text": "14.10 Empiler deux bases de données\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On va empiler la somme des notes en dessous de la base des notes */\n%let var = Identifiant Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\n/* On sélectionne un nombre réduit de variables pour simplifier l'exemple */\n%let var2 = %sysfunc(tranwrd(&var., Identifiant,));\ndata Notes;set donnees_sas (keep = &var.);run;\n/* Moyenne des notes par individu */\nproc means data = Notes noprint mean;var &var2.;output out = Ajout mean = &var2.;run;\n/* On concatène avec les données. Valeur manquante si les variables ne correspondent pas */\n/* L'instruction set permet de concaténer les bases */\ndata Empiler;set Notes Ajout (drop = _type_ _freq_);run;\n/* Autre solution, proc append */\ndata Empiler;set Notes;run;\nproc append base = Empiler data = Ajout force;run;\n/* On renomme la ligne des moyennes ajoutée */\ndata Empiler;\n  set Empiler nobs = nobs;\n  if _N_ = nobs then Identifiant = \"Moyenne\";\nrun;\n\n\n\n# On va empiler la somme des notes en dessous de la base des notes\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\n# Moyenne des notes par individu\nmoyennes &lt;- data.frame(t(colMeans(donnees_rbase[, varNotes], na.rm = TRUE)))\n# On sélectionne la base des notes\nnotes &lt;- donnees_rbase[, varNotes]\n# rbind lorsque les bases empilées ont le même nombre de colonne\nempiler &lt;- rbind(notes, moyennes)\n# Mais, ne fonctionne plus si l'on concatène des bases de taille différente\nnotes &lt;- donnees_rbase[, c(\"identifiant\", varNotes)]\n# Ne fonctionne pas\n#empiler &lt;- rbind(notes, moyennes)\n# Une solution alternative, lorsque le nombre de colonnes diffère entre les deux bases\n# Lorsque les variables ne correspondent pas, on les crée avec des valeurs manquantes, via setdiff\nrbind_alt &lt;- function(x, y) {\n  rbind(data.frame(c(x, sapply(setdiff(names(y), names(x)), function(z) NA))),\n        data.frame(c(y, sapply(setdiff(names(x), names(y)), function(z) NA)))\n  )\n  }\nempiler &lt;- rbind_alt(notes, moyennes)\n# On renomme la ligne des moyennes ajoutée\nempiler[nrow(empiler), \"identifiant\"] &lt;- \"Moyenne\"\n\n\n\n\n# On va empiler la somme des notes en dessous de la base des notes\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\n# Moyenne des notes par individu\nmoyennes &lt;- donnees_tidyverse %&gt;% \n  summarise(across(varNotes, ~mean(., na.rm = TRUE)))\nempiler &lt;- donnees_tidyverse %&gt;% \n  select(all_of(varNotes)) %&gt;% \n  bind_rows(moyennes)\n# Fonctionne toujours si l'on concatène des bases de taille différente\nempiler &lt;- donnees_tidyverse %&gt;% \n  select(identifiant, all_of(varNotes)) %&gt;% \n  bind_rows(moyennes)\nempiler &lt;- empiler %&gt;% \n  # On renomme la ligne des moyennes ajoutée\n  mutate(identifiant = ifelse(row_number() == nrow(empiler),\n                              \"Moyenne\",\n                              identifiant))\n\n\n\n\n# On va empiler la somme des notes en dessous de la base des notes\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\n# Moyenne des notes par individu\nmoyennes &lt;- data.table(donnees_datatable[, lapply(.SD, mean, na.rm = TRUE), .SDcols = varNotes])\n# On sélectionne la base des notes\nnotes &lt;- donnees_datatable[, mget(c(\"identifiant\", varNotes))]\nempiler &lt;- rbindlist(list(notes, moyennes), fill = TRUE)\n# On renomme la ligne des moyennes ajoutée\nset(empiler, i = nrow(empiler), j = \"identifiant\", value = \"Moyenne\")",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#ajouter-une-ligne-de-valeurs-manquantes-à-une-base-de-données",
    "href": "01-aide_memoire_r_sas.html#ajouter-une-ligne-de-valeurs-manquantes-à-une-base-de-données",
    "title": "Aide-mémoire SAS - R",
    "section": "14.11 Ajouter une ligne de valeurs manquantes à une base de données",
    "text": "14.11 Ajouter une ligne de valeurs manquantes à une base de données\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata Ajout;run;\ndata Ajout_Missing;set Jointure Ajout;run;\n\n\n\najout_na &lt;- donnees_rbase\najout_na[nrow(ajout_na) + 1, ] &lt;- NA\n\n\n\n\najout_na &lt;- donnees_tidyverse %&gt;%\n  bind_rows(tibble(NA))\n\n\n\n\najout_na &lt;- rbindlist(list(donnees_datatable, data.table(NA)), fill = TRUE)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#semi-join",
    "href": "01-aide_memoire_r_sas.html#semi-join",
    "title": "Aide-mémoire SAS - R",
    "section": "14.12 Semi join",
    "text": "14.12 Semi join\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Identifiants de la base de gauche qui ont un correspondant dans la base de droite */\nproc sql;\n  create table Semi_Join as select * from donnees_sas\n  where Identifiant in (select distinct Identifiant from Diplome);\n  select count(*) from Semi_Join;\nquit;\nproc sql;\n  create table Semi_Join as select * from donnees_sas a\n  where exists (select * from Diplome b where (a.Identifiant = b.Identifiant));\n  select count(*) from Semi_Join;\nquit;\n\n\n\n# Identifiants de la base de gauche qui ont un correspondant dans la base de droite\nsemiJoin &lt;- donnees_rbase[donnees_rbase$identifiant %in% diplome_rbase$identifiant, ]\ndim(semiJoin)\n\n\n\n\n# Identifiants de la base de gauche qui ont un correspondant dans la base de droite\nsemiJoin &lt;- donnees_tidyverse %&gt;% \n  semi_join(diplome_tidyverse, join_by(identifiant == identifiant))\ndim(semiJoin)\n# Autre solution\nsemiJoin &lt;- semi_join(donnees_tidyverse, diplome_tidyverse, join_by(identifiant == identifiant))\ndim(semiJoin)\n\n\n\n\n# Identifiants de la base de gauche qui ont un correspondant dans la base de droite\nsemiJoin &lt;- donnees_datatable[identifiant %in% diplome_datatable$identifiant, ]\ndim(semiJoin)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#anti-join",
    "href": "01-aide_memoire_r_sas.html#anti-join",
    "title": "Aide-mémoire SAS - R",
    "section": "14.13 Anti join",
    "text": "14.13 Anti join\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Identifiants de la base de gauche qui n'ont pas de correspondant dans la base de droite */\nproc sql;\n  create table Anti_Join as select * from donnees_sas\n  where Identifiant not in (select distinct Identifiant from Diplome);\n  select count(*) from Anti_Join;\nquit;\nproc sql;\n  create table Anti_Join as select * from donnees_sas a\n  where not exists (select * from Diplome b where (a.Identifiant = b.Identifiant);\n  select count(*) from Anti_Join;\nquit;\n\n\n\n# Identifiants de la base de gauche qui n'ont pas de correspondant dans la base de droite\nantiJoin &lt;- donnees_rbase[! donnees_rbase$identifiant %in% diplome_rbase$identifiant, ]\ndim(antiJoin)\n\n\n\n\n# Identifiants de la base de gauche qui n'ont pas de correspondant dans la base de droite\nantiJoin &lt;- donnees_tidyverse %&gt;% \n  anti_join(diplome_tidyverse, join_by(identifiant == identifiant))\ndim(antiJoin)\n# Autre solution\nantiJoin &lt;- anti_join(donnees_tidyverse, diplome_tidyverse, join_by(identifiant == identifiant))\ndim(antiJoin)\n\n\n\n\n# Identifiants de la base de gauche qui n'ont pas de correspondant dans la base de droite\nantiJoin &lt;- donnees_datatable[! identifiant %in% diplome_datatable$identifiant, ]\ndim(antiJoin)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#autres-fonctions-utiles",
    "href": "01-aide_memoire_r_sas.html#autres-fonctions-utiles",
    "title": "Aide-mémoire SAS - R",
    "section": "14.14 Autres fonctions utiles",
    "text": "14.14 Autres fonctions utiles\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc sql;\n  /* Concaténation des identifiants */\n  select Identifiant from Jointure union all\n  select Identifiant from Diplome order by identifiant;\n  /* Identifiants uniques des 2 bases */\n  select distinct Identifiant from\n  (select distinct Identifiant from Jointure union select distinct Identifiant from Diplome)\n  order by identifiant;\n  /* Identifiants communs des 2 bases */\n  select Identifiant from Jointure intersect select Identifiant from Diplome\n  order by identifiant;\n  /* Identifiants dans jointure mais pas diplome */\n  select distinct Identifiant from Jointure where\n  Identifiant not in (select distinct Identifiant from Diplome)\n  order by identifiant;\n  select Identifiant from Jointure except select Identifiant from Diplome;\n  /* Identifiants dans diplome mais pas jointure */\n  select distinct Identifiant from Diplome\n  where Identifiant not in (select distinct Identifiant from Jointure)\n  order by identifiant;\n  select Identifiant from Diplome except\n  select Identifiant from Jointure order by identifiant;\nquit;\n\n\n\n# base:: permet de s'assurer que les fonctions proviennent de R-Base\n# Des fonctions du même nom existent en Tidyverse, et tendent à prédominer si le package est lancé\n# Concaténation des identifiants avec les doublons\nsort(c(jointure_rbase$identifiant, diplome_rbase$identifiant))\n# Identifiants uniques des 2 bases\nsort(base::union(jointure_rbase$identifiant, diplome_rbase$identifiant))\nsort(base::unique(c(jointure_rbase$identifiant, diplome_rbase$identifiant)))\n# Identifiants communs des 2 bases\nsort(base::intersect(jointure_rbase$identifiant, diplome_rbase$identifiant))\n# Identifiants dans jointure mais pas diplome\nsort(base::setdiff(jointure_rbase$identifiant, diplome_rbase$identifiant))\n# Identifiants dans diplome mais pas jointure\nsort(base::setdiff(diplome_rbase$identifiant, jointure_rbase$identifiant))\n\n\n\n\n# dplyr:: permet de s'assurer que ce sont les fonctions du Tidyverse (et non leurs homonymes de R-Base qui sont utilisées)\n\n# Concaténation des identifiants\ndplyr::union_all(jointure_tidyverse$identifiant, diplome_tidyverse$identifiant) %&gt;% \n  sort()\n# Identifiants uniques des 2 bases\nunique(dplyr::union_all(jointure_tidyverse$identifiant, diplome_tidyverse$identifiant)) %&gt;% \n  sort()\ndplyr::union(jointure_tidyverse$identifiant, diplome_tidyverse$identifiant) %&gt;% \n  sort()\n# Identifiants communs des 2 bases\ndplyr::intersect(jointure_tidyverse$identifiant, diplome_tidyverse$identifiant) %&gt;% \n  sort()\n# Identifiants dans jointure mais pas diplome\ndplyr::setdiff(jointure_tidyverse$identifiant, diplome_tidyverse$identifiant) %&gt;% \n  sort()\n# Identifiants dans diplome mais pas jointure\ndplyr::setdiff(diplome_tidyverse$identifiant, jointure_tidyverse$identifiant) %&gt;% \n  sort()\n\n\n\n\n# Les fonctions spécifiques à data.table fonctionnent avec des formats data.table, d'où la syntaxe un peu différente de R-Base\n\n# Concaténation des identifiants\nvariable &lt;- \"identifiant\"\nsort(c(jointure_datatable[[variable]], diplome_datatable[[variable]]))\n# Identifiants uniques des 2 bases\nsort(unique(c(jointure_datatable[[variable]], diplome_datatable[[variable]])))\nsort(union(jointure_datatable[[variable]], diplome_datatable[[variable]]))\n# Identifiants communs des 2 bases\nfintersect(jointure_datatable[, ..variable], diplome_datatable[, ..variable])[order(identifiant)]\n# Identifiants dans jointure mais pas diplome\nfsetdiff(jointure_datatable[, ..variable], diplome_datatable[, ..variable])[order(identifiant)]\n# Identifiants dans diplome mais pas jointure\nfsetdiff(diplome_datatable[, ..variable], jointure_datatable[, ..variable])[order(identifiant)]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#moyenne",
    "href": "01-aide_memoire_r_sas.html#moyenne",
    "title": "Aide-mémoire SAS - R",
    "section": "15.1 Moyenne",
    "text": "15.1 Moyenne\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc means data = donnees_sas mean;var note_contenu;run;\nproc sql;select mean(note_contenu) from donnees_sas;run;\n\n\n\n# Importance du na.rm = TRUE\nmean(donnees_rbase$note_contenu)\nmean(donnees_rbase$note_contenu, na.rm = TRUE)\n\n\n\n\n# Importance du na.rm = TRUE\ndonnees_tidyverse %&gt;% pull(note_contenu) %&gt;% mean()\ndonnees_tidyverse %&gt;% pull(note_contenu) %&gt;% mean(na.rm = TRUE)\n\n# Autres solutions\n# Le chiffre est arrondi lorsqu'il est affiché, du fait des propriétés des tibbles\ndonnees_tidyverse %&gt;% summarise(mean(note_contenu, na.rm = TRUE))\ndonnees_tidyverse %&gt;% \n  summarise(across(note_contenu, ~mean(., na.rm = TRUE)))\n\n# Attention, en tidyverse, les syntaxes suivantes ne fonctionnent pas !\n# donnees_tidyverse %&gt;% mean(note_formateur)\n# donnees_tidyverse %&gt;% mean(note_formateur, na.rm = TRUE)\n\n\n\n\n# Importance du na.rm = TRUE\ndonnees_datatable[, mean(note_contenu)]\ndonnees_datatable[, mean(note_contenu, na.rm = TRUE)]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#moyenne-par-sélection",
    "href": "01-aide_memoire_r_sas.html#moyenne-par-sélection",
    "title": "Aide-mémoire SAS - R",
    "section": "15.2 Moyenne par sélection",
    "text": "15.2 Moyenne par sélection\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Ici pour les seules femmes */\nproc means data = donnees_sas mean;\n  var note_contenu;\n  where sexef = \"Femme\";\nrun;\n\n\n\n# Ici, pour les seules femmes\nwith(subset(donnees_rbase, sexef == \"Femme\"), mean(note_contenu, na.rm = TRUE))\n\n\n\n\n# Ici, pour les seules femmes\ndonnees_tidyverse %&gt;%\n  filter(sexef == \"Femme\") %&gt;% \n  pull(note_contenu) %&gt;%\n  mean(na.rm = TRUE)\n\n# Autres solutions\ndonnees_tidyverse %&gt;%\n  filter(sexef == \"Femme\") %&gt;% \n  summarise(moyenne = mean(note_contenu, na.rm = TRUE))\ndonnees_tidyverse %&gt;%\n  filter(sexef == \"Femme\") %&gt;% \n  summarise(across(note_contenu, ~ mean(., na.rm = TRUE)))\n# Attention, syntaxe qui ne fonctionne qu'avec %&gt;%, pas avec %&gt;% !\ndonnees_tidyverse %&gt;%\n  filter(sexef == \"Femme\") %&gt;% \n  {mean(.$note_contenu, na.rm = TRUE)}\n\n\n\n\n# Ici, pour les seules femmes\ndonnees_datatable[sexef == \"Femme\", mean(note_contenu, na.rm = TRUE)]\ndonnees_datatable[sexef == \"Femme\", lapply(.SD, function(x) mean(x, na.rm = TRUE)), .SDcols = \"note_contenu\"]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#moyenne-pondérée",
    "href": "01-aide_memoire_r_sas.html#moyenne-pondérée",
    "title": "Aide-mémoire SAS - R",
    "section": "15.3 Moyenne pondérée",
    "text": "15.3 Moyenne pondérée\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Ensemble des données */\nproc means data = donnees_sas mean;\n  var note_contenu;\n  weight poids_sondage;\nrun;\n/* Par sélection (ici pour les seules femmes) */\nproc means data = donnees_sas mean;\n  var note_contenu;\n  where sexef = \"Femme\";\n  weight poids_sondage;\nrun;\n\n\n\n# Ensemble des données\nweighted.mean(donnees_rbase$note_contenu, donnees_rbase$poids_sondage, na.rm = TRUE)\n# Autre méthode, mais attention aux NA !!\nwith(donnees_rbase, sum(note_contenu * poids_sondage, na.rm = TRUE) / sum((!is.na(note_contenu)) * poids_sondage, na.rm = TRUE))\n# Par sélection (ici pour les seules femmes)\nwith(subset(donnees_rbase, sexef == \"Femme\"), sum(note_contenu * poids_sondage, na.rm = TRUE) / sum(poids_sondage, na.rm = TRUE))\n# On peut aussi utiliser la fonction crossprod\n# Mais ne fonctionne pas dans ce cas, car elle ne prend pas en compte les na.rm = TRUE\n# Ne pas confondre cumprod et crossprod !!!!\nwith(subset(donnees_rbase, sexef == \"Femme\"), crossprod(note_contenu, poids_sondage) / sum(poids_sondage, na.rm = TRUE))\n\n\n\n\n# Ensemble des données\ndonnees_tidyverse %&gt;%\n  summarise(across(note_contenu, ~weighted.mean(., w = poids_sondage, na.rm = TRUE)))\n# Par sélection\ndonnees_tidyverse %&gt;%\n  filter(sexef == \"Femme\") %&gt;%\n  summarise(across(note_contenu, ~weighted.mean(., w = poids_sondage, na.rm = TRUE)))\n\n\n\n\n# Ensemble des données\ndonnees_datatable[, weighted.mean(note_contenu, poids_sondage, na.rm = TRUE)]\n# Par sélection (ici pour les seules femmes)\ndonnees_datatable[sexef == \"Femme\", weighted.mean(note_contenu, poids_sondage, na.rm = TRUE)]\ndonnees_datatable[sexef == \"Femme\", lapply(.SD, function(x) weighted.mean(x, poids_sondage, na.rm = TRUE)),\n                  .SDcols = \"note_contenu\"]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#moyenne-de-plusieurs-variables",
    "href": "01-aide_memoire_r_sas.html#moyenne-de-plusieurs-variables",
    "title": "Aide-mémoire SAS - R",
    "section": "15.4 Moyenne de plusieurs variables",
    "text": "15.4 Moyenne de plusieurs variables\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\nproc means data = donnees_sas mean;\n  var &notes.;\nrun;\n\n\n\nnotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\n# Plusieurs solutions\n# Sous forme de liste\nlapply(donnees_rbase[, notes], mean, na.rm = TRUE)\n# Sous forme de vecteur\nsapply(donnees_rbase[, notes], mean, na.rm = TRUE)\napply(donnees_rbase[, notes], 2, mean, na.rm = TRUE)\n# Si l'on souhaite renommer les colonnes\nmoyennes &lt;- sapply(donnees_rbase[, notes], mean, na.rm = TRUE)\nnames(moyennes) &lt;- paste(\"Moyenne\", names(moyennes), sep = \"_\")\nmoyennes\n\n\n\n\nnotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\ndonnees_tidyverse %&gt;%\n  summarise_at(notes, mean, na.rm = TRUE)\n# Autres solutions\ndonnees_tidyverse %&gt;%\n  summarise(across(all_of(notes), ~ mean(.x, na.rm = TRUE)))\n# Obsolète\ndonnees_tidyverse %&gt;%  \n  select(starts_with(\"Note\") & !ends_with(\"_100\")) %&gt;% \n  summarise_all(.funs = ~ mean(., na.rm = TRUE), .vars = notes)\n# Si l'on souhaite renommer les colonnes\nmoyennes &lt;- donnees_tidyverse %&gt;%\n  summarise_at(notes, mean, na.rm = TRUE) %&gt;% \n  rename_with(~ paste(\"Moyenne\", ., sep = \"_\"))\nmoyennes &lt;- donnees_tidyverse %&gt;%\n  summarise(across(all_of(notes), ~ mean(.x, na.rm = TRUE), .names = \"Moyenne_{.col}\"))\n\n\n\n\nnotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\nmoyennes &lt;- donnees_datatable[, lapply(.SD, mean, na.rm = TRUE), .SDcols = notes]\n# Si l'on souhaite renommer les colonnes\nsetnames(moyennes, notes, paste(\"Moyenne\", notes, sep = \"_\"))\nmoyennes",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#moyenne-pondérée-de-plusieurs-variables",
    "href": "01-aide_memoire_r_sas.html#moyenne-pondérée-de-plusieurs-variables",
    "title": "Aide-mémoire SAS - R",
    "section": "15.5 Moyenne pondérée de plusieurs variables",
    "text": "15.5 Moyenne pondérée de plusieurs variables\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\nproc means data = donnees_sas mean;\n  var &notes.;\n  weight poids_sondage;\nrun;\n\n\n\nwith(donnees_rbase, sapply(donnees_rbase[, notes], function(x) weighted.mean(x, poids_sondage, na.rm = TRUE)))\n\n\n\n\nnotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\ndonnees_tidyverse %&gt;%\n  summarise(across(notes, ~ weighted.mean(.x, poids_sondage, na.rm = TRUE)))\n# Autre solution\ndonnees_tidyverse %&gt;%\n  summarise_at(notes, ~ weighted.mean(.x, poids_sondage, na.rm = TRUE))\n\n\n\n\nmoyennes &lt;- donnees_datatable[, lapply(.SD, function(x) weighted.mean(x, poids_sondage, na.rm = TRUE)), .SDcols = notes]\nmoyennes",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#nombreuses-statistiques-somme-moyenne-médiane-mode-etc.",
    "href": "01-aide_memoire_r_sas.html#nombreuses-statistiques-somme-moyenne-médiane-mode-etc.",
    "title": "Aide-mémoire SAS - R",
    "section": "15.6 Nombreuses statistiques (somme, moyenne, médiane, mode, etc.)",
    "text": "15.6 Nombreuses statistiques (somme, moyenne, médiane, mode, etc.)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Petite différence avec SAS sur le nombre de lignes du fait des valeurs manquantes */\n/* Somme, moyenne, médiane, minimum, maximum, variance, écart-type, nombre de données non manquantes (n),\n   nombre de données manquantes (nmiss), intervalle, mode */\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\n/* Par la proc means, en un seul tableau */\nproc means data = donnees_sas sum mean median min max var std n nmiss range mode;\n  var &notes.;\nrun;\n/* Par la proc univariate, variable par variable */\nproc univariate data = donnees_sas;\n  var &notes.;\nrun;\n\n\n\n# Somme, moyenne, médiane, minimum, maximum, variance, écart-type, nombre de données (manquantes et non manquantes),\n# Nombre de valeurs manquantes, Intervalle\n# Petite différence avec SAS sur le nombre de lignes du fait des valeurs manquantes\n# Une solution pour obtenir le mode est d'utiliser fmode du package collapse\nlibrary(collapse)\nsapply(donnees_rbase[, notes], function(x) c(\"Somme\"      = sum(x, na.rm = TRUE),\n                                             \"Moyenne\"    = mean(x, na.rm = TRUE),\n                                             \"Médiane\"    = median(x, na.rm = TRUE),\n                                             \"Min\"        = min(x, na.rm = TRUE),\n                                             \"Max\"        = max(x, na.rm = TRUE),\n                                             # Pour la variance, la somme des carrés est divisée par n - 1, où n est le nombre de données\n                                             \"Variance\"   = var(x, na.rm = TRUE),\n                                             \"Ecart-type\" = sd(x, na.rm = TRUE),\n                                             \"N\"          = length(x),\n                                             \"NMiss\"      = sum(is.na(x)),\n                                             \"Intervalle\" = max(x, na.rm = TRUE) - min(x, na.rm = TRUE),\n                                             \"Mode\"       = collapse::fmode(x)\n))\n\n\n\n\n# Petite différence avec SAS sur le nombre de lignes du fait des valeurs manquantes\n# Une solution pour obtenir le mode est d'utiliser fmode du package collapse\nlibrary(collapse)\nnotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\nStatsDesc_tidyverse &lt;- function(x) {\n  c(\n    Somme      = sum(x, na.rm = TRUE),\n    Moyenne    = mean(x, na.rm = TRUE),\n    Mediane    = median(x, na.rm = TRUE),\n    Min        = min(x, na.rm = TRUE),\n    Max        = max(x, na.rm = TRUE),\n    Variance   = var(x, na.rm = TRUE),\n    Ecart_type = sd(x, na.rm = TRUE),\n    N          = length(x),\n    NMiss      = sum(is.na(x)),\n    Intervalle = max(x, na.rm = TRUE) - min(x, na.rm = TRUE),\n    Mode       = collapse::fmode(x)\n    )\n}\n# 1ère solution avec les notes en ligne et les statistiques en colonnes\ndonnees_tidyverse %&gt;% \n  select(all_of(notes)) %&gt;% \n  map(~ StatsDesc_tidyverse(.x)) %&gt;% \n  bind_rows() %&gt;% \n  bind_cols(tibble(Note = c(notes))) %&gt;% \n  relocate(Note)\n# 2e solution avec les notes en colonne\ndonnees_tidyverse %&gt;%\n  reframe(across(notes, ~ StatsDesc_tidyverse(.x))) %&gt;% \n  bind_cols(tibble(Indicateur = c(\"Somme\", \"Moyenne\", \"Mediane\", \"Min\", \"Max\", \"Variance\",\n                                  \"Ecart_type\", \"N\", \"NMiss\", \"Intervalle\", \"Mode\"))) %&gt;% \n  relocate(Indicateur)\n\n\n\n\n# Petite différence avec SAS sur le nombre de lignes du fait des valeurs manquantes\nnotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\n# Une solution pour obtenir le mode est d'utiliser fmode du package collapse\nlibrary(collapse)\nmoyennes &lt;- donnees_datatable[, lapply(.SD, function(x) c(sum(x, na.rm = TRUE),\n                                                          mean(x, na.rm = TRUE),\n                                                          median(x, na.rm = TRUE),\n                                                          min(x, na.rm = TRUE),\n                                                          max(x, na.rm = TRUE),\n                                                          var(x, na.rm = TRUE),\n                                                          sd(x, na.rm = TRUE),\n                                                          .N,\n                                                          sum(is.na(x)),\n                                                          max(x, na.rm = TRUE) - min(x, na.rm = TRUE),\n                                                          collapse::fmode(x)\n                                                          )),\n                              .SDcols = notes]\ncbind(data.table(Nom = c(\"Somme\", \"Moyenne\", \"Médiane\", \"Min\", \"Max\", \"Variance\", \"Ecart_type\", \"N\", \"NMiss\", \"Intervalle\", \"Mode\")), moyennes)\n# Autre solution\nStatsDesc &lt;- function(x) {\n  list(\n    Variable   = names(x),\n    Somme      = lapply(x, sum, na.rm = TRUE),\n    Moyenne    = lapply(x, mean, na.rm = TRUE),\n    Mediane    = lapply(x, median, na.rm = TRUE),\n    Min        = lapply(x, min, na.rm = TRUE),\n    Max        = lapply(x, max, na.rm = TRUE),\n    Variance   = lapply(x, var, na.rm = TRUE),\n    Ecart_type = lapply(x, sd, na.rm = TRUE),\n    N          = lapply(x, function(x) length(x)),\n    NMiss      = lapply(x, function(x) sum(is.na(x))),\n    Intervalle = lapply(x, function(x) max(x, na.rm = TRUE) - min(x, na.rm = TRUE)),\n    Mode       = lapply(x, collapse::fmode)\n    )\n}\ndonnees_datatable[, StatsDesc(.SD), .SDcols = notes]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#nombreuses-statistiques-pondérées-somme-moyenne-médiane-mode-etc.",
    "href": "01-aide_memoire_r_sas.html#nombreuses-statistiques-pondérées-somme-moyenne-médiane-mode-etc.",
    "title": "Aide-mémoire SAS - R",
    "section": "15.7 Nombreuses statistiques pondérées (somme, moyenne, médiane, mode, etc.)",
    "text": "15.7 Nombreuses statistiques pondérées (somme, moyenne, médiane, mode, etc.)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Somme, moyenne, médiane, minimum, maximum, variance, écart-type, nombre de données non manquantes (n),\n   nombre de données manquantes (nmiss), intervalle, mode */\n/* Par la proc means, en un seul tableau */\n/* L'option vardef = wgt permet de diviser la variable par la somme des poids et non le nombre de données, pour être cohérent\n   avec R */\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\n/* Par la proc means, en un seul tableau */\nproc means data = donnees_sas sum mean median min max var std n nmiss range mode vardef = wgt;\n  var &notes.;\n  weight poids_sondage;\nrun;\n/* Par la proc univariate, variable par variable */\nproc univariate data = donnees_sas;\n  var &notes.;\n  weight poids_sondage;\nrun;\n\n\n\n# Une solution pour obtenir les résultats pondérés est d'utiliser les fonctions du package collapse\n# L'option na.rm est par défaut à TRUE dans le package\nlibrary(collapse)\nsapply(donnees_rbase[, notes], function(x) c(\"Somme\"      = collapse::fsum(x, w = donnees_rbase$poids_sondage),\n                                             \"Moyenne\"    = collapse::fmean(x, w = donnees_rbase$poids_sondage),\n                                             \"Médiane\"    = collapse::fmedian(x, w = donnees_rbase$poids_sondage),\n                                             \"Min\"        = collapse::fmin(x),\n                                             \"Max\"        = collapse::fmax(x),\n                                             # Pour la variance, la somme des carrés est divisée par n - 1, où n est le nombre de données\n                                             \"Variance\"   = collapse::fvar(x, w = donnees_rbase$poids_sondage),\n                                             \"Ecart-type\" = collapse::fsd(x, w = donnees_rbase$poids_sondage),\n                                             \"N\"          = collapse::fnobs(x),\n                                             \"NMiss\"      = collapse::fnobs(is.na(x)),\n                                             \"Intervalle\" = collapse::fmax(x) - collapse::fmin(x),\n                                             \"Mode\"       = collapse::fmode(x, w = donnees_rbase$poids_sondage)\n))\n\n\n\n\n# Une solution pour obtenir les résultats pondérés est d'utiliser les fonctions du package collapse\n# L'option na.rm est par défaut à TRUE dans le package\nlibrary(collapse)\nnotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\nStatsDescPond_tidyverse &lt;- function(x, w) {\n  c(\n    Somme      = collapse::fsum(x, w),\n    Moyenne    = collapse::fmean(x, w),\n    Mediane    = collapse::fmedian(x, w),\n    Min        = collapse::fmin(x),\n    Max        = collapse::fmax(x),\n    Variance   = collapse::fvar(x, w),\n    Ecart_type = collapse::fsd(x, w),\n    N          = collapse::fnobs(x),\n    NMiss      = collapse::fnobs(is.na(x)),\n    Intervalle = collapse::fmax(x) - collapse::fmin(x),\n    Mode       = collapse::fmode(x, w)\n  )\n}\n# À FAIRE : Comment faire cela ???\n# Tous les codes suivants ne fonctionnent pas !\n#donnees_tidyverse %&gt;%\n#  reframe(across(notes, ~ StatsDescPond_tidyverse(.x, 10))) %&gt;% \n#  bind_cols(tibble(Indicateur = c(\"Somme\", \"Moyenne\", \"Mediane\", \"Min\", \"Max\", \"Variance\",\n#                                  \"Ecart_type\", \"N\", \"NMiss\", \"Intervalle\", \"Mode\"))) %&gt;% \n#  relocate(Indicateur)\n#donnees_tidyverse %&gt;% \n#  select(all_of(notes), poids_sondage) %&gt;% \n#  map(all_of(notes), ~ StatsDescPond_tidyverse(.x, poids_sondage)) %&gt;% \n#  bind_rows() %&gt;% \n#  bind_cols(tibble(Note = c(notes))) %&gt;% \n#  relocate(Note)\n#donnees_tidyverse %&gt;% \n#  select(all_of(notes), poids_sondage) %&gt;% \n#  map(~StatsDescPond_tidyverse(.x, donnees_tidyverse$poids_sondage) )\n\n\n\n\n# Une solution pour obtenir les résultats pondérés est d'utiliser les fonctions du package collapse\n# L'option na.rm est par défaut à TRUE dans le package\nlibrary(collapse)\n# À FAIRE : y-a-t-il plus simple ???\n# Est-on obligés d'utiliser systématiquement donnees_datatable$poids_sondage ?\nnotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\nStatsDescPond &lt;- function(x) {\n  list(\n    Variables  = names(x),\n    Somme      = lapply(x, collapse::fsum, w = donnees_datatable$poids_sondage),\n    Moyenne    = lapply(x, collapse::fmean, w = donnees_datatable$poids_sondage),\n    Mediane    = lapply(x, collapse::fmedian, w = donnees_datatable$poids_sondage),\n    Min        = lapply(x, collapse::fmin),\n    Max        = lapply(x, collapse::fmax),\n    Variance   = lapply(x, collapse::fvar, w = donnees_datatable$poids_sondage),\n    Ecart_type = lapply(x, collapse::fsd, w = donnees_datatable$poids_sondage),\n    N          = lapply(x, collapse::fnobs),\n    NMiss      = lapply(x, function(x) collapse::fnobs(is.na(x))),\n    Intervalle = lapply(x, function(x) collapse::fmax(x) - collapse::fmin(x)),\n    Mode       = lapply(x, collapse::fmode, w = donnees_datatable$poids_sondage)\n  )\n}\ndonnees_datatable[, StatsDescPond(.SD), .SDcols = notes]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#calcul-dune-variance-pondérée",
    "href": "01-aide_memoire_r_sas.html#calcul-dune-variance-pondérée",
    "title": "Aide-mémoire SAS - R",
    "section": "15.8 Calcul d’une variance pondérée",
    "text": "15.8 Calcul d’une variance pondérée\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc means data = donnees_sas var vardef = wgt;\n  var note_contenu;\n  weight poids_sondage;\nrun;\n\n\n\nlibrary(collapse)\nwith(donnees_rbase, collapse::fvar(note_contenu, w = poids_sondage))\n# On la calcule \"manuellement\" pour confirmer le résultat\n# Formule : S_i{w_i * x_i**2} / S_i{w_i} - x_m**2\nx_2 &lt;- with(donnees_rbase,\n            sum(poids_sondage * note_contenu**2 * complete.cases(note_contenu, poids_sondage), na.rm = TRUE))\nx_m &lt;- with(donnees_rbase,\n            sum(poids_sondage * note_contenu * complete.cases(note_contenu, poids_sondage), na.rm = TRUE))\np &lt;- with(donnees_rbase,\n          sum(poids_sondage * complete.cases(note_contenu, poids_sondage), na.rm = TRUE))\nx_2 / p - (x_m / p) ** 2\n\n\n\n\nlibrary(collapse)\ndonnees_tidyverse %&gt;% \n  summarise(var = collapse::fvar(note_contenu, w = poids_sondage))\n# On la calcule \"manuellement\" pour confirmer le résultat\n# Formule : S_i{w_i * x_i**2} / S_i{w_i} - x_m**2\nx_2 &lt;- with(donnees_tidyverse,\n            sum(poids_sondage * note_contenu**2 * complete.cases(note_contenu, poids_sondage), na.rm = TRUE))\nx_m &lt;- with(donnees_tidyverse,\n            sum(poids_sondage * note_contenu * complete.cases(note_contenu, poids_sondage), na.rm = TRUE))\np &lt;- with(donnees_tidyverse,\n          sum(poids_sondage * complete.cases(note_contenu, poids_sondage), na.rm = TRUE))\nx_2 / p - (x_m / p) ** 2\n\n\n\n\nlibrary(collapse)\ndonnees_datatable[, collapse::fvar(note_contenu, w = poids_sondage)]\n# On la calcule \"manuellement\" pour confirmer le résultat\n# Formule : S_i{w_i * x_i**2} / S_i{w_i} - x_m**2\nx_2 &lt;- donnees_datatable[, sum(poids_sondage * note_contenu**2 * complete.cases(note_contenu, poids_sondage),\n                               na.rm = TRUE)]\nx_m &lt;- donnees_datatable[, sum(poids_sondage * note_contenu * complete.cases(note_contenu, poids_sondage),\n                               na.rm = TRUE)]\np &lt;- donnees_datatable[, sum(poids_sondage * complete.cases(note_contenu, poids_sondage), na.rm = TRUE)]\nx_2 / p - (x_m / p) ** 2",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#déciles-et-quartiles",
    "href": "01-aide_memoire_r_sas.html#déciles-et-quartiles",
    "title": "Aide-mémoire SAS - R",
    "section": "15.9 Déciles et quartiles",
    "text": "15.9 Déciles et quartiles\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On calcule déjà la moyenne des notes par individu */\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\ndata donnees_sas;\n  set donnees_sas;\n  /* 1ère solution */\n  Note_moyenne    = mean(of &notes.);\n  /* 2e solution : l'équivalent des list-comprehension de Python en SAS */\n  %macro List_comprehension;\n    Note_moyenne2 = mean(of %do i = 1 %to %sysfunc(countw(&notes.));\n                              %let j = %scan(&notes., &i.);\n                              &j.\n                            %end;);;\n  %mend List_comprehension;\n  %List_comprehension;\nrun;\n\n/* Déciles et quartiles de la note moyenne */\n/* Par la proc means */\nproc means data = donnees_sas StackODSOutput Min P10 P20 P30 P40 Median P60 P70 Q3 P80 P90 Max Q1 Median Q3 QRANGE;\n  var Note_moyenne;\n  ods output summary = Deciles_proc_means;\nrun;\n/* Par la proc univariate */\nproc univariate data = donnees_sas;\n  var Note_moyenne;\n  output out = Deciles_proc_univariate pctlpts=00 to 100 by 10 25 50 75 PCTLPRE=_; \nrun;\n\n\n\n# on calcule déjà la moyenne des notes par individu\nnotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\ndonnees_rbase$note_moyenne &lt;- rowMeans(donnees_rbase[, notes], na.rm = TRUE)\n# Et les quantiles\nquantile(donnees_rbase$note_moyenne, probs = c(seq(0, 1, 0.1), 0.25, 0.75), na.rm = TRUE)\n# Intervalle inter-quartile\nIQR(donnees_rbase$note_moyenne, na.rm = TRUE)\n\n\n\n\n# on calcule déjà la moyenne des notes par individu\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  mutate(note_moyenne = rowMeans(across(all_of(varNotes)), na.rm = TRUE))\n# Et les quantiles\ndonnees_tidyverse %&gt;%\n  pull(note_moyenne) %&gt;% \n  quantile(probs = c(seq(0, 1, 0.1), 0.25, 0.75), na.rm = TRUE)\n# Intervalle inter-quartile\ndonnees_tidyverse %&gt;%\n  pull(note_moyenne) %&gt;% \n  IQR(na.rm = TRUE)\n\n\n\n\n# on calcule déjà la moyenne des notes par individu\nnotes &lt;- c(\"note_contenu\",\"note_formateur\",\"note_moyens\",\"note_accompagnement\",\"note_materiel\")\n# On souhaite moyenner les notes par formation\ndonnees_datatable[, note_moyenne := rowMeans(.SD, na.rm = TRUE), .SDcols = notes]\ndonnees_datatable[, quantile(.SD, probs = c(seq(0, 1, 0.1), 0.25, 0.75), na.rm = TRUE), .SDcols = \"note_moyenne\"]\n# Intervalle inter-quartile\ndonnees_datatable[, IQR(note_moyenne, na.rm = TRUE)]\ndonnees_datatable[, lapply(.SD, function(x) IQR(x, na.rm = TRUE)), .SDcols = \"note_moyenne\"]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#déciles-et-quartiles-pondérés",
    "href": "01-aide_memoire_r_sas.html#déciles-et-quartiles-pondérés",
    "title": "Aide-mémoire SAS - R",
    "section": "15.10 Déciles et quartiles pondérés",
    "text": "15.10 Déciles et quartiles pondérés\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On calcule déjà la moyenne des notes par individu */\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\ndata donnees_sas;\n  set donnees_sas;\n  Note_moyenne = mean(of &notes.);\nrun;\n/* Par la proc means */\nproc means data = donnees_sas StackODSOutput Min P10 P20 P30 P40 Median P60 P70 Q3 P80 P90 Max Q1 Median Q3 QRANGE;\n  var Note_moyenne;\n  ods output summary = Deciles_proc_means;\n  weight poids_sondage;\nrun;\n/* Par la proc univariate */\nproc univariate data = donnees_sas;\n  var Note_moyenne;\n  output out = Deciles_proc_univariate pctlpts=00 to 100 by 10 25 50 75 PCTLPRE=_;\n  weight poids_sondage;\nrun;\n\n\n\n# Une solution pour obtenir les résultats pondérés est d'utiliser la fonction fquantile du package collapse\nlibrary(collapse)\n# on calcule déjà la moyenne des notes par individu\nnotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\ndonnees_rbase$note_moyenne &lt;- rowMeans(donnees_rbase[, notes], na.rm = TRUE)\n# Et les quantiles\n# L'option na.rm est par défaut à TRUE dans le package\ncollapse::fquantile(donnees_rbase$note_moyenne, w = donnees_rbase$poids_sondage,\n                    probs = c(seq(0, 1, 0.1)))\n\n\n\n\n# Une solution pour obtenir les résultats pondérés est d'utiliser les fonctions du package collapse\nlibrary(collapse)\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  mutate(note_moyenne = rowMeans(across(all_of(varNotes)), na.rm = TRUE))\n# Et les quantiles\n# L'option na.rm est par défaut à TRUE dans le package\ndonnees_tidyverse %&gt;%\n  pull(note_moyenne) %&gt;% \n  collapse::fquantile(probs = c(seq(0, 1, 0.1)), w = donnees_tidyverse$poids_sondage)\ndonnees_tidyverse %&gt;%\n  pull(note_moyenne) %&gt;% \n  collapse::fquantile(probs = c(0, 0.25, 0.5, 0.75, 1), w = donnees_tidyverse$poids_sondage)\n\n\n\n\n# Une solution pour obtenir les résultats pondérés est d'utiliser la fonction fquantile du package collapse\nlibrary(collapse)\n# on calcule déjà la moyenne des notes par individu\nnotes &lt;- c(\"note_contenu\",\"note_formateur\",\"note_moyens\",\"note_accompagnement\",\"note_materiel\")\n# On souhaite moyenner les notes par formation\n# L'option na.rm est par défaut à TRUE dans le package\ndonnees_datatable[, note_moyenne := rowMeans(.SD, na.rm = TRUE), .SDcols = notes]\ndonnees_datatable[, lapply(.SD, function(x) collapse::fquantile(x, w = poids_sondage,\n                                                                probs = c(seq(0, 1, 0.1))\n                                                                )),\n                           .SDcols = \"note_moyenne\"]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#rang-de-la-note",
    "href": "01-aide_memoire_r_sas.html#rang-de-la-note",
    "title": "Aide-mémoire SAS - R",
    "section": "15.11 Rang de la note",
    "text": "15.11 Rang de la note\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Ajouter dans la base le rang de la note par ordre décroissant */\nproc rank data = donnees_sas out = donnees_sas descending;\n  var note_moyenne;\n  ranks rang_note_moyenne;\nrun;\n\n\n\n# Ajouter dans la base le rang de la note par ordre décroissant\ndonnees_rbase$rang_note_moyenne &lt;- rank(-donnees_rbase$note_moyenne)\n\n\n\n\n# Ajouter dans la base le rang de la note par ordre décroissant\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  mutate(note_moyenne = rowMeans(across(all_of(varNotes)), na.rm = TRUE)) %&gt;% \n  mutate(rang_note_moyenne = rank(-note_moyenne))\n\n\n\n\n# Ajouter dans la base le rang de la note par ordre décroissant\n# Attention, en R, rank trie par ordre croissant par défaut, alors que le tri est par ordre décroissant en SAS\n# On exprime le rang par ordre décroissant, avec le - devant\ndonnees_datatable[, rang_note_moyenne := rank(-note_moyenne)]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#corrélation-linéaire-entre-deux-notes",
    "href": "01-aide_memoire_r_sas.html#corrélation-linéaire-entre-deux-notes",
    "title": "Aide-mémoire SAS - R",
    "section": "15.12 Corrélation linéaire entre deux notes",
    "text": "15.12 Corrélation linéaire entre deux notes\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Covariance et corrélation linéaire (Kendall, Pearson, Spearman) */\nproc corr data = donnees_sas kendall pearson spearman cov;\n  var note_contenu note_formateur;\nrun;\n\n\n\n# Covariance (Kendall, Pearson, Spearman)\nwith(donnees_rbase,\n     sapply(c(\"pearson\", \"spearman\", \"kendall\"),\n            function(x) cov(note_contenu, note_formateur, method = x, use = \"complete.obs\")))\n# Corrélation linéaire (Kendall, Pearson, Spearman)\nwith(donnees_rbase,\n     sapply(c(\"pearson\", \"spearman\", \"kendall\"),\n            function(x) cor(note_contenu, note_formateur, method = x, use = \"complete.obs\")))\n\n\n\n\n# Covariance (Kendall, Pearson, Spearman)\n# À FAIRE : peut-on faire mieux ???\nmethodes &lt;- c(\"pearson\", \"spearman\", \"kendall\")\nmethodes %&gt;% \n  purrr::map(~ \n    donnees_tidyverse %&gt;% \n      summarise(cov = cov(note_contenu, note_formateur, method = .x, use = \"complete.obs\"))) %&gt;% \n  setNames(methodes) %&gt;% \n  as_tibble()\n\n# Corrélation linéaire (Kendall, Pearson, Spearman)\n# À FAIRE : peut-on faire mieux ???\nmethodes &lt;- c(\"pearson\", \"spearman\", \"kendall\")\nmethodes %&gt;% \n  purrr::map(~ donnees_tidyverse %&gt;% \n               summarise(cor = cor(note_contenu, note_formateur, method = .x, use = \"complete.obs\"))) %&gt;% \n  setNames(methodes) %&gt;% \n  as_tibble()\n\n\n\n\n# Covariance (Kendall, Pearson, Spearman)\nmethodes &lt;- c(\"pearson\", \"spearman\", \"kendall\")\nsetNames(donnees_datatable[, lapply(methodes,\n                           function(x) cov(note_contenu, note_formateur,\n                                           method = x,\n                                           use = \"complete.obs\"))],\n         methodes)\n# Corrélation linéaire (Kendall, Pearson, Spearman)\nsetNames(donnees_datatable[, lapply(methodes,\n                                    function(x) cor(note_contenu, note_formateur,\n                                                    method = x,\n                                                    use = \"complete.obs\"))],\n         methodes)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#tableaux-de-fréquence-proc-freq-pour-1-variable",
    "href": "01-aide_memoire_r_sas.html#tableaux-de-fréquence-proc-freq-pour-1-variable",
    "title": "Aide-mémoire SAS - R",
    "section": "16.1 Tableaux de fréquence (proc freq) pour 1 variable",
    "text": "16.1 Tableaux de fréquence (proc freq) pour 1 variable\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc freq data = donnees_sas;\n  tables Sexe CSP;\n  format Sexe sexef. CSP $cspf.;\nrun;\n\n\n\n# Tableaux de fréquence (proc freq) (sans les valeurs manquantes)\ntable(donnees_rbase$cspf)\ntable(donnees_rbase$sexef)\n# Autre syntaxe, donnant une mise en forme différente\nftable(donnees_rbase$cspf)\n# Pour enlever les \"donnees_rbase$\", on peut utiliser with pour se placer dans l'environnement de donnees_rbase\nwith(donnees_rbase, table(cspf))\n# Pour les proportions\nprop.table(table(donnees_rbase$cspf)) * 100\n# Devient plus difficile si l'on souhaite plus (sommes et proportions cumulées par exemple)\nfreq &lt;- setNames(as.data.frame(table(donnees_rbase$cspf)), c(\"cspf\", \"Freq\"))\nfreq &lt;- transform(freq, Prop = Freq / sum(Freq) * 100)\nfreq &lt;- transform(freq,\n                  Freq_cum = cumsum(Freq),\n                  Prop_cum = cumsum(Prop))\nfreq\n\n\n\n\ndonnees_tidyverse %&gt;% \n  count(cspf) %&gt;% \n  mutate(prop = n / sum(n) * 100,\n         n_cum = cumsum(n),\n         prop_cum = cumsum(prop))\ndonnees_tidyverse %&gt;% \n  count(sexef) %&gt;% \n  mutate(prop = n / sum(n) * 100,\n         n_cum = cumsum(n),\n         prop_cum = cumsum(prop))\n# Ou alors\ndonnees_tidyverse %&gt;% \n  group_by(cspf) %&gt;% \n  summarise(n = n()) %&gt;% \n  mutate(prop = n / sum(n) * 100,\n         n_cum = cumsum(n),\n         prop_cum = cumsum(prop)\n  )\n\n\n\n\n# Tableaux de fréquence (proc freq) (avec les valeurs manquantes)\ndonnees_datatable[, table(cspf) ]\ndonnees_datatable[, table(sexef) ]\n# Pour les proportions\ndonnees_datatable[, prop.table(table(cspf)) ] * 100\ndonnees_datatable[, .(Nombre = .N,\n                      Pourcentage = .N / length(donnees_datatable[, cspf]) * 100),\n                  keyby = cspf]\ndonnees_datatable[, {tot = .N; .SD[, .(frac = .N / tot * 100), keyby = cspf]} ]\n# Autre façon d'utiliser les méthodes de data.table, avec les fréquences et proportions cumulés\ntab &lt;- data.table::dcast(donnees_datatable, cspf ~ ., fun = length)\ncolnames(tab)[colnames(tab) == \".\"] &lt;- \"Nombre\"\ntab[, Prop := lapply(.SD, function(col) col / sum(col) * 100), .SDcols = is.numeric]\ntab[, c(\"Freq_cum\", \"Prop_cum\") := list(cumsum(Nombre), cumsum(Prop))]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#tableaux-de-fréquence-avec-les-valeurs-manquantes",
    "href": "01-aide_memoire_r_sas.html#tableaux-de-fréquence-avec-les-valeurs-manquantes",
    "title": "Aide-mémoire SAS - R",
    "section": "16.2 Tableaux de fréquence avec les valeurs manquantes",
    "text": "16.2 Tableaux de fréquence avec les valeurs manquantes\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc freq data = donnees_sas;\n  tables Sexe CSP / missing;\n  format Sexe sexef. CSP $cspf.;\nrun;\n\n\n\n# Tableaux de fréquence (proc freq) (avec les valeurs manquantes)\ntable(donnees_rbase$cspf, useNA = \"always\")\nprop.table(table(donnees_rbase$cspf, useNA = \"always\")) * 100\n\n\n\n\n# Tableaux de fréquence (proc freq) (avec les valeurs manquantes)\ntable(donnees_rbase$cspf, useNA = \"always\")\nprop.table(table(donnees_rbase$cspf, useNA = \"always\")) * 100\ndonnees_tidyverse %&gt;% \n  count(cspf) %&gt;% \n  mutate(prop = n / sum(n) * 100)\n\n\n\n\ndonnees_datatable[, table(cspf, useNA = \"always\") ]\ndonnees_datatable[, prop.table(table(cspf, useNA = \"always\"))] * 100\ndonnees_datatable[, .(Nombre = .N,\n                      Pourcentage = .N / length(donnees_datatable[, cspf]) * 100),\n                  keyby = cspf]\ndonnees_datatable[, {tot = .N; .SD[, .(frac = .N / tot * 100), keyby = cspf]} ]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#tableaux-de-fréquence-trié-par-modalité-la-plus-courante",
    "href": "01-aide_memoire_r_sas.html#tableaux-de-fréquence-trié-par-modalité-la-plus-courante",
    "title": "Aide-mémoire SAS - R",
    "section": "16.3 Tableaux de fréquence trié par modalité la plus courante",
    "text": "16.3 Tableaux de fréquence trié par modalité la plus courante\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc freq data = donnees_sas order = freq;\n  tables Sexe CSP / missing;\n  format Sexe sexef. CSP $cspf.;\nrun;\n\n\n\nfreq &lt;- setNames(as.data.frame(table(donnees_rbase$cspf)), c(\"cspf\", \"Freq\"))\nfreq &lt;- transform(freq, Prop = Freq / sum(Freq) * 100)\nfreq[order(-freq$Freq), ]\n\n\n\n\ndonnees_tidyverse %&gt;% \n  count(cspf) %&gt;% \n  arrange(desc(n)) %&gt;% \n  mutate(prop = n / sum(n) * 100,\n         n_cum = cumsum(n),\n         prop_cum = cumsum(prop))\ndonnees_tidyverse %&gt;% \n  count(cspf, sort = TRUE) %&gt;% \n  mutate(prop = n / sum(n) * 100,\n         n_cum = cumsum(n),\n         prop_cum = cumsum(prop))\n\n\n\n\ndonnees_datatable[, .(Nombre = .N,\n                      Pourcentage = .N / length(donnees_datatable[, cspf]) * 100),\n                  keyby = cspf][order(-Nombre)]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#tableaux-de-fréquence-avec-la-pondération",
    "href": "01-aide_memoire_r_sas.html#tableaux-de-fréquence-avec-la-pondération",
    "title": "Aide-mémoire SAS - R",
    "section": "16.4 Tableaux de fréquence avec la pondération",
    "text": "16.4 Tableaux de fréquence avec la pondération\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc freq data = donnees_sas;\n  tables Sexe CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n\n\n\nxtabs(poids_sondage ~ cspf, data = donnees_rbase, addNA = TRUE)\nprop.table(xtabs(poids_sondage ~ cspf, data = donnees_rbase, addNA = TRUE))\n\n\n\n\ndonnees_tidyverse %&gt;% \n  count(cspf, wt = poids_sondage) %&gt;% \n  mutate(prop = n / sum(n) * 100,\n         n_cum = cumsum(n),\n         prop_cum = cumsum(prop))\n\n\n\n\ndonnees_datatable[, xtabs(poids_sondage ~ cspf, data = donnees_datatable, addNA = TRUE) ]\ndonnees_datatable[, prop.table(xtabs(poids_sondage ~ cspf, data = donnees_datatable, addNA = TRUE)) ]\ndonnees_datatable[, .(prop = sum(poids_sondage, na.rm = TRUE) / sum(donnees_datatable[, poids_sondage]) * 100), keyby = cspf]\ndonnees_datatable[, {tot = sum(poids_sondage, na.rm = TRUE); .SD[, .(prop = sum(poids_sondage, na.rm = TRUE) / tot * 100), by = cspf]} ]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#tableaux-de-contingence-proc-freq-pour-2-variables",
    "href": "01-aide_memoire_r_sas.html#tableaux-de-contingence-proc-freq-pour-2-variables",
    "title": "Aide-mémoire SAS - R",
    "section": "16.5 Tableaux de contingence (proc freq) pour 2 variables",
    "text": "16.5 Tableaux de contingence (proc freq) pour 2 variables\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\nrun;\n\n/* Tableau de contingence (tableau croisé) sans les proportions lignes, colonnes et totales */\nproc freq data = donnees_sas;\n  tables CSP * Sexe  / missing nofreq norow nocol;\n  format Sexe sexef. CSP $cspf.;\nrun;\n\n\n\n# Tableau simple\ntable(donnees_rbase$cspf, donnees_rbase$sexef, useNA = \"always\")\n# Tableau avec les sommes\naddmargins(table(donnees_rbase$cspf, donnees_rbase$sexef, useNA = \"always\"))\n# Proportions\ntab &lt;- table(donnees_rbase$cspf, donnees_rbase$sexef, useNA = \"always\")\n# Proportions par case\naddmargins(prop.table(tab)) * 100\n# Proportions par ligne\naddmargins(prop.table(tab, margin = 1)) * 100\n# Proportions par colonne\naddmargins(prop.table(tab, margin = 2)) * 100\n\n# Solution alternative, sans pondération\ntab &lt;- xtabs(~ cspf + sexef, data = donnees_rbase)\ntab\naddmargins(prop.table(tab)) * 100\naddmargins(prop.table(tab, margin = 1), margin = 2) * 100\naddmargins(prop.table(tab, margin = 2), margin = 1) * 100\n\n\n\n\n# À FAIRE : ajouter une une ligne avec les sommes !\n# Tableau de fréquence\ndonnees_tidyverse %&gt;% \n  group_by(cspf, sexef) %&gt;% \n  summarise(prop = n(), .groups = \"drop_last\") %&gt;% \n  ungroup() %&gt;% \n  mutate(prop = prop / sum(prop) * 100) %&gt;%\n  spread(sexef, prop) %&gt;% \n  mutate(Total = rowSums(across(where(is.numeric)), na.rm = TRUE))\n\n# Proportions par ligne\ndonnees_tidyverse %&gt;% \n  group_by(cspf, sexef) %&gt;% \n  summarise(prop = n()) %&gt;% \n  mutate(prop = prop / sum(prop) * 100) %&gt;% \n  spread(sexef, prop)\n\n# Proportions par colonne\ndonnees_tidyverse %&gt;% \n  group_by(sexef, cspf) %&gt;% \n  summarise(prop = n()) %&gt;% \n  mutate(prop = prop / sum(prop) * 100) %&gt;% \n  spread(sexef, prop)\n\n\ntab &lt;- donnees_tidyverse %&gt;% \n  count(cspf, sexef, wt = poids_sondage, name = \"prop\") %&gt;% \n  ungroup() %&gt;% \n  mutate(prop = prop / sum(prop) * 100) %&gt;% \n  # À FAIRE : pourrait-on sommer directement avec pivot_wider ? Argument values_fn?\n  # Ne semble pas fonctionner, pourqoi ???\n  pivot_wider(names_from = sexef, values_from = prop) %&gt;% \n  # Somme par lignes\n  mutate(Total = rowSums(across(where(is.numeric)), na.rm = TRUE))\n# Autre solution avec rowwise : bien penser à c_across et non across !\n#rowwise() %&gt;% \n#mutate(Total = sum(c_across(where(is.numeric)), na.rm = T)) %&gt;% \n#ungroup()\n# Somme par colonnes\ntab &lt;- bind_rows(tab, tab %&gt;% \n                   summarise(across(where(is.numeric), \\(x) mean(x, na.rm = TRUE)),\n                             across(where(is.character), ~\"Total\"))\n)\ntab\n\n\n\n\n# Tableau simple\ndonnees_datatable[, table(cspf, sexef, useNA = \"always\") ]\n# Tableau avec les sommes\ndonnees_datatable[, addmargins(table(cspf, sexef, useNA = \"always\")) ]\n# Proportions\ntab &lt;- donnees_datatable[, table(cspf, sexef, useNA = \"always\") ]\n# Proportions par case\naddmargins(prop.table(tab)) * 100\n# Proportions par ligne\naddmargins(prop.table(tab, margin = 1)) * 100\n# Proportions par colonne\naddmargins(prop.table(tab, margin = 2)) * 100\n\n# Solution alternative, sans pondération\ntab &lt;- donnees_datatable[, xtabs(~ cspf + sexef, data = donnees_datatable) ]\ntab\naddmargins(prop.table(tab)) * 100\naddmargins(prop.table(tab, margin = 1), margin = 2) * 100\naddmargins(prop.table(tab, margin = 2), margin = 1) * 100\n\n# Autre solution, avec les Grouping sets\ntab &lt;- data.table::cube(donnees_datatable, .(Nb = .N), by = c(\"cspf\", \"sexef\"))\ntab &lt;- data.table::dcast(tab, cspf ~ sexef, value.var = \"Nb\")\n# On harmonise le tableau\ntab &lt;- rbind(tab[2:nrow(tab)], tab[1,])\nsetcolorder(tab, c(setdiff(names(tab), \"NA\"), \"NA\"))\n# On renomme la ligne et la colonne des totaux\ntab[nrow(tab), 1] &lt;- \"Total\"\nnames(tab)[which(names(tab) == \"NA\")] &lt;- \"Total\"\ntab\n\n# Autre façon d'utiliser les méthodes de data.table\ntab_prop &lt;- data.table::dcast(donnees_datatable, cspf ~ sexef, fun.aggregate = length)\n# Proportion par ligne\ntab_prop[, .SD / Reduce(`+`, .SD), cspf]\n# Proportion par colonne\ncols &lt;- unique(donnees_datatable[, (sexef)])\ntab_prop[, (lapply(.SD, function(col) col / sum(col))), .SDcols = cols]\n\n# Pour avoir les sommes lignes\n# À FAIRE : ne marche pas, à revoir !\n#tab_prop &lt;- data.table::dcast(donnees_datatable, cspf ~ sexef, fun.aggregate = length)\n#tab_prop[, Total := rowSums(.SD), .SDcols = is.numeric]\n#tab_prop &lt;- rbind(tab_prop, tab_prop[, c(cspf = \"Total\", lapply(.SD, sum, na.rm = TRUE)),\n#                                     .SDcols = is.numeric],\n#                  fill = TRUE)\n#tab_prop[, (lapply(.SD, function(col) col / sum(col))), .SDcols = -1]\n## Pour avoir les sommes colonnes\n#tab[, sum(.SD), by = 1:nrow(tab), .SDcols = is.numeric]\n#tab[, (lapply(.SD, function(col) col / sum(col))), .SDcols = -1]\n#\n## Autre solution plus pratique avec data.table\n## Manipuler des formules sur R\n#variable &lt;- c(\"cspf\", \"sexef\")\n#formule &lt;- as.formula(paste(paste(variable, collapse = \" + \"), \".\", sep = \" ~ \"))\n#tab_prop &lt;- data.table::dcast(donnees_datatable, formule, fun.aggregate = length)\n#colnames(tab_prop)[colnames(tab_prop) == \".\"] &lt;- \"total\"\n#tab_prop[, prop := total / sum(total)]\n## Le tableau est remis sous forme croisée\n#tab_prop &lt;- dcast(tab_prop, cspf ~ sexef, value.var = c(\"prop\"), fill = 0)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#tableau-de-contingence-avec-pondération",
    "href": "01-aide_memoire_r_sas.html#tableau-de-contingence-avec-pondération",
    "title": "Aide-mémoire SAS - R",
    "section": "16.6 Tableau de contingence avec pondération",
    "text": "16.6 Tableau de contingence avec pondération\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n\n\n\ntab &lt;- xtabs(poids_sondage ~ cspf + sexef, data = donnees_rbase, addNA = TRUE)\ntab\naddmargins(prop.table(tab)) * 100\naddmargins(prop.table(tab, margin = 1), margin = 2) * 100\naddmargins(prop.table(tab, margin = 2), margin = 1) * 100\n\n\n\n\n# Avec la fonction count\ndonnees_tidyverse %&gt;% \n  count(cspf, sexef, wt = poids_sondage, name = \"prop\") %&gt;% \n  ungroup() %&gt;% \n  mutate(prop = prop / sum(prop) * 100) %&gt;% \n  spread(sexef, prop)\n# Avec la fonction summarise\ndonnees_tidyverse %&gt;% \n  group_by(cspf, sexef) %&gt;% \n  summarise(prop = sum(poids_sondage, na.rm = TRUE)) %&gt;% \n  ungroup() %&gt;% \n  mutate(prop = prop / sum(prop) * 100) %&gt;% \n  spread(sexef, prop)\n# Avec ajout des sommes par ligne et colonne\ntab &lt;- donnees_tidyverse %&gt;% \n  count(cspf, sexef, wt = poids_sondage, name = \"prop\") %&gt;% \n  ungroup() %&gt;% \n  mutate(prop = prop / sum(prop) * 100) %&gt;% \n  # À FAIRE : pourrait-on sommer directement avec pivot_wider ? Argument values_fn?\n  # Ne semble pas fonctionner, pourqoi ???\n  pivot_wider(names_from = sexef, values_from = prop) %&gt;% \n  # Somme par lignes\n  mutate(Total = rowSums(across(where(is.numeric)), na.rm = TRUE))\n  # Autre solution avec rowwise : bien penser à c_across et non across !\n  #rowwise() %&gt;% \n  #mutate(Total = sum(c_across(where(is.numeric)), na.rm = T)) %&gt;% \n  #ungroup()\n# Somme par colonnes\ntab &lt;- bind_rows(tab, tab %&gt;% \n                   summarise(across(where(is.numeric), sum, na.rm = TRUE),\n                             across(where(is.character), ~\"Total\"))\n            )\ntab\n\n\n\n\ntab &lt;- donnees_datatable[, xtabs(poids_sondage ~ cspf + sexef, data = donnees_datatable, addNA = TRUE) ]\ntab\naddmargins(prop.table(tab)) * 100\naddmargins(prop.table(tab, margin = 1), margin = 2) * 100\naddmargins(prop.table(tab, margin = 2), margin = 1) * 100",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#copier-coller-le-tableau-dans-un-tableur-excel-etc.",
    "href": "01-aide_memoire_r_sas.html#copier-coller-le-tableau-dans-un-tableur-excel-etc.",
    "title": "Aide-mémoire SAS - R",
    "section": "16.7 Copier-coller le tableau dans un tableur (Excel, etc.)",
    "text": "16.7 Copier-coller le tableau dans un tableur (Excel, etc.)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Copier-coller le résultat sur la fenêtre html \"Results Viewer\" */\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing chisq;\n  format Sexe sexef. CSP $cspf.;\nrun;\n\n\n\n# On utilise les packages knitr et kableExtra\nlibrary(knitr)\nlibrary(kableExtra)\n# Création d'un tableau\ntab &lt;- xtabs(~ cspf + sexef, data = donnees_rbase)\ntab &lt;- addmargins(prop.table(tab)) * 100\n\n# Afficher de façon plus jolie un tableau\nknitr::kable(tab)\n\n# Copier-coller le résultat vers Excel\n# Il suffit d'appliquer ce code ....\nkableExtra::kable_paper(kableExtra::kbl(tab), \"hover\", full_width = F)\n# ... et de copier-coller le résultat de la fenêtre Viewer vers Excel\n\n\n\n\n# On utilise les packages knitr et kableExtra\nlibrary(knitr)\nlibrary(kableExtra)\n# Création d'un tableau\ntab &lt;- donnees_tidyverse %&gt;% \n  group_by(cspf, sexef) %&gt;% \n  summarise(prop = n(), .groups = \"drop_last\") %&gt;% \n  ungroup() %&gt;% \n  mutate(prop = prop / sum(prop) * 100) %&gt;% \n  spread(sexef, prop)\n\n# Afficher de façon plus jolie un tableau\ntab %&gt;% knitr::kable()\n\n# Copier-coller le résultat vers Excel\n# Il suffit d'appliquer ce code ....\ntab %&gt;% \n  knitr::kable() %&gt;% \n  kableExtra::kable_paper(\"hover\", full_width = F)\n# ... et de copier-coller le résultat de la fenêtre Viewer vers Excel\n\n\n\n\n# On utilise les packages knitr et kableExtra\nlibrary(knitr)\nlibrary(kableExtra)\n# Création d'un tableau\ntab &lt;- donnees_datatable[, xtabs(poids_sondage ~ cspf + sexef, data = donnees_datatable, addNA = TRUE) ]\ntab &lt;- \naddmargins(prop.table(tab)) * 100\n\n# Afficher de façon plus jolie un tableau\nknitr::kable(tab)\n\n# Copier-coller le résultat vers Excel\n# Il suffit d'appliquer ce code ....\nkableExtra::kable_paper(kableExtra::kbl(tab), \"hover\", full_width = F)\n# ... et de copier-coller le résultat de la fenêtre Viewer vers Excel",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#tests-dassociaton-chi-deux-etc.",
    "href": "01-aide_memoire_r_sas.html#tests-dassociaton-chi-deux-etc.",
    "title": "Aide-mémoire SAS - R",
    "section": "16.8 Tests d’associaton (Chi-Deux, etc.)",
    "text": "16.8 Tests d’associaton (Chi-Deux, etc.)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing chisq;\n  format Sexe sexef. CSP $cspf.;\nrun;\n\n\n\n# Test du Khi-Deux\nwith(donnees_rbase, chisq.test(cspf, sexef))\nsummary(table(donnees_rbase$cspf, donnees_rbase$sexef))\n\n\n\n\n# Test du Khi-Deux\n#donnees_tidyverse %&gt;%\n#  summarise(a = chisq.test(sexef, cspf))\n# À FAIRE : fonctionne, mais pas vraiment Tidyverse\nwith(donnees_tidyverse, chisq.test(cspf, sexef))\n\n\n\n\n# Test du Khi-Deux\ndonnees_datatable[, chisq.test(cspf, sexef)]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#solutions-avec-package-r-permettant-de-pondérer",
    "href": "01-aide_memoire_r_sas.html#solutions-avec-package-r-permettant-de-pondérer",
    "title": "Aide-mémoire SAS - R",
    "section": "16.9 Solutions avec package R permettant de pondérer",
    "text": "16.9 Solutions avec package R permettant de pondérer\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Sans objet pour SAS */\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n\n\n\n# Autre possibilité, avec packages, pour avoir la même présentation que la proc freq de SAS\n# 5 packages paraissent pertinents : descr, flextable, questionr, survey, procs\n\n\n\n\n# Autre possibilité, avec packages, pour avoir la même présentation que la proc freq de SAS\n# 5 packages paraissent pertinents : descr, flextable, questionr, survey, procs\n\n\n\n\n# Autre possibilité, avec packages, pour avoir la même présentation que la proc freq de SAS\n# 5 packages paraissent pertinents : descr, flextable, questionr, survey, procs",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#package-descr",
    "href": "01-aide_memoire_r_sas.html#package-descr",
    "title": "Aide-mémoire SAS - R",
    "section": "16.10 Package descr",
    "text": "16.10 Package descr\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Sans objet pour SAS */\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n\n\n\nlibrary(descr)\n# Non pondéré\nwith(donnees_rbase, descr::crosstab(cspf, sexef,                         prop.r = TRUE, prop.c = TRUE, prop.t = TRUE))\n# Pondéré\nwith(donnees_rbase, descr::crosstab(cspf, sexef, weight = poids_sondage, prop.r = TRUE, prop.c = TRUE, prop.t = TRUE))\n# Sans les proportions par ligne et colonne\nwith(donnees_rbase, descr::crosstab(cspf, sexef, weight = poids_sondage, prop.r = FALSE, prop.c = FALSE, prop.t = TRUE))\n\n\n\n\n# À FAIRE : est-il possible d'appliquer le pipe ???\nlibrary(descr)\n# Non pondéré\nwith(donnees_tidyverse, descr::crosstab(cspf, sexef,                         prop.r = TRUE, prop.c = TRUE, prop.t = TRUE))\n# Pondéré\nwith(donnees_tidyverse, descr::crosstab(cspf, sexef, weight = poids_sondage, prop.r = TRUE, prop.c = TRUE, prop.t = TRUE))\n# Sans les proportions par ligne et colonne\nwith(donnees_tidyverse, descr::crosstab(cspf, sexef, weight = poids_sondage, prop.r = FALSE, prop.c = FALSE, prop.t = TRUE))\n\n\n\n\nlibrary(descr)\n# Non pondéré\nwith(donnees_datatable, descr::crosstab(cspf, sexef,                         prop.r = TRUE, prop.c = TRUE, prop.t = TRUE))\n# Pondéré\nwith(donnees_datatable, descr::crosstab(cspf, sexef, weight = poids_sondage, prop.r = TRUE, prop.c = TRUE, prop.t = TRUE))\n# Sans les proportions par ligne et colonne\nwith(donnees_datatable, descr::crosstab(cspf, sexef, weight = poids_sondage, prop.r = FALSE, prop.c = FALSE, prop.t = TRUE))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#package-flextable",
    "href": "01-aide_memoire_r_sas.html#package-flextable",
    "title": "Aide-mémoire SAS - R",
    "section": "16.11 Package flextable",
    "text": "16.11 Package flextable\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Sans objet pour SAS */\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n\n\n\nlibrary(flextable)\n# Non pondéré\nflextable::proc_freq(donnees_rbase, \"cspf\", \"sexef\")\n# Pondéré\nflextable::proc_freq(donnees_rbase, \"cspf\", \"sexef\", weight = \"poids_sondage\")\n# Sans les proportions par ligne et colonne\nflextable::proc_freq(donnees_rbase, \"cspf\", \"sexef\", weight = \"poids_sondage\", include.row_percent = FALSE,\n                     include.column_percent = FALSE)\n\n\n\n\n# À FAIRE : est-il possible d'appliquer le pipe ???\nlibrary(flextable)\n# Non pondéré\nflextable::proc_freq(donnees_tidyverse, \"cspf\", \"sexef\")\n# Pondéré\nflextable::proc_freq(donnees_tidyverse, \"cspf\", \"sexef\", weight = \"poids_sondage\")\n# Sans les proportions par ligne et colonne\nflextable::proc_freq(donnees_tidyverse, \"cspf\", \"sexef\", weight = \"poids_sondage\", include.row_percent = FALSE,\n                     include.column_percent = FALSE)\n\n\n\n\nlibrary(flextable)\n# Non pondéré\nflextable::proc_freq(donnees_datatable, \"cspf\", \"sexef\")\n# Pondéré\nflextable::proc_freq(donnees_datatable, \"cspf\", \"sexef\", weight = \"poids_sondage\")\n# Sans les proportions par ligne et colonne\nflextable::proc_freq(donnees_datatable, \"cspf\", \"sexef\", weight = \"poids_sondage\", include.row_percent = FALSE,\n                     include.column_percent = FALSE)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#package-questionr",
    "href": "01-aide_memoire_r_sas.html#package-questionr",
    "title": "Aide-mémoire SAS - R",
    "section": "16.12 Package questionr",
    "text": "16.12 Package questionr\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Sans objet pour SAS */\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n\n\n\n# Sans pondération\nlibrary(questionr)\n# Tableau croisé\n# Sans pondération\ntab &lt;- with(donnees_rbase, questionr::wtd.table(cspf, sexef, useNA = \"ifany\"), na.rm = TRUE)\n# Avec pondération\ntab &lt;- with(donnees_rbase, questionr::wtd.table(cspf, sexef, weights = poids_sondage, useNA = \"ifany\"), na.rm = TRUE)\ntab\n# Proportions\nquestionr::prop(tab)\n# Proportions colonnes\nquestionr::cprop(tab)\n# Proportions lignes\nquestionr::rprop(tab)\n\n\n\n\n# Sans pondération\nlibrary(questionr)\n# Tableau croisé\n# Sans pondération\ntab &lt;- with(donnees_tidyverse, questionr::wtd.table(cspf, sexef, useNA = \"ifany\"), na.rm = TRUE)\n# Avec pondération\ntab &lt;- with(donnees_tidyverse, questionr::wtd.table(cspf, sexef, weights = poids_sondage, useNA = \"ifany\"), na.rm = TRUE)\ntab\n# Proportions\nquestionr::prop(tab)\n# Proportions colonnes\nquestionr::cprop(tab)\n# Proportions lignes\nquestionr::rprop(tab)\n\n\n\n\n# Sans pondération\nlibrary(questionr)\n# Tableau croisé\n# Sans pondération\ntab &lt;- with(donnees_datatable, questionr::wtd.table(cspf, sexef, useNA = \"ifany\"), na.rm = TRUE)\n# Avec pondération\ntab &lt;- with(donnees_datatable, questionr::wtd.table(cspf, sexef, weights = poids_sondage, useNA = \"ifany\"), na.rm = TRUE)\ntab\n# Proportions\nquestionr::prop(tab)\n# Proportions colonnes\nquestionr::cprop(tab)\n# Proportions lignes\nquestionr::rprop(tab)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#package-survey",
    "href": "01-aide_memoire_r_sas.html#package-survey",
    "title": "Aide-mémoire SAS - R",
    "section": "16.13 Package survey",
    "text": "16.13 Package survey\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Sans objet pour SAS */\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n\n\n\n# À FAIRE : ne fonctionne pas\nlibrary(survey)\ntab &lt;- survey::svydesign(id = ~1, weights = ~poids_sondage, data = donnees_rbase)\nsurvey::svytable(poids_sondage ~ sexef + cspf, design = tab)\n\n\n\n\n# La syntaxe avec pipe n'est pas compatible avec le package survey\nlibrary(survey)\ntab &lt;- survey::svydesign(id = ~1, weights = ~poids_sondage, data = donnees_tidyverse)\nsurvey::svytable(poids_sondage ~ sexef + cspf, design = tab)\n\n\n\n\n# À FAIRE : ne fonctionne pas\nlibrary(survey)\ntab &lt;- survey::svydesign(id = ~1, weights = ~poids_sondage, data = donnees_datatable)\nsurvey::svytable(poids_sondage ~ sexef + cspf, design = tab)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#package-procs",
    "href": "01-aide_memoire_r_sas.html#package-procs",
    "title": "Aide-mémoire SAS - R",
    "section": "16.14 Package procs",
    "text": "16.14 Package procs\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Sans objet pour SAS */\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n\n\n\nlibrary(procs)\nprocs::proc_freq(donnees_rbase, tables = cspf * sexef, options = v(missing))\n# Ne fonctionne pas avec le poids !!!\n#procs::proc_freq(donnees_rbase, tables = cspf * sexef, weight = poids_sondage, options = v(missing))\n\n\n\n\nlibrary(procs)\nprocs::proc_freq(donnees_tidyverse, tables = cspf * sexef, options = v(missing))\n# Ne fonctionne pas avec le poids !!!\n#procs::proc_freq(donnees_tidyverse, tables = cspf * sexef, weight = poids_sondage, options = v(missing))\n\n\n\n\nlibrary(procs)\n# Il semble nécessaire de convertire l'objet en data.frame\nprocs::proc_freq(setDF(donnees_datatable), tables = cspf * sexef, options = v(missing))\n# Ne fonctionne pas avec le poids !!!\n#procs::proc_freq(setDF(donnees_datatable), tables = cspf * sexef, weight = poids_sondage, options = v(missing))\n# On reconvertit en data.table\nsetDT(donnees_datatable)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#solutions-avec-package-r-ne-permettant-apparemment-pas-de-pondérer",
    "href": "01-aide_memoire_r_sas.html#solutions-avec-package-r-ne-permettant-apparemment-pas-de-pondérer",
    "title": "Aide-mémoire SAS - R",
    "section": "16.15 Solutions avec package R ne permettant apparemment pas de pondérer",
    "text": "16.15 Solutions avec package R ne permettant apparemment pas de pondérer\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Sans objet pour SAS */\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n\n\n\n# Autre possibilité, avec packages, pour avoir la même présentation que la proc freq de SAS\n# Autres packages, qui semblent quasi-inutiles, car ils ne permettent apparemment pas de pondérer\n\n# Package janitor\nlibrary(janitor)\n# Attention, la fonction tabyl ne permet pas de pondérer\ntab &lt;- janitor::tabyl(donnees_rbase, cspf, sexef)\ntab\njanitor::adorn_totals(tab, c(\"row\", \"col\"))\n# Pourcentages\njanitor::adorn_percentages(tab, denominator = \"all\", na.rm = TRUE)\n# Pourcentages lignes\njanitor::adorn_percentages(tab, denominator = \"row\", na.rm = TRUE)\n# Pourcentages colonnes\njanitor::adorn_percentages(tab, denominator = \"col\", na.rm = TRUE)\n\n# Package crosstable\nlibrary(crosstable)\ncrosstable::crosstable(donnees_rbase, cspf, by = sexef, showNA = \"always\", percent_digits = 0, percent_pattern =\"{n} ({p_col}/{p_row})\")\n\n# Package gmodels\nlibrary(gmodels)\ngmodels::CrossTable(donnees_rbase$cspf, donnees_rbase$sexef)\n\n# Package gtsummary\nlibrary(gtsummary)\n# Pourcentages par case, colonne, ligne\ngtsummary::tbl_cross(data = donnees_rbase, row = cspf, col = sexef, percent = c(\"cell\"),   margin = c(\"column\", \"row\"), missing = c(\"always\"))\ngtsummary::tbl_cross(data = donnees_rbase, row = cspf, col = sexef, percent = c(\"column\"), margin = c(\"column\", \"row\"), missing = c(\"always\"))\ngtsummary::tbl_cross(data = donnees_rbase, row = cspf, col = sexef, percent = c(\"row\"),    margin = c(\"column\", \"row\"), missing = c(\"always\"))\n\n\n\n\n# Autre possibilité, avec packages, pour avoir la même présentation que la proc freq de SAS\n# Autres packages, qui semblent quasi-inutiles, car ils ne permettent apparemment pas de pondérer\n\n# Package janitor\nlibrary(janitor)\n# Attention, la fonction tabyl ne permet pas de pondérer\ntab &lt;- donnees_tidyverse %&gt;% \n  janitor::tabyl(cspf, sexef) %&gt;% \n  janitor::adorn_totals(c(\"row\", \"col\"))\ntab\n# Pourcentages\ntab %&gt;% janitor::adorn_percentages(denominator = \"all\", na.rm = TRUE)\n# Pourcentages lignes\ntab %&gt;% janitor::adorn_percentages(denominator = \"row\", na.rm = TRUE)\n# Pourcentages colonnes\ntab %&gt;% janitor::adorn_percentages(denominator = \"col\", na.rm = TRUE)\n\n# Package crosstable\nlibrary(crosstable)\ncrosstable::crosstable(donnees_tidyverse, cspf, by = sexef, showNA = \"always\",\n                       percent_digits = 0, percent_pattern =\"{n} ({p_col}/{p_row})\")\n\n# Package gmodels\nlibrary(gmodels)\ndonnees_tidyverse %&gt;% \n  summarise(gmodels::CrossTable(cspf, sexef))\n\n# Package gtsummary\nlibrary(gtsummary)\n# Pourcentages par case, colonne, ligne\ngtsummary::tbl_cross(data = donnees_tidyverse, row = cspf, col = sexef, percent = c(\"cell\"),   margin = c(\"column\", \"row\"), missing = c(\"always\"))\ngtsummary::tbl_cross(data = donnees_tidyverse, row = cspf, col = sexef, percent = c(\"column\"), margin = c(\"column\", \"row\"), missing = c(\"always\"))\ngtsummary::tbl_cross(data = donnees_tidyverse, row = cspf, col = sexef, percent = c(\"row\"),    margin = c(\"column\", \"row\"), missing = c(\"always\"))\n\n\n\n\n# Autre possibilité, avec packages, pour avoir la même présentation que la proc freq de SAS\n# Autres packages, qui semblent quasi-inutiles, car ils ne permettent apparemment pas de pondérer\n\n# Package janitor\nlibrary(janitor)\n# Attention, la fonction tabyl ne permet pas de pondérer\ntab &lt;- janitor::tabyl(donnees_datatable, cspf, sexef)\ntab\njanitor::adorn_totals(tab, c(\"row\", \"col\"))\n# Pourcentages\njanitor::adorn_percentages(tab, denominator = \"all\", na.rm = TRUE)\n# Pourcentages lignes\njanitor::adorn_percentages(tab, denominator = \"row\", na.rm = TRUE)\n# Pourcentages colonnes\njanitor::adorn_percentages(tab, denominator = \"col\", na.rm = TRUE)\n\n# Package crosstable : lui non plus ne permet pas de pondérer, apparemment ...\nlibrary(crosstable)\ncrosstable::crosstable(donnees_datatable, cspf, by = sexef, showNA = \"always\",\n                       percent_digits = 0, percent_pattern =\"{n} ({p_col}/{p_row})\")\n\n# Package gmodels : ne permet pas de pondérer, apparemment\nlibrary(gmodels)\ngmodels::CrossTable(donnees_datatable$cspf, donnees_datatable$sexef)\n\n# Package gtsummary : ne permet pas de pondérer, apparemment\nlibrary(gtsummary)\n# Pourcentages par case, colonne, ligne\ngtsummary::tbl_cross(data = donnees_datatable, row = cspf, col = sexef, percent = c(\"cell\"),  \n                     margin = c(\"column\", \"row\"), missing = c(\"always\"))\ngtsummary::tbl_cross(data = donnees_datatable, row = cspf, col = sexef, percent = c(\"column\"),\n                     margin = c(\"column\", \"row\"), missing = c(\"always\"))\ngtsummary::tbl_cross(data = donnees_datatable, row = cspf, col = sexef, percent = c(\"row\"),   \n                     margin = c(\"column\", \"row\"), missing = c(\"always\"))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#une-seule-variable-de-groupement-une-seule-variable",
    "href": "01-aide_memoire_r_sas.html#une-seule-variable-de-groupement-une-seule-variable",
    "title": "Aide-mémoire SAS - R",
    "section": "17.1 Une seule variable de groupement, une seule variable",
    "text": "17.1 Une seule variable de groupement, une seule variable\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Moyenne de note_contenu et nombre de personnes */\n/* 1ère solution */\nproc sort data = donnees_sas;by cspf;run;\nproc means data = donnees_sas mean n;var note_contenu;class cspf;run;\n/* 2e solution */\nproc tabulate data = donnees_sas;\n  var note_contenu;\n  class cspf;\n  table (cspf all = \"Total\"), note_contenu * (mean n);\nrun;\n/* 3e solution */\nproc sql;\n  select cspf, mean(note_contenu) as note_contenu_moyenne, count(*) as N\n  from donnees_sas\n  group by cspf\n  order by cspf;\nquit;\n/* Avec la pondération */\nproc sort data = donnees_sas;by cspf;run;\nproc means data = donnees_sas mean n;\n  var note_contenu;class cspf;\n  weight poids_sondage;\nrun;\nproc tabulate data = donnees_sas;\n  var note_contenu;\n  class cspf;\n  weight poids_sondage;\n  table (cspf all = \"Total\"), note_contenu * (mean n);\nrun;\n\n\n\n# Moyenne de note_contenu et nombre de personnes\naggregate(note_contenu ~ cspf, donnees_rbase, function(x) c(Moyenne = mean(x, na.rm = TRUE), Nombre = length(x)))\n# Moyenne de note_contenu\n# Une seule variable, une seule variable de groupe, une seule fonction\naggregate(note_contenu ~ cspf, donnees_rbase, mean, na.rm = TRUE)\n# rowsum, à ne pas confondre avec rowSums, calcule des sommes, et uniquement des sommes\nrowsum(donnees_rbase$note_contenu, donnees_rbase$cspf, recorder = TRUE, na.rm = TRUE)\n# Fonctions tapply et by\ntapply(donnees_rbase$note_contenu, donnees_rbase$cspf, mean, na.rm = TRUE)\nwith(donnees_rbase, tapply(note_contenu, cspf, mean, na.rm = TRUE))\ntapply(donnees_rbase$note_contenu, donnees_rbase$cspf, mean, na.rm = TRUE)\nby(donnees_rbase$note_contenu, donnees_rbase$cspf, mean, na.rm = TRUE)\n\n# Avec la pondération : tapply ne fonctionne pas, il faut découper la base en facteurs avec split\nsapply(split(donnees_rbase, donnees_rbase$cspf), function(x) weighted.mean(x$note_contenu, x$poids_sondage, na.rm = TRUE))\n# À FAIRE : autre solution ?\n\n\n\n\n# Moyenne de note_contenu et nombre de personnes\ndonnees_tidyverse %&gt;% \n  group_by(cspf) %&gt;% \n  summarise(Nombre = n(), Moyenne = mean(note_contenu, na.rm = TRUE))\n# Moyenne de note_contenu\n# Une seule variable, une seule variable de groupe, une seule fonction\ndonnees_tidyverse %&gt;% \n  group_by(cspf) %&gt;% \n  summarise(Moyenne = mean(note_contenu, na.rm = TRUE))\n\n# Avec la pondération\ndonnees_tidyverse %&gt;% \n  group_by(cspf) %&gt;% \n  summarise(Moyenne = weighted.mean(note_contenu, poids_sondage, na.rm = TRUE))\n\n\n\n\n# Moyenne de note_contenu et nombre de personnes\ndonnees_datatable[, .(note_contenu_moyenne = mean(note_contenu, na.rm = TRUE), N = .N), by = cspf]\ndonnees_datatable[, .(note_contenu_moyenne = mean(note_contenu, na.rm = TRUE), N = .N), keyby = \"cspf\"]\n# Variables définies à part\nvarNotes &lt;- \"note_contenu\"\nvar_groupe &lt;- \"cspf\"\n# À FAIRE : les deux variables sont empilées, pourquoi ??\ndonnees_datatable[, lapply(.SD, function(x) list(moyenne = mean(x, na.rm = TRUE), n = length(x))), keyby = var_groupe,\n                  .SDcols = varNotes]\n# Avec la pondération\ndonnees_datatable[, lapply(.SD, function(x) weighted.mean(x, poids_sondage, na.rm = TRUE)), keyby = var_groupe,\n                  .SDcols = varNotes]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#plusieurs-variables",
    "href": "01-aide_memoire_r_sas.html#plusieurs-variables",
    "title": "Aide-mémoire SAS - R",
    "section": "17.2 Plusieurs variables",
    "text": "17.2 Plusieurs variables\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let var_notes = note_contenu note_formateur note_moyens note_accompagnement note_materiel;\n%let var_groupe = cspf sexef;\nproc sort data = donnees_sas;by &var_groupe.;run;\nproc means data = donnees_sas mean n;\n  class &var_groupe.;\n  var &var_notes.;\n  output out = Resultat;\nrun;\n/* Autre solution */\n%macro sel;\n  %global select;\n  %local i j;\n  %let select = ;\n  %do i = 1 %to %sysfunc(countw(&var_notes.));\n    %let j = %scan(&var_notes., &i., %str( ));\n    %let select = &select. mean(&j) as &j._moyenne,;\n  %end;\n%mend sel;\n%sel;\n%let group = %sysfunc(tranwrd(&var_groupe., %str( ), %str(, )));\nproc sql;\n  select &group., &select. count(*) as N\n  from donnees_sas\n  group by &group.\n  order by &group.;\nquit;\n\n\n\n# Plusieurs solutions avec aggregate (plutôt lent)\naggregate(note_contenu ~ cspf + sexef, donnees_rbase, function(x) c(mean = mean(x), n = length(x)))\naggregate(cbind(note_contenu, note_materiel) ~ cspf + sexef, donnees_rbase, function(x) c(moyenne = mean(x, na.rm = TRUE), n = length(x)))\n# Via les formules\nvariable &lt;- c(\"note_contenu\")\nvarGroupement &lt;- c(\"cspf\", \"sexef\")\nformule &lt;- as.formula(paste(variable, paste(varGroupement, collapse = \" + \"), sep = \" ~ \"))\naggregate(formule, donnees_rbase, function(x) c(moyenne = mean(x, na.rm = TRUE), n = length(x)))\n# Avec by\nby(donnees_rbase[, variable], donnees_rbase[, varGroupement], function(x) c(mean = mean(x, na.rm = TRUE), n = length(x)))\n# Avec rowum : on ne peut calculer que la somme\nrowsum(donnees_rbase[, variable], interaction(donnees_rbase[, varGroupement], sep = \"_\", lex.order = TRUE))\n\n\n\n\ndonnees_tidyverse %&gt;% \n  group_by(cspf, sexef) %&gt;% \n  summarise(Moyenne = mean(note_contenu, na.rm = TRUE), n = n())\n\n\n\n\ndonnees_datatable[, .(note_contenu_moyenne = mean(note_contenu, na.rm = TRUE), N = .N), keyby = c(\"cspf\", \"sexef\")]\n# Autre solution\ndata.table::dcast(donnees_datatable, cspf + sexef ~ ., value.var = \"note_contenu\", fun.aggregate = mean, na.rm = TRUE)\n# Variables définies à part\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nvar_groupe &lt;- c(\"cspf\", \"sexef\")\n# À FAIRE : les deux variables sont empilées, pourquoi ??\ndonnees_datatable[, lapply(.SD, function(x) list(moyenne = mean(x, na.rm = TRUE), n = length(x))),\n                  keyby = var_groupe,\n                  .SDcols = varNotes]\n\n# Nombre de femmes par CSP\n# Il y a un recycling de gender = \"M\", utile de le mentionner\ndonnees_datatable[, .(Femmes = sum(sexef == \"Femme\", na.rm = TRUE), Hommes = sum(sexef == \"Homme\", na.rm = TRUE)), by = .(cspf)]\n\n# À FAIRE :\n# Exemple avec les variables dans .SDcols\n# data.table::setDT(DF)[, lapply(.SD, mean, na.rm = TRUE), .SDcols = c(\"x\", \"y\"), by = list(g, h)]\n# D'autres variations (par exemple, c(x, y) ou list(\"x\", \"y\") ne fonctionnent pas !)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#tableaux-croisés-à-2-variables-de-groupement",
    "href": "01-aide_memoire_r_sas.html#tableaux-croisés-à-2-variables-de-groupement",
    "title": "Aide-mémoire SAS - R",
    "section": "17.3 Tableaux croisés à 2 variables de groupement",
    "text": "17.3 Tableaux croisés à 2 variables de groupement\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc tabulate data = donnees_sas;\n  class cspf sexef;\n  var note_contenu;\n  table (cspf all = \"Ensemble\"), sexef * (note_contenu) * mean;\nrun;\n\n\n\n# Tableau croisé Cspf par Sexef\nvarGroupement &lt;- c(\"cspf\", \"sexef\")\nvariable &lt;- c(\"note_contenu\")\n# Solution avec tapply\ntapply(donnees_rbase[, variable], donnees_rbase[varGroupement], function(x) moyenne = mean(x, na.rm = TRUE))\n# Solution avec xtabs\nxtabs(note_contenu ~ cspf + sexef, aggregate(note_contenu ~ cspf + sexef, data = donnees_rbase, FUN = mean, na.rm = TRUE))\n# Ou, sous forme de formule\nformule &lt;- as.formula(paste(variable, paste(varGroupement, collapse = \" + \"), sep = \" ~ \"))\nxtabs(formule, aggregate(formule, data = donnees_rbase, FUN = mean, na.rm = TRUE))\n# Autre solution, en calculant un tableau \"long\", et en le transformant en \"wide\"\ntableau &lt;- aggregate(note_contenu ~ cspf + sexef, data = donnees_rbase, FUN = mean, na.rm = TRUE)\nreshape(tableau, \n        timevar = varGroupement[2],\n        idvar = varGroupement[1],\n        direction = \"wide\")\n\n\n\n\n# Tableau croisé Cspf par Sexef\nvarGroupement &lt;- c(\"cspf\", \"sexef\")\nvariable &lt;- c(\"note_contenu\")\ndonnees_tidyverse %&gt;% \n  group_by(across(all_of(varGroupement))) %&gt;% \n  summarise(across(all_of(variable), ~ mean(.x, na.rm = TRUE), .names = \"Moyenne\")) %&gt;% \n  spread(varGroupement[2], Moyenne)\n# Autre solution\ndonnees_tidyverse %&gt;% \n  group_by(!!!syms(varGroupement)) %&gt;% \n  summarise(Moyenne = mean(.data[[variable]], na.rm = TRUE)) %&gt;% \n  spread(varGroupement[2], Moyenne)\n\n\n\n\n# Tableau croisé Cspf par Sexef\nvarGroupement &lt;- c(\"cspf\", \"sexef\")\nvariable &lt;- \"note_contenu\"\ndata.table::dcast(donnees_datatable, cspf ~ sexef, value.var = \"note_contenu\", fun.aggregate = mean, na.rm = TRUE)\n# Avec références seulement\ndata.table::dcast(donnees_datatable, get(varGroupement[1]) ~ get(varGroupement[2]), value.var = variable,\n                  fun.aggregate = mean, na.rm = TRUE)\n# Autre solution, plus indirecte\n# À FAIRE : attention, toujours utiliser lapply, même avec une seule variable ! LE DIRE !!!\ntab &lt;- donnees_datatable[, lapply(.SD, mean, na.rm = TRUE), keyby = varGroupement, .SDcols = \"note_contenu\"]\ndata.table::dcast(tab, get(varGroupement[1]) ~ get(varGroupement[2]), value.var = variable)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#tableaux-croisés-à-3-variables-de-groupement-ou-plus-1-variable-en-ligne-2-en-colonne",
    "href": "01-aide_memoire_r_sas.html#tableaux-croisés-à-3-variables-de-groupement-ou-plus-1-variable-en-ligne-2-en-colonne",
    "title": "Aide-mémoire SAS - R",
    "section": "17.4 Tableaux croisés à 3 variables de groupement ou plus : 1 variable en ligne, 2 en colonne",
    "text": "17.4 Tableaux croisés à 3 variables de groupement ou plus : 1 variable en ligne, 2 en colonne\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Notes par croisement de CSP (en ligne) et de Sexe x Niveau */\n%let notes = note_contenu note_formateur note_moyens note_accompagnement note_materiel;\nproc tabulate data = donnees_sas;\n  class cspf sexef;\n  var &notes.;\n  table (cspf all = \"Ensemble\"), sexef * (&notes.) * mean;\nrun;\n\n/* Note_contenu par croisement de CSP (en ligne) et de Sexe x Niveau */\nproc tabulate data = donnees_sas;\n  class cspf sexef Niveau;\n  var note_moyenne;\n  table (cspf all = \"Ensemble\"), (sexef * Niveau) * (note_moyenne) * mean;\nrun;\n\n\n\n# 1er exemple : CSPF en ligne, et chacune des 5 notes croisées avec le sexe en colonne\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nvar_groupe &lt;- c(\"cspf\", \"sexef\")\ntableau &lt;- aggregate(donnees_rbase[, varNotes], donnees_rbase[var_groupe], function(x) moyenne = mean(x, na.rm = TRUE))\nreshape(tableau, \n        timevar = var_groupe[2],\n        idvar = var_groupe[1],\n        direction = \"wide\")\n\n# 2e exemple : CSPF en ligne, et croisement Sexe x Qualifié en colonne, note_contenu sommée\n# À FAIRE : proposer une fonction ?\nformule &lt;- as.formula(\"note_contenu ~ cspf + sexef + niveau\")\ntab &lt;- xtabs(formule, aggregate(formule, data = donnees_rbase, FUN = mean, na.rm = TRUE))\nnomsCol &lt;- do.call(paste, c(expand.grid(dimnames(tab)[-1L]), sep = \"_\"))\nnomsLig &lt;- dimnames(tab)[[1L]]\n# Transformation du tableau de résultats (en format array) vers un format matrix, puis dataframe\n# Permet d'exprimer le array (matrice multidimensionnelle) en un tableau à deux dimensions\n# On transforme le tableau en matrice ayant en nombre de lignes dim(tab)[1], c'est-à-dire le nombre de lignes du array\n# et en nombre de colonnes le reste des variables\ntab &lt;- data.frame(matrix(tab, nrow = dim(tab)[1L]))\n# Renommage des noms des colonnes de la base\ncolnames(tab) &lt;- nomsCol\n# Renommage des noms des lignes de la base\nrow.names(tab) &lt;- nomsLig\n# On annule les valeurs manquantes\ntab[is.na(tab)] &lt;- 0\ntab\n# À FAIRE : développer autour de cet exemple\n# Avec 3 variables\nxtabs(cbind(note_contenu, note_materiel) ~ cspf + sexef, donnees_rbase)\n\n\n\n\n# 1er exemple : CSPF en ligne, et chacune des 5 notes croisées avec le sexe en colonne\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nvar_groupe &lt;- c(\"cspf\", \"sexef\")\ndonnees_tidyverse %&gt;% \n  group_by(across(all_of(var_groupe))) %&gt;% \n  summarise(across(all_of(varNotes), ~ mean(.x, na.rm = TRUE))) %&gt;% \n  pivot_wider(names_from = sexef,\n              values_from = all_of(varNotes))\n\n\n\n# 2e exemple : CSPF en ligne, et croisement Sexe x Qualifié en colonne, note_contenu sommée\nvarNotes &lt;- c(\"note_contenu\")\nvar_groupe &lt;- c(\"cspf\", \"sexef\", \"niveau\")\ndonnees_tidyverse %&gt;% \n  group_by(across(all_of(var_groupe))) %&gt;% \n  summarise(across(all_of(varNotes), ~ mean(.x, na.rm = TRUE))) %&gt;% \n  pivot_wider(names_from = c(sexef, niveau),\n              values_from = all_of(varNotes),\n              values_fill = 0)\n\n\n\n\n# 1er exemple : CSPF en ligne, et chacune des 5 notes croisées avec le sexe en colonne\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nvar_groupe &lt;- c(\"cspf\", \"sexef\")\ndata.table::dcast(donnees_datatable, get(varGroupement[1]) ~ get(varGroupement[2]), value.var = varNotes,\n                  fun.aggregate = mean, na.rm = TRUE)\n\n# 2e exemple : CSPF en ligne, et croisement Sexe x Qualifié en colonne, note_contenu sommée\ndata.table::dcast(donnees_datatable, cspf ~ sexef + niveau, value.var = \"note_contenu\",\n                  fun.aggregate = mean, na.rm = TRUE)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#boucles-imbriquées",
    "href": "01-aide_memoire_r_sas.html#boucles-imbriquées",
    "title": "Aide-mémoire SAS - R",
    "section": "18.1 Boucles imbriquées",
    "text": "18.1 Boucles imbriquées\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata _null_;call symput('annee', strip(year(today())));run;\n/* Ensemble des premiers jours de chaque mois entre 2020 et le 31 décembre de l'année courante */\n%macro Boucles_Imbriquees(an_debut, an_fin);\n  %local i j;\n  %global liste_mois;\n  %let liste_mois = ;\n  %do i = &an_debut. %to &an_fin.;\n    %do j = 1 %to 12;\n      %let liste_mois = &liste_mois. %sysfunc(putn(%sysfunc(mdy(&j., 1, &i.)), ddmmyy10.));\n    %end;\n  %end;\n%mend Boucles_Imbriquees;\n%let annee = %sysfunc(year(%sysfunc(today())));\n%Boucles_Imbriquees(an_debut = 2020, an_fin = &annee.);\n%put &liste_mois.;\n\n\n\n# Ensemble des premiers jours de chaque mois entre 2020 et l'année courante\nannee &lt;- lubridate::year(Sys.Date())\n# 1ère solution avec for (lente, à déconseiller !)\nlisteMois &lt;- c()\nfor (i in seq(2020, annee)) {\n  for (j in 1:12) {\n    listeMois &lt;- as.Date(c(listeMois, lubridate::ymd(sprintf(\"%02d-%02d-01\", i, j))), origin = \"1970-01-01\")\n  }\n}\n# 2e  solution : 2 fonctions lapply imbriquées\nlisteMois &lt;- as.Date(unlist(lapply(seq(2020, annee), \n                                   function(x) lapply(1:12, function(y) lubridate::ymd(sprintf(\"%02d-%02d-01\", x, y))))),\n                     origin = \"1970-01-01\")\n# 3e solution : expand.grid\nlisteMois &lt;- sort(as.Date(apply(expand.grid(seq(2020, annee), 1:12), 1, \n                                function(x) lubridate::ymd(sprintf(\"%02d-%02d-01\", x[1], x[2]))),\n                          origin = \"1970-01-01\"))\n# 4e solution, la plus simple !\nseq.Date(lubridate::ymd(sprintf(\"%02d-01-01\", 2020)), lubridate::ymd(sprintf(\"%02d-12-01\", annee)), by = \"month\")\n\n\n\n\n# Ensemble des premiers jours de chaque mois entre 2020 et l'année courante\nannee &lt;- lubridate::year(Sys.Date())\n# 1ère solution : 2 fonctions map imbriquées\nlisteMois &lt;- purrr::map(seq(2020, annee), \n                        function(x) purrr::map(1:12,\n                                               function(y) lubridate::ymd(sprintf(\"%02d-%02d-01\", x, y)))) %&gt;% \n  unlist() %&gt;% \n  as.Date(, origin = \"1970-01-01\")\n\n# 2e solution : expand_grid\nlisteMois &lt;- tidyr::expand_grid(annee = seq(2020, annee), mois = 1:12) %&gt;% \n  apply(1, function(x) lubridate::ymd(sprintf(\"%02d-%02d-01\", x[1], x[2]))) %&gt;% \n  as.Date(, origin = \"1970-01-01\") %&gt;% \n  sort()\n\n# 3e solution, la plus simple\nseq.Date(lubridate::ymd(sprintf(\"%02d-01-01\", 2020)), lubridate::ymd(sprintf(\"%02d-12-01\", annee)), by = \"month\")\n\n\n\n\n# Ensemble des premiers jours de chaque mois entre 2020 et l'année courante\nannee &lt;- lubridate::year(Sys.Date())\n# 1ère solution avec for (lente, à déconseiller !)\nlisteMois &lt;- c()\nfor (i in seq(2020, annee)) {\n  for (j in 1:12) {\n    listeMois &lt;- as.Date(c(listeMois, lubridate::ymd(sprintf(\"%02d-%02d-01\", i, j))), origin = \"1970-01-01\")\n  }\n}\n# 2e  solution : 2 fonctions lapply imbriquées\nlisteMois &lt;- as.Date(unlist(lapply(seq(2020, annee), \n                                   function(x) lapply(1:12, function(y) lubridate::ymd(sprintf(\"%02d-%02d-01\", x, y))))),\n                     origin = \"1970-01-01\")\n# 3e solution : expand.grid\nlisteMois &lt;- sort(as.Date(apply(expand.grid(seq(2020, annee), 1:12), 1, \n                                function(x) lubridate::ymd(sprintf(\"%02d-%02d-01\", x[1], x[2]))),\n                          origin = \"1970-01-01\"))\n# 4e solution, la plus simple\nseq.Date(lubridate::ymd(sprintf(\"%02d-01-01\", 2020)), lubridate::ymd(sprintf(\"%02d-12-01\", annee)), by = \"month\")",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#boucles-imbriquées-second-exemple",
    "href": "01-aide_memoire_r_sas.html#boucles-imbriquées-second-exemple",
    "title": "Aide-mémoire SAS - R",
    "section": "18.2 Boucles imbriquées (second exemple)",
    "text": "18.2 Boucles imbriquées (second exemple)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Itérer sur toutes les années et les trimestres d'une certaine plage */\n/* on va afficher les noms base_AAAA_tT_nmax où AAAA désigne les années, T les trimestres, depuis 2020 */\n%macro iteration(debut, fin);\n  %global liste_an;\n  %let liste_an = ;\n  %do i = &debut. %to &fin.;\n    %let liste_an = &liste_an.&i.-;\n  %end;\n%mend iteration;\n%iteration(debut = 2020, fin = %sysfunc(year(%sysfunc(today()))));\n%put &liste_an.;\n%let liste_trim = 1 2 3 4;\n%let liste_niv = max min;\n/* Supposons que nous ayons des noms de fichier suffixés par AXXXX_TY_NZ, avec X l'année, Y le trimestre et\n   Z max ou min. Par exemple, A2010_T2_NMax */\n/* Pour obtenir l'ensemble de ces noms de 2010 à cette année */\n%macro noms_fichiers(base = temp);\n  %global res;\n  %let res = ;\n  %do j = 1 %to %sysfunc(countw(&liste_an., \"-\"));\n    %let y = %scan(&liste_an., &j., \"-\"); /* année */\n    %do i = 1 %to 4;\n      %let t = %scan(&liste_trim, &i.); /* trimestre */\n      %do g = 1 %to 2;\n        %let n = %scan(&liste_niv., &g.); /* niveau */\n        %let res = &res. &base._&y._t&t._n&n.;\n      %end;\n    %end;\n  %end;\n%mend noms_fichiers;\n%noms_fichiers(base = base);\n%put &res.;\n\n\n\n# Itérer sur toutes les années et les trimestres d'une certaine plage\n# on va afficher les noms base_AAAA_tT_nmax où AAAA désigne les années, T les trimestres, depuis 2020 \ndebut &lt;- 2020\nfin &lt;- lubridate::year(Sys.Date())\nres &lt;- unlist(lapply(debut:fin, function(x) lapply(c(\"max\", \"min\"), function(y)  sprintf(\"base_%4d_t%d_n%s\", x, 1:4, y))))\n\n\n\n\n# Itérer sur toutes les années et les trimestres d'une certaine plage\n# on va afficher les noms base_AAAA_tT_nmax où AAAA désigne les années, T les trimestres, depuis 2020 \ndebut &lt;- 2020\nfin &lt;- lubridate::year(Sys.Date())\nlisteMois &lt;- purrr::map(debut:fin, \n                        function(x) purrr::map(c(\"max\", \"min\"),\n                                               function(y) sprintf(\"base_%4d_t%d_n%s\", x, 1:4, y))) %&gt;% \n                          unlist()\n\n\n\n\n# Itérer sur toutes les années et les trimestres d'une certaine plage\n# on va afficher les noms base_AAAA_tT_nmax où AAAA désigne les années, T les trimestres, depuis 2020 \ndebut &lt;- 2020\nfin &lt;- lubridate::year(Sys.Date())\nres &lt;- unlist(lapply(debut:fin, function(x) lapply(c(\"max\", \"min\"), function(y)  sprintf(\"base_%4d_t%d_n%s\", x, 1:4, y))))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#boucles-for",
    "href": "01-aide_memoire_r_sas.html#boucles-for",
    "title": "Aide-mémoire SAS - R",
    "section": "18.3 Boucles for",
    "text": "18.3 Boucles for\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On va créer une base par année d'entrée */\nproc sql noprint;\n  select year(min(date_entree)), year(max(date_entree)) into :an_min, :an_max\n  from donnees_sas;\nquit;\n%macro Base_par_mois(debut, fin);\n  /* %local impose que an n'est pas de signification hors de la macro */\n  %local an;\n  /* %global impose que nom_bases peut être utilisé en dehors de la macro */\n  %global nom_bases;\n  /* On initalise la création de la macri-variable nom_bases */\n  %let nom_bases = ;\n  /* On itère entre &debut. et &fin. */\n  %do an = &debut. %to &fin.;\n    data Entree_&an.;\n      set donnees_sas;\n      if year(date_entree) = &an.;\n    run;\n    /* On ajoute à la macro-variable le nom de la base */\n    %let nom_bases = &nom_bases. Entree_&an.;\n  %end;\n%mend Base_par_mois;\n%Base_par_mois(debut = &an_min., fin = &an_max.);\n%put &nom_bases.;\n\n/* On va désormais empiler toutes les bases (concaténation par colonne) */\n/* L'instruction set utilisée de cette façon permet cet empilement */\ndata concatene;\n  set &nom_bases.;\nrun;\n\n\n\n# On va créer une base par année d'entrée\nanMin &lt;- min(lubridate::year(donnees_rbase$date_entree), na.rm = TRUE)\nanMax &lt;- max(lubridate::year(donnees_rbase$date_entree), na.rm = TRUE)\nfor (i in anMin:anMax) {\n  # assign permet de faire passer une chaîne de caractères en variable R\n  assign(paste(\"entree\", i, sep = \"_\"), donnees_rbase[which(lubridate::year(donnees_rbase$date_entree) == i), ])\n}\n# On va désormais empiler toutes les bases (concaténation par colonne)\n# do.call applique la fonction rbind à l'ensemble des bases issues du lapply\n# get permet de faire le chemin inverse de assign\nconcatene &lt;- do.call(rbind, lapply(paste(\"entree\", anMin:anMax, sep = \"_\"), get))\n\n\n\n\n# À FAIRE : problème pour les entrées où la date est manquante\n# On va créer une base par année d'entrée\nanMin &lt;- donnees_tidyverse %&gt;% pull(date_entree) %&gt;% lubridate::year() %&gt;% min(na.rm = TRUE)\nanMax &lt;- donnees_tidyverse %&gt;% pull(date_entree) %&gt;% lubridate::year() %&gt;% max(na.rm = TRUE)\nfor (i in anMin:anMax) {\n  # assign permet de faire passer une chaîne de caractères en variable R\n  assign(paste(\"entree\", i, sep = \"_\"),\n         donnees_tidyverse %&gt;% filter(lubridate::year(date_entree) == as.name(i)))\n}\n# On va désormais empiler toutes les bases (concaténation par colonne)\n# purrr::reduce applique la fonction bind_rows à l'ensemble des bases issues du purrr::map\n# get permet de faire le chemin inverse de assign\nconcatene &lt;- purrr::map(paste(\"entree\", anMin:anMax, sep = \"_\"), get) %&gt;% \n  purrr::reduce(bind_rows)\n\n\n\n\n# On va créer une base par année d'entrée\nanMin &lt;- min(lubridate::year(donnees_datatable$date_entree), na.rm = TRUE)\nanMax &lt;- max(lubridate::year(donnees_datatable$date_entree), na.rm = TRUE)\nfor (i in anMin:anMax) {\n  # assign permet de faire passer une chaîne de caractères en variable R\n  assign(paste(\"entree\", i, sep = \"_\"), donnees_datatable[lubridate::year(donnees_datatable$date_entree) == i, ])\n}\n# On va désormais empiler toutes les bases (concaténation par colonne)\n# do.call applique la fonction rbind à l'ensemble des bases issues du lapply\n# get permet de faire le chemin inverse de assign\nconcatene &lt;- rbindlist(lapply(paste(\"entree\", anMin:anMax, sep = \"_\"), get))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#boucles-for-second-exemple",
    "href": "01-aide_memoire_r_sas.html#boucles-for-second-exemple",
    "title": "Aide-mémoire SAS - R",
    "section": "18.4 Boucles for (second exemple)",
    "text": "18.4 Boucles for (second exemple)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On recherche toutes les valeurs de CSP différentes et on les met dans une variable.\n   On appelle la proc SQL :\n   - utilisation du quit et non run à la fin\n   - on récupère toutes les valeurs différentes de CSP, séparés par un espace (separated by)\n   - s'il y a un espace dans les noms, on le remplace par _ \n   - on les met dans la macro-variable liste_csp\n   - on trier la liste par valeur de CSP */\n/* On crée une variable de CSP formaté sans les accents et les espaces */\ndata donnees_sas;\n  set donnees_sas;\n  /* SAS ne pourra pas créer des bases de données avec des noms accentués */\n  /* On supprime dans le nom les lettres accentués. On le fait avec la fonction Translate */\n  CSPF2 = tranwrd(strip(CSPF), \" \", \"_\");\n  CSPF2 = translate(CSPF2, \"eeeeaacio\", \"éèêëàâçîô\");\nrun;\n\n/* Boucles et macros en SAS */\n/* Les boucles ne peuvent être utilisées que dans le cadre de macros */\n/* Ouverture de la macro */\n%macro Boucles(base = donnees_sas, var = CSPF2);\n  /* Les modalités de la variable */\n  proc sql noprint;select distinct &var. into :liste separated by \" \" from &base. order by &var.;quit;\n  /* On affiche la liste de ces modalités */\n  %put &liste.;\n  /* %let permet à SAS d'affecter une valeur à une variable en dehors d'une manipulation de base de données */\n  /* %sysfunc indique à SAS qu'il doit utiliser la fonction countw dans le cadre d'une macro (pas important) */\n  /* countw est une fonction qui compte le nombre de mots (séparés par un espace) d'une chaîne de caractères */\n  /* =&gt; on compte le nombre de CSP différentes */\n  %let nb = %sysfunc(countw(&liste.));\n  %put Nombre de modalités différentes : &nb.;\n  /* On itère pour chaque CSP différente ... */\n  %do i = 1 %to &nb.;\n    /* %scan : donne le i-ème mot de &liste. (les mots sont séparés par un espace) */\n    /* =&gt; on récupère donc la CSP numéro i */\n    %let j = %scan(&liste., &i.);\n    %put Variable : &j.;\n    /* On crée une base avec seulement les individus de la CSP correspondante */\n    data &var.;set donnees_sas;if &var. = \"&j.\";run;\n  %end;\n/* Fermeture de la macro */\n%mend Boucles;\n/* Lancement de la macro */\n%Boucles(base = donnees_sas, var = CSPF2);\n\n\n\n# Base par CSP\nfor (i in unique(donnees_rbase$cspf)) {\n  # Met en minuscule et enlève les accents\n  nomBase &lt;- tolower(chartr(\"éèêëàâçîô\", \"eeeeaacio\", i))\n  # assign permet de faire passer une chaîne de caractères en variable R\n  assign(nomBase, donnees_rbase[which(donnees_rbase$cspf == i), ])\n}\n\n\n\n\n# Base par CSP\nfor (i in donnees_tidyverse %&gt;% distinct(cspf) %&gt;% pull()) {\n  # Met en minuscule et enlève les accents\n  nomBase &lt;- chartr(\"éèêëàâçîô\", \"eeeeaacio\", i) %&gt;% tolower()\n  # assign permet de faire passer une chaîne de caractères en variable R\n  assign(nomBase, donnees_tidyverse %&gt;% \n           filter(cspf == as.name(i)))\n}\n\n\n\n\n# Créer une base pour chaque individu d'une certaine CSP\nfor (i in unique(donnees_datatable$cspf)) {\n  # Met en minuscule et enlève les accents\n  nomBase &lt;- tolower(chartr(\"éèêëàâçîô\", \"eeeeaacio\", i))\n  # assign permet de faire passer une chaîne de caractères en variable R\n  assign(nomBase, donnees_datatable[donnees_datatable$cspf == i, ])\n}",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#autres-transcriptions-de-fonctions-sas-vers-r",
    "href": "01-aide_memoire_r_sas.html#autres-transcriptions-de-fonctions-sas-vers-r",
    "title": "Aide-mémoire SAS - R",
    "section": "18.5 Autres transcriptions de fonctions SAS vers R",
    "text": "18.5 Autres transcriptions de fonctions SAS vers R\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* À FAIRE */\n\n\n\n# Mesurer la durée d'exécution d'un programme\nsystem.time(donnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ])\n# En SAS : include(\"chemin\")\n# En R : source(\"chemin\", encoding = \"utf-8\", echo = TRUE, max.deparse.length = 1e3)\n\n\n\n\n# Mesurer la durée d'exécution d'un programme\nsystem.time(donnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n              arrange(identifiant, date_entree))\n# En SAS : include(\"chemin\")\n# En R : source(\"chemin\", encoding = \"utf-8\", echo = TRUE, max.deparse.length = 1e3)\n\n\n\n\n# Mesurer la durée d'exécution d'un programme\nsystem.time(setorder(donnees_datatable, \"identifiant\", \"date_entree\", na.last = FALSE))\n# En SAS : include(\"chemin\")\n# En R : source(\"chemin\", encoding = \"utf-8\", echo = TRUE, max.deparse.length = 1e3)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#outils-daide-au-débogage",
    "href": "01-aide_memoire_r_sas.html#outils-daide-au-débogage",
    "title": "Aide-mémoire SAS - R",
    "section": "19.1 Outils d’aide au débogage",
    "text": "19.1 Outils d’aide au débogage\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\noptions symbolgen mprint mlogic;\n%macro Debogage;\n  %local phrase i j;\n  %let phrase = Voici une phrase;\n  %do i = 1 %to %sysfunc(countw(&phrase.));\n    %let j = %scan(&phrase., &i.);\n    %put Mot n°&i. = &j.;\n  %end;\n%mend Debogage;\n%Debogage;\noptions nosymbolgen nomprint nomlogic;\n\n\n\n#phrase &lt;- c(\"voici\", \"une\", \"phrase\")\n#options(error=recover)\n#for (i in phrase) print(k)\n#options(error=NULL)\n\n# À FAIRE : autres outils\n#traceback()\n#browser()\n\n\n\n\n# À FAIRE : creuser\n#phrase &lt;- c(\"voici\", \"une\", \"phrase\")\n#options(error=recover)\n#for (i in phrase) print(k)\n#options(error=NULL)\n\n# À FAIRE : autres outils\n#traceback()\n#browser()\n\n\n\n\n#phrase &lt;- c(\"voici\", \"une\", \"phrase\")\n#options(error=recover)\n#for (i in phrase) print(k)\n#options(error=NULL)\n\n# À FAIRE : autres outils\n#traceback()\n#browser()",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#emploi-des-guillemets-et-double-guillemets",
    "href": "01-aide_memoire_r_sas.html#emploi-des-guillemets-et-double-guillemets",
    "title": "Aide-mémoire SAS - R",
    "section": "20.1 Emploi des guillemets et double guillemets",
    "text": "20.1 Emploi des guillemets et double guillemets\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Quelques points de vigilance en SAS (à ne connaître que si on est amené à modifier le programme SAS, pas utiles sinon) */\n/* Double guillemets pour les macro-variables */\n%let a = Bonjour;\n%put '&a.'; /* Incorrect */\n%put \"&a.\"; /* Correct */\n\n\n\n# Sans objet en R\n\n\n\n\n# Sans objet en R\n\n\n\n\n# Sans objet en R",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#macro-variable-définie-avec-un-statut-global-avant-son-appel-dans-le-cadre-dun-statut-local",
    "href": "01-aide_memoire_r_sas.html#macro-variable-définie-avec-un-statut-global-avant-son-appel-dans-le-cadre-dun-statut-local",
    "title": "Aide-mémoire SAS - R",
    "section": "20.2 Macro-variable définie avec un statut global avant son appel dans le cadre d’un statut local",
    "text": "20.2 Macro-variable définie avec un statut global avant son appel dans le cadre d’un statut local\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%macro test;\n  %let reponse = oui;\n%mend test;\n%test;\n/* 1. Erreur car &reponse. n'est défini que dans le cas d'un environnement local */ \n%put &reponse.;\n/* 2. Défini auparavant dans un environnement global, elle change de valeur à l'appel de la fonction */\n%let reponse = non;\n%put Reponse : &reponse.;\n%test;\n%put Reponse après la macro : &reponse.;\n/* 3. Problème corrigé, en imposant la variable à local dans la macro */\n%macro test2;\n  %local reponse;\n  %let reponse = oui;\n%mend test2;\n%let reponse = non;\n%put Reponse : &reponse.;\n%test2;\n%put Année après la macro : &reponse.;\n\n\n\n# Sans objet en R\n\n\n\n\n# Sans objet en R\n\n\n\n\n# Sans objet en R",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#taille-des-objets-en-mémoire",
    "href": "01-aide_memoire_r_sas.html#taille-des-objets-en-mémoire",
    "title": "Aide-mémoire SAS - R",
    "section": "21.1 Taille des objets en mémoire",
    "text": "21.1 Taille des objets en mémoire\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Taille d'une base de données */\nproc sql;\n  select libname, memname, filesize format = sizekmg., filesize format = sizek.\n  from Dictionary.Tables\n  where libname = \"WORK\" and memname = upcase(\"donnees_sas\") and memtype = \"DATA\";\nquit;\n\n\n\n# Taille, en mémoire, d'une base (en Mb)\nformat(object.size(donnees_rbase), nsmall = 3, digits = 2, unit = \"Mb\")\n\n# Taille des objets en mémoire, en Gb\nsort(sapply(ls(), function(x){object.size(get(x))}), decreasing = TRUE)/10**9\n\n\n\n\n# Taille, en mémoire, d'une base (en Mb)\ndonnees_tidyverse %&gt;% \n  object.size() %&gt;% \n  format(nsmall = 3, digits = 2, unit = \"Mb\")\n\n# Taille des objets en mémoire, en Gb\nsort(sapply(ls(), function(x){object.size(get(x))}), decreasing = TRUE)/10**9\n\n\n\n\n# Liste des bases de données en mémoire\ndata.table::tables() \n\n# Taille, en mémoire, d'une base (en Mb)\nformat(object.size(donnees_datatable), nsmall = 3, digits = 2, unit = \"Mb\")\n\n# Taille des objets en mémoire, en Gb\nsort(sapply(ls(), function(x){object.size(get(x))}), decreasing = TRUE)/10**9",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#supprimer-des-bases",
    "href": "01-aide_memoire_r_sas.html#supprimer-des-bases",
    "title": "Aide-mémoire SAS - R",
    "section": "21.2 Supprimer des bases",
    "text": "21.2 Supprimer des bases\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Supprimer une base */\nproc datasets lib = work nolist;delete donnees_sas;run;\n\n/* Supprimer toutes les bases dans la work */\nproc datasets lib = work nolist kill;run;\n\n\n\n# Supprimer une base\n#rm(donnees_rbase)\n\n# Supprimer toutes les bases et tous les objets de la mémoire vive\n#rm(list = ls())\n\n\n\n\n# Supprimer une base\n#rm(donnees_tidyverse)\n\n# Supprimer toutes les bases et tous les objets de la mémoire vive\n#rm(list = ls())\n\n\n\n\n# Supprimer une base\n#rm(donnees_datatable)\n\n# Supprimer toutes les bases et tous les objets de la mémoire vive\n#rm(list = ls())",
    "crumbs": [
      "Aide-mémoire"
    ]
  }
]