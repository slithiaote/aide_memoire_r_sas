[
  {
    "objectID": "01-aide_memoire_r_sas.html",
    "href": "01-aide_memoire_r_sas.html",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "",
    "text": "L’aide-mémoire a pour but de fournir des codes écrits en SAS et d’en donner la traduction en différents environnements R :\net en python pandas.\nLes codes traduits sont typiques de la production statistique ou la réalisation d’études descriptives.\nCe document vise à faciliter la compréhension ou la traduction de codes ainsi que le passage d’un langage présenté à un autre. Il s’adresse notamment aux utilisateurs d’un de ces langages qui souhaitent comprendre ou traduire des codes écrits dans un autre langage.\nIl se veut complémentaire de la documentation en ligne en français Utilit’R, née à l’Insee (https://www.book.utilitr.org/). Le lecteur est invité à s’y référer pour obtenir des informations importantes sur l’utilisation de R et qui ne sont pas discutées dans ce document, comme l’importation de données en R (https://www.book.utilitr.org/03_fiches_thematiques/fiche_import_fichiers_plats).\nEnfin, si vous souhaitez collaborer à cet aide-mémoire ou nous faire part de votre avis, n’hésitez pas à nous contacter via nos adresses email.",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#installation-des-packages",
    "href": "01-aide_memoire_r_sas.html#installation-des-packages",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "1.1 Installation des packages",
    "text": "1.1 Installation des packages\nDes informations sur l’installation des packages en R sont disponibles sur le site Utilit’R : https://book.utilitr.org/01_R_Insee/Fiche_installer_packages.html.\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Sans objet pour SAS */\n\n\n\n# Les packages doivent au préalable être installés sur le disque dur\n# Pour installer un package :\n# install.packages(\"nom_du_package\")\n\n\n\n\n# Les packages doivent au préalable être installés sur le disque dur\n# Pour installer un package :\n# install.packages(\"nom_du_package\")\n\n\n\n\n# Les packages doivent au préalable être installés sur le disque dur\n# Pour installer un package :\n# install.packages(\"nom_du_package\")\n\n\n\n\n# Les packages doivent au préalable être installés sur le disque dur\n# Pour installer un package :\n# install.packages(\"nom_du_package\")\n\n\n\n\n# Commande à écrire dans le prompt d'Anaconda\n# Pour installer un package :\n# pip install nom_du_package",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#importation-des-packages-1",
    "href": "01-aide_memoire_r_sas.html#importation-des-packages-1",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "1.2 Importation des packages",
    "text": "1.2 Importation des packages\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Sans objet pour SAS */\n\n\n\n# Sans objet pour R-Base\n\n# Cependant, on importe le package lubridate pour faciliter la gestion des dates\nlibrary(lubridate)\n\n# Documentation de R base\n?\"[.data.frame\"\n\n\n\n\n# Chargement des packages\n# Le tidyverse proprement dit\nlibrary(tidyverse)\n# Les packages importés par le tidyverse sont :\n# - dplyr (manipulation de données)\n# - tidyr (réorganisation de bases de données)\n# - readr (importation de données)\n# - purrr (permet de réaliser des boucles)\n# - tibble (format de données tibble, complémentaire du data.frame)\n# - stringr (manipulation de chaînes de caractères)\n# - ggplot2 (création de graphiques)\n# - forcats (gestion des formats \"factors\")\n\n# Pour manipuler les dates\nlibrary(lubridate)\n# Pour utiliser le pipe %&gt;%\nlibrary(magrittr)\n\n# Documentation de tidyverse\nvignette(\"dplyr\")\n\n\n\n\nlibrary(data.table)\n# Pour manipuler les dates\nlibrary(lubridate)\n\n# Documentation de data.table\n?'[.data.table'\n\n\n\n\n#library(duckdb)\n#library(arrow)\n\n\n\n\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#documentation-utilitr-cheatsheets-etc.",
    "href": "01-aide_memoire_r_sas.html#documentation-utilitr-cheatsheets-etc.",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "1.3 Documentation (Utilit’R, cheatsheets, etc.)",
    "text": "1.3 Documentation (Utilit’R, cheatsheets, etc.)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nSans objet pour SAS.\n\n\nPas de documentation spécifique sur R base dans Utilit’R.\nAide-mémoire (Cheatsheet) : https://dplyr.tidyverse.org/articles/base.html\n\n\nDocumentation Utilit’R : https://book.utilitr.org/03_Fiches_thematiques/Fiche_tidyverse.html.\nAide-mémoire (Cheatsheets) :\n\ngénéral : https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf\ndplyr : https://rstudio.github.io/cheatsheets/data-transformation.pdf\ntidyr : https://rstudio.github.io/cheatsheets/tidyr.pdf\nreadr : https://rstudio.github.io/cheatsheets/data-import.pdf\npurrr : https://rstudio.github.io/cheatsheets/purrr.pdf\nstringr : https://rstudio.github.io/cheatsheets/strings.pdf\nggplot2 : https://rstudio.github.io/cheatsheets/data-visualization.pdf\nforcats : https://rstudio.github.io/cheatsheets/factors.pdf\nlubridate : https://rstudio.github.io/cheatsheets/lubridate.pdf\n\n\n\nDocumentation Utilit’R : https://book.utilitr.org/03_Fiches_thematiques/Fiche_datatable.html.\nAide-mémoire (Cheatsheets) :\n\nhttps://www.beoptimized.be/pdf/R_Data_Transformation.pdf\nhttps://paulvanderlaken.com/wp-content/uploads/2017/08/datatable_cheat_sheet_r.pdf\n\n\n\nDocumentation Utilit’R pour arrow : https://book.utilitr.org/03_Fiches_thematiques/Fiche_arrow.html.\nDocumentation Utilit’R pour duckdb : https://book.utilitr.org/03_Fiches_thematiques/Fiche_duckdb.html.",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#documentation-pour-rstudio",
    "href": "01-aide_memoire_r_sas.html#documentation-pour-rstudio",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "1.4 Documentation pour RStudio",
    "text": "1.4 Documentation pour RStudio\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nSans objet pour SAS.\n\n\nSi vous utilisez l’IDE RStudio : https://rstudio.github.io/cheatsheets/rstudio-ide.pdf\nPlusieurs raccourcis clavier sont notamment très utiles :\n\nRaccourcis RStudio\n\n\n\n\n\n\nRaccourci\nEffet\n\n\n\n\nAlt et -\n-&gt;\n\n\nCtrl et Shift et m\n%&gt;%\n\n\nCtrl et Entrée\nExécuter le code sélectionné ou de la ligne où se trouve le curseur\n\n\nAlt et Entrée\nExécuter le code jusqu’à la ligne où se trouve le curseur\n\n\nCtrl et Shift et a\nReformater automatiquement le code sélectionné pour qu’il soit plus lisible\n\n\nAlt et flèche de droite ou de gauche\nAller directement à la fin (flèche de droite) ou au début (flèche de gauche) de la ligne\n\n\nAlt et flèche du haut ou du bas\nIntervertir la ligne avec celle du dessus (flèche du haut) ou du dessous (flèche du bas)\n\n\nCtrl et flèche de droite ou de gauche\nPasser d’un mot à l’autre de la ligne\n\n\nAlt et déplacement du curseur de la souris en haut ou bas\nPermet de modifier simultanément le même emplacement de plusieurs lignes successives\n\n\nCtrl et Shift et U\nMet en minuscule les caractères sélectionnés\n\n\n\n\n\nSi vous utilisez l’IDE RStudio : https://rstudio.github.io/cheatsheets/rstudio-ide.pdf\nPlusieurs raccourcis clavier sont notamment très utiles :\n\nRaccourcis RStudio\n\n\n\n\n\n\nRaccourci\nEffet\n\n\n\n\nAlt et -\n-&gt;\n\n\nCtrl et Shift et m\n%&gt;%\n\n\nCtrl et Entrée\nExécuter le code sélectionné ou de la ligne où se trouve le curseur\n\n\nAlt et Entrée\nExécuter le code jusqu’à la ligne où se trouve le curseur\n\n\nCtrl et Shift et a\nReformater automatiquement le code sélectionné pour qu’il soit plus lisible\n\n\nAlt et flèche de droite ou de gauche\nAller directement à la fin (flèche de droite) ou au début (flèche de gauche) de la ligne\n\n\nAlt et flèche du haut ou du bas\nIntervertir la ligne avec celle du dessus (flèche du haut) ou du dessous (flèche du bas)\n\n\nCtrl et flèche de droite ou de gauche\nPasser d’un mot à l’autre de la ligne\n\n\nAlt et déplacement du curseur de la souris en haut ou bas\nPermet de modifier simultanément le même emplacement de plusieurs lignes successives\n\n\nCtrl et Shift et U\nMet en minuscule les caractères sélectionnés\n\n\n\n\n\nSi vous utilisez l’IDE RStudio : https://rstudio.github.io/cheatsheets/rstudio-ide.pdf\nPlusieurs raccourcis clavier sont notamment très utiles :\n\nRaccourcis RStudio\n\n\n\n\n\n\nRaccourci\nEffet\n\n\n\n\nAlt et -\n-&gt;\n\n\nCtrl et Shift et m\n%&gt;%\n\n\nCtrl et Entrée\nExécuter le code sélectionné ou de la ligne où se trouve le curseur\n\n\nAlt et Entrée\nExécuter le code jusqu’à la ligne où se trouve le curseur\n\n\nCtrl et Shift et a\nReformater automatiquement le code sélectionné pour qu’il soit plus lisible\n\n\nAlt et flèche de droite ou de gauche\nAller directement à la fin (flèche de droite) ou au début (flèche de gauche) de la ligne\n\n\nAlt et flèche du haut ou du bas\nIntervertir la ligne avec celle du dessus (flèche du haut) ou du dessous (flèche du bas)\n\n\nCtrl et flèche de droite ou de gauche\nPasser d’un mot à l’autre de la ligne\n\n\nAlt et déplacement du curseur de la souris en haut ou bas\nPermet de modifier simultanément le même emplacement de plusieurs lignes successives\n\n\nCtrl et Shift et U\nMet en minuscule les caractères sélectionnés\n\n\n\n\n\n\n\n\nSans objet pour pandas.",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#mode-demploi-de-laide-mémoire",
    "href": "01-aide_memoire_r_sas.html#mode-demploi-de-laide-mémoire",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "2.1 Mode d’emploi de l’aide-mémoire",
    "text": "2.1 Mode d’emploi de l’aide-mémoire\nLes codes informatiques sont appliqués sur une base de données illustrative fictive sur les formations. Cette base est importée à cette étape. Aussi, pour répliquer les codes sur sa machine, le lecteur doit d’abord exécuter le code d’importation de la base de données ci-dessous.\nLes codes sont majoritairement exécutables indépendamment les uns des autres. Les codes de la partie “Les jointures de bases” nécessitent cependant l’importation des bases réalisée lors de la première section de la partie.",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#création-dune-base-de-données-dexemple",
    "href": "01-aide_memoire_r_sas.html#création-dune-base-de-données-dexemple",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "2.2 Création d’une base de données d’exemple",
    "text": "2.2 Création d’une base de données d’exemple\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Données fictives sur des formations */\ndata donnees_sas;\n  infile cards dsd dlm='|';\n  format Identifiant $3. Sexe 1. CSP $1. Niveau $30. Date_naissance ddmmyy10. Date_entree ddmmyy10. Duree Note_Contenu Note_Formateur Note_Moyens\n         Note_Accompagnement Note_Materiel poids_sondage 4.1 CSPF $25. Sexef $5.;\n  input Identifiant $ Sexe CSP $ Niveau $ Date_naissance :ddmmyy10. Date_entree :ddmmyy10. Duree Note_Contenu Note_Formateur Note_Moyens\n        Note_Accompagnement Note_Materiel poids_sondage CSPF $ Sexef $;\n  cards;\n  173|2|1|Qualifié|17/06/1998|01/01/2021|308|12|6|17|4|19|117.1|Cadre|Femme\n  173|2|1|Qualifié|17/06/1998|01/01/2022|365|6||12|7|14|98.3|Cadre|Femme\n  173|2|1|Qualifié|17/06/1998|06/01/2022|185|8|10|11|1|9|214.6|Cadre|Femme\n  173|2|1|Non qualifié|17/06/1998|02/01/2023|365|14|15|15|10|8|84.7|Cadre|Femme\n  174|1|1|Qualifié|08/12/1984|17/08/2021|183|17|18|20|15|12|65.9|Cadre|Homme\n  175|1|1|Qualifié|16/09/1989|21/12/2022|730|5|5|8|4|9|148.2|Cadre|Homme\n  198|2|3|Non qualifié|17/03/1987|28/07/2022|30|10|10|10|16|8|89.6|Employé|Femme\n  198|2|3|Qualifié|17/03/1987|17/11/2022|164|11|7|6|14|13|100.3|Employé|Femme\n  198|2|3|Qualifié|17/03/1987|21/02/2023|365|9|20|3|4|17|49.3|Employé|Femme\n  168|1|2|Qualifié|30/07/2002|04/09/2019|365|18|11|20|13|15|148.2|Profession intermédiaire|Homme\n  211|2|3|Non qualifié||17/12/2021|135|16|16|15|12|9|86.4|Employé|Femme\n  278|1|5|Qualifié|10/08/1948|07/06/2018|365|14|10|6|8|12|99.2|Retraité|Homme\n  347|2|5|Qualifié|13/09/1955||180|12|5|7|11|12|105.6|Retraité|Femme\n  112|1|3|Non qualifié|13/09/2001|02/03/2022|212|3|10|11|9|8|123.1|Employé|Homme\n  112|1|3|Non qualifié|13/09/2001|01/03/2021|365|7|13|8|19|2|137.4|Employé|Homme\n  112|1|3|Qualifié|13/09/2001|01/12/2023|365|9|||||187.6|Employé|Homme\n  087|2|4|Non qualifié|||365||10||||87.3|Ouvrier|Femme\n  087|2|4|Non qualifié||31/10/2020|365|||11|||87.3|Ouvrier|Femme\n  099|1|4|Qualifié|06/06/1998|01/03/2021|364|12|11|10|12|13|169.3|Ouvrier|Homme\n  099|1|4|Qualifié|06/06/1998|01/03/2022|364|12|11|10|12|13|169.3|Ouvrier|Homme\n  099|1|4|Qualifié|06/06/1998|01/03/2023|364|12|11|10|12|13|169.3|Ouvrier|Homme\n  187|2|2|Qualifié|05/12/1986|01/01/2022|364|10|10|10|10|10|169.3|Profession intermédiaire|Femme\n  187|2|2|Qualifié|05/12/1986|01/01/2023|364|10|10|10|10|10|234.1|Profession intermédiaire|Femme\n  689|1|1||01/12/2000|06/11/2017|123|9|7|8|13|16|189.3|Cadre|Homme\n  765|1|4|Non qualifié|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9|Ouvrier|Homme\n  765|1|4|Non qualifié|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9|Ouvrier|Homme\n  765|1|4|Non qualifié|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9|Ouvrier|Homme\n  ;\nrun;\n\n/* Ajout de variables utiles */\ndata donnees_sas;\n  set donnees_sas;\n  /* Date de sortie du dispositif : ajout de la durée à la date d'entrée */\n  format date_sortie ddmmyy10.;\n  date_sortie = intnx('day', date_entree, duree);\n  /* Âge à l'entrée dans le dispositif */\n  Age = intck('year', date_naissance, date_entree);\nrun;\n\n\n\n# Données fictives sur des formations\nlibrary(lubridate)\ndonnees_rbase &lt;- data.frame(\n  Identifiant = c(\"173\", \"173\", \"173\", \"173\", \"174\", \"175\", \"198\", \"198\", \"198\", \"168\", \"211\", \"278\", \"347\", \"112\", \"112\", \"112\", \"087\", \"087\", \"099\", \"099\", \"099\", \"187\", \"187\", \"689\", \"765\", \"765\", \"765\"),\n  Sexe = c(\"2\", \"2\", \"2\", \"2\", \"1\", \"1\", \"2\", \"2\", \"2\", \"1\", \"2\", \"1\", \"2\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", \"1\", \"1\"),\n  CSP = c(\"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"3\", \"3\", \"3\", \"2\", \"3\", \"5\", \"5\", \"3\", \"3\", \"3\", \"4\", \"4\", \"4\", \"4\", \"4\", \"2\", \"2\", \"1\", \"4\", \"4\", \"4\"),\n  Niveau = c(\"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \n             \"Non qualifié\", \"Qualifié\", \"Non qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", NA, \"Non qualifié\", \"Non qualifié\", \"Non qualifié\"),\n  Date_naissance = c(\"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"08/12/1984\", \"16/09/1989\", \"17/03/1987\", \"17/03/1987\", \"17/03/1987\", \"30/07/2002\", NA, \"10/08/1948\", \n                     \"13/09/1955\", \"13/09/2001\", \"13/09/2001\", \"13/09/2001\", NA, NA, \"06/06/1998\", \"06/06/1998\", \"06/06/1998\", \"05/12/1986\", \"05/12/1986\", \"01/12/2000\", \"26/12/1995\", \"26/12/1995\", \"26/12/1995\"),\n  Date_entree = c(\"01/01/2021\", \"01/01/2022\", \"06/01/2022\", \"02/01/2023\", \"17/08/2021\", \"21/12/2022\", \"28/07/2022\", \"17/11/2022\", \"21/02/2023\", \"04/09/2019\", \"17/12/2021\", \"07/06/2018\", NA, \"02/03/2022\", \"01/03/2021\", \"01/12/2023\", NA, \n                  \"31/10/2020\", \"01/03/2021\", \"01/03/2022\", \"01/03/2023\", \"01/01/2022\", \"01/01/2023\", \"06/11/2017\", \"17/04/2020\", \"17/04/2020\", \"17/04/2020\"),\n  Duree = c(\"308\", \"365\", \"185\", \"365\", \"183\", \"730\", \"30\", \"164\", \"365\", \"365\", \"135\", \"365\", \"180\", \"212\", \"365\", \"365\", \"365\", \"365\", \"364\", \"364\", \"364\", \"364\", \"364\", \"123\", \"160\", \"160\", \"160\"),\n  Note_Contenu = c(\"12\", \"6\", \"8\", \"14\", \"17\", \"5\", \"10\", \"11\", \"9\", \"18\", \"16\", \"14\", \"12\", \"3\", \"7\", \"9\", NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"9\", \"13\", \"13\", \"13\"),\n  Note_Formateur = c(\"6\", NA, \"10\", \"15\", \"18\", \"5\", \"10\", \"7\", \"20\", \"11\", \"16\", \"10\", \"5\", \"10\", \"13\", NA, \"10\", NA, \"11\", \"11\", \"11\", \"10\", \"10\", \"7\", \"10\", \"10\", \"10\"),\n  Note_Moyens = c(\"17\", \"12\", \"11\", \"15\", \"20\", \"8\", \"10\", \"6\", \"3\", \"20\", \"15\", \"6\", \"7\", \"11\", \"8\", NA, NA, \"11\", \"10\", \"10\", \"10\", \"10\", \"10\", \"8\", \"12\", \"12\", \"12\"),\n  Note_Accompagnement = c(\"4\", \"7\", \"1\", \"10\", \"15\", \"4\", \"16\", \"14\", \"4\", \"13\", \"12\", \"8\", \"11\", \"9\", \"19\", NA, NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"13\", \"18\", \"18\", \"18\"),\n  Note_Materiel = c(\"19\", \"14\", \"9\", \"8\", \"12\", \"9\", \"8\", \"13\", \"17\", \"15\", \"9\", \"12\", \"12\", \"8\", \"2\", NA, NA, NA, \"13\", \"13\", \"13\", \"10\", \"10\", \"16\", \"10\", \"10\", \"10\"),\n  poids_sondage = c(\"117.1\", \"98.3\", \"214.6\", \"84.7\", \"65.9\", \"148.2\", \"89.6\", \"100.3\", \"49.3\", \"148.2\", \"86.4\", \"99.2\", \"105.6\", \"123.1\", \"137.4\", \"187.6\", \"87.3\", \"87.3\",\n                    \"169.3\", \"169.3\", \"169.3\", \"169.3\", \"234.1\", \"189.3\", \"45.9\", \"45.9\", \"45.9\"),\n  CSPF = c(\"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\",\"Cadre\", \"Employé\", \"Employé\", \"Employé\", \"Profession intermédiaire\", \"Employé\", \"Retraité\", \"Retraité\", \"Employé\",\n           \"Employé\", \"Employé\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Profession intermédiaire\", \"Profession intermédiaire\", \"Cadre\", \"Ouvrier\", \"Ouvrier\",\n           \"Ouvrier\"),\n  Sexef = c(\"Femme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Femme\", \"Homme\", \"Femme\", \"Homme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\",\n            \"Homme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Homme\", \"Homme\")\n)\n\n# Mise en forme des données\n\n# R est sensible à la casse, il est pertinent d'harmoniser les noms des variables en minuscule\ncolnames(donnees_rbase) &lt;- tolower(colnames(donnees_rbase))\n\n# On a importé toutes les variables en format caractère\n# On convertit certaines variables en format numérique\nenNumerique &lt;- c(\"duree\", \"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\ndonnees_rbase[, enNumerique] &lt;- lapply(donnees_rbase[, enNumerique], as.integer)\ndonnees_rbase$poids_sondage &lt;- as.numeric(donnees_rbase$poids_sondage)\n\n# On récupère les variables dont le nom débute par le mot \"date\"\nenDate &lt;- names(donnees_rbase)[grepl(\"date\", tolower(names(donnees_rbase)))]\n# On exprime les dates en format Date\ndonnees_rbase[, enDate] &lt;- lapply(donnees_rbase[, enDate], lubridate::dmy)\n\n# Date de sortie du dispositif\ndonnees_rbase$date_sortie &lt;- donnees_rbase$date_entree + lubridate::days(donnees_rbase$duree)\n\n# Âge à l'entrée dans le dispositif\ndonnees_rbase$age &lt;- floor(lubridate::time_length(difftime(donnees_rbase$date_entree, donnees_rbase$date_naissance), \"years\"))\n\n\n\n\n# Données fictives sur des formations\nlibrary(tidyverse)\nlibrary(lubridate)\ndonnees_tidyverse &lt;- tibble(\n  Identifiant = c(\"173\", \"173\", \"173\", \"173\", \"174\", \"175\", \"198\", \"198\", \"198\", \"168\", \"211\", \"278\", \"347\", \"112\", \"112\", \"112\", \"087\", \"087\", \"099\", \"099\", \"099\", \"187\", \"187\", \"689\", \"765\", \"765\", \"765\"),\n  Sexe = c(\"2\", \"2\", \"2\", \"2\", \"1\", \"1\", \"2\", \"2\", \"2\", \"1\", \"2\", \"1\", \"2\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", \"1\", \"1\"),\n  CSP = c(\"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"3\", \"3\", \"3\", \"2\", \"3\", \"5\", \"5\", \"3\", \"3\", \"3\", \"4\", \"4\", \"4\", \"4\", \"4\", \"2\", \"2\", \"1\", \"4\", \"4\", \"4\"),\n  Niveau = c(\"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \n             \"Non qualifié\", \"Qualifié\", \"Non qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", NA, \"Non qualifié\", \"Non qualifié\", \"Non qualifié\"),\n  Date_naissance = c(\"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"08/12/1984\", \"16/09/1989\", \"17/03/1987\", \"17/03/1987\", \"17/03/1987\", \"30/07/2002\", NA, \"10/08/1948\", \n                     \"13/09/1955\", \"13/09/2001\", \"13/09/2001\", \"13/09/2001\", NA, NA, \"06/06/1998\", \"06/06/1998\", \"06/06/1998\", \"05/12/1986\", \"05/12/1986\", \"01/12/2000\", \"26/12/1995\", \"26/12/1995\", \"26/12/1995\"),\n  Date_entree = c(\"01/01/2021\", \"01/01/2022\", \"06/01/2022\", \"02/01/2023\", \"17/08/2021\", \"21/12/2022\", \"28/07/2022\", \"17/11/2022\", \"21/02/2023\", \"04/09/2019\", \"17/12/2021\", \"07/06/2018\", NA, \"02/03/2022\", \"01/03/2021\", \"01/12/2023\", NA, \n                  \"31/10/2020\", \"01/03/2021\", \"01/03/2022\", \"01/03/2023\", \"01/01/2022\", \"01/01/2023\", \"06/11/2017\", \"17/04/2020\", \"17/04/2020\", \"17/04/2020\"),\n  Duree = c(\"308\", \"365\", \"185\", \"365\", \"183\", \"730\", \"30\", \"164\", \"365\", \"365\", \"135\", \"365\", \"180\", \"212\", \"365\", \"365\", \"365\", \"365\", \"364\", \"364\", \"364\", \"364\", \"364\", \"123\", \"160\", \"160\", \"160\"),\n  Note_Contenu = c(\"12\", \"6\", \"8\", \"14\", \"17\", \"5\", \"10\", \"11\", \"9\", \"18\", \"16\", \"14\", \"12\", \"3\", \"7\", \"9\", NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"9\", \"13\", \"13\", \"13\"),\n  Note_Formateur = c(\"6\", NA, \"10\", \"15\", \"18\", \"5\", \"10\", \"7\", \"20\", \"11\", \"16\", \"10\", \"5\", \"10\", \"13\", NA, \"10\", NA, \"11\", \"11\", \"11\", \"10\", \"10\", \"7\", \"10\", \"10\", \"10\"),\n  Note_Moyens = c(\"17\", \"12\", \"11\", \"15\", \"20\", \"8\", \"10\", \"6\", \"3\", \"20\", \"15\", \"6\", \"7\", \"11\", \"8\", NA, NA, \"11\", \"10\", \"10\", \"10\", \"10\", \"10\", \"8\", \"12\", \"12\", \"12\"),\n  Note_Accompagnement = c(\"4\", \"7\", \"1\", \"10\", \"15\", \"4\", \"16\", \"14\", \"4\", \"13\", \"12\", \"8\", \"11\", \"9\", \"19\", NA, NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"13\", \"18\", \"18\", \"18\"),\n  Note_Materiel = c(\"19\", \"14\", \"9\", \"8\", \"12\", \"9\", \"8\", \"13\", \"17\", \"15\", \"9\", \"12\", \"12\", \"8\", \"2\", NA, NA, NA, \"13\", \"13\", \"13\", \"10\", \"10\", \"16\", \"10\", \"10\", \"10\"),\n  poids_sondage = c(\"117.1\", \"98.3\", \"214.6\", \"84.7\", \"65.9\", \"148.2\", \"89.6\", \"100.3\", \"49.3\", \"148.2\", \"86.4\", \"99.2\", \"105.6\", \"123.1\", \"137.4\", \"187.6\", \"87.3\", \"87.3\",\n                    \"169.3\", \"169.3\", \"169.3\", \"169.3\", \"234.1\", \"189.3\", \"45.9\", \"45.9\", \"45.9\"),\n  CSPF = c(\"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\",\"Cadre\", \"Employé\", \"Employé\", \"Employé\", \"Profession intermédiaire\", \"Employé\", \"Retraité\", \"Retraité\", \"Employé\",\n           \"Employé\", \"Employé\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Profession intermédiaire\", \"Profession intermédiaire\", \"Cadre\", \"Ouvrier\", \"Ouvrier\",\n           \"Ouvrier\"),\n  Sexef = c(\"Femme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Femme\", \"Homme\", \"Femme\", \"Homme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\",\n            \"Homme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Homme\", \"Homme\")\n)\n\n# Mise en forme des données\n\n# R est sensible à la casse, il est pertinent d'harmoniser les noms des variables en minuscule\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% rename_with(tolower)\n\n# On a importé toutes les variables en format caractère\n# On convertit certaines variables en format numérique\nenNumerique &lt;- c(\"duree\", \"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\n# On convertit certaines variables au format date\n# On récupère d'abord les variables dont le nom débute par le mot \"date\"\nenDate &lt;- names(donnees_tidyverse)[grepl(\"^date\", tolower(names(donnees_tidyverse)))]\n\n# Conversion proprement dite\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%  \n  mutate(across(all_of(enNumerique), as.integer)) %&gt;% \n  mutate(poids_sondage = as.numeric(poids_sondage)) %&gt;% \n  mutate(across(all_of(enDate), lubridate::dmy))\n\n# Date de sortie du dispositif\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(date_sortie = date_entree + lubridate::days(duree)) %&gt;% \n  # Âge à l'entrée dans le dispositif\n  mutate(age = as.period(interval(start = date_naissance, end = date_entree))$year)\n\n\n\n\n# Données fictives sur des formations\nlibrary(data.table)\nlibrary(lubridate)\ndonnees_datatable &lt;- data.table(\n  Identifiant = c(\"173\", \"173\", \"173\", \"173\", \"174\", \"175\", \"198\", \"198\", \"198\", \"168\", \"211\", \"278\", \"347\", \"112\", \"112\", \"112\", \"087\", \"087\", \"099\", \"099\", \"099\", \"187\", \"187\", \"689\", \"765\", \"765\", \"765\"),\n  Sexe = c(\"2\", \"2\", \"2\", \"2\", \"1\", \"1\", \"2\", \"2\", \"2\", \"1\", \"2\", \"1\", \"2\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", \"1\", \"1\"),\n  CSP = c(\"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"3\", \"3\", \"3\", \"2\", \"3\", \"5\", \"5\", \"3\", \"3\", \"3\", \"4\", \"4\", \"4\", \"4\", \"4\", \"2\", \"2\", \"1\", \"4\", \"4\", \"4\"),\n  Niveau = c(\"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \n             \"Non qualifié\", \"Qualifié\", \"Non qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", NA, \"Non qualifié\", \"Non qualifié\", \"Non qualifié\"),\n  Date_naissance = c(\"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"08/12/1984\", \"16/09/1989\", \"17/03/1987\", \"17/03/1987\", \"17/03/1987\", \"30/07/2002\", NA, \"10/08/1948\", \n                     \"13/09/1955\", \"13/09/2001\", \"13/09/2001\", \"13/09/2001\", NA, NA, \"06/06/1998\", \"06/06/1998\", \"06/06/1998\", \"05/12/1986\", \"05/12/1986\", \"01/12/2000\", \"26/12/1995\", \"26/12/1995\", \"26/12/1995\"),\n  Date_entree = c(\"01/01/2021\", \"01/01/2022\", \"06/01/2022\", \"02/01/2023\", \"17/08/2021\", \"21/12/2022\", \"28/07/2022\", \"17/11/2022\", \"21/02/2023\", \"04/09/2019\", \"17/12/2021\", \"07/06/2018\", NA, \"02/03/2022\", \"01/03/2021\", \"01/12/2023\", NA, \n                  \"31/10/2020\", \"01/03/2021\", \"01/03/2022\", \"01/03/2023\", \"01/01/2022\", \"01/01/2023\", \"06/11/2017\", \"17/04/2020\", \"17/04/2020\", \"17/04/2020\"),\n  Duree = c(\"308\", \"365\", \"185\", \"365\", \"183\", \"730\", \"30\", \"164\", \"365\", \"365\", \"135\", \"365\", \"180\", \"212\", \"365\", \"365\", \"365\", \"365\", \"364\", \"364\", \"364\", \"364\", \"364\", \"123\", \"160\", \"160\", \"160\"),\n  Note_Contenu = c(\"12\", \"6\", \"8\", \"14\", \"17\", \"5\", \"10\", \"11\", \"9\", \"18\", \"16\", \"14\", \"12\", \"3\", \"7\", \"9\", NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"9\", \"13\", \"13\", \"13\"),\n  Note_Formateur = c(\"6\", NA, \"10\", \"15\", \"18\", \"5\", \"10\", \"7\", \"20\", \"11\", \"16\", \"10\", \"5\", \"10\", \"13\", NA, \"10\", NA, \"11\", \"11\", \"11\", \"10\", \"10\", \"7\", \"10\", \"10\", \"10\"),\n  Note_Moyens = c(\"17\", \"12\", \"11\", \"15\", \"20\", \"8\", \"10\", \"6\", \"3\", \"20\", \"15\", \"6\", \"7\", \"11\", \"8\", NA, NA, \"11\", \"10\", \"10\", \"10\", \"10\", \"10\", \"8\", \"12\", \"12\", \"12\"),\n  Note_Accompagnement = c(\"4\", \"7\", \"1\", \"10\", \"15\", \"4\", \"16\", \"14\", \"4\", \"13\", \"12\", \"8\", \"11\", \"9\", \"19\", NA, NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"13\", \"18\", \"18\", \"18\"),\n  Note_Materiel = c(\"19\", \"14\", \"9\", \"8\", \"12\", \"9\", \"8\", \"13\", \"17\", \"15\", \"9\", \"12\", \"12\", \"8\", \"2\", NA, NA, NA, \"13\", \"13\", \"13\", \"10\", \"10\", \"16\", \"10\", \"10\", \"10\"),\n  poids_sondage = c(\"117.1\", \"98.3\", \"214.6\", \"84.7\", \"65.9\", \"148.2\", \"89.6\", \"100.3\", \"49.3\", \"148.2\", \"86.4\", \"99.2\", \"105.6\", \"123.1\", \"137.4\", \"187.6\", \"87.3\", \"87.3\",\n                    \"169.3\", \"169.3\", \"169.3\", \"169.3\", \"234.1\", \"189.3\", \"45.9\", \"45.9\", \"45.9\"),\n  CSPF = c(\"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\",\"Cadre\", \"Employé\", \"Employé\", \"Employé\", \"Profession intermédiaire\", \"Employé\", \"Retraité\", \"Retraité\", \"Employé\",\n           \"Employé\", \"Employé\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Profession intermédiaire\", \"Profession intermédiaire\", \"Cadre\", \"Ouvrier\", \"Ouvrier\",\n           \"Ouvrier\"),\n  Sexef = c(\"Femme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Femme\", \"Homme\", \"Femme\", \"Homme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\",\n            \"Homme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Homme\", \"Homme\")\n)\n\n# Mise en forme des données\n\n# R est sensible à la casse, il est pertinent d'harmoniser les noms des variables en minuscule\ncolnames(donnees_datatable) &lt;- tolower(colnames(donnees_datatable))\n\n# On a importé toutes les variables en format caractère\n\n# On convertit certaines variables en format numérique\nenNumerique &lt;- c(\"duree\", \"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\ndonnees_datatable[, lapply(.SD, as.integer), .SDcols = enNumerique]\n# Autre solution\n# En data.table, les instructions débutant par set modifient les éléments par référence, c'est-à-dire sans copie.\n# Ceci est plus efficace pour manipuler des données volumineuses.\nfor (j in enNumerique) {\n  set(donnees_datatable, j = j, value = as.numeric(donnees_datatable[[j]]))\n}\ndonnees_datatable[, poids_sondage := as.numeric(poids_sondage)]\n\n# On récupère les variables dont le nom débute par le mot \"date\"\nvarDates &lt;- names(donnees_datatable)[grepl(\"date\", tolower(names(donnees_datatable)))]\n# On exprime les dates en format Date\ndonnees_datatable[, (varDates) := lapply(.SD, lubridate::dmy), .SDcols = varDates]\n\n# Date de sortie du dispositif\ndonnees_datatable[, date_sortie := date_entree + lubridate::days(duree)]\n\n# Âge à l'entrée dans le dispositif\ndonnees_datatable[, age := floor(lubridate::time_length(difftime(donnees_datatable$date_entree, donnees_datatable$date_naissance), \"years\"))]\n\n\n\nDuckdb est un serveur SQL séparé de la session R. Les calculs sont effectués en dehors de R et l’espace mémoire est distinct de celui de R. Au lieu d’accéder directement aux données, il faut passer par un objet connection qui contient l’adresse du serveur, un peu comme lorsque l’on se connecte à un serveur web. Ici en particulier, il est nécessaire de transférer les données vers duckdb.\n\n# Ouvrir une connexion au serveur duckdb\ncon &lt;- DBI::dbConnect(duckdb::duckdb()); \n\n# On \"copie\" les données dans une table du nom table_duckdb\n# Données fictives sur des formations\ncon %&gt;% duckdb::duckdb_register(name = \"table_duckdb\", df = donnees_tidyverse)\n\ncon %&gt;% tbl(\"table_duckdb\")\n\n# Fermer la connexion au serveur duckdb\nDBI::dbDisconnect(con, shutdown = TRUE)\n\nPour la suite, on suppose que la connexion est ouverte sous le nom con, et que les données sont accessibles par la requête requete_duckdb. Le code modifiera la requête, mais pas la table dans le serveur SQL.\n\ncon &lt;- DBI::dbConnect(duckdb::duckdb()); \ncon %&gt;% duckdb::duckdb_register(name = \"table_duckdb\", df = donnees_tidyverse)\nrequete_duckdb &lt;- con %&gt;% tbl(\"table_duckdb\")\n\nN.B. Duckdb est envisagé pour des traitements sans charger des données en mémoire, par exemple en lisant directement un fichier .parquet sur le disque dur. Dans ce cas, les opérations sont effectuées à la volée, mais n’affectent pas les fichiers source.\n\n\n\ndonnees_python = pd.DataFrame({\n    \"Identifiant\": [\"173\", \"173\", \"173\", \"173\", \"174\", \"175\", \"198\", \"198\", \"198\", \"168\", \"211\", \"278\", \"347\", \"112\", \"112\", \"112\", \"087\", \"087\", \"099\", \"099\", \"099\", \"187\", \"187\", \"689\", \"765\", \"765\", \"765\"],\n    \"Sexe\": [\"2\", \"2\", \"2\", \"2\", \"1\", \"1\", \"2\", \"2\", \"2\", \"1\", \"2\", \"1\", \"2\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", \"1\", \"1\"],\n    \"CSP\": [\"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"4\", \"4\", \"4\", \"2\", \"3\", \"5\", \"5\", \"3\", \"3\", \"3\", \"3\", \"3\", \"3\", \"3\", \"3\", \"2\", \"2\", \"1\", \"4\", \"4\", \"4\"],\n    \"Niveau\": [\"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Non qualifié\", \n             \"Non qualifié\", \"Qualifié\", \"Non qualifié\", \"Non qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", \"Qualifié\", None, \"Non qualifié\", \"Non qualifié\", \"Non qualifié\"],\n    \"Date_naissance\": [\"17/06/1994\", \"17/06/1995\", \"17/06/1998\", \"17/06/1998\", \"08/12/1984\", \"16/09/1989\", \"17/03/1987\", \"17/03/1987\", \"17/03/1987\", \"30/07/2002\", None, \"10/08/1948\", \"13/09/1955\", \"13/09/2001\", \"13/09/2001\", \"13/09/2001\", None, None, \"06/06/1998\", \"06/06/1998\", \"06/06/1998\", \"05/12/1986\", \"05/12/1986\", \"01/12/2000\", \"26/12/1995\", \"26/12/1995\", \"26/12/1995\"],\n    \"Date_entree\": [\"01/01/2021\", \"01/01/2021\", \"06/01/2022\", \"02/01/2023\", \"17/08/2021\", \"21/12/2022\", \"28/07/2022\", \"17/11/2022\", \"21/02/2023\", \"04/09/2019\", \"17/12/2021\", \"07/06/2018\", None, \"02/03/2022\", \"01/03/2021\", \"01/12/2023\", None, \"31/10/2020\", \"01/03/2021\", \"01/03/2022\", \"01/03/2023\", \"01/01/2022\", \"01/01/2023\", \"06/11/2017\", \"17/04/2020\", \"17/04/2020\", \"17/04/2020\"],\n    \"Duree\": [\"308\", \"365\", \"185\", \"365\", \"183\", \"730\", \"30\", \"164\", \"365\", \"365\", \"135\", \"365\", \"180\", \"212\", \"365\", \"365\", \"365\", \"365\", \"364\", \"364\", \"364\", \"364\", \"364\", \"123\", \"160\", \"160\", \"160\"],\n    \"Note_Contenu\": [\"12\", \"6\", \"8\", \"14\", \"17\", \"5\", \"10\", \"11\", \"9\", \"18\", \"16\", \"14\", \"12\", \"3\", \"7\", None, None, None, \"12\", \"12\", \"12\", \"10\", \"10\", \"9\", \"13\", \"13\", \"13\"],\n    \"Note_Formateur\": [\"6\", None, \"10\", \"15\", \"18\", \"5\", \"10\", \"7\", \"20\", \"11\", \"16\", \"10\", \"5\", \"10\", \"13\", None, None, None, \"11\", \"11\", \"11\", \"10\", \"10\", \"7\", \"10\", \"10\", \"10\"],\n    \"Note_Moyens\": [\"17\", \"12\", \"11\", \"15\", \"20\", \"8\", \"10\", \"6\", \"3\", \"20\", \"15\", \"6\", \"7\", \"11\", \"8\", None, None, None, \"10\", \"10\", \"10\", \"10\", \"10\", \"8\", \"12\", \"12\", \"12\"],\n    \"Note_Accompagnement\": [\"4\", \"7\", \"1\", \"10\", \"15\", \"4\", \"16\", \"14\", \"4\", \"13\", \"12\", \"8\", \"11\", \"9\", \"19\", None, None, None, \"12\", \"12\", \"12\", \"10\", \"10\", \"13\", \"18\", \"18\", \"18\"],\n    \"Note_Materiel\": [\"19\", \"14\", \"9\", \"8\", \"12\", \"9\", \"8\", \"13\", \"17\", \"15\", \"9\", \"12\", \"12\", \"8\", \"2\", None, None, None, \"13\", \"13\", \"13\", \"10\", \"10\", \"16\", \"10\", \"10\", \"10\"],\n    \"poids_sondage\": [\"117.1\", \"98.3\", \"214.6\", \"84.7\", \"65.9\", \"148.2\", \"89.6\", \"100.3\", \"49.3\", \"148.2\", \"86.4\", \"99.2\", \"105.6\", \"123.1\", \"137.4\", \"187.6\", \"87.3\", \"87.3\", \"169.3\", \"169.3\", \"169.3\", \"169.3\", \"234.1\", \"189.3\", \"45.9\", \"45.9\", \"45.9\"],\n    \"CSPF\": [\"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\", \"Cadre\",\"Cadre\", \"Employé\", \"Employé\", \"Employé\", \"Profession intermédiaire\", \"Employé\", \"Retraité\", \"Retraité\", \"Employé\", \"Employé\", \"Employé\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\", \"Profession intermédiaire\", \"Profession intermédiaire\", \"Cadre\", \"Ouvrier\", \"Ouvrier\", \"Ouvrier\"],\n    \"Sexef\": [\"Femme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Femme\", \"Homme\", \"Femme\", \"Homme\", \"Femme\", \"Homme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Homme\", \"Femme\", \"Femme\", \"Homme\", \"Homme\", \"Homme\", \"Homme\"]\n})\n\n# Mise en forme des données\n\n# Python est sensible à la casse, il est pertinent d'harmoniser les noms des variables en minuscule\ndonnees_python.columns = donnees_python.columns.str.lower()\n\n# On convertit certaines variables en format numérique\nenNumerique = [\"duree\", \"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\"]\ndonnees_python[enNumerique] = donnees_python[enNumerique].astype(float)\ndonnees_python['poids_sondage'] = donnees_python['poids_sondage'].astype(float)\n\n# Colonnes à convertir en date\nenDate = ['date_naissance', 'date_entree']\ndonnees_python[enDate] = donnees_python[enDate].apply(pd.to_datetime, format='%d/%m/%Y', errors='coerce')\n\n# Date de sortie du dispositif\ndonnees_python['date_sortie'] = donnees_python['date_entree'] + pd.to_timedelta(donnees_python['duree'], unit='D')\n\n# Âge à l'entrée dans le dispositif\ndonnees_python['age'] = np.floor((donnees_python['date_entree'] - donnees_python['date_naissance']).dt.days / 365.25).astype('Int64')",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#manipulation-du-format-de-la-base-de-données",
    "href": "01-aide_memoire_r_sas.html#manipulation-du-format-de-la-base-de-données",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "2.3 Manipulation du format de la base de données",
    "text": "2.3 Manipulation du format de la base de données\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nSans objet pour SAS.\n\n\n\n# On vérifie que la base importée est bien un data.frame\nis.data.frame(donnees_rbase)\n\n# Format de la base\nclass(donnees_rbase)\n\n\n\n\n# On vérifie que la base importée est bien un tibble\nis_tibble(donnees_tidyverse)\n\n# Transformation en tibble, le format de Tidyverse\ndonnees_tidyverse &lt;- as_tibble(donnees_tidyverse)\n\n# Format de la base\nclass(donnees_tidyverse)\n\n\n\n\n# On vérifie que la base est bien un data.table\nis.data.table(donnees_datatable)\n\n# Transformation en data.frame\nsetDF(donnees_datatable)\nis.data.frame(donnees_datatable)\n\n# Transformation en data.table\n# En data.table, les instructions débutant par set modifient les éléments par référence, c'est-à-dire sans copie.\n# Ceci est plus efficace pour manipuler des données volumineuses.\nsetDT(donnees_datatable)\nis.data.table(donnees_datatable)\n# Autre possibilité\ndonnees_datatable &lt;- as.data.table(donnees_datatable)\n\n# La data.table est une liste\nis.list(donnees_datatable)\n\n# Format de la base\nclass(donnees_datatable)\n\n\n\n\n\n\n\ntype(donnees_python)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#importation-de-données-extérieures",
    "href": "01-aide_memoire_r_sas.html#importation-de-données-extérieures",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "2.4 Importation de données extérieures",
    "text": "2.4 Importation de données extérieures\nImporter des données extérieures dans SAS ou R est sans doute la première tâche à laquelle est confronté l’utilisateur de ces logiciels. Ce point important est décrit sur le site Utilit’R : https://www.book.utilitr.org/03_fiches_thematiques/fiche_import_fichiers_plats.\nPour importer des fichiers :\n\nplats (.csv, .tsv, .txt, etc.) : https://book.utilitr.org/03_Fiches_thematiques/Fiche_import_fichiers_plats.html\nSAS : https://book.utilitr.org/03_Fiches_thematiques/Fiche_import_tables_sas.html\nissus de tableurs (Excel, Calc) : https://book.utilitr.org/03_Fiches_thematiques/Fiche_import_tableurs.html\nparquet : https://book.utilitr.org/03_Fiches_thematiques/Fiche_import_fichiers_parquet.html\n\nQuelques éléments additionnels non couverts dans Utilit’R sont présentés ici.\n\n2.4.1 La fonction readLines() de R\nLa fonction readLines() de R peut s’avérer utile lors de l’importation de fichiers très volumineux. Elle permet de n’importer que les premières lignes du fichier, sans importer l’ensemble de la base, et ainsi de visualiser rapidement le contenu des données et la nature de l’éventuel séparateur de colonnes.\nLes options de la fonction utiles sont :\n\ncon : chemin du fichier à importer\nn : nombre maximal de lignes du fichier lues\nencoding : définir l’encodage du fichier (“UTF-8” ou “latin1”)\n\n\n\n2.4.2 Spécificité des environnements\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Importer un fichier xls */\n/* proc import out = NomBaseImportee \n   datafile = \"CHEMIN DE LA BASE\"\n   DBMS = XLS REPLACE;\n  run; */\n  \n/* Importer un fichier avec séparateur | */\n/* data NomDeLaBase;\n     infile \"CHEMIN DE LA BASE IMPORTEE\" dlm = \"|\" missover dsd firstobs = 2;\n     informat VARIABLES;\n     format VARIABLES;\n     input VARIABLES;\n   run; */\n\n\nOn utilisera les fonctions read.table, read.csv et read.csv2.\n\n\nOn utilisera les fonctions du package readr : https://book.utilitr.org/03_Fiches_thematiques/Fiche_import_fichiers_plats.html#importer-un-fichier-avec-le-package-readr.\n\n\nOn utilisera la fonction fread : https://book.utilitr.org/03_Fiches_thematiques/Fiche_import_fichiers_plats.html#importer-un-fichier-avec-le-package-data.table.\nUne option utile non présentée dans le lien est : keepLeadingZeros. Si cette option est valorisée à TRUE, les valeurs numériques précédées par des 0 seront importées sous forme caractère et le zéro initial sera conservé.\n\n\n\n\n\nOn utilisera les fonctions pd.read_csv() pour lire les fichiers CSV.\n\n#Pour les fichiers SAS :\n#from sas7bdat import SAS7BDAT\n#import retrying\n\n #file_path = 'chemin/nom_fichier.sas7bdat'\n #with SAS7BDAT(file_path) as reader:\n #   data = reader.to_data_frame()",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#chemin-du-bureau-de-lutilisateur",
    "href": "01-aide_memoire_r_sas.html#chemin-du-bureau-de-lutilisateur",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "3.1 Chemin du bureau de l’utilisateur",
    "text": "3.1 Chemin du bureau de l’utilisateur\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* On vide la log */\ndm \"log; clear; \";\n/* On récupère déjà l'identifiant de l'utilisateur (systèmes Windows) */\n%let user = &sysuserid;\n\n/* Chemin proprement dit */\n%let bureau = C:\\Users\\&user.\\Desktop;\nlibname bur \"&bureau.\";\n\n\n\n# On récupère déjà l'identifiant de l'utilisateur\nuser &lt;- Sys.getenv(\"USERNAME\")\n\n# Chemin proprement dit\nchemin &lt;- file.path(\"C:/Users\", user, \"Desktop\")\n\n\n\n\n# On récupère déjà l'identifiant de l'utilisateur\nuser &lt;- Sys.getenv(\"USERNAME\")\n\n# Chemin proprement dit\nchemin &lt;- file.path(\"C:/Users\", user, \"Desktop\")\n\n\n\n\n# On récupère déjà l'identifiant de l'utilisateur\nuser &lt;- Sys.getenv(\"USERNAME\")\n\n# Chemin proprement dit\nchemin &lt;- file.path(\"C:/Users\", user, \"Desktop\")\n\n\n\n\n\n\n\n# On récupère déjà l'identifiant de l'utilisateur\nuser = os.getenv('USERNAME')\n\n# Chemin en texte\nchemin = \"C:/Users/\" + str(user) + \"/Desktop\"",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#affichage-de-lannée",
    "href": "01-aide_memoire_r_sas.html#affichage-de-lannée",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "3.2 Affichage de l’année",
    "text": "3.2 Affichage de l’année\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Année courante */\n%let annee = %sysfunc(year(%sysfunc(today())));\n/* & (esperluette) indique à SAS qu'il doit remplacer an par sa valeur définie par le %let */\n%put Année : &annee.;\n\n/* Autre possibilité */\ndata _null_;call symput('annee', strip(year(today())));run;\n%put Année (autre méthode) : &annee.;\n\n/* Année passée */\n%put Année passée : %eval(&annee. - 1);\n\n\n\n# Année courante\nannee &lt;- lubridate::year(Sys.Date())\nsprintf(\"Année : %04d\", annee)\nprint(paste0(\"Année : \", annee))\n\n# Autre possibilité\nprint(paste0(\"Année : \", format(Sys.Date(), \"%Y\")))\n\n# Année passée\nannee_1 &lt;- annee - 1\npaste0(\"Année passée : \", annee_1)\n\n\n\n\n# Année courante\nannee &lt;- lubridate::year(Sys.Date())\nsprintf(\"Année : %04d\", annee)\nprint(paste0(\"Année : \", annee))\n\n# Autre possibilité\nprint(paste0(\"Année : \", format(Sys.Date(), \"%Y\")))\n\n# Année passée\nannee_1 &lt;- annee - 1\npaste0(\"Année passée : \", annee_1)\n\n\n\n\n# Année courante\nannee &lt;- lubridate::year(Sys.Date())\nsprintf(\"Année : %04d\", annee)\nprint(paste0(\"Année : \", annee))\n\n# Autre possibilité\nprint(paste0(\"Année : \", format(Sys.Date(), \"%Y\")))\n\n# Année passée\nannee_1 &lt;- annee - 1\npaste0(\"Année passée : \", annee_1)\n\n\n\n\n\n\n\n# Année courante\nannee = datetime.now().year\n# Afficher l'année actuelle\nprint(\"Année :\", annee)\n\n# Année passée\nannee_1 = annee - 1\nprint(\"Année passée :\", annee_1)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#construction-des-instructions-if-else",
    "href": "01-aide_memoire_r_sas.html#construction-des-instructions-if-else",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "3.3 Construction des instructions if / else",
    "text": "3.3 Construction des instructions if / else\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n%macro Annee(an);\n  %if &an. &gt;= 2024 %then %put Nous sommes en 2024 ou après !;\n  %else %put Nous sommes avant 2024 !;\n%mend Annee;\n%Annee(&annee.);\n\n\n\n# Construction incorrecte ! Le else doit être sur la même ligne que le {\n#if (annee &gt;= 2024) {\n#  print(\"Nous sommes en 2024 ou après !\")\n#}\n#else {\n#  print(\"Nous sommes avant 2024 !\")\n#}\n\n# Construction correcte ! Le else doit être sur la même ligne que le {\nif (annee &gt;= 2024) {\n  print(\"Nous sommes en 2024 ou après !\")\n} else {\n  print(\"Nous sommes avant 2024 !\")\n}\n\n\n\n\n# Construction incorrecte ! Le else doit être sur la même ligne que le {\n#if (annee &gt;= 2024) {\n#  print(\"Nous sommes en 2024 ou après !\")\n#}\n#else {\n#  print(\"Nous sommes avant 2024 !\")\n#}\n\n# Construction correcte ! Le else doit être sur la même ligne que le {\nif (annee &gt;= 2024) {\n  print(\"Nous sommes en 2024 ou après !\")\n} else {\n  print(\"Nous sommes avant 2024 !\")\n}\n\n\n\n\n# Construction incorrecte ! Le else doit être sur la même ligne que le {\n#if (annee &gt;= 2024) {\n#  print(\"Nous sommes en 2024 ou après !\")\n#}\n#else {\n#  print(\"Nous sommes avant 2024 !\")\n#}\n\n# Construction correcte ! Le else doit être sur la même ligne que le {\nif (annee &gt;= 2024) {\n  print(\"Nous sommes en 2024 ou après !\")\n} else {\n  print(\"Nous sommes avant 2024 !\")\n}\n\n\n\n\n\n\n\nif annee &gt;= 2024:\n    print(\"Nous sommes en 2024 ou après !\")\nelse:\n    print(\"Nous sommes avant 2024 !\")",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#répertoire-de-travail",
    "href": "01-aide_memoire_r_sas.html#répertoire-de-travail",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "3.4 Répertoire de travail",
    "text": "3.4 Répertoire de travail\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Afficher le répertoire de travail par défaut (la Work) */\n%let chemin_work = %sysfunc(pathname(work));\n%put &chemin_work.;\n\n/* Autre solution */\nproc sql;\n  select path from dictionary.libnames where libname = \"WORK\";\nquit;\n\n/* Définir le répertoire de travail, si besoin */\n/* libname \"nom du répertoire\"; */\n\n\n\n# Afficher le répertoire de travail\ngetwd()\n\n# Définir le répertoire de travail, si besoin\n#setwd(dir = \"nom du répertoire\")\n\n\n\n\n# Afficher le répertoire de travail\ngetwd()\n\n# Définir le répertoire de travail, si besoin\n#setwd(dir = \"nom du répertoire\")\n\n\n\n\n# Afficher le répertoire de travail\ngetwd()\n\n# Définir le répertoire de travail, si besoin\n#setwd(dir = \"nom du répertoire\")\n\n\n\n\n\n\n\n# Afficher le répertoire de travail\nos.getcwd()",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#autres-points-à-connaître",
    "href": "01-aide_memoire_r_sas.html#autres-points-à-connaître",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "3.5 Autres points à connaître",
    "text": "3.5 Autres points à connaître\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nMise en garde : certains codes SAS pourraient aussi avec profit être écrits en langage SAS IML (Interactive Matrix Language). Cet aide-mémoire n’ayant pas vocation à être un dictionnaire SAS, cette méthode d’écriture n’est pas proposée ici.\n\n\nR base est réputé plus lent que ses concurrents, ce qui est souvent vrai. Mais certaines fonctions en R base peuvent être très rapides (rowsum, rowSums, colSums, rowMeans, colMeans, tapply, etc.)\n\n# Le pipe permet d'enchaîner des opérations sur une même base.\n# Il n'est pas réservé au tidyverse, et peut être utilisé avec R-Base et data.table.\n1:10 |&gt; sum()\n\n\n\ntidyverse promeut l’utilisation du pipe (%&gt;%), qui permet d’enchaîner des opérations sur une même base modifiée successivement. 2 types de pipes existent, le pipe de magrittr (%&gt;%) et le pipe de R-Base (|&gt;, à partir de la version 4.1) Les fonctionnalités simples des deux opérateurs sont identiques, mais il existe des différences. Dans cet aide-mémoire, le pipe de magrittr (%&gt;%) est privilégié.\nLe tidyverse peut s’utiliser sans pipe, mais le pipe simplifie la gestion des programmes. Les autres environnements (R base, data.table) peuvent aussi se présenter avec le pipe.\n\n\n\n# Principe de base de data.table\n# dt[i, j, by = ]\n#   dt : nom de la base en format data.table (instruction FROM de SQL)\n#   i : sélection de lignes (instructions WHERE et ORDER de SQL)\n#   j : sélection et manipulation de colonnes (instruction SELECT de SQL)\n#   by = : groupements (instruction GROUP BY de SQL)\n\n# L'instruction HAVING de SQL peut être obtenue par une seconde instruction de sélection, par exemple :\n# dt[i, j, by = ][SOMME &gt; VALEUR]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#avoir-une-vue-densemble-des-données",
    "href": "01-aide_memoire_r_sas.html#avoir-une-vue-densemble-des-données",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "4.1 Avoir une vue d’ensemble des données",
    "text": "4.1 Avoir une vue d’ensemble des données\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Statistiques globales sur les variables numériques */\nproc means data = donnees_sas n mean median min p10 p25 median p75 p90 max;var _numeric_;run;\n\n/* Statistiques globales sur les variables caractères */\nproc freq data = donnees_sas;tables _character_ / missing;run;\n\n\n\n# Informations sur les variables\nstr(donnees_rbase)\n\n# Statistiques descriptives des variables de la base\nsummary(donnees_rbase)\nlibrary(Hmisc)\nHmisc::describe(donnees_rbase)\n\n# Visualiser la base de données\nView(donnees_rbase)\n\n\n\n\n# Informations sur les variables\ndonnees_tidyverse %&gt;% str()\ndonnees_tidyverse %&gt;% glimpse()\n\n# Statistiques descriptives des variables de la base\ndonnees_tidyverse %&gt;% summary()\n\n# Visualiser la base de données\ndonnees_tidyverse %&gt;% View()\n\n\n\n\n# Informations sur les variables\nstr(donnees_datatable)\n\n# Statistiques descriptives des variables de la base\nsummary(donnees_datatable)\n\n# Visualiser la base de données\nView(donnees_datatable)\n\n\n\nOn accède aux données du serveur SQL DuckDB au travers de l’objet requete_duckdb, qui est une requête (avec l’adresse du serveur) et non pas un dataframe ou un tibble. Comme l’accès n’est pas direct, la plupart des fonctions du tidyverse fonctionnent, mais opèrent sur “l’adresse du serveur DuckDB” au lieu d’opérer sur les valeurs (nombres, chaînes de caractères). A part glimpse, la plupart des fonctions ne renvoient pas un résultat exploitable.\n\n# Informations sur les variables\n# requete_duckdb %&gt;% str() \nrequete_duckdb %&gt;% glimpse() # préférer glimpse()\n# requete_duckdb %&gt;% summary()\n# requete_duckdb %&gt;% View() \n\n\n\n\n# Informations sur les variables\n# donnees_python.info()\n\n# Statistiques descriptives des variables de la base\n# donnees_python.describe()",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#afficher-le-type-des-variables",
    "href": "01-aide_memoire_r_sas.html#afficher-le-type-des-variables",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "4.2 Afficher le type des variables",
    "text": "4.2 Afficher le type des variables\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nproc contents data = donnees_sas;run;\n\n\n\nsapply(donnees_rbase, class)\n\n\n\n\npurrr::map(donnees_tidyverse, class)\nclass(donnees_tidyverse)\n\n\n\n\ndonnees_datatable[, lapply(.SD, class)]\n\n\n\nOn ne peut pas appliquer directement la fonction class sur un objet de type connection. Cependant, DuckDB affiche le type des variables dans un print. On peut également appliquer la fonction class sur un extrait des données (après collect).\n\npurrr::map(requete_duckdb %&gt;% select(c(1,2)) %&gt;% head() %&gt;% collect(), class)\nclass(requete_duckdb)\n\n\n\n\n### Afficher le type des variables :\ndonnees_python.dtypes",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#extraire-les-x-premières-lignes-de-la-base-10-par-défaut",
    "href": "01-aide_memoire_r_sas.html#extraire-les-x-premières-lignes-de-la-base-10-par-défaut",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "4.3 Extraire les x premières lignes de la base (10 par défaut)",
    "text": "4.3 Extraire les x premières lignes de la base (10 par défaut)\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n%let x = 10;\nproc print data = donnees_sas (firstobs = 1 obs = &x.);run;\n/* Ou alors */\ndata Lignes&x.;set donnees_sas (firstobs = 1 obs = &x.);proc print;run;\n\n\n\nx &lt;- 10\ndonnees_rbase[1:x, ]\nhead(donnees_rbase, x)\n\n\n\n\nx &lt;- 10\ndonnees_tidyverse %&gt;% \n  slice(1:x)\n\n\n\n\nx &lt;- 10\ndonnees_datatable[, first(.SD, x)]\ndonnees_datatable[, .SD[1:x]]\nfirst(donnees_datatable, x)\nhead(donnees_datatable, x)\n\n\n\nDuckDB affiche les dix premières lignes par défaut lorsque l’on évalue une requête, comme indiqué dans le code ci-dessous.\n\nrequete_duckdb\n# Ceci est équivalent au code suivant\n# requete_duckdb %&gt;% print(n=10)\n\nAttention, comme il n’y a pas d’ordre en SQL, il faut ordonner les lignes si on veut un résultat reproductible. C’est une opération qui peut être couteuse en temps CPU.\n\nrequete_duckdb %&gt;% arrange(duree) %&gt;% print()\n\nL’objet requete_duckdb est bien une requête (i.e. une liste à deux éléments) même si on peut en afficher le résultat avec la fonction print. Notamment, les informations restent dans la mémoire de DuckDB. Il faut demander explicitement le transfert du résultat vers la session R avec la fonction collect(). On obtient alors un objet de type data.frame ou au lieu de tbl_duckdb_connection.\n\nclass(requete_duckdb)\nresultat_tibble &lt;- requete_duckdb %&gt;% collect()\nclass(resultat_tibble)\n\nLa fonction collect() transfère l’ensemble des données. Pour obtenir uniquement 10 lignes, il faut utiliser l’une des fonctions slice_* (cf documentation). On conseille slice_min ou slice_max qui indiquent explicitement l’ordre utilisé.\n\nrequete_duckdb %&gt;% slice_max(duree, n=4, with_ties=FALSE) # with_ties = TRUE retourne les cas d'égalité, donc plus de 4 lignes\n\nEn DuckDB et/ou sur un serveur SQL, on déconseille les fonctions head (qui ne respecte pas toujours l’ordre indiqué par arrange) ou top_n (superseded). La fonction slice en fonctionne pas : elle ne peut pas respecter l’ordre.\n\n\n\nx = 10\ndonnees_python.head(x)\n# Autre méthode : la spécificité de Python est que l'on commence à compter à partir de 0\n# La première ligne se situe en position 0\ndonnees_python.iloc[0:x, :]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#extraire-les-x-dernières-lignes-de-la-base-10-par-défaut",
    "href": "01-aide_memoire_r_sas.html#extraire-les-x-dernières-lignes-de-la-base-10-par-défaut",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "4.4 Extraire les x dernières lignes de la base (10 par défaut)",
    "text": "4.4 Extraire les x dernières lignes de la base (10 par défaut)\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n%let x = 10;\nproc sql noprint;select count(*) into :total_lignes from donnees_sas;quit;\n%let deb = %eval(&total_lignes. - &x. + 1);\ndata Lignes_&x.;set donnees_sas (firstobs = &deb. obs = &total_lignes.);run;\n\n\n\nx &lt;- 10\ntail(donnees_rbase, x)\n\n# Autre possibilité\ndonnees_rbase[ ( nrow(donnees_rbase) - x ) : nrow(donnees_rbase), ]\n\n# Les parenthèses sont importantes. Comparer les deux expressions ! Bon exemple du recycling\n( nrow(donnees_rbase) - x ) : nrow(donnees_rbase)\nnrow(donnees_rbase) - x : nrow(donnees_rbase)\n\n\n\n\nx &lt;- 10\ndonnees_tidyverse %&gt;% \n  slice( (n() - x) : n())\n\n\n\n\nx &lt;- 10\ndonnees_datatable[, last(.SD, x)]\ndonnees_datatable[, tail(.SD, x)]\nlast(donnees_datatable, x)\ntail(donnees_datatable, x)\n\n\n\nMêmes remarques que pour les premières lignes : il n’y a pas d’ordre a priori en SQL. On conseille slice_min ou slice_max qui indiquent explicitement l’ordre utilisé, et l’on déconseille slice et tail.\n\nrequete_duckdb %&gt;% slice_min(duree, n=5, with_ties=FALSE) # with_ties = TRUE retourne les cas d'égalité, donc plus de 5 lignes\n\n\n\n\nx = 10\ndonnees_python.tail(x)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#nombre-de-lignes-et-de-colonnes-dans-la-base",
    "href": "01-aide_memoire_r_sas.html#nombre-de-lignes-et-de-colonnes-dans-la-base",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "4.5 Nombre de lignes et de colonnes dans la base",
    "text": "4.5 Nombre de lignes et de colonnes dans la base\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Nombre de lignes */\nproc sql;select count(*) as Nb_Lignes from donnees_sas;quit;\nproc sql;\n  select count(*) as Nb_Lignes, count(distinct identifiant) as Nb_Identifiants\n  from donnees_sas;\nquit;\n\n/* Nombre de colonnes */\nproc sql;select count(*) as Nb_Colonnes from Var;run;\n\n\n\n# Les syntaxes dim(donnees_rbase)[1] et dim(donnees_rbase)[2] sont plus rapides que nrow() et ncol()\nsprintf(\"Nombre de lignes : %d | Nombre de colonnes : %d\", dim(donnees_rbase)[1], dim(donnees_rbase)[2])\nsprintf(\"Nombre de lignes : %d | Nombre de colonnes : %d\", nrow(donnees_rbase), ncol(donnees_rbase))\n\n\n\n\nsprintf(\"Nombre de lignes : %d | Nombre de colonnes : %d\",\n        donnees_tidyverse %&gt;% nrow(),\n        donnees_tidyverse %&gt;% ncol())\n\n# Nombre de lignes\ndonnees_tidyverse %&gt;% nrow()\n# Nombre de colonnes\ndonnees_tidyverse %&gt;% ncol()\n\n\n\n\ndim(donnees_datatable) ; dim(donnees_datatable)[1] ; dim(donnees_datatable)[2]\ndim(donnees_datatable) ; nrow(donnees_datatable) ; ncol(donnees_datatable)\nsprintf(\"Nombre de lignes : %d | Nombre de colonnes : %d\", dim(donnees_datatable)[1], dim(donnees_datatable)[2])\n\n# Autre solution rapide pour le nombre de lignes\ndonnees_datatable[, .N]\n\n\n\nDuckdb/SQL ne connaît pas le nombre de lignes sans un calcul. Il faut faire count().\n\n#Nombre de lignes\nrequete_duckdb %&gt;% nrow() # retourne NA\nrequete_duckdb %&gt;% count() # correct\n\n#Nombre de colonnes\nrequete_duckdb %&gt;%  ncol()\n\n\n\n\ndonnees_python.shape\nprint('Nombre de lignes : ' + str(donnees_python.shape[0]))\nprint('Nombre de colonnes : ' + str(donnees_python.shape[1]))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#les-variables-de-la-base",
    "href": "01-aide_memoire_r_sas.html#les-variables-de-la-base",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "4.6 Les variables de la base",
    "text": "4.6 Les variables de la base\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Par ordre d'apparition dans la base */\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql;select name into :nom_col separated by \" \" from Var order by varnum;run;\n\n/* On affiche les noms des variables */\n%put Liste des variables : &nom_col.;\n\n/* Par ordre alphabétique */\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql;select name into :nom_col separated by \" \" from Var;run;\n\n/* On affiche les noms des variables */\n%put Liste des variables : &nom_col.;\n\n/* On supprime la base Var temporaire */\nproc datasets lib = Work nolist;delete Var;run;\n\n\n\n# Les variables par ordre d'apparition dans la base\nnames(donnees_rbase)\ncolnames(donnees_rbase)\n\n# Les variables par ordre alphabétique\nls(donnees_rbase)\nsort(colnames(donnees_rbase))\n\n\n\n\n# Les variables par ordre d'apparition dans la base\ndonnees_tidyverse %&gt;% names()\ndonnees_tidyverse %&gt;% colnames()\n\n# Les variables par ordre alphabétique\ndonnees_tidyverse %&gt;% colnames() %&gt;% sort()\n\n\n\n\n# Les variables par ordre d'apparition dans la base\nnames(donnees_datatable)\ncolnames(donnees_datatable)\n\n# Les variables par ordre alphabétique\nsort(colnames(donnees_datatable))\n\n\n\n\nrequete_duckdb %&gt;% colnames()\n\n\n\n\ndonnees_python.columns",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#mettre-les-noms-des-variables-en-minuscule",
    "href": "01-aide_memoire_r_sas.html#mettre-les-noms-des-variables-en-minuscule",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "4.7 Mettre les noms des variables en minuscule",
    "text": "4.7 Mettre les noms des variables en minuscule\nR est sensible à la casse, il est pertinent d’harmoniser les noms des variables en minuscule.\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nSans objet, SAS n’est pas sensible à la casse.\n\n\n\ncolnames(donnees_rbase) &lt;- tolower(colnames(donnees_rbase))\n\n# Autre possibilité\nsetNames(donnees_rbase, tolower(names(donnees_rbase)))\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% rename_with(tolower)\n\n# Autre solution\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  magrittr::set_colnames(value = casefold(colnames(.), upper = FALSE))\n\n\n\n\ncolnames(donnees_datatable) &lt;- tolower(colnames(donnees_datatable))\n\n\n\n\n\n\n\ndonnees_python.columns = donnees_python.columns.str.lower()",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#nombre-didentifiants-uniques-et-de-lignes-dans-la-base",
    "href": "01-aide_memoire_r_sas.html#nombre-didentifiants-uniques-et-de-lignes-dans-la-base",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "4.8 Nombre d’identifiants uniques et de lignes dans la base",
    "text": "4.8 Nombre d’identifiants uniques et de lignes dans la base\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nproc sql;\n  select count(*) as Nb_Lignes, count(distinct identifiant) as Nb_Identifiants_Uniques\n  from donnees_sas;\nquit;\n\n\n\nsprintf(\"La base de données contient %d lignes et %d identifiants uniques !\",\n        nrow(donnees_rbase),\n        length(unique(donnees_rbase$identifiant)))\n\n\n\n\nsprintf(\"La base de données contient %d lignes et %d identifiants uniques !\",\n        donnees_tidyverse %&gt;% nrow(),\n        donnees_tidyverse %&gt;% select(identifiant) %&gt;%\n          n_distinct()\n        )\n# Autre solution pour le nombre d'identifiants uniques\ndonnees_tidyverse %&gt;% select(identifiant) %&gt;% n_distinct()\ndonnees_tidyverse %&gt;% distinct(identifiant) %&gt;% nrow()\n\n\n\n\nsprintf(\"La base de données contient %d lignes et %d identifiants uniques !\",\n        nrow(donnees_datatable),\n        donnees_datatable[, uniqueN(identifiant)])\n\n\n\n\nrequete_duckdb %&gt;% nrow()\nrequete_duckdb %&gt;% distinct(identifiant) %&gt;% count()\n\nNote : on a vu que nrow ne fonctionne pas en DuckDB.\n\n\n\n(donnees_python['identifiant']).nunique()",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#quelle-est-la-position-de-la-variable-date_entree",
    "href": "01-aide_memoire_r_sas.html#quelle-est-la-position-de-la-variable-date_entree",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "4.9 Quelle est la position de la variable date_entree ?",
    "text": "4.9 Quelle est la position de la variable date_entree ?\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n%let var = date_entree;\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql;\n  select varnum as Position from Var where lowcase(NAME) = \"&var.\";\nrun;\n\n\n\nvariable &lt;- \"date_entree\"\npos &lt;- match(variable, names(donnees_rbase))\nsprintf(\"La variable %s se trouve en colonne n°%s !\", variable, pos)\n\n\n\n\nvariable &lt;- \"date_entree\"\npos &lt;- match(variable, donnees_tidyverse %&gt;% colnames())\nsprintf(\"La variable %s se trouve en colonne n°%s !\", variable, pos)\n\n\n\n\nvariable &lt;- \"date_entree\"\npos &lt;- match(variable, names(donnees_datatable))\nsprintf(\"La variable %s se trouve en colonne n°%s !\", variable, pos)\n\n\n\n\nvariable &lt;- \"date_entree\"\npos &lt;- match(variable, requete_duckdb %&gt;% colnames())\nsprintf(\"La variable %s se trouve en colonne n°%s !\", variable, pos)\n\n\n\n\n# Attention, Python commence à compter à partir de 0\n# Si date_entree est la première colonne, alors on affichera 0\nvariable = \"date_entree\"\npos = donnees_python.columns.get_loc(variable)\nprint(f\"La variable {variable} se trouve en colonne n°{pos} !\")",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#variables-qui-débutent-par-le-mot-note",
    "href": "01-aide_memoire_r_sas.html#variables-qui-débutent-par-le-mot-note",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "4.10 Variables qui débutent par le mot Note",
    "text": "4.10 Variables qui débutent par le mot Note\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nproc contents data = donnees_sas out = Variables;run;\nproc sql;select Name from Variables where upcase(substr(Name, 1, 4)) = \"NOTE\";run;\n\n\n\ngrep(\"^note\", names(donnees_rbase), ignore.case = TRUE, value = TRUE)\n\n# Autre possibilité\nnames(donnees_rbase)[grepl(\"^note\", names(donnees_rbase), ignore.case = TRUE)]\n\n\n\n\nnames(donnees_tidyverse) %&gt;% str_subset(\"^note\")\n\n\n\n\ngrep(\"^note\", names(donnees_datatable), ignore.case = TRUE, value = TRUE)\n\n# Autre possibilité\nnames(donnees_datatable)[grepl(\"^note\", names(donnees_datatable), ignore.case = TRUE)]\n\n\n\n\n\n\n\nimport re\n\n# Obtenir les noms des colonnes qui commencent par \"note\" en ignorant la casse\ncolumns_with_note = list(filter(lambda col: re.match(r'^note', col, re.IGNORECASE), donnees_python.columns))\ncolumns_with_note",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#variables-qui-se-terminent-par-le-mot-naissance",
    "href": "01-aide_memoire_r_sas.html#variables-qui-se-terminent-par-le-mot-naissance",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "4.11 Variables qui se terminent par le mot Naissance",
    "text": "4.11 Variables qui se terminent par le mot Naissance\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nproc contents data = donnees_sas out = Variables;run;\nproc sql;\n  select Name from Variables\n  where upcase(substr(NAME, length(Name) - %length(NAISSANCE) + 1, length(name))) = \"NAISSANCE\";\nrun;\n\n\n\ngrep(\"naissance$\", names(donnees_rbase), ignore.case = TRUE, value = TRUE)\n\n# Autre possibilité\nnames(donnees_rbase)[grepl(\"naissance$\", names(donnees_rbase), ignore.case = TRUE)]\n\n\n\n\nnames(donnees_tidyverse) %&gt;% str_subset(\"naissance$\")\n\n\n\n\ngrep(\"naissance$\", names(donnees_datatable), ignore.case = TRUE, value = TRUE)\n\n# Autre possibilité\nnames(donnees_datatable)[grepl(\"naissance$\", names(donnees_datatable), ignore.case = TRUE)]\n\n\n\n\n\n\n\ncolumns_with_naissance = list(filter(lambda col: re.search(r'naissance$', col, re.IGNORECASE), donnees_python.columns))\ncolumns_with_naissance",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-une-colonne-par-sa-position",
    "href": "01-aide_memoire_r_sas.html#sélectionner-une-colonne-par-sa-position",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "5.1 Sélectionner une colonne par sa position",
    "text": "5.1 Sélectionner une colonne par sa position\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n%let pos = 1;\nproc contents data = donnees_sas out = Var noprint;run;\n\nproc sql noprint;\n  select name into :nom_col separated by \" \"\n  from Var\n  where varnum = &pos.;\nrun;\n\ndata Colonnes;set donnees_sas (keep = &nom_col.);run;\nproc datasets lib = Work nolist;delete Var;run;\n\n\n\npos &lt;- 1\n# Résultat sous forme de vecteur caractère\nid &lt;- donnees_rbase[[pos]] ; class(id)\nid &lt;- donnees_rbase[, pos] ; class(id)\n\n# Résultat sous forme de data.frame\nid &lt;- donnees_rbase[pos] ; class(id)\n# Attention, utilisation du drop = FALSE étrange\n# En fait, l'affectation par [] a pour option par défaut drop = TRUE. Ce qui implique que si l'affectation renvoie un data.frame d'1 seule colonne, l'objet sera transformé en objet plus simple (vecteur en l'occurrence)\nid &lt;- donnees_rbase[, pos, drop = FALSE] ; class(id)\n\n\n\n\n# Sous forme de vecteur\nid &lt;- donnees_tidyverse %&gt;% pull(1)\nclass(id)\npos &lt;- 1\nid &lt;- donnees_tidyverse %&gt;% pull(all_of(pos))\nclass(id)\n\n# Sous forme de tibble\nid &lt;- donnees_tidyverse %&gt;% select(1)\nclass(id)\npos &lt;- 1\nid &lt;- donnees_tidyverse %&gt;% select(all_of(pos))\nclass(id)\n\n\n\n\npos &lt;- 1\n# Résultat sous forme de vecteur caractère\nid &lt;- donnees_datatable[[pos]] ; class(id)\n\n# Résultat sous forme de data.table\nid &lt;- donnees_datatable[pos] ; class(id)\n\n\n\nEn DuckDB, il y a une vraie différence entre select et pull. Dans le premier cas, les calculs restent du côté DuckDB, et c’est donc le moteur SQL qui continue à exécuter les calculs. Avec pull, le résultat est un tibble et les données sont transférées à la session R.\n\n\n\nrequete_duckdb %&gt;% select(3)\n# # Source:   SQL [?? x 1]\n# # Database: DuckDB v0.10.2 [sebastien.li-thiao-t@Windows 10 x64:R 4.3.2/:memory:]\n#   csp  \n#   &lt;chr&gt;\n# 1 1    \n# 2 1    \n# 3 1    \n# 4 1    \n# # ℹ more rows\n\n\n\n\n\nrequete_duckdb %&gt;% pull(3)\n#  [1] \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"3\" \"3\" \"3\" \"2\" \"3\" \"5\" \"5\" \"3\" \"3\" \"3\" \"4\" \"4\" \"4\"\n# [20] \"4\" \"4\" \"2\" \"2\" \"1\" \"4\" \"4\" \"4\"\n\n\n\n\n\n\npos = 0 # Contrairement à R, le compte commence à partir de 0 en Python\n\n# Résultat sous forme de vecteur caractère\ndonnees_python.iloc[:, pos]\n\n# Résultat sous forme de data.frame\ndonnees_python.iloc[:, [pos]]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-une-colonne-par-son-nom",
    "href": "01-aide_memoire_r_sas.html#sélectionner-une-colonne-par-son-nom",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "5.2 Sélectionner une colonne par son nom",
    "text": "5.2 Sélectionner une colonne par son nom\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata Colonnes;set donnees_sas (keep = identifiant);run;\ndata Colonnes;set donnees_sas;keep identifiant;run;\n\n\n\n# Résultat sous forme de vecteur caractère\nid &lt;- donnees_rbase$identifiant ; class(id)\nid &lt;- donnees_rbase[[\"identifiant\"]] ; class(id)\nid &lt;- donnees_rbase[, \"identifiant\"] ; class(id)\n\n# Résultat sous forme de data.frame\nid &lt;- donnees_rbase[\"identifiant\"] ; class(id)\n# Attention, utilisation du drop = FALSE étrange\n# En fait, l'affectation par [] a pour option par défaut drop = TRUE. Ce qui implique que si l'affectation renvoie\n# un data.frame d'1 seule colonne, l'objet sera transformé en objet plus simple (vecteur en l'occurrence)\nclass(donnees_rbase[, \"identifiant\", drop = FALSE])\nid &lt;- donnees_rbase[\"identifiant\"] ; class(id)\nid &lt;- donnees_rbase[, \"identifiant\", drop = FALSE] ; class(id)\n\n\n\n\n# Sous forme de vecteur\nid &lt;- donnees_tidyverse %&gt;% pull(identifiant)\nid &lt;- donnees_tidyverse %&gt;% pull(\"identifiant\")\n\n# Sous forme de tibble\nid &lt;- donnees_tidyverse %&gt;% select(identifiant)\nid &lt;- donnees_tidyverse %&gt;% select(\"identifiant\")\n\n\n\n\n# Résultat sous forme de vecteur caractère\nid &lt;- donnees_datatable$identifiant ; class(id)\nid &lt;- donnees_datatable[[\"identifiant\"]] ; class(id)\nid &lt;- donnees_datatable[, identifiant] ; class(id)\n\n# Résultat sous forme de data.table\nid &lt;- donnees_datatable[, \"identifiant\"] ; class(id)\nid &lt;- donnees_datatable[, .SD, .SDcols = \"identifiant\"] ; class(id)\n# Ne fonctionnent pas !\n#id &lt;- donnees_datatable[, .(\"identifiant\")] ; class(id)\n#id &lt;- donnees_datatable[J(\"identifiant\")] ; class(id)\n#id &lt;- donnees_datatable[, list(\"identifiant\")] ; class(id)\n#id &lt;- donnees_datatable[list(\"identifiant\")] ; class(id)\n\n\n\n\nrequete_duckdb %&gt;% select(identifiant)\nrequete_duckdb %&gt;% select(\"identifiant\") # déconseillé\nrequete_duckdb %&gt;% select(any_of(\"identifiant\"))\n\nNote : certaines fonction du tidyverse nécessitent de passer par les opérateurs any_of ou all_of pour ce genre d’opérations (distinct par exemple). On conseille de le faire aussi pour select.\n\n\n\n# Résultat sous forme de vecteur caractère\ndonnees_python[\"identifiant\"]\ndonnees_python.identifiant\n\n# Résultat sous forme de data.frame\ndonnees_python[[\"identifiant\"]]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#selection-de-colonnes-par-un-vecteur-contenant-des-chaînes-de-caractères",
    "href": "01-aide_memoire_r_sas.html#selection-de-colonnes-par-un-vecteur-contenant-des-chaînes-de-caractères",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "5.3 Selection de colonnes par un vecteur contenant des chaînes de caractères",
    "text": "5.3 Selection de colonnes par un vecteur contenant des chaînes de caractères\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n%let var = identifiant Sexe note_contenu;\ndata Colonnes;\n  /* Sélection de colonnes */\n  set donnees_sas (keep = &var.);\n  /* Autre solution */\n  keep &var.;\nrun;\n\n\n\nvariable &lt;- \"identifiant\"\n# Résultat sous forme de vecteur caractère\nid &lt;- donnees_rbase[, variable] ; class(id)\nid &lt;- donnees_rbase[[variable]] ; class(id)\n\n# Résultat sous forme de data.frame\nid &lt;- donnees_rbase[variable] ; class(id)\n# Attention, utilisation du drop = FALSE étrange\n# En fait, l'affectation par [] a pour option par défaut drop = TRUE. Ce qui implique que si l'affectation renvoie un data.frame d'1 seule colonne, l'objet sera transformé en objet plus simple (vecteur en l'occurrence)\nid &lt;- donnees_rbase[, variable, drop = FALSE] ; class(id)\n\n\n\n\nvariable &lt;- \"identifiant\"\n# Sous forme de vecteur\nid &lt;- donnees_tidyverse %&gt;% pull(all_of(variable))\n# Sous forme de tibble\nid &lt;- donnees_tidyverse %&gt;% select(all_of(variable))\n\n\n\n\n# Résultat sous forme de vecteur caractère\nvariable &lt;- \"identifiant\"\nid &lt;- donnees_datatable[[variable]] ; class(id)\nid &lt;- donnees_datatable[, get(variable)] ; class(id)\n\n# Résultat sous forme de data.table\nid &lt;- donnees_datatable[, ..variable] ; class(id)\nid &lt;- donnees_datatable[, variable, with = FALSE] ; class(id)\nid &lt;- donnees_datatable[, .SD, .SDcols = variable] ; class(id)\nid &lt;- donnees_datatable[, variable, env = list(variable = as.list(variable))] ; class(id)\n\n# Attention, ces syntaxes ne fonctionnent pas ! Il faut nécessairement passer par les syntaxes au-dessus.\n#id &lt;- donnees_datatable[, .(variable)] ; class(id)\n#id &lt;- donnees_datatable[, list(variable)] ; class(id)\n\n\n\n\nvariable &lt;- c(\"identifiant\",\"duree\")\nrequete_duckdb %&gt;% select(any_of(variable))\n\n\n\n\nvariable = 'identifiant'\n\n# Résultat sous forme de vecteur caractère\ndonnees_python[nom_var]\n\n# Résultat sous forme de data.frame\ndonnees_python[[nom_var]]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sauf-certaines-variables",
    "href": "01-aide_memoire_r_sas.html#sauf-certaines-variables",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "5.4 Sauf certaines variables",
    "text": "5.4 Sauf certaines variables\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n%let var = identifiant Sexe note_contenu;\ndata Colonnes;set donnees_sas (drop = &var.);run;\n\n\n\nvariable &lt;- c(\"identifiant\", \"sexe\", \"note_contenu\")\nexclusion_var &lt;- donnees_rbase[, setdiff(names(donnees_rbase), variable)]\n\n# Ne fonctionnent pas !\n#exclusion_var &lt;- donnees_rbase[, -c(variable)]\n#exclusion_var &lt;- donnees_rbase[, !c(variable)]\n\n\n\n\nvariable &lt;- c(\"identifiant\", \"sexe\", \"note_contenu\")\nexclusion_var &lt;- donnees_tidyverse %&gt;% select(!all_of(variable))\nexclusion_var &lt;- donnees_tidyverse %&gt;% select(-all_of(variable))\n\n\n\n\nvariable &lt;- c(\"identifiant\", \"sexe\", \"note_contenu\")\nexclusion_var &lt;- donnees_datatable[, !..variable]\n\n\n\nLes opérateurs - et ! fonctionnent.\n\nrequete_duckdb %&gt;% select(!identifiant)\nrequete_duckdb %&gt;% select(-all_of(variable))\n\n\n\n\nvariable = [\"identifiant\", \"sexe_red\", \"note_contenu\"]\ndonnees_python.drop(columns=variable, axis = 0)\n# En ajoutant l'argument inplace = True à la fonction .drop(), la base de données est directement modifiée en supprimant les variables du vecteur",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-la-3e-colonne",
    "href": "01-aide_memoire_r_sas.html#sélectionner-la-3e-colonne",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "5.5 Sélectionner la 3e colonne",
    "text": "5.5 Sélectionner la 3e colonne\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nproc contents data = donnees_sas out = Var noprint;run;\n\nproc sql noprint;\n  select name into :nom_col separated by \" \"\n  from Var\n  where varnum = 3;\nrun;\n\ndata Col3;set donnees_sas (keep = &nom_col.);run;\n\n\n\ncol3 &lt;- donnees_rbase[, 3]\n\n# Autre possibilité\ncol3 &lt;- donnees_rbase[3]\n\n\n\n\ncol3 &lt;- donnees_tidyverse %&gt;% pull(3)\n\n# Autre possibilité\ncol3 &lt;- donnees_tidyverse %&gt;% select(3)\n\n\n\n\ncol3 &lt;- donnees_datatable[, 3]\n\n\n\n\nrequete_duckdb %&gt;% select(3)\n\n\n\n\n# Attention, en Python, la position de la 3e colonne est 2\npos = 3\ndonnees_python.iloc[:, pos-1]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-plusieurs-colonnes",
    "href": "01-aide_memoire_r_sas.html#sélectionner-plusieurs-colonnes",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "5.6 Sélectionner plusieurs colonnes",
    "text": "5.6 Sélectionner plusieurs colonnes\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n%let var = identifiant note_contenu sexe;\ndata Colonnes;set donnees_sas (keep = &var.);run;\n\n/* Autre solution */\n/* En SQL, les variables sélectionnées dans l'instruction SELECT sont séparées par des virgules. On ajoute des virgules entre les variables. */\nproc sql;\n  create table Colonnes as\n  select %sysfunc(tranwrd(&var., %str( ), %str(, )))\n  from donnees_sas;\nquit;\n\n\n\ncols &lt;- c(\"identifiant\", \"note_contenu\", \"sexe\")\ncolonnes &lt;- donnees_rbase[, cols]\n\n# Autre possibilité\ncolonnes &lt;- donnees_rbase[cols]\n\n\n\n\ncols &lt;- c(\"identifiant\", \"note_contenu\", \"sexe\")\n# Plusieurs possibilités\ncolonnes &lt;- donnees_tidyverse %&gt;% select(all_of(cols))\ncolonnes &lt;- donnees_tidyverse %&gt;% select(any_of(cols))\ncolonnes &lt;- donnees_tidyverse %&gt;% select({{ cols }})\ncolonnes &lt;- donnees_tidyverse %&gt;% select(!!cols)\n\n\n\n\ncols &lt;- c(\"identifiant\", \"note_contenu\", \"sexe\")\n# Plusieurs écritures possibles\n\n# Ecriture cohérente avec la logique data.table\ncolonnes &lt;- donnees_datatable[, .SD, .SDcols = cols]\n\n# Ecriture avec with = FALSE : désactive la possibilité de se référer à des colonnes sans les guillemets\ncolonnes &lt;- donnees_datatable[, cols, with = FALSE]\n\n# Ecriture avec mget\ncolonnes &lt;- donnees_datatable[, mget(cols)]\n\n# Ecriture un peu contre-intuitve. Attention ! L'écriture est bien ..cols, et non ..(cols) !!\n# Les syntaxes donnees_datatable[, ..(cols)] et donnees_datatable[, .(cols)] ne fonctionnent pas\ncolonnes &lt;- donnees_datatable[, ..cols]\n\n\n\n\ncols &lt;- c(\"identifiant\", \"note_contenu\", \"sexe\")\n# Plusieurs possibilités\nrequete_duckdb %&gt;% select(all_of(cols))\nrequete_duckdb %&gt;% select(any_of(cols))\nrequete_duckdb %&gt;% select({{ cols }})\nrequete_duckdb %&gt;% select(!!cols)\n\n\n\n\ncols = [\"identifiant\", \"note_contenu\", \"sexe\"]\ncolonnes = donnees_python[cols]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-les-colonnes-qui-débutent-par-le-mot-note",
    "href": "01-aide_memoire_r_sas.html#sélectionner-les-colonnes-qui-débutent-par-le-mot-note",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "5.7 Sélectionner les colonnes qui débutent par le mot Note",
    "text": "5.7 Sélectionner les colonnes qui débutent par le mot Note\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* 1ère solution */\ndata Selection_Variables;set donnees_sas (keep = Note:);run;\n\n/* 2e solution */\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql;\n  select name into :var_notes separated by \" \"\n  from Var where substr(upcase(name), 1, 4) = \"NOTE\" order by varnum;\nrun;\nproc datasets lib = Work nolist;delete Var;run;\ndata donnees_sas_Notes;set donnees_sas (keep = &var_notes.);run;\n\n\n\nvarNotes &lt;- donnees_rbase[grepl(\"^note\", names(donnees_rbase), ignore.case = TRUE)]\n\n# Autre possibilité\nvarNotes &lt;- donnees_rbase[substr(tolower(names(donnees_rbase)), 1, 4) == \"note\"]\n\n\n\n\nvarNotes &lt;- donnees_tidyverse %&gt;% select(starts_with(\"note\"))\n\n\n\n\n# 1ère méthode\ncols &lt;- names(donnees_datatable)[substr(names(donnees_datatable), 1, 4) == \"note\"]\n# Ou encore\ncols &lt;- names(donnees_datatable)[names(donnees_datatable) %like% \"^note\"]\n\nsel &lt;- donnees_datatable[, .SD, .SDcols = cols]\n\n# 2e méthode\nsel &lt;- donnees_datatable[, .SD, .SDcols = patterns(\"^note\")]\n\n\n\n\nrequete_duckdb %&gt;% select(starts_with(\"note\"))\n\n\n\n\nvarNotes = donnees_python[list(filter(lambda col: re.match(r'^note', col, re.IGNORECASE), donnees_python.columns))]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-les-colonnes-qui-ne-débutent-pas-par-le-mot-note",
    "href": "01-aide_memoire_r_sas.html#sélectionner-les-colonnes-qui-ne-débutent-pas-par-le-mot-note",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "5.8 Sélectionner les colonnes qui ne débutent pas par le mot Note",
    "text": "5.8 Sélectionner les colonnes qui ne débutent pas par le mot Note\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata Selection_Variables;set donnees_sas (drop = Note:);run;\n\n\n\nvarNotes &lt;- donnees_rbase[! grepl(\"^note\", names(donnees_rbase), ignore.case = TRUE)]\n\n# Autre possibilité\nvarNotes &lt;- donnees_rbase[substr(tolower(names(donnees_rbase)), 1, 4) != \"note\"]\n\n\n\n\nvarNotes &lt;- donnees_tidyverse %&gt;% select(-starts_with(\"note\"))\nvarNotes &lt;- donnees_tidyverse %&gt;% select(!starts_with(\"note\"))\n\n\n\n\ncols &lt;- grep(\"^note\", names(donnees_datatable), value = TRUE, ignore.case = TRUE)\nsel &lt;- donnees_datatable[, .SD, .SDcols = -cols]\nsel &lt;- donnees_datatable[, .SD, .SDcols = -patterns(\"^note\")]\n\n\n\n\nrequete_duckdb %&gt;% select(-starts_with(\"note\"))\nrequete_duckdb %&gt;% select(!starts_with(\"note\"))\n\n\n\n\nvarNotes = donnees_python.drop(columns=list(filter(lambda col: re.match(r'^note', col, re.IGNORECASE), donnees_python.columns)), \n                               axis = 0)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-lensemble-des-variables-numériques-de-la-base",
    "href": "01-aide_memoire_r_sas.html#sélectionner-lensemble-des-variables-numériques-de-la-base",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "5.9 Sélectionner l’ensemble des variables numériques de la base",
    "text": "5.9 Sélectionner l’ensemble des variables numériques de la base\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata Colonnes;set donnees_sas (keep = _numeric_);run;\n\n\n\nvarNumeriques &lt;- donnees_rbase[, sapply(donnees_rbase, is.numeric), drop = FALSE]\n\n\n\n\nvarNumeriques &lt;- donnees_tidyverse %&gt;% select_if(is.numeric)\nvarNumeriques &lt;- donnees_tidyverse %&gt;% select(where(is.numeric))\n\n\n\n\nsel &lt;- donnees_datatable[, .SD, .SDcols = is.numeric]\n\n\n\n\nrequete_duckdb %&gt;% select_if(is.numeric)\n# requete_duckdb %&gt;% select(where(is.numeric))\n\n\n\n\nvarNumeriques = donnees_python.select_dtypes(include='number')",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-lensemble-des-variables-de-format-date",
    "href": "01-aide_memoire_r_sas.html#sélectionner-lensemble-des-variables-de-format-date",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "5.10 Sélectionner l’ensemble des variables de format “Date”",
    "text": "5.10 Sélectionner l’ensemble des variables de format “Date”\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql noprint;\n  select name into :nom_col separated by \" \"\n  from Var where format not in (\"$\", \"\");\nrun;\ndata Colonnes;set donnees_sas (keep = &nom_col.);run;\nproc datasets lib = Work nolist;delete Var;run;\n\n\n\nvarDates &lt;- donnees_rbase[, sapply(donnees_rbase, is.Date), drop = FALSE]\nvarDates &lt;- Filter(is.Date, donnees_rbase)\n\n\n\n\nvarDates &lt;- donnees_tidyverse %&gt;% select(where(is.Date))\nvarDates &lt;- donnees_tidyverse %&gt;% select_if(is.Date)\n\n\n\n\nvar_dates &lt;- donnees_datatable[, .SD, .SDcols = is.Date]\n\n\n\n\nrequete_duckdb %&gt;% select_if(is.Date)\n# requete_duckdb %&gt;% select(where(is.Date))\n\n\n\n\nvarDates = donnees_python.select_dtypes(include=['datetime64[ns]'])",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-des-lignes-par-leur-numéro",
    "href": "01-aide_memoire_r_sas.html#sélectionner-des-lignes-par-leur-numéro",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "6.1 Sélectionner des lignes par leur numéro",
    "text": "6.1 Sélectionner des lignes par leur numéro\n\n6.1.1 3e ligne\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata Ligne3; set donnees_sas (firstobs = 3 obs = 3); run;\n\n\n\nligne3 &lt;- donnees_rbase[3, ]\n\n\n\n\nligne3 &lt;- donnees_tidyverse %&gt;% slice(3)\n\n\n\n\nligne3 &lt;- donnees_datatable[3, ]\nligne3 &lt;- donnees_datatable[3]\n\n\n\nDuckDB, moteur SQL, ne respecte pas l’ordre des lignes. Il faut passer par un filtre ou choisir explicitement un ordre.\n\n\n\ndonnees_python.iloc[2] # En Python, la troisieme ligne est en position 2\n\n\n\n\n\n\n6.1.2 3 premières lignes et 3 premières colonnes\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql noprint;\n  select name into :nom_col separated by \" \" from Var\n  where 1 &lt;= varnum &lt;= 3;\nrun;\ndata Top3;\n  set donnees_sas (firstobs = 1 obs = 3 keep = &nom_col.);\nrun;\nproc datasets lib = Work nolist;delete Var;run;\n\n\n\ntop3 &lt;- donnees_rbase[1:3, 1:3]\n\n\n\n\ntop3 &lt;- donnees_tidyverse %&gt;% slice(1:3) %&gt;% select(1:3)\n\n\n\n\ntop3 &lt;- donnees_datatable[1:3, 1:3]\n\n\n\nDuckDB, moteur SQL, ne respecte pas l’ordre des lignes. Il faut passer par un filtre ou choisir explicitement un ordre.\n\n\n\ntop3 = donnees_python.iloc[:3, :3]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-des-lignes-par-condition",
    "href": "01-aide_memoire_r_sas.html#sélectionner-des-lignes-par-condition",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "6.2 Sélectionner des lignes par condition",
    "text": "6.2 Sélectionner des lignes par condition\n\n6.2.1 Entrées en 2023\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata En2023;\n  set donnees_sas (where = (year(date_entree) = 2023));\nrun;\n\n\n\n# Bonnes écritures, qui excluent les valeurs manquantes\nen2023 &lt;- donnees_rbase[lubridate::year(donnees_rbase$date_entree) %in% c(2023), ]\nen2023 &lt;- donnees_rbase[which(lubridate::year(donnees_rbase$date_entree) == 2023), ]\nen2023 &lt;- subset(donnees_rbase, lubridate::year(donnees_rbase$date_entree) == 2023)\n\n\n\n\nen2023 &lt;- donnees_tidyverse %&gt;% filter(lubridate::year(date_entree) == 2023)\n\n\n\n\n# Pas de problème avec les valeurs manquantes comme pour la syntaxe en R-Base\n# Une fonction year() est déjà implémentée en data.table, l'usage de lubridate est inutile\nen2023 &lt;- donnees_datatable[data.table::year(date_entree) == 2023, ]\nen2023 &lt;- donnees_datatable[data.table::year(date_entree) == 2023]\nen2023 &lt;- subset(donnees_datatable, data.table::year(date_entree) == 2023)\n\n\n\n\nrequete_duckdb %&gt;% filter(lubridate::year(date_entree) == 2023)\n\n\n\n\nen2023 = donnees_python[donnees_python['date_entree'].dt.year == 2023]\n\n\n\n\n\n\n6.2.2 Entrées entre 2021 et 2023\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata Entre2021_2023;\n  set donnees_sas (where = (2021 &lt;= year(date_entree) &lt;= 2023));\nrun;\n\n\n\nentre2021_2023 &lt;- donnees_rbase[lubridate::year(donnees_rbase$date_entree) %in% 2021:2023, ]\nentre2021_2023 &lt;- donnees_rbase[lubridate::year(donnees_rbase$date_entree) &gt;= 2021 & lubridate::year(donnees_rbase$date_entree) &lt;= 2023, ]\n\n\n\n\nentre2021_2023 &lt;- donnees_tidyverse %&gt;% filter(between(lubridate::year(date_entree), 2021, 2023))\nentre2021_2023 &lt;- donnees_tidyverse %&gt;% filter(lubridate::year(date_entree) %in% 2021:2023)\nentre2021_2023 &lt;- donnees_tidyverse %&gt;% filter(lubridate::year(date_entree) &gt;= 2021, lubridate::year(date_entree) &lt;= 2023)\n\n\n\n\n# Une fonction year() est déjà implémentée en data.table, l'usage de lubridate est inutile\nentre2021_2023 &lt;- donnees_datatable[data.table::year(date_entree) %in% 2021:2023]\nentre2021_2023 &lt;- donnees_datatable[between(data.table::year(date_entree), 2021, 2023)]\n\n\n\n\nrequete_duckdb %&gt;% filter(between(lubridate::year(date_entree), 2021, 2023))\n\n\n\n\nen2021_2023 = donnees_python[(donnees_python['date_entree'].dt.year &gt;= 2021) &\n                            (donnees_python['date_entree'].dt.year &lt;= 2023)]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-des-lignes-suivant-de-multiples-conditions",
    "href": "01-aide_memoire_r_sas.html#sélectionner-des-lignes-suivant-de-multiples-conditions",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "6.3 Sélectionner des lignes suivant de multiples conditions",
    "text": "6.3 Sélectionner des lignes suivant de multiples conditions\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Femmes entrées avant 2023 */\n/* Ecriture correcte */\ndata Avant2023_Femme;\n  set donnees_sas (where = (year(date_entree) &lt; 2023 and not missing(date_entree) and sexe = 2));\nrun;\n\n/* Ecriture incorrecte. Les valeurs manquantes sont considérées comme des nombres négatifs faibles, et inférieurs à 2023. */\n/* Elles sont sélectionnées dans le code suivant : */\ndata Avant2023_Femme;\n  set donnees_sas (where = (year(date_entree) &lt; 2023 and sexe = 2));\nrun;\n\n\n\n# Femmes entrées avant 2023\navant2023_femme &lt;- subset(donnees_rbase, lubridate::year(date_entree) &lt; 2023 & sexe == \"2\")\n\n# Autre solution\navant2023_femme &lt;- with(donnees_rbase, donnees_rbase[which(lubridate::year(date_entree) &lt; 2023 & sexe == \"2\"), ])\n\n\n\n\n# Femmes entrées avant 2023\navant2023_femme &lt;- donnees_tidyverse %&gt;% \n  filter(lubridate::year(date_entree) &lt; 2023 & sexe == \"2\")\navant2023_femme &lt;- donnees_tidyverse %&gt;% \n  filter(lubridate::year(date_entree) &lt; 2023, sexe == \"2\")\n\n\n\n\n# Femmes entrées avant 2023\n# Une fonction year() est déjà implémentée en data.table, l'usage de lubridate est inutile\navant2023_femme &lt;- donnees_datatable[data.table::year(date_entree) &lt; 2023 & sexe == \"2\"]\navant2023_femme &lt;- subset(donnees_datatable, data.table::year(date_entree) &lt; 2023 & sexe == \"2\")\n\n\n\n\nrequete_duckdb %&gt;% \n  filter(lubridate::year(date_entree) &lt; 2023 & sexe == \"2\") # Femmes entrées avant 2023\n\n\n\n\navant2023_femme = donnees_python[(donnees_python['date_entree'].dt.year &lt; 2023) &\n                            (donnees_python['sexe'] == \"2\")]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-des-lignes-par-référence-lignes-de-lidentifiant-087",
    "href": "01-aide_memoire_r_sas.html#sélectionner-des-lignes-par-référence-lignes-de-lidentifiant-087",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "6.4 Sélectionner des lignes par référence : lignes de l’identifiant “087”",
    "text": "6.4 Sélectionner des lignes par référence : lignes de l’identifiant “087”\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n%let var = identifiant;\n%let sel = 087;\n\ndata Selection;\n  set donnees_sas;\n  if &var. in (\"&sel.\");\nrun;\n\n/* Autre solution */\ndata Selection;\n  set donnees_sas (where = (&var. in (\"&sel.\")));\nrun;\n\n\n\nvariable &lt;- \"identifiant\"\nsel &lt;- \"087\"\ndonnees_rbase[donnees_rbase[, variable] %in% sel, ]\n\n# Autre solution\nsubset(donnees_rbase, get(variable) %in% sel)\n\n\n\n\ndonnees_tidyverse %&gt;% filter(identifiant %in% c(\"087\")) %&gt;% select(identifiant)\ndonnees_tidyverse %&gt;% filter(identifiant == \"087\") %&gt;% select(identifiant)\n\n# Essayons désormais par variable\nvariable &lt;- \"identifiant\"\nsel &lt;- \"087\"\ndonnees_tidyverse %&gt;% filter(if_any(variable, ~ .x %in% sel)) %&gt;% select(all_of(variable))\ndonnees_tidyverse %&gt;% filter(get(variable) %in% sel) %&gt;% select(all_of(variable))\n\n\n\n\nvariable &lt;- \"identifiant\"\nsel &lt;- \"087\"\ndonnees_datatable[donnees_datatable[[variable]] %chin% sel, ]\ndonnees_datatable[get(variable) %chin% sel, ]\n\n\n\n\nrequete_duckdb %&gt;% filter(identifiant %in% c(\"087\")) %&gt;% select(identifiant)\nrequete_duckdb %&gt;% filter(identifiant == \"087\") %&gt;% select(identifiant)\n# Essayons désormais par variables\nvariable &lt;- \"identifiant\"\nsel &lt;- \"087\"\nrequete_duckdb %&gt;% select(any_of(variable))\n\n\n\n\nvariable = \"identifiant\"\nsel = \"087\"\ndonnees_python[donnees_python[variable] == sel]\ndonnees_python[donnees_python[variable].isin([sel])]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-des-lignes-et-des-colonnes",
    "href": "01-aide_memoire_r_sas.html#sélectionner-des-lignes-et-des-colonnes",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "6.5 Sélectionner des lignes et des colonnes",
    "text": "6.5 Sélectionner des lignes et des colonnes\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n%let cols = identifiant note_contenu sexe;\ndata Femmes;\n  set donnees_sas (where = (Sexe = 2) keep = &cols.);\nrun;\n\n/* Autre solution */\ndata Femmes;\n  set donnees_sas;\n  if Sexe = 2;\n  keep &cols.;\nrun;\n\n/* Par nom ou par variable */\n%let var = identifiant Sexe note_contenu;\ndata Femmes;\n  /* Sélection de colonnes */\n  set donnees_sas (keep = &var.);\n  /* Sélection de lignes respectant une certaine condition */\n  if Sexe = \"2\";\n  /* Création de colonne */\n  note2 = note_contenu / 20 * 5;\n  /* Suppression de colonnes */\n  drop Sexe;\n  /* Selection de colonnes */\n  keep identifiant Sexe note_contenu;\nrun;\n\n\n\ncols &lt;- c(\"identifiant\", \"note_contenu\", \"sexe\", \"date_naissance\")\nfemmes &lt;- donnees_rbase[donnees_rbase$sexe %in% c(\"2\"), cols]\nfemmes &lt;- subset(donnees_rbase, sexe %in% c(\"2\"), cols)\n\n\n\n\ncols &lt;- c(\"identifiant\", \"note_contenu\", \"sexe\", \"date_naissance\")\nfemmes &lt;- donnees_tidyverse %&gt;% filter(sexe == \"2\") %&gt;% select(all_of(cols))\nfemmes &lt;- donnees_tidyverse %&gt;% filter(sexe == \"2\") %&gt;% select({{cols}})\n\n\n\n\ncols &lt;- c(\"identifiant\", \"note_contenu\", \"sexe\", \"date_naissance\")\nfemmes &lt;- donnees_datatable[sexe == \"2\", ..cols]\nfemmes &lt;- subset(donnees_datatable, sexe %in% c(\"2\"), cols)\n\n\n\n\ncols &lt;- c(\"identifiant\", \"note_contenu\", \"sexe\", \"date_naissance\")\nrequete_duckdb %&gt;% filter(sexe == \"2\") %&gt;% select(all_of(cols))\nrequete_duckdb %&gt;% filter(sexe == \"2\") %&gt;% select({{cols}})\n\n\n\n\ncols = [\"identifiant\", \"note_contenu\", \"sexe\", \"date_naissance\"]\nfemmes = donnees_python[donnees_python[\"sexe\"] == \"2\"][cols]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-des-lignes-selon-une-condition-externe",
    "href": "01-aide_memoire_r_sas.html#sélectionner-des-lignes-selon-une-condition-externe",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "6.6 Sélectionner des lignes selon une condition externe",
    "text": "6.6 Sélectionner des lignes selon une condition externe\nOn souhaite sélectionner des colonnes selon une condition, mais cette condition est située à l’extérieur des opérateurs de manipulation des données.\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n%let condition = sexe = 2;\ndata Femmes;\n  set donnees_sas (where = (&condition.));\nrun;\n\n\n\ncondition &lt;- substitute(sexe == \"2\")\nfemmes &lt;- subset(donnees_rbase, eval(condition))\n\n# Autre solution\ncondition &lt;- quote(sexe == \"2\")\nfemmes &lt;- subset(donnees_rbase, eval(condition))\n\n\n\n\ncondition &lt;- expr(sexe == \"2\")\nfemmes &lt;- donnees_tidyverse %&gt;% \n  filter(!!condition)\n\n\n\n\ncondition &lt;- quote(sexe == \"2\")\nfemmes &lt;- donnees_datatable[condition, , env = list(condition = condition)]\nfemmes &lt;- donnees_datatable[eval(condition)]\n\n\n\n\nfilter_condition &lt;- . %&gt;% filter(sexe == \"2\")\nrequete_duckdb %&gt;% filter_condition()\n\n\n\n\ncondition = lambda df: df['sexe'] == \"2\"\nfemmes = donnees_python[condition(donnees_python)]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#renommer-des-variables",
    "href": "01-aide_memoire_r_sas.html#renommer-des-variables",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "7.1 Renommer des variables",
    "text": "7.1 Renommer des variables\nOn renomme sexe en sexe2, puis on renomme à son tour sexe2 en sexe.\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata donnees_sas;\n  set donnees_sas (rename = (sexe = sexe2));\n  rename sexe2 = sexe;\nrun;\n\n\n\n# On renomme la variable sexe en sexe_red\nnames(donnees_rbase)[names(donnees_rbase) == \"sexe\"] &lt;- \"sexe_red\"\n\n# On la renomme en sexe\nnames(donnees_rbase)[names(donnees_rbase) == \"sexe_red\"] &lt;- \"sexe\"\n\n\n\n\n# On renomme la variable sexe en sexe_red\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  rename(sexe_red = sexe)\n\n# On la renomme en sexe\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  rename(sexe = sexe_red)\n\n\n\n\n# On renomme la variable sexe en sexe_red\nnames(donnees_datatable)[names(donnees_datatable) == \"sexe\"] &lt;- \"sexe_red\"\n\n# On la renomme en sexe\nnames(donnees_datatable)[names(donnees_datatable) == \"sexe_red\"] &lt;- \"sexe\"\n\n# Autre solution\n# En data.table, les instructions débutant par set modifient les éléments par référence, c'est-à-dire sans copie.\n# Ceci est plus efficace pour manipuler des données volumineuses.\nsetnames(donnees_datatable, \"sexe\", \"sexe_red\")\nsetnames(donnees_datatable, \"sexe_red\", \"sexe\")\n\n\n\nEn dplyr/arrow/duckdb, le renommage n’est pas persistant, i.e. la variable requete_duckdb n’est pas modifiée par la fonction rename.\n\n# On renomme la variable sexe en sexe_red\nrequete_duckdb %&gt;% rename(sexe_red = sexe)\n\n\n\n\n# Renommer la colonne sexe en sexe_red\ndonnees_python = donnees_python.rename(columns={'sexe': 'sexe_red'})\n\n# On la renomme en sexe\ndonnees_python = donnees_python.rename(columns={'sexe_red': 'sexe'})",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#créer-des-variables-avec-des-conditions",
    "href": "01-aide_memoire_r_sas.html#créer-des-variables-avec-des-conditions",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "7.2 Créer des variables avec des conditions",
    "text": "7.2 Créer des variables avec des conditions\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata Civilite;\n  set donnees_sas;\n  \n  /* 1ère solution (if) */\n  format Civilite $20.;\n  if      Sexe = 2 then Civilite = \"Mme\";\n  else if Sexe = 1 then Civilite = \"M\";\n  else                  Civilite = \"Inconnu\";\n  \n  /* 2e solution (do - end) */\n  if      Sexe = 2 then do;\n    Civilite2 = \"Mme\";\n  end;\n  else if Sexe = 1 then do;\n    Civilite2 = \"M\";\n  end;\n  else do;\n    Civilite2 = \"Inconnu\";\n  end;\n  \n  /* 3e solution (select) */\n  format Civilite3 $20.;\n  select;\n    when      (Sexe = 2) Civilite3 = \"Mme\";\n    when      (Sexe = 1) Civilite3 = \"M\";\n    otherwise            Civilite3 = \"Inconnu\";\n  end;\n  \n  keep Sexe Civilite Civilite2 Civilite3;run;\nrun;\n\n\n\ndonnees_rbase$civilite &lt;- ifelse(donnees_rbase$sexe == \"2\", \"Mme\",\n                                 ifelse(donnees_rbase$sexe == \"1\", \"M\",\n                                        \"Inconnu\"))\n\n# Autre solution (rapide)\ndonnees_rbase$civilite                            &lt;- \"Inconnu\"\ndonnees_rbase$civilite[donnees_rbase$sexe == \"1\"] &lt;- \"M\"\ndonnees_rbase$civilite[donnees_rbase$sexe == \"2\"] &lt;- \"Mme\"\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  mutate(civilite = case_when(sexe == \"2\" ~ \"Mme\",\n                              sexe == \"1\" ~ \"M\",\n                              TRUE        ~ \"Inconnu\")\n)\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n    mutate(civilite = if_else(sexe == \"2\", \"Mme\",\n                              if_else(sexe == \"1\", \"M\",\n                                      \"Inconnu\")))\n\n\n\n\ndonnees_datatable[, civilite := fcase(sexe == \"2\", \"Mme\",\n                                      sexe == \"1\", \"M\",\n                                      is.na(sexe), \"Inconnu\")]\n\n\n\nNote : l’opération n’est pas persistante, i.e. l’objet requete_duckdb n’est pas modifié\n\nrequete_duckdb %&gt;%\n  mutate(civilite = case_when(sexe == \"2\" ~ \"Mme\",\n                              sexe == \"1\" ~ \"M\",\n                              .default = \"Inconnu\"))\n\nrequete_duckdb %&gt;%\n  mutate(civilite = if_else(sexe == \"2\", \"Mme\",\n                            if_else(sexe == \"1\", \"M\",\n                                    \"Inconnu\")))\n\n\n\n\n# Avec un mapping : \nmapping = {'2': 'Mme', '1': 'M'}\ndonnees_python['civilite'] = donnees_python['sexe'].map(mapping).filna('Inconnu')\n\n# Avec une fonction apply/lambda et les condition IF/ELSE :\ndonnees_python['civilite'] = donnees_python['sexe'].apply(\n    lambda x: 'Mme' if x == '2' else ('M' if x == '1' else 'Inconnu')\n)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#formater-les-modalités-des-valeurs-discrètes-ou-caractères",
    "href": "01-aide_memoire_r_sas.html#formater-les-modalités-des-valeurs-discrètes-ou-caractères",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "7.3 Formater les modalités des valeurs discrètes ou caractères",
    "text": "7.3 Formater les modalités des valeurs discrètes ou caractères\n\n7.3.1 Création des formats\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Utilisation des formats */\nproc format;\n  /* Variable discrète */\n  value sexef\n  1 = \"Homme\"\n  2 = \"Femme\";\n\n  /* Variable caractère */\n  value $ cspf\n  '1' = \"Cadre\"\n  '2' = \"Profession intermédiaire\"\n  '3' = \"Employé\"\n  '4' = \"Ouvrier\"\n  '5' = \"Retraité\";\nrun;\n\n\n\nsexef &lt;- c(\"1\" = \"Homme\", \"2\" = \"Femme\")\ncspf  &lt;- c(\"1\" = \"Cadre\", \"2\" = \"Profession intermédiaire\", \"3\" = \"Employé\", \"4\" = \"Ouvrier\", \"5\" = \"Retraité\")\n\n\n\n\nsexef_format &lt;- c(\"1\" = \"Homme\", \"2\" = \"Femme\")\ncspf_format  &lt;- c(\"1\" = \"Cadre\", \"2\" = \"Profession intermédiaire\", \"3\" = \"Employé\", \"4\" = \"Ouvrier\", \"5\" = \"Retraité\")\n\n\n\n\nsexeform &lt;- c(\"1\" = \"Homme\", \"2\" = \"Femme\")\ncspform  &lt;- c(\"1\" = \"Cadre\", \"2\" = \"Profession intermédiaire\", \"3\" = \"Employé\", \"4\" = \"Ouvrier\", \"5\" = \"Retraité\")\n\n\n\nPréférer case_match quand il s’agit de valeurs déterminées.\n\nrequete_duckdb %&gt;% \n  mutate(sexef = case_when(\n    sexef==\"1\" ~ \"Homme\",\n    sexef==\"2\" ~ \"Femme\",\n    .default = sexef),\n    \n         cspf = case_match(csp,\n    \"1\" ~ \"Cadre\",\n    \"2\" ~ \"Profession intermédiaire\",\n    \"3\" ~ \"Employé\",\n    \"4\" ~ \"Ouvrier\",\n    \"5\" ~ \"Retraité\",\n    .default = csp)) %&gt;% \n  select(Sexe, sexef, csp, cspf)\n\n\n\n\n# On créée les formats sous type de dictionnaire\nsexef_format = {\n                \"1\": \"Homme\", \n                \"2\": \"Femme\"\n                }\ncspf_format = {\n    \"1\": \"Cadre\", \n    \"2\": \"Profession intermédiaire\", \n    \"3\": \"Employé\", \n    \"4\": \"Ouvrier\", \n    \"5\": \"Retraité\"\n}\n\n\n\n\n\n\n7.3.2 Utiliser les formats (valeurs discrètes ou caractères)\nNécessite le lancement des formats à l’étape précédente.\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata donnees_sas;\n  set donnees_sas;\n  /* Exprimer dans le format sexef (Hommes / Femmes) */\n  format Sexef $25.;\n  Sexef = put(Sexe, sexef.);\n  /* On exprime la CSP en texte dans une variable CSPF avec le format */\n  format CSPF $25.;\n  CSPF = put(CSP, $cspf.);\nrun;\n\n\n\n# On exprime CSP et sexe en variable formatée\ndonnees_rbase$cspf  &lt;- cspf[donnees_rbase$csp]\ndonnees_rbase$sexef &lt;- sexef[donnees_rbase$sexe]\n\n\n\n\n# On exprime CSP et sexe en variable formatée\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(sexef = sexef_format[sexe],\n         cspf = cspf_format[csp])\n\n# Autre solution\n# Les éventuelles valeurs manquantes sont conservées en NA\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(\n    sexef = case_when(\n      sexe == \"1\" ~ \"Homme\",\n      sexe == \"2\" ~ \"Femme\",\n      TRUE        ~ sexe),\n    \n    cspf = case_when(\n      csp == \"1\" ~ \"Cadre\",\n      csp == \"2\" ~ \"Profession intermédiaire\",\n      csp == \"3\" ~ \"Employé\",\n      csp == \"4\" ~ \"Ouvrier\",\n      csp == \"5\" ~ \"Retraité\",\n      TRUE       ~ csp)\n    )\n\n# Syntaxe pour attribuer une valeur aux NA\nvaleurAuxNA &lt;- donnees_tidyverse %&gt;% \n  mutate(sexef = case_when(\n    sexe == \"1\" ~ \"Homme\",\n    sexe == \"2\" ~ \"Femme\",\n    is.na(x)    ~ \"Inconnu\",\n    TRUE        ~ sexe))\n\n\n\n\n# On exprime CSP et sexe en variable formatée\ndonnees_datatable[, `:=` (cspf = cspform[csp], sexef = sexeform[sexe])]\n\n\n\n\n\n\n\ndonnees_python['sexef'] = donnees_python['sexe'].map(sexef_format)\n# On peut aussi utiliser replace : donnees_python['sexef'] = donnees_python['sexe'].replace(sexef_format)\ndonnees_python['cspf'] = donnees_python['csp'].map(cspf_format)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#formater-les-modalités-des-valeurs-continues",
    "href": "01-aide_memoire_r_sas.html#formater-les-modalités-des-valeurs-continues",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "7.4 Formater les modalités des valeurs continues",
    "text": "7.4 Formater les modalités des valeurs continues\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Âge formaté */\n/* Fonctionne aussi sur le principe du format */\nproc format;\n  /* Variable continue */\n  value agef\n  low-&lt;26 = \"1. De 15 à 25 ans\"\n  26&lt;-&lt;50 = \"2. De 26 à 49 ans\"\n  50-high = \"3. 50 ans ou plus\";\nrun;\n\ndata donnees_sas;\n  set donnees_sas;\n  /* Âge formaté */\n  Agef = put(Age, agef.);\nrun;\n\n\n\n# Âge formaté\n# L'option right = TRUE implique que les bornes sont ]0; 25] / ]25; 49] / ]49; Infini[\nagef &lt;- cut(donnees_rbase$age, \n            breaks         = c(0, 25, 49, Inf),\n            right          = TRUE,\n            labels         = c(\"1. De 15 à 25 ans\", \"2. De 26 à 49 ans\", \"3. 50 ans ou plus\"), \n            ordered_result = TRUE)\n\n# Autres solutions\ndonnees_rbase$agef[donnees_rbase$age &lt; 26]                           &lt;- \"1. De 15 à 25 ans\"\n# 26 &lt;= donnees_rbase$age &lt; 50 ne fonctionne pas, il faut passer en 2 étapes\ndonnees_rbase$agef[26 &lt;= donnees_rbase$age & donnees_rbase$age &lt; 50] &lt;- \"2. De 26 à 49 ans\"\ndonnees_rbase$agef[donnees_rbase$age &gt;= 50]                          &lt;- \"3. 50 ans ou plus\"\n\ndonnees_rbase$agef &lt;- ifelse(donnees_rbase$age &lt; 26, \"1. De 15 à 25 ans\",\n                             ifelse(26 &lt;= donnees_rbase$age & donnees_rbase$age &lt; 50, \"2. De 26 à 49 ans\",\n                                    ifelse(donnees_rbase$age &gt;= 50, \"3. 50 ans ou plus\",\n                                           NA_integer_)))\n\n\n\n\n# Âge formaté\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  mutate(agef = case_when(\n    age &lt; 26             ~ \"1. De 15 à 25 ans\",\n    age &gt;= 26 & age &lt; 50 ~ \"2. De 26 à 49 ans\",\n    age &gt;= 50            ~ \"3. 50 ans ou plus\")\n    )\n\n\n\n\n# Âge formaté\ndonnees_datatable[, agef := fcase(age &lt; 26,             \"1. De 15 à 25 ans\",\n                                  26 &lt;= age & age &lt; 50, \"2. De 26 à 49 ans\",\n                                  age &gt;= 50,            \"3. 50 ans ou plus\")]\n\n\n\nPréférer case_match quand il s’agit de valeurs déterminées.\n\n# Âge formaté\nrequete_duckdb %&gt;%\n  mutate(agef = case_when(\n    age &lt; 26             ~ \"1. De 15 à 25 ans\",\n    age &gt;= 26 | age &lt; 50 ~ \"2. De 26 à 49 ans\",\n    age &gt;= 50            ~ \"3. 50 ans ou plus\")) %&gt;% \n  select(age, agef)\n\n\n\n\n# Pour les bins : [0, 26, 51] correspond à [0, 26[, [26, 51[, etc\ndonnees_python['agef'] = pd.cut(donnees_python['age'], \n                                   bins=[0, 26, 51, float('inf')], \n                                   labels=[\"1. De 15 à 25 ans\", \"2. De 26 à 49 ans\", \"3. 50 ans ou plus\"], \n                                   right=False)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#changer-le-type-dune-variable",
    "href": "01-aide_memoire_r_sas.html#changer-le-type-dune-variable",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "7.5 Changer le type d’une variable",
    "text": "7.5 Changer le type d’une variable\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata donnees_sas;\n  set donnees_sas;\n  \n  /* Transformer la variable Sexe en caractère */\n  Sexe_car = put(Sexe, $1.);\n  \n  /* Transformer la variable Sexe_car en numérique */\n  Sexe_num = input(Sexe_car, 1.);\n  \n  /* Transformer une date d'un format caractère à un format Date */\n  format date $10.;\n  date = \"01/01/2000\";\n  format date_sas yymmdd10.;\n  date_sas = input(date, ddmmyy10.);\nrun;\n\n\n\n# Transformer la variable sexe en numérique\ndonnees_rbase$sexe_numerique &lt;- as.numeric(donnees_rbase$sexe)\n\n# Transformer la variable sexe_numerique en caractère\ndonnees_rbase$sexe_caractere &lt;- as.character(donnees_rbase$sexe_numerique)\n\n# Transformer une date d'un format caractère à un format Date\ndonnees_rbase$date_r &lt;- lubridate::dmy(\"01/01/2000\")\n\n\n\n\n# Transformer la variable sexe en numérique\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%  \n  mutate(sexe_numerique = as.numeric(sexe))\n\n# Transformer la variable sexe_numerique en caractère\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  mutate(sexe_caractere = as.character(sexe_numerique))\n\n# Transformer une date d'un format caractère à un format Date\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%  \n  mutate(date_r = lubridate::dmy(\"01/01/2000\"))\n\n\n\n\n# Transformer la variable sexe en numérique\ndonnees_datatable[, sexe_numerique := as.numeric(sexe)]\n\n# Transformer la variable sexe_numerique en caractère\ndonnees_datatable[, sexe_caractere := as.character(sexe_numerique)]\n\n# Transformer une date d'un format caractère à un format Date\ndonnees_datatable[, date_r := lubridate::dmy(\"01/01/2000\")]\n\n\n\n\nrequete_duckdb %&gt;%  \n  mutate(sexe_numerique = as.numeric(sexe)) %&gt;% # Transformer la variable sexe en numérique\n  mutate(sexe_caractere = as.character(sexe_numerique)) %&gt;% # Transformer la variable sexe_numerique en caractère\n  select(starts_with(\"sexe\")) %&gt;% print(n=5)\n\nEn DuckDB, plusieurs syntaxes sont possibles pour transformer une chaîne de caractères en date si la chaîne de caractères est au format YYYY-MM-DD. Dans le cas contraire, passer par la fonction strptime de DuckDB pour indiquer le format de la date.\n\n# Transformer une date d'un format caractère à un format Date\nrequete_duckdb %&gt;%  \n  mutate(date_0 = as.Date(\"2000-01-01\")) %&gt;% \n  mutate(date_1 = as.Date(strptime(\"01/01/2000\",\"%d/%m/%Y\"))) %&gt;% \n  # mutate(date_r = lubridate::dmy(\"01/01/2000\")) %&gt;% # no known SQL translation\n  select(starts_with(\"date\"))\n\nNote : duckdb fait des conversions de type implicitement, mais seulement les conversions incontestables. Il faudra souvent préciser le type des variables.\n\n\n\n# Transformer la variable sexe en numérique\ndonnees_python['sexe_numerique'] = pd.to_numeric(donnees_python['sexe'])\n\n# Transformer la variable sexe_numerique en caractère\ndonnees_python['sexe_caractere'] = donnees_python['sexe_numerique'].astype(str)\n\n# Transformer une date d'un format caractère à un format Date\ndonnees_python['date_r'] = pd.to_datetime('01/01/2000', format='%d/%m/%Y')",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#changer-le-type-de-plusieurs-variables-à-faire",
    "href": "01-aide_memoire_r_sas.html#changer-le-type-de-plusieurs-variables-à-faire",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "7.6 Changer le type de plusieurs variables À FAIRE",
    "text": "7.6 Changer le type de plusieurs variables À FAIRE\n\narrow/duckdb\n\n\n\nenNumerique &lt;- c(\"duree\", \"note_contenu\", \"note_formateur\")\nenDate &lt;- c('date_naissance', 'date_entree')\n\nrequete_duckdb %&gt;%  \n  mutate_at(enNumerique, as.integer) %&gt;% \n  mutate_at(enDate, as.character) %&gt;% \n  mutate_at(enDate, ~ as.Date(strptime(.,'%Y-%m-%d'))) %&gt;% # strptime est une fonction duckdb\n  select(enNumerique, enDate) %&gt;% print(n=5)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#créer-et-supprimer-des-variables",
    "href": "01-aide_memoire_r_sas.html#créer-et-supprimer-des-variables",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "7.7 Créer et supprimer des variables",
    "text": "7.7 Créer et supprimer des variables\n\n7.7.1 1er exemple\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Manipulation de colonnes par référence */\ndata Creation;\n  set donnees_sas;\n  note_contenu2 = note_contenu / 20 * 5;\n  note_formateur2 = note_formateur / 20 * 5;\n  /* Suppression des variables créées */\n  drop note_contenu2 note_formateur2;\nrun;\n\n\n\ndonnees_rbase$note2 &lt;- donnees_rbase$note_contenu / 20 * 5\n# Le with permet de s'affranchir des expressions \"donnees_rbase$\"\nwith(donnees_rbase, note2 &lt;- note_contenu / 20 * 5)\n\n# On ne peut pas utiliser transform pour des variables récemment créées\n#donnees_rbase &lt;- transform(donnees_rbase, note3 = note_contenu ** 2, note3 = log(note3))\ndonnees_rbase &lt;- transform(donnees_rbase, note2 = note_contenu / 20 * 5)\n\n# Suppression de variables\ndonnees_rbase$note2 &lt;- NULL\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(note2 = note_contenu / 20 * 5)\n\n# Suppression de variables\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  select(-note2)\n\n\n\n\n# Création de variables\ndonnees_datatable[, note2 := note_contenu / 20 * 5]\n\n# Suppression de variables\ndonnees_datatable[, note2 := NULL]\n\n\n\nNote : l’opération n’est pas persistante, i.e. l’objet requete_duckdb n’est pas modifié\n\n# Création de la colonne note2\nrequete_duckdb %&gt;% \n  mutate(note2 = as.integer(note_contenu) / 20 * 5) %&gt;% \n  select(note2)\n\n# Suppression de colonnes\nrequete_duckdb %&gt;% select(-contains(\"date\"), -starts_with(\"note\"))\n\n\n\n\n# Création de la colonne note2\ndonnees_python['note2'] = donnees_python['note_contenu'] / 20 * 5\n\n# Suppression de variables :\ndonnees_python.drop(['note2'], axis = 1, inplace = True)\n\n\n\n\n\n\n7.7.2 2e exemple\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Création et suppressions de plusieurs variables */\ndata donnees_sas;\n  set donnees_sas;\n  note_contenu2 = note_contenu / 20 * 5;\n  note_formateur2 = note_formateur / 20 * 5;  \n                           \n  /* Suppression des variables créées */\n  drop note_contenu2 note_formateur2;\nrun;\n\n\n\n# Création et suppressions de plusieurs variables\ndonnees_rbase &lt;- transform(donnees_rbase, \n                           note_contenu2   = note_contenu / 20 * 5,\n                           note_formateur2 = note_formateur / 20 * 5)\n\n# Suppression des variables créées\nvariable &lt;- c(\"note_contenu2\", \"note_formateur2\")\ndonnees_rbase[, variable] &lt;- NULL\n\n\n\n\n# Création et suppressions de plusieurs variables\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(note_contenu2 = note_contenu / 20 * 5,\n         note_formateur2 = note_formateur / 20 * 5)\n\n# Suppression des variables créées\nvariable &lt;- c(\"note_contenu2\", \"note_formateur2\")\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  select(-all_of(variable))\n\n\n\n\n# Création et suppressions de plusieurs variables\ndonnees_datatable[, c(\"note_contenu2\", \"note_formateur2\") := list(note_contenu / 20 * 5, note_formateur / 20 * 5)]\ndonnees_datatable[, `:=` (note_contenu2 = note_contenu / 20 * 5, note_formateur2 = note_formateur / 20 * 5)]\n\n# Suppression des variables créées\ndonnees_datatable[, c(\"note_contenu2\", \"note_formateur2\") := NULL]\n\n# Ou par référence extérieure\nvariable &lt;- c(\"note_contenu2\", \"note_formateur2\")\ndonnees_datatable[, `:=` (note_contenu2 = note_contenu / 20 * 5, note_formateur2 = note_formateur / 20 * 5)]\ndonnees_datatable[, (variable) := NULL]\n\n\n\n\n# À FAIRE : à compléter !\n# Création de la colonne note2\nrequete_duckdb %&gt;% \n  mutate(note2 = as.integer(Note_Contenu) / 20 * 5) %&gt;% \n  select(note2)\n\n# Suppression de colonnes\n#requete_duckdb %&gt;% select(- CSP, -contains(\"Date\"), -starts_with(\"Note\"))\n\n\n\n\n# Création des colonnes note_contenu2 et note_formateur2\ndonnees_python = donnees_python.assign(\n                                    note_contenu2 = donnees_python['note_contenu'] / 20 * 5,\n                                    note_formateur2 = donnees_python['note_formateur'] / 20 * 5\n                                    )\n\n# Suppression des variables nouvellement crées\ndonnees_python.drop(columns=['note_contenu2', 'note_formateur2'], axis = 1, inplace = True)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#on-souhaite-réexprimer-toutes-les-notes-sur-100-et-non-sur-20",
    "href": "01-aide_memoire_r_sas.html#on-souhaite-réexprimer-toutes-les-notes-sur-100-et-non-sur-20",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "7.8 On souhaite réexprimer toutes les notes sur 100 et non sur 20",
    "text": "7.8 On souhaite réexprimer toutes les notes sur 100 et non sur 20\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n%let notes = Note_Contenu   Note_Formateur Note_Moyens     Note_Accompagnement     Note_Materiel;\n/* On supprime d'abord les doubles blancs entre les variables */\n%let notes = %sysfunc(compbl(&notes.));\n/* On affiche les notes dans la log de SAS */\n%put &notes;\n\n/* 1ère solution : avec les array */\n/* Les variables sont modifiées dans cet exemple */\ndata Sur100_1;\n  set donnees_sas;\n  array variables (*) &notes.;\n  do increment = 1 to dim(variables);\n    variables[increment] = variables[increment] / 20 * 100;\n  end; \n  drop increment;\nrun;\n\n/* 2e solution : avec une macro */\n/* De nouvelles variables sont ajoutées dans cet exemple */\ndata Sur100_2;\n  set donnees_sas;\n  \n  %macro Sur100;\n    %do i = 1 %to %sysfunc(countw(&notes.));\n      %let note = %scan(&notes., &i.);\n      &note._100 = &note. / 20 * 100;\n    %end;\n  %mend Sur100;\n  \n  %Sur100;\nrun;\n\n\n\nnotes &lt;- names(donnees_rbase)[grepl(\"^note\", names(donnees_rbase))]\n\n# Les variables sont modifiées dans cet exemple\nsur100 &lt;- donnees_rbase[, notes] / 20 * 100\n\n# On  souhaite conserver les notes sur 100 dans d'autres variables, suffixées par _100\ndonnees_rbase[, paste0(notes, \"_100\")] &lt;- donnees_rbase[, notes] / 20 * 100\n\n\n\n\n# Les variables sont modifiées dans cet exemple\nsur100 &lt;- donnees_tidyverse %&gt;% \n  mutate(across(starts_with(\"note\"), ~ .x / 20 * 100))\n\n# On  souhaite conserver les notes sur 100 dans d'autres variables, suffixées par _100\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(across(starts_with(\"note\"), ~ .x / 20 * 100, .names = \"{.col}_100\"))\n\n\n\n\nnotes &lt;- names(donnees_datatable)[grepl(\"^note\", names(donnees_datatable))]\n\n# Les variables sont modifiées dans cet exemple\nsur100 &lt;- copy(donnees_datatable)\nsur100 &lt;- sur100[, (notes) := lapply(.SD, function(x) x / 20 * 100), .SDcols = notes]\nsur100 &lt;- sur100[, (notes) := lapply(.SD, function(x) x / 20 * 100), .SD = notes]\n\n# Ou encore, plus simple\n# Dans cet exemple, les notes dans la base donnees_datatable ne sont pas changées\nsur100 &lt;- sur100[, lapply(.SD, function(x) x / 20 * 100), .SDcols = patterns(\"^note\")]\n\n# On  souhaite conserver les notes sur 20 dans d'autres variables, suffixées par _20\ndonnees_datatable[, (paste0(notes, \"_100\")) := lapply(.SD, function(x) x / 20 * 100), .SDcols = notes]\n\n# Autre possibilité en utilisant l'instruction set, très rapide\nfor (j in notes) {\n  set(x = donnees_datatable, j = paste0(j, \"_100\"), value = donnees_datatable[[j]] / 20 * 100)\n}\n\n\n\n\nrequete_duckdb %&gt;% \n  mutate(across(starts_with(\"note\"), ~ as.numeric(.x)/20*100)) %&gt;% \n  select(starts_with(\"note\"))\n\n\n\n\n# Sélectionner les colonnes dont les noms commencent par \"note\"\nnotes = [col for col in donnees_python.columns if col.startswith('note')]\n\n# Transformer les colonnes sélectionnées\nsur100 = donnees_python[notes] / 20 * 100\n\n# Ajouter les nouvelles colonnes avec un suffixe \"_100\"\nfor col in notes:\n    donnees_python[f\"{col}_100\"] = sur100[col]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#mettre-un-0-devant-un-nombre",
    "href": "01-aide_memoire_r_sas.html#mettre-un-0-devant-un-nombre",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "7.9 Mettre un 0 devant un nombre",
    "text": "7.9 Mettre un 0 devant un nombre\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata Zero_devant;\n  set donnees_sas (keep = date_entree);\n  /* Obtenir le mois et la date */\n  Mois = month(date_entree);\n  Annee = year(date_entree);\n  /* Mettre le mois sur 2 positions (avec un 0 devant si le mois &lt;= 9) : format prédéfini z2. */\n  Mois_a = put(Mois, z2.);\n  drop Mois;\n  rename Mois_a = Mois;\nrun;\n\n\n\ndonnees_rbase$mois &lt;- sprintf(\"%02d\", lubridate::month(donnees_rbase$date_entree))\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(mois = sprintf(\"%02d\", lubridate::month(date_entree)))\n\n# Autre solution\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(mois = lubridate::month(date_entree),\n         mois = ifelse(str_length(mois) &lt; 2, paste0(\"0\", mois), mois))\n\n\n\n\n# Une fonction month() est déjà implémentée en data.table, l'usage de lubridate est inutile\ndonnees_datatable[, mois := sprintf(\"%02d\", data.table::month(date_entree))]\n\n\n\n\nrequete_duckdb %&gt;% \n  mutate(mois = stringr::str_pad(as.character(month(date_entree)), width = 2L, pad = \"0\")) %&gt;% \n  select(mois, date_entree)\n\n\n\n\n# Extraire le mois et l'année\ndonnees_python['mois'] = donnees_python['date_entree'].dt.month\ndonnees_python['annee'] = donnees_python['date_entree'].dt.year\n\n# Mettre le numéro du mois sur 2 positions (avec un 0 devant si le mois &lt;= 9)\ndonnees_python['mois'] = donnees_python['mois'].fillna(0).astype(int).apply(lambda x: f\"{x:02d}\")",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#arrondir-une-valeur-numérique",
    "href": "01-aide_memoire_r_sas.html#arrondir-une-valeur-numérique",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "7.10 Arrondir une valeur numérique",
    "text": "7.10 Arrondir une valeur numérique\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata Arrondis;\n  set donnees_sas (keep = poids_sondage);\n  /* Arrondi à l'entier le plus proche */\n  poids_arrondi_0 = round(poids_sondage);\n  /* Arrondi à 1 chiffre après la virgule */\n  poids_arrondi_1 = round(poids_sondage, 0.1);\n  /* Arrondi à 2 chiffre après la virgule */\n  poids_arrondi_2 = round(poids_sondage, 0.01);\n  /* Arrondi à l'entier inférieur */\n  poids_inf = floor(poids_sondage);\n  /* Arrondi à l'entier supérieur */\n  poids_sup = ceil(poids_sondage);  \nrun;\n\n\n\n# Arrondi à l'entier le plus proche\npoids_arrondi_0 &lt;- round(donnees_rbase$poids_sondage, 0)\n# Arrondi à 1 chiffre après la virgule\npoids_arrondi_1 &lt;- round(donnees_rbase$poids_sondage, 1)\n# Arrondi à 2 chiffre après la virgule\npoids_arrondi_2 &lt;- round(donnees_rbase$poids_sondage, 2)\n# Arrondi à l'entier inférieur\npoids_inf &lt;- floor(donnees_rbase$poids_sondage)\n# Arrondi à l'entier supérieur\npoids_sup &lt;- ceiling(donnees_rbase$poids_sondage)\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  # Arrondi à l'entier le plus proche\n  mutate(poids_arrondi_0 = round(poids_sondage, 0)) %&gt;% \n  # Arrondi à 1 chiffre après la virgule\n  mutate(poids_arrondi_1 = round(poids_sondage, 1)) %&gt;% \n  # Arrondi à 2 chiffre après la virgule\n  mutate(poids_arrondi_2 = round(poids_sondage, 2)) %&gt;% \n  # Arrondi à l'entier inférieur\n  mutate(poids_inf = floor(poids_sondage)) %&gt;% \n  # Arrondi à l'entier supérieur\n  mutate(poids_sup = ceiling(poids_sondage))\ndonnees_tidyverse %&gt;% select(starts_with(\"poids\"))\n\n\n\n\n# Arrondi à l'entier le plus proche\ndonnees_datatable[, poids_arrondi_0 := round(poids_sondage, 0)]\n# Arrondi à 1 chiffre après la virgule\ndonnees_datatable[, poids_arrondi_1 := round(poids_sondage, 1)]\n# Arrondi à 2 chiffre après la virgule\ndonnees_datatable[, poids_arrondi_2 := round(poids_sondage, 2)]\n# Arrondi à l'entier inférieur\ndonnees_datatable[, poids_inf := floor(poids_sondage)]\n# Arrondi à l'entier supérieur\ndonnees_datatable[, poids_sup := ceiling(poids_sondage)]\n\n\n\n\nrequete_duckdb %&gt;% \n  mutate( # la fonction round de duckdb ne prend pas l'argument digits, mais la traduction fonctionne\n    poids_arrondi_0 = round(as.numeric(poids_sondage),  0),\n    poids_arrondi_1 = round(as.numeric(poids_sondage),  1),\n    poids_arrondi_2 = round(as.numeric(poids_sondage), -1),\n    poids_floor     = floor(as.numeric(poids_sondage)    ),\n    poids_ceiling   = ceiling(as.numeric(poids_sondage)  )\n    ) %&gt;% \n  select(starts_with(\"poids\"))\n\n\n\n\n# Arrondi à l'entier le plus proche\ndonnees_python['poids_arrondi_0'] = donnees_python['poids_sondage'].round(0)\n\n# Arrondi à 1 chiffre après la virgule\ndonnees_python['poids_arrondi_1'] = donnees_python['poids_sondage'].round(1)\n\n# Arrondi à 2 chiffres après la virgule\ndonnees_python['poids_arrondi_2'] = donnees_python['poids_sondage'].round(2)\n\n# Arrondi à l'entier inférieur\ndonnees_python['poids_inf'] = np.floor(donnees_python['poids_sondage'])\n\n# Arrondi à l'entier supérieur\ndonnees_python['poids_sup'] = np.ceil(donnees_python['poids_sondage'])",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#corriger-une-valeur-de-la-base",
    "href": "01-aide_memoire_r_sas.html#corriger-une-valeur-de-la-base",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "7.11 Corriger une valeur de la base",
    "text": "7.11 Corriger une valeur de la base\nOn souhaite corriger une valeur dans la base. La note_contenu de l’identifiant 168 est en fait 8 et non 18.\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata donnees_sas_corr;\n  set donnees_sas;\n  if identifiant = \"168\" then note_contenu = 8;\nrun;\n\n\n\ndonnees_rbase_cor &lt;- donnees_rbase\ndonnees_rbase_cor[donnees_rbase_cor$identifiant == \"168\", \"note_contenu\"] &lt;- 8\n\n\n\nhttps://dplyr.tidyverse.org/reference/rows.html Note : rows_update ne modifie pas l’objet.\n\ndonnees_tidyverse_cor %&gt;% \n  rows_update(tibble(identifiant = \"168\", note_contenu = 8), by = \"identifiant\") # guillemets nécessaires\n\n# Autre solution, qui n'est pas du pur Tidyverse\ndonnees_tidyverse_cor &lt;- donnees_tidyverse\ndonnees_tidyverse_cor[donnees_tidyverse_cor$identifiant == \"168\", \"note_contenu\"] &lt;- 8\n\n\n\n\ndonnees_datatable_cor &lt;- copy(donnees_datatable)\ndonnees_datatable_cor[identifiant == \"168\", note_contenu := 8]\n\n\n\nhttps://dplyr.tidyverse.org/reference/rows.html\nC’est compliqué de modifier efficacement une valeur en duckDB.\n\n# Exemple avec rows_update\ncon %&gt;% duckdb::duckdb_register(name = \"temp\", df = tibble(identifiant = \"168\", note_contenu = 8), overwrite = TRUE)\nrequete_duckdb %&gt;% \n  rows_update(con %&gt;% tbl(\"temp\"), by = \"identifiant\", unmatched = \"ignore\") %&gt;% # guillemets nécessaires\n  filter(identifiant == \"168\")\n\n# Il vaut mieux écrire du SQL ou bien faire plusieurs modifications avec case_when\nrequete_duckdb %&gt;% \n  mutate(note_contenu = case_when(\n    identifiant == \"168\" ~ 8,\n    .default = note_contenu)) %&gt;% \n  filter(identifiant == \"168\")\n\nNote : l’opération n’est pas persistante, i.e. l’objet requete_duckdb n’est pas modifié\n\n\n\ndonnees_python_cor = donnees_python.copy()\ndonnees_python_cor.loc[donnees_python_cor['identifiant'] == '168', 'note_contenu'] = 8",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#créer-une-date-à-partir-dune-chaîne-de-caractères",
    "href": "01-aide_memoire_r_sas.html#créer-une-date-à-partir-dune-chaîne-de-caractères",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "8.1 Créer une date à partir d’une chaîne de caractères",
    "text": "8.1 Créer une date à partir d’une chaîne de caractères\nCréer le 31 décembre de l’année sous forme de date.\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Pour créer une date avec l'année courante */\n%let an = %sysfunc(year(%sysfunc(today())));\ndata donnees_sas;\n  set donnees_sas;\n  /* Deux manières de créer une date */\n  format Decembre_31_&an._a Decembre_31_&an._b ddmmyy10.;\n  Decembre_31_&an._a = \"31dec&an.\"d;\n  /* mdy pour month, day, year (pas d'autre alternative, ymd par exemple n'existe pas) */\n  Decembre_31_&an._b = mdy(12, 31, &an.);\nrun;\n\n\n\n# Pour créer une date avec l'année courante\nannee &lt;- format(Sys.Date(), \"%Y\")\nas.Date(paste0(annee, \"-12-31\"), origin = \"1970-01-01\")\nlubridate::ymd(paste0(annee, \"-12-31\"))\nlubridate::dmy(paste0(\"31/12/\", annee))\nlubridate::mdy(paste0(\"12.31.\", annee))\n\n\n\n\n# Pour créer une date avec l'année courante\nannee &lt;- format(Sys.Date(), \"%Y\")\nas.Date(paste0(annee, \"-12-31\"))\nlubridate::ymd(paste0(annee, \"-12-31\"))\nlubridate::dmy(paste0(\"31/12/\", annee))\nlubridate::mdy(paste0(\"12.31.\", annee))\n\n\n\n\n# Pour créer une date avec l'année courante\nannee &lt;- format(Sys.Date(), \"%Y\")\nas.Date(paste0(annee, \"-12-31\"))\nlubridate::ymd(paste0(annee, \"-12-31\"))\nlubridate::dmy(paste0(\"31/12/\", annee))\nlubridate::mdy(paste0(\"12.31.\", annee))\n\n\n\n\n# Pour créer une date avec l'année courante\nrequete_duckdb %&gt;% \n  mutate(exemple1 = as.Date(\"2024/07/14\"),\n         exemple2 = as.Date(strptime(\"01/01/2000\", \"%d/%m/%Y\"))) %&gt;% \n  # mutate(date_r = lubridate::dmy(\"01/01/2000\")) %&gt;% # no known SQL translation\n  select(contains(\"exemple\"))\n\n\n\n\n# Pour créer une date avec l'année courante\nannee = datetime.now().year\n\n# Méthode 1 : Utiliser pandas pour créer une date\npd.to_datetime(f\"{annee}-12-31\")\npd.to_datetime(f\"31/12/{annee}\", dayfirst=True, format=\"%d/%m/%Y\")\npd.to_datetime(f\"12.31.{annee}\", format=\"%m.%d.%Y\")\n\n# Méthode 2 : Utiliser datetime pour créer une date\ndatetime.strptime(f\"{annee}-12-31\", \"%Y-%m-%d\")",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#calculer-sur-des-dates",
    "href": "01-aide_memoire_r_sas.html#calculer-sur-des-dates",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "8.2 Calculer sur des dates",
    "text": "8.2 Calculer sur des dates\nAttention, calculer sur des dates est un peu compliqué à cause de cas particuliers. Par exemple, le 29 février, les années bisextiles, le calcul des mois, des semaines, les fuseaux horaires, etc. Calculer en nombre de jours ou secondes ne pose pas de problème en général.\n\n8.2.1 Écart entre deux dates\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata donnees_sas;\n  set donnees_sas;\n  /* Durée (en année) entre 2 dates */\n  /* Âge à l'entrée dans le dispositif */\n  Age = intck('year', date_naissance, date_entree);\n  /* En mois */\n  Age_mois = intck('month', date_naissance, date_entree);\n  /* En jours */\n  Age_jours   = intck('days', date_naissance, date_entree);\n  Age_jours_2 = date_entree - date_naissance;\nrun;\n\n\n\n# Durée (en année) entre 2 dates\n# Âge à l'entrée dans le dispositif\ndonnees_rbase$age &lt;- floor(lubridate::time_length(difftime(donnees_rbase$date_entree, donnees_rbase$date_naissance), \"years\"))\n\n# En mois\ndonnees_rbase$age_mois &lt;- floor(lubridate::time_length(difftime(donnees_rbase$date_entree, donnees_rbase$date_naissance), \"months\"))\n\n# En jours\ndonnees_rbase$age_jours   &lt;- floor(lubridate::time_length(difftime(donnees_rbase$date_entree, donnees_rbase$date_naissance), \"days\"))\ndonnees_rbase$age_jours_2 &lt;- donnees_rbase$date_entree - donnees_rbase$date_naissance\n\n\n\n\n# Durée (en année) entre 2 dates\n# Âge à l'entrée dans le dispositif\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(age = as.period(interval(start = date_naissance, end = date_entree))$year)\n\n# En mois : À FAIRE\n\n# En jours : À FAIRE\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(age_jours_2 = date_entree - date_naissance)\n\n\n\n\n# Durée (en année) entre 2 dates\n# Âge à l'entrée dans le dispositif\ndonnees_datatable[, age := floor(lubridate::time_length(difftime(date_entree, date_naissance), \"years\"))]\n\n# En mois\ndonnees_datatable[, age_mois := floor(lubridate::time_length(difftime(date_entree, date_naissance), \"months\"))]\n\n# En jours\ndonnees_datatable[, age_jours := floor(lubridate::time_length(difftime(date_entree, date_naissance), \"days\"))]\ndonnees_datatable[, age_jours_2 := date_entree - date_naissance]\n\n\n\n\n# Durée entre deux dates\nrequete_duckdb %&gt;% \n  mutate(duree_annees = year(age(date_entree,date_naissance)),\n         duree_mois = month(age(date_entree,date_naissance)),\n         ) %&gt;% \n  select(contains(\"duree_\"))\n\n\n\n\ndonnees_python['age_jours'] = (donnees_python['date_entree'] - donnees_python['date_naissance']).dt.days\n# Remplacer les valeurs NaN par 0\ndonnees_python['age_jours'] = np.floor(donnees_python['age_jours'].fillna(0)).astype(int)\n\n\n\n\n\n\n8.2.2 Ajouter une durée à une date\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* On utilise ici %sysevalf et non %eval pour des calculs avec des macro-variables non entières */\n%let sixmois = %sysevalf(365.25/2);\n%put sixmois : &sixmois.;\ndata donnees_sas;\n  set donnees_sas;\n  /* Date de sortie du dispositif : ajout de la durée à la date d'entrée */\n  format date_sortie ddmmyy10.;\n  date_sortie = intnx('day', date_entree, duree);\n  \n  /* Date 6 mois après la sortie */\n  format Date_6mois ddmmyy10.;\n  Date_6mois   = intnx('month', date_sortie, 6);\n  \n  /* Ajout de jours, cette fois */\n  format Date_6mois_2 ddmmyy10.;\n  Date_6mois_2 = intnx('days', date_sortie, &sixmois.);\nrun;\n\n\n\n# Date de sortie du dispositif\ndonnees_rbase$date_sortie &lt;- donnees_rbase$date_entree + lubridate::days(donnees_rbase$duree)\n\n# Date 6 mois après la sortie\ndonnees_rbase$date_6mois   &lt;- donnees_rbase$date_sortie %m+% months(6)\ndonnees_rbase$date_6mois   &lt;- lubridate::add_with_rollback(donnees_rbase$date_sortie, months(6))\ndonnees_rbase$date_6mois_2 &lt;- donnees_rbase$date_sortie + lubridate::days(round(365.25/2))\n\n\n\n\n# Date de sortie du dispositif\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(date_sortie = date_entree + lubridate::days(duree))\n\n# Date 6 mois après la sortie\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(date_6mois = date_sortie %m+% months(6))\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(date_6mois = lubridate::add_with_rollback(date_sortie, months(6)))\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(date_6mois_2 = date_sortie + lubridate::days(round(365.25/2)))\n\n\n\n\n# Date de sortie du dispositif\ndonnees_datatable[, date_sortie := date_entree + lubridate::days(duree)]\n\n# Date 6 mois après la sortie\ndonnees_datatable[, date_6mois   := date_sortie %m+% months(6)]\ndonnees_datatable[, date_6mois   := lubridate::add_with_rollback(date_sortie, months(6))]\ndonnees_datatable[, date_6mois_2 := date_sortie + lubridate::days(round(365.25/2))]\n\n\n\n\nrequete_duckdb %&gt;% \n  mutate(date_sortie = date_entree + duree,\n         date_6mois = date_sortie + to_months(6L)) %&gt;% # préciser le type de 6\n  select(date_sortie, date_6mois)\n\n\n\n\nfrom datetime import timedelta\nfrom dateutil.relativedelta import relativedelta\n\n# Date de sortie du dispositif\ndonnees_python['date_sortie'] = donnees_python['date_entree'] + pd.to_timedelta(donnees_python['duree'], unit='D')\n\n# Ajouter une colonne date_6mois qui est la date six mois après date_sortie\ndonnees_python['date_6mois'] = donnees_python['date_sortie'] + pd.DateOffset(months=6)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#formater-les-dates",
    "href": "01-aide_memoire_r_sas.html#formater-les-dates",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "8.3 Formater les dates",
    "text": "8.3 Formater les dates\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* On utilise ici %sysevalf et non %eval pour des calculs avec des macro-variables non entières */\n%let sixmois = %sysevalf(365.25/2);\n%put sixmois : &sixmois.;\ndata donnees_sas;\n  set donnees_sas;\n  \n  /* Âge à l'entrée dans le dispositif */\n  Age = intck('year', date_naissance, date_entree);\n  \n  /* Âge formaté */\n  Agef = put(Age, agef.);\n  \n  /* Date de sortie du dispositif : ajout de la durée à la date d'entrée */\n  format date_sortie ddmmyy10.;\n  date_sortie = intnx('day', date_entree, duree);\n  /* La durée du contrat est-elle inférieure à 6 mois ? */\n  Duree_Inf_6_mois = (Duree &lt; &sixmois. & Duree ne .);\n  \n  /* Deux manières de créer une date */\n  format Decembre_31_&an._a Decembre_31_&an._b ddmmyy10.;\n  Decembre_31_&an._a = \"31dec&an.\"d;\n  \n  /* mdy pour month, day, year (pas d'autre alternative, ymd par exemple n'existe pas) */\n  Decembre_31_&an._b = mdy(12, 31, &an.); \n  \n  /* Date 6 mois après la sortie */\n  format Date_6mois ddmmyy10.;\n  Date_6mois = intnx('month', date_sortie, 6);\nrun;\n/* Ventilation pondérée (cf. infra) */\nproc freq data = donnees_sas;tables apres_31_decembre;weight poids_sondage;run;\n\n\n\n# Âge à l'entrée dans le dispositif\ndonnees_rbase$age &lt;- floor(lubridate::time_length(difftime(donnees_rbase$date_entree, donnees_rbase$date_naissance), \"years\"))\n\n# Âge formaté\ndonnees_rbase$agef[donnees_rbase$age &lt; 26]                           &lt;- \"1. De 15 à 25 ans\"\n# 26 &lt;= donnees_rbase$age &lt; 50 ne fonctionne pas, il faut passer en 2 étapes\ndonnees_rbase$agef[26 &lt;= donnees_rbase$age & donnees_rbase$age &lt; 50] &lt;- \"2. De 26 à 49 ans\"\ndonnees_rbase$agef[donnees_rbase$age &gt;= 50]                          &lt;- \"3. 50 ans ou plus\"\n\n# Autre solution\n# L'option right = TRUE implique que les bornes sont ]0; 25] / ]25; 49] / ]49; Infini[\nagef &lt;- cut(donnees_rbase$age, \n            breaks = c(0, 25, 49, Inf),\n            right = TRUE,\n            labels = c(\"1. De 15 à 25 ans\", \"2. De 26 à 49 ans\", \"3. 50 ans ou plus\"), \n            ordered_result = TRUE)\n\n# Manipuler les dates\nsixmois &lt;- 365.25/2\n\n# La durée du contrat est-elle inférieure à 6 mois ?\ndonnees_rbase$duree_inf_6_mois &lt;- ifelse(donnees_rbase$duree &lt; sixmois, 1, 0)\n\n# Date de sortie du dispositif\ndonnees_rbase$date_sortie &lt;- donnees_rbase$date_entree + lubridate::days(donnees_rbase$duree)\n\n# Date 6 mois après la sortie\ndonnees_rbase$date_6mois &lt;- donnees_rbase$date_sortie + lubridate::month(6)\n\n\n\n\n# Âge à l'entrée dans le dispositif\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(age = as.period(interval(start = date_naissance, end = date_entree))$year)\n\n# Âge formaté\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  mutate(agef = case_when(\n    age &lt; 26             ~ \"1. De 15 à 25 ans\",\n    age &gt;= 26 & age &lt; 50 ~ \"2. De 26 à 49 ans\",\n    age &gt;= 50            ~ \"3. 50 ans ou plus\")\n    )\n\n# Manipuler les dates\nsixmois &lt;- 365.25/2\n# La durée du contrat est-elle inférieure à 6 mois ?\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(duree_inf_6_mois = case_when(duree &lt;  sixmois ~ 1,\n                                      duree &gt;= sixmois ~ 0))\ndonnees_tidyverse %&gt;% pull(duree_inf_6_mois) %&gt;% table()\n\n# Date de sortie du dispositif\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(date_sortie = date_entree + lubridate::days(duree))\n\n# Date 6 mois après la sortie\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(date_6mois = date_sortie + lubridate::month(6))\n\n\n\n\n# Âge à l'entrée dans le dispositif\ndonnees_datatable[, age := floor(lubridate::time_length(difftime(donnees_datatable$date_entree, donnees_datatable$date_naissance), \"years\"))]\n\n# Âge formaté\ndonnees_datatable[, agef := fcase(age &lt; 26,             \"1. De 15 à 25 ans\",\n                                  26 &lt;= age & age &lt; 50, \"2. De 26 à 49 ans\",\n                                  age &gt;= 50,            \"3. 50 ans ou plus\")]\n\n# Manipuler les dates\nsixmois &lt;- 365.25/2\n# La durée du contrat est-elle inférieure à 6 mois ?\ndonnees_datatable[, duree_inf_6_mois := ifelse(duree &gt;= sixmois, 1, 0)]\ndonnees_datatable[, duree_inf_6_mois := fifelse(duree &gt;= sixmois, 1, 0)]\ndonnees_datatable[, duree_inf_6_mois := fcase(duree &gt;= sixmois, 1,\n                                              duree &lt;  sixmois, 0)]\n# Date de sortie du dispositif\ndonnees_datatable[, date_sortie := date_entree + lubridate::days(duree)]\n\n# Date 6 mois après la sortie\ndonnees_datatable[, date_6mois := date_sortie + lubridate::month(6)]\n\n\n\n\n# Création de la colonne age \nrequete_duckdb %&gt;% \n  mutate(age = year(age(date_entree,date_naissance))) %&gt;% \n  select(age)\n\n# Âge formaté\nrequete_duckdb %&gt;%\n  mutate(age = year(age(date_entree,date_naissance))) %&gt;% \n  mutate(agef = case_when(\n    age &lt; 26 ~ \"1. De 15 à 25 ans\",\n    age &gt;= 26 | age &lt; 50 ~  \"2. De 26 à 49 ans\",\n    age &gt;= 50 ~ \"3. 50 ans ou plus\")) %&gt;% \n  select(age, agef)\n\n\n\n\nfrom datetime import timedelta\nfrom dateutil.relativedelta import relativedelta\n\n# Calculer la durée en jours pour six mois\nsixmois = 365.25 / 2\n\n# La durée du contrat est-elle inférieure à 6 mois ?\ndonnees_python['duree_inf_6_mois'] = np.where(donnees_python['duree'] &lt; sixmois, 1, 0)\n\n# Créer une date spécifique (31 décembre de l'année en cours)\ndonnees_python['date_specifique'] = pd.to_datetime(donnees_python['date_entree'].dt.year.fillna(0).astype(int).astype(str) + \"-12-31\", format='%Y-%m-%d', errors='coerce')",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#majuscule-minuscule",
    "href": "01-aide_memoire_r_sas.html#majuscule-minuscule",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "9.1 Majuscule, minuscule",
    "text": "9.1 Majuscule, minuscule\n\n9.1.1 Majuscule\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata donnees_sas;\n  set donnees_sas;\n  CSP_majuscule = upcase(CSPF);\nrun;\n\n\n\ndonnees_rbase$csp_maj &lt;- toupper(donnees_rbase$cspf)\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(csp_maj = toupper(cspf))\n\n\n\n\ndonnees_datatable[, csp_maj := toupper(cspf)]\n\n\n\n\nrequete_duckdb %&gt;% mutate(csp_maj = toupper(cspf)) %&gt;% select(csp_maj)\n\n\n\n\ndonnees_python['csp_maj'] = donnees_python['cspf'].str.upper()\n\n\n\n\n\n\n9.1.2 Minuscule\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata donnees_sas;\n  set donnees_sas;\n  CSP_minuscule = lowcase(CSPF);\nrun;\n\n\n\ndonnees_rbase$csp_min &lt;- tolower(donnees_rbase$cspf)\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(csp_maj = tolower(cspf))\n\n\n\n\n# En minuscule\ndonnees_datatable[, csp_min := tolower(cspf)]\n\n\n\n\nrequete_duckdb %&gt;% mutate(csp_maj = tolower(cspf)) %&gt;% select(csp_maj)\n\n\n\n\ndonnees_python['csp_min'] = donnees_python['cspf'].str.lower()\n\n\n\n\n\n\n9.1.3 Première lettre en majuscule\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata donnees_sas;\n  set donnees_sas;\n  Niveau = propcase(Niveau);\nrun;\n\n\n\n# 1ère lettre en majuscule, autres lettres en minuscule\ndonnees_rbase$niveau &lt;- paste0(\n  toupper(substr(donnees_rbase$niveau, 1, 1)),\n  tolower(substr(donnees_rbase$niveau, 2, length(donnees_rbase$niveau)))\n  )\n\n\n\n\n# 1ère lettre en majuscule, autres lettres en minuscule\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%  \n  mutate(niveau = str_to_title(niveau))\n\n\n\n\n# 1ère lettre en majuscule, autres lettres en minuscule\ndonnees_datatable[, niveau := paste0(toupper(substr(niveau, 1, 1)), tolower(substr(niveau, 2, length(niveau))))]\n\n\n\n\nrequete_duckdb %&gt;% \n  # mutate(csp_maj = str_to_title(cspf)) %&gt;% # fonction non traduite\n  mutate(\n    l_niveau = as.integer(length(niveau)-1),\n    niveau = paste0(toupper(substr(niveau, 1, 1)), tolower(right(niveau, l_niveau)))) %&gt;% \n  # note : on utilise la fonction duckdb right car substr semble ne pas accepter un paramètre variable\n  select(l_niveau, niveau)\n\n\n\n\ndonnees_python['niveau'] = donnees_python['cspf'].str.capitalize()",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#nombre-de-caractères-dans-une-chaîne-de-caractères",
    "href": "01-aide_memoire_r_sas.html#nombre-de-caractères-dans-une-chaîne-de-caractères",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "9.2 Nombre de caractères dans une chaîne de caractères",
    "text": "9.2 Nombre de caractères dans une chaîne de caractères\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata donnees_sas;\n  set donnees_sas;\n  taille_id = length(identifiant);\nrun;\n\n\n\ndonnees_rbase$taille_id &lt;- nchar(donnees_rbase$identifiant)\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(taille_id = nchar(identifiant))\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(taille_id = str_split(identifiant, '') %&gt;% \n           lengths)\n\n\n\n\ndonnees_datatable[, taille_id := nchar(identifiant)]\n\n\n\n\nrequete_duckdb %&gt;% mutate(taille_id = nchar(identifiant)) %&gt;% select(taille_id) %&gt;% print()\n\n\n\n\ndonnees_python['taille_id'] = donnees_python['identifiant'].str.len()",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#remplacer-une-chaîne-de-caractères-par-une-autre",
    "href": "01-aide_memoire_r_sas.html#remplacer-une-chaîne-de-caractères-par-une-autre",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "9.3 Remplacer une chaîne de caractères par une autre",
    "text": "9.3 Remplacer une chaîne de caractères par une autre\nOn souhaite remplacer le mot qualifie par le mot Qualifié.\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata A_Corriger;\n  infile cards dsd dlm='|';\n  format A_corriger $8.;\n  input A_corriger $;\n  cards;\n  Qualifie\n  qualifie\n  Qualifie\n  QUALIFIE\n;\nrun;\n\ndata A_Corriger;\n  set A_Corriger;\n  Corrige = lowcase(A_corriger);\n  Corrige = tranwrd(Corrige, \"qualifie\", \"Qualifié\");\nrun;\n\n\n\n# Le mot Qualifié n'a pas d'accent : on le corrige\naCorriger &lt;- c(\"Qualifie\", \"qualifie\", \"Qualifie\", \"QUALIFIE\")\n\n# [Q-q] permet de représenter Q ou q, et donc de prendre en compte Qualifie et qualifie\ngsub(\"[Q-q]ualifie\", \"Qualifié\", tolower(aCorriger))\n\n\n\n\n# Le mot Qualifié n'a pas d'accent : on le corrige\naCorriger &lt;- c(\"Qualifie\", \"qualifie\", \"Qualifie\", \"QUALIFIE\")\n\n# [Q-q] permet de représenter Q ou q, et donc de prendre en compte Qualifie et qualifie\naCorriger %&gt;% tolower() %&gt;% str_replace_all(\"[Q-q]ualifie\", \"Qualifié\")\n\n\n\n\n# Le mot Qualifié n'a pas d'accent : on le corrige\naCorriger &lt;- c(\"Qualifie\", \"qualifie\", \"Qualifie\", \"QUALIFIE\")\n\n# [Q-q] permet de représenter Q ou q, et donc de prendre en compte Qualifie et qualifie\ngsub(\"[Q-q]ualifie\", \"Qualifié\", tolower(aCorriger))\n\n\n\n\nrequete_duckdb %&gt;% mutate(niveau = stringr::str_replace_all(niveau, \"[Q-q]ualifie\", \"Qualifié\")) %&gt;% select(niveau)\n\n\n\n\naCorriger = [\"Qualifie\", \"qualifie\", \"Qualifie\", \"QUALIFIE\"]\n[re.sub(r'[qQ]ualifie', 'Qualifié', mot.lower()) for mot in aCorriger]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#extraire-des-éléments-dune-chaîne-de-caractères",
    "href": "01-aide_memoire_r_sas.html#extraire-des-éléments-dune-chaîne-de-caractères",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "9.4 Extraire des éléments d’une chaîne de caractères",
    "text": "9.4 Extraire des éléments d’une chaîne de caractères\nLe comportement de la fonction substr est différent entre SAS et R :\n\nen SAS, dans substr(extrait, 2, 3), le 2 correspond à la position du 1er caractère à récupérer, le 3 au nombre total de caractères extrait à partir du 2e =&gt; Le résultat est xtr\nen R, dans substr(“extrait”, 2, 3), le 2 correspond à la position du 1er caractère à récupérer, le 3 à la position du dernier caractère =&gt; Le résultat est “xt”.\n\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata Exemple_texte;\n  set Exemple_texte;\n  \n  /* Extraire les 2e, 3e et 4e caractère du mot extrait */\n  /* Fonction tranwrd (TRANslate WoRD) */\n  /* 2 correspond à la position du 1er caractère à récupérer, 3 le nombre total de caractères à partir du 2e */\n  extrait = substr(extrait, 2, 3);\nrun;\nproc print data = Exemple_texte;run;\n\n\n\n# Extraire les 2e, 3e et 4e caractères de Concatener\n# 2 correspond à la position du 1er caractère à récupérer, 5 la position du dernier caractère\nextrait &lt;- substr(\"extrait\", 2, 5)\n\n\n\n\n# Extraire les 2e, 3e et 4e caractères de Concatener\n# 2 correspond à la position du 1er caractère à récupérer, 5 la position du dernier caractère\nextrait &lt;- str_sub(\"extrait\", 2, 5)\n\n\n\n\n# Extraire les 2e, 3e et 4e caractères de texte\n# 2 correspond à la position du 1er caractère à récupérer, 5 la position du dernier caractère\nextrait &lt;- substr(\"extrait\", 2, 5)\n\n\n\n\nrequete_duckdb %&gt;% mutate(niveau = stringr::str_sub(niveau, 2, 5)) %&gt;% select(niveau)\n\n\n\n\n# La position 1 en Python correspond au 2eme élément\nextrait = \"extrait\"[1:5]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#enlever-les-blancs-superflus-dune-chaîne-de-caractères",
    "href": "01-aide_memoire_r_sas.html#enlever-les-blancs-superflus-dune-chaîne-de-caractères",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "9.5 Enlever les blancs superflus d’une chaîne de caractères",
    "text": "9.5 Enlever les blancs superflus d’une chaîne de caractères\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata Exemple_texte;\n  Texte = \"              Ce   Texte   mériterait   d être   corrigé                  \";\nrun;\n\ndata Exemple_texte;\n  set Exemple_texte;\n  /* Enlever les blancs au début et à la fin de la chaîne de caractère */\n  Enlever_Blancs_Initiaux = strip(Texte);\n  \n  /* Enlever les doubles blancs dans la chaîne de caractères */\n  Enlever_Blancs_Entre = compbl(Enlever_Blancs_Initiaux);\n  \n  /* Enlever doubles blancs */\n  /* REVOIR !!!!! */\n  Enlever_Doubles_Blancs = compress(Texte, \"  \", \"t\");\nrun;\nproc print data = Exemple_texte;run;\n\n\n\n# Enlever les blancs au début et à la fin de la chaîne de caractère\ntexte  &lt;- \"              Ce   Texte   mériterait   d être   corrigé   \"\n\n# \"\\\\s+\" est une expression régulière indiquant 1 ou plusieurs espaces successifs\n# Le gsub remplace 1 ou plusieurs espaces successifs par un seul espace\n# trimws enlève les espaces au début et à la fin d'une chaîne de caractère \ntexte &lt;- gsub(\"\\\\s+\", \" \", trimws(texte))\n\n\n\n\n# Enlever les blancs au début et à la fin de la chaîne de caractère\ntexte  &lt;- \"              Ce   Texte   mériterait   d être   corrigé  \"\n\n# str_squish() supprime les espaces blancs au début et à la fin, et remplace tous les espaces blancs internes par un seul espace\ntexte &lt;- str_squish(texte)\n\n\n\n\n# Enlever les blancs au début et à la fin de la chaîne de caractère\ntexte  &lt;- \"              Ce   Texte   mériterait   d être   corrigé  \"\n\n# \"\\\\s+\" est une expression régulière indiquant 1 ou plusieurs espaces successifs\n# Le gsub remplace 1 ou plusieurs espaces successifs par un seul espace\n# trimws enlève les espaces au début et à la fin d'une chaîne de caractère \ntexte &lt;- gsub(\"\\\\s+\", \" \", trimws(texte))\n\n\n\n\nrequete_duckdb %&gt;% mutate(niveau = stringr::str_squish(niveau)) %&gt;% select(niveau)\n\n\n\n\n# Enlever les blancs au début et à la fin de la chaîne de caractère\ntexte = \"              Ce   Texte   mériterait   d être   corrigé   \"\ntexte = re.sub(r'\\s+', ' ', texte).strip()",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#concaténer-des-chaînes-de-caractères",
    "href": "01-aide_memoire_r_sas.html#concaténer-des-chaînes-de-caractères",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "9.6 Concaténer des chaînes de caractères",
    "text": "9.6 Concaténer des chaînes de caractères\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata Exemple_texte;\n  Texte1 = \"Ce texte\";\n  Texte2 = \"va être\";\n  Texte3 = \"concaténé\";\n  Texte4 = \"\";\nrun;\n\ndata Exemple_texte;\n  set Exemple_texte;\n  \n  /* Trois méthodes pour concaténer des chaînes de caractères */\n  Concatener  = Texte1||\" \"||Texte2;\n  Concatener2 = Texte1!!\" \"!!Texte2;\n  Concatener3 = catx(\" \", Texte1, Texte2);\n  \n  /* Effet des valeurs manquantes */\n  /* Le séparateur est enlevé lors d'une concaténation avec une chaîne de caractère vide */\n  Concatener4 = catx(\"-\", Texte4, Texte3);\nrun;\nproc print data = Exemple_texte;run;\n\n\n\n# Concaténer des chaînes de caractères\ntexte1 &lt;- \"Ce texte\"\ntexte2 &lt;- \"va être\"\ntexte3 &lt;- \"concaténé\"\ntexte4 &lt;- \"\"\n\nconcatene &lt;- paste(texte1, texte2, texte3, sep = \" \")\npaste0(texte1, \" \", texte2, \" \", texte3)\n\n# Effet des valeurs manquantes : le délimiteur (ici -) apparaît avec la concaténation avec le caractère manquant\npaste(texte4, texte3, sep = \"-\")\n\n\n\n\n# Concaténer des chaînes de caractères\ntexte1 &lt;- \"Ce texte\"\ntexte2 &lt;- \"va être\"\ntexte3 &lt;- \"concaténé\"\ntexte4 &lt;- \"\"\n\nconcatene &lt;- str_flatten(c(texte1, texte2, texte3), collapse = \" \")\n\n# Effet des valeurs manquantes : le délimiteur (ici -) apparaît avec la concaténation avec le caractère manquant\nstr_flatten(c(texte4, texte3), collapse = \"-\")\n\n\n\n\n# Concaténer des chaînes de caractères\ntexte1 &lt;- \"Ce texte\"\ntexte2 &lt;- \"va être\"\ntexte3 &lt;- \"concaténé\"\ntexte4 &lt;- \"\"\n\nconcatene &lt;- paste(texte1, texte2, texte3, sep = \" \")\npaste0(texte1, \" \", texte2, \" \", texte3)\n\n# Effet des valeurs manquantes : le délimiteur (ici -) apparaît avec la concaténation avec le caractère manquant\npaste(texte4, texte3, sep = \"-\")\n\n\n\n\nrequete_duckdb %&gt;% mutate(niveau = paste0(niveau,niveau)) %&gt;% select(niveau)\n\n\n\n\n# Concaténer des chaînes de caractères\ntexte1 = \"Ce texte\"\ntexte2 = \"va être\"\ntexte3 = \"concaténé\"\ntexte4 = \"\"\n\nconcatene = ' '.join([texte1, texte2, texte3])\n\n# Effet des valeurs manquantes : le délimiteur (ici -) apparaît avec la concaténation avec le caractère manquant\n'-'.join([texte4, texte3])",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#transformer-plusieurs-caractères-différents",
    "href": "01-aide_memoire_r_sas.html#transformer-plusieurs-caractères-différents",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "9.7 Transformer plusieurs caractères différents",
    "text": "9.7 Transformer plusieurs caractères différents\nSupprimer les accents, cédilles, caractères spéciaux.\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata Exemple_texte;\n  set Exemple_texte;\n  /* Transformer plusieurs caractères différents */\n  /* On transforme le é en e, le â en a, le î en i, ... */\n  texte = \"éèêëàâçîô\";\n  texte_sans_accent = translate(texte, \"eeeeaacio\", \"éèêëàâçîô\");\nrun;\nproc print data = Exemple_texte;run;\n\n\n\n# Transformer plusieurs caractères différents\ntexte &lt;- \"éèêëàâçîô\"\nchartr(\"éèêëàâçîô\", \"eeeeaacio\", texte)\n\n\n\n\n# Transformer plusieurs caractères différents\ntexte &lt;- \"éèêëàâçîô\"\nchartr(\"éèêëàâçîô\", \"eeeeaacio\", texte)\n\n\n\n\n# Transformer plusieurs caractères différents\ntexte &lt;- \"éèêëàâçîô\"\nchartr(\"éèêëàâçîô\", \"eeeeaacio\", texte)\n\n\n\n\nrequete_duckdb %&gt;% mutate(niveau = strip_accents(niveau)) %&gt;% select(niveau) # strip_accents est une fonction duckdb\n# chartr n'est pas traduite en duckdb\n\n\n\n\ntexte = \"éèêëàâçîô\"\ntexte.replace(\"éèêëàâçîô\", \"eeeeaacio\")",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#découper-une-chaîne-de-caractères-selon-un-caractère-donné",
    "href": "01-aide_memoire_r_sas.html#découper-une-chaîne-de-caractères-selon-un-caractère-donné",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "9.8 Découper une chaîne de caractères selon un caractère donné",
    "text": "9.8 Découper une chaîne de caractères selon un caractère donné\nDécouper une phrase selon les espaces pour isoler les mots.\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata Mots;\n  delim = \" \";\n  Texte = \"Mon texte va être coupé !\";\n  \n  /* Chaque mot dans une variable */\n  %macro Decouper;\n    %do i = 1 %to %sysfunc(countw(Texte, delim));\n      Mot&i. = scan(Texte, &i., delim);\n    %end;\n  %mend Decouper;\n  %Decouper;\n  \n  /* Les mots empilés */\n  nb_mots = countw(Texte, delim);\n  do nb = 1 to nb_mots;\n    mots = scan(Texte, nb, delim);\n    output;\n  end;\nrun;\nproc print data = Mots;run;\n\n\n\ntexte  &lt;- \"Mon texte va être coupé !\"\nunlist(strsplit(texte, split = \" \"))\n\n\n\n\ntexte  &lt;- \"Mon texte va être coupé !\"\nstr_split(texte, pattern = \" \") %&gt;% unlist()\n\n\n\n\ntexte  &lt;- \"Mon texte va être coupé !\"\nunlist(strsplit(texte, split = \" \"))\n\n\n\n\nrequete_duckdb %&gt;% mutate(niveau = string_split(niveau, \" \")) %&gt;% select(niveau) # string_split est une fonction duckdb\n# `str_split()` is not available in this SQL variant\n# strsplit n'est pas disponible non plus\n\nN.B. On obtient une seule colonne contenant des listes (de chaînes de caractères). DuckDB sait gérer des types complexes dans des cases, tout comme dplyr, mais c’est plus difficile à manipuler.\n\n\n\ntexte = \"Mon texte va être coupé !\"\ntexte.split()",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#inverser-une-chaîne-de-caractères",
    "href": "01-aide_memoire_r_sas.html#inverser-une-chaîne-de-caractères",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "9.9 Inverser une chaîne de caractères",
    "text": "9.9 Inverser une chaîne de caractères\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata Mots;\n  Texte = \"Mon texte va être inversé !\";\n  x = left(reverse(Texte));\nrun;\nproc print data = Mots;run;\n\n\n\ntexte &lt;- \"Mon texte va être inversé !\"\ninverserTexte &lt;- function(x) {\n  sapply(\n    lapply(strsplit(x, NULL), rev),\n    paste, collapse = \"\")\n  }\ninverserTexte(texte)\n\n\n\n\nlibrary(stringi)\ntexte &lt;- \"Mon texte va être inversé !\"\nstringi::stri_reverse(texte)\n\n\n\n\ntexte &lt;- \"Mon texte va être inversé !\"\ninverserTexte &lt;- function(x) {\n  sapply(\n    lapply(strsplit(x, NULL), rev),\n    paste, collapse = \"\")\n}\ninverserTexte(texte)\n\n\n\n\nrequete_duckdb %&gt;% mutate(niveau = reverse(niveau)) %&gt;% select(niveau) # reverse est une fonction duckdb\n# stri_reverse : No known SQL translation\n\n\n\n\ntexte = \"Mon texte va être inversé !\"\ntexte[::-1]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#repérer-les-valeurs-manquantes-variables-age-et-niveau",
    "href": "01-aide_memoire_r_sas.html#repérer-les-valeurs-manquantes-variables-age-et-niveau",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "10.1 Repérer les valeurs manquantes (variables Age et Niveau)",
    "text": "10.1 Repérer les valeurs manquantes (variables Age et Niveau)\nLignes où les variables Age ou Niveau sont manquantes.\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata Manquant;\n  set donnees_sas;\n  /* 1ère solution */\n  if missing(age) or missing(Niveau) then missing1 = 1;else missing1 = 0;\n  /* 2e solution */\n  if age = . or Niveau = '' then missing2 = 1;else missing2 = 0;\n  keep Age Niveau Missing1 Missing2;\nrun;\n\n\n\n# Mauvaise méthode pour repérer les valeurs manquantes\nmanquant &lt;- donnees_rbase[donnees_rbase$age == NA | donnees_rbase$niveau == NA, ]\n\n# Bonne méthode pour repérer les valeurs manquantes\nmanquant &lt;- donnees_rbase[is.na(donnees_rbase$age) | is.na(donnees_rbase$niveau), ]\n\n\n\n\n# Mauvaise méthode pour repérer les valeurs manquantes\nmanquant &lt;- donnees_tidyverse %&gt;%\n  filter(age == NA | niveau == NA)\n\n# Bonne méthode pour repérer les valeurs manquantes\nmanquant &lt;- donnees_tidyverse %&gt;%\n  filter(is.na(age) | is.na(niveau))\n\n\n\n\n# Mauvaise méthode pour repérer les valeurs manquantes\nmanquant &lt;- donnees_datatable[age == NA | niveau == NA]\n\n# Bonne méthode pour repérer les valeurs manquantes\nmanquant &lt;- donnees_datatable[is.na(age)]\ndonnees_datatable[, manquant := fifelse(is.na(age) | is.na(niveau), 1, 0)]\n\n\n\n\nrequete_duckdb %&gt;% filter(is.na(age) | is.na(niveau))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#nombre-et-proportion-de-valeurs-manquantes-par-variable",
    "href": "01-aide_memoire_r_sas.html#nombre-et-proportion-de-valeurs-manquantes-par-variable",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "10.2 Nombre et proportion de valeurs manquantes par variable",
    "text": "10.2 Nombre et proportion de valeurs manquantes par variable\n\n10.2.1 Pour l’ensemble des variables\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Une solution possible */\n%macro Iteration(base = donnees_sas);\n  %local nbVar;\n  proc contents data = donnees_sas out = ListeVar noprint;run;\n  proc sql noprint;select count(*) into :nbVar from ListeVar;quit;\n  \n  %do i = 1 %to &nbVar.;\n    data _null_;\n      set ListeVar (firstobs = &i. obs = &i.);\n      call symput('var', name);\n    run;\n    proc sql;\n      select max(\"&var.\") as Variable, sum(missing(&var.)) as Manquants, sum(missing(&var.)) / count(*) * 100 as Prop_Manquants\n      from &base.;\n    quit;\n  %end;\n  \n  proc datasets lib = work nolist;delete ListeVar;run;\n%mend Iteration;\n\n%Iteration;\n\n\n\n# Nombre de valeurs manquantes\ncolSums(is.na(donnees_rbase))\napply(is.na(donnees_rbase), 2, sum)\n\n# Proportion de valeurs manquantes\ncolMeans(is.na(donnees_rbase)) * 100\napply(is.na(donnees_rbase), 2, mean) * 100\n\n\n\n\n# Nombre et proportion de valeurs manquantes\ndonnees_tidyverse %&gt;%\n  reframe(across(everything(), ~c( sum(is.na(.x)), mean(is.na(.x) * 100)) ))\n\n# Autres solutions\ndonnees_tidyverse %&gt;% map(~c( sum(is.na(.x)), mean(is.na(.x) * 100)))\n\ndonnees_tidyverse %&gt;%\n  summarise(across(everything(), .fns = list(nb = \\(x) sum(is.na(x)), prop = \\(x) mean(is.na(x)) * 100), .names = c(\"{.col}_{.fn}\")))\n\n# Obsolète\ndonnees_tidyverse %&gt;% summarise_each(funs(mean(is.na(.)) * 100))\n\n\n\n\n# Nombre et proportion de valeurs manquantes\ndonnees_datatable[, lapply(.SD, function(x) c(sum(is.na(x)), mean(is.na(x)) * 100))]\n\n\n\n\nrequete_duckdb %&gt;%\n  summarise(across(everything(), .fns = list(nb = \\(x) sum(as.integer(is.na(x))), prop = \\(x) mean(as.integer(is.na(x))) * 100), .names = c(\"{.col}_{.fn}\")))\n\n\n\n\n\n\n10.2.2 Pour les variables numériques ou dates\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Partie \"Missing Values\" en bas du tableau consacré à la variable */\nproc univariate data = donnees_sas;var _numeric_;run;\n\n\n\napply(is.na(\n  donnees_rbase[sapply(donnees_rbase, function(x) is.numeric(x) | lubridate::is.Date(x))]\n  ), \n  2, \n  function(x) c( sum(x), mean(x) * 100 ) )\n\n# Autres solutions\nsapply(\n  donnees_rbase[sapply(donnees_rbase, function(x) is.numeric(x) | lubridate::is.Date(x))],\n  function(x) c( sum(is.na(x)), mean(is.na(x)) * 100 ) )\nsapply(\n  donnees_rbase[sapply(donnees_rbase, function(x) is.numeric(x) | lubridate::is.Date(x))],\n  function(x) c (sum(is.na(x)), sum(is.na(x)) / length(x) * 100) )\n\n\n\n\ndonnees_tidyverse %&gt;%\n  summarise(across(where(~ is.numeric(.x) | lubridate::is.Date(.x)),\n                   c(~sum(is.na(.x)), ~mean(is.na(.x)))))\ndonnees_tidyverse %&gt;%\n  summarise(across(where(~ is.numeric(.x) | lubridate::is.Date(.x)),\n                   list(~sum(is.na(.x)), ~sum(is.na(.x)) / length(.x))))\n\n\n\n\ndonnees_datatable[, lapply(.SD, function(x) mean(is.na(x)) * 100),\n                  .SDcols = function(x) c(lubridate::is.Date(x) | is.numeric(x))]\n\n\n\nEn duckdb, on ne peut pas écrire where(is.numeric), mais on peut passer par starts_with ou contains.\n\n# ! This tidyselect interface doesn't support predicates.",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#incidence-des-valeurs-manquantes",
    "href": "01-aide_memoire_r_sas.html#incidence-des-valeurs-manquantes",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "10.3 Incidence des valeurs manquantes",
    "text": "10.3 Incidence des valeurs manquantes\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* En SAS, les valeurs manquantes sont des nombres négatifs faibles */\ndata Valeur_Manquante;\n  set donnees_sas;\n  /* Lorsque Age est manquant (missing), Jeune_Correct vaut 0 mais Jeune_Incorrect vaut 1 */\n  /* En effet, pour SAS, un Age manquant est une valeur inférieure à 0, donc bien inférieure à 25.\n     Donc la variable Jeune_Incorrect vaut bien 1 pour les âges inconnus */\n  Jeune_Incorrect = (Age &lt;= 25);\n  Jeune_Correct   = (0 &lt;= Age &lt;= 25);\nrun;\n\n/* On affiche les résultats */\nproc print data = Valeur_Manquante (keep  = Age Jeune_Correct Jeune_Incorrect\n                                    where = (missing(Age)));\nrun;\nproc freq data = Valeur_Manquante;tables Jeune_Incorrect Jeune_Correct;run;\n\n\n\n# Une somme avec NA donne NA en résultat\nmean(donnees_rbase$note_formateur)\n# Sauf avec l'option na.rm = TRUE\nmean(donnees_rbase$note_formateur, na.rm = TRUE)\n\n\n\n\n# Une somme avec NA donne NA en résultat\ndonnees_tidyverse %&gt;% pull(note_formateur) %&gt;% mean()\n# Sauf avec l'option na.rm = TRUE\ndonnees_tidyverse %&gt;% pull(note_formateur) %&gt;% mean(na.rm = TRUE)\n\n# Attention, en tidyverse, les syntaxes suivantes ne fonctionnent pas !\n# donnees_tidyverse %&gt;% mean(note_formateur)\n# donnees_tidyverse %&gt;% mean(note_formateur, na.rm = TRUE)\n\n\n\n\n# Une somme avec NA donne NA en résultat\ndonnees_datatable[, mean(note_formateur)]\n# Sauf avec l'option na.rm = TRUE\ndonnees_datatable[, mean(note_formateur, na.rm = TRUE)]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#remplacer-les-valeurs-manquantes-dune-seule-variable-par-0",
    "href": "01-aide_memoire_r_sas.html#remplacer-les-valeurs-manquantes-dune-seule-variable-par-0",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "10.4 Remplacer les valeurs manquantes d’une seule variable par 0",
    "text": "10.4 Remplacer les valeurs manquantes d’une seule variable par 0\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let var = note_contenu;\ndata donnees_sas_sans_missing;\n  set donnees_sas;\n  if missing(&var.) then &var. = 0;\n  /* Ou alors */\n  if &var. = . then &var. = 0;\n  /* Ou encore */\n  if note_contenu = . then note_contenu = 0;\nrun;\n\n\n\nvariable &lt;- \"note_contenu\"\ndonnees_rbase_sans_na &lt;- donnees_rbase\ndonnees_rbase_sans_na[is.na(donnees_rbase_sans_na[, variable]), variable] &lt;- 0\n\n# Autres solutions\ndonnees_rbase_sans_na[, variable][is.na(donnees_rbase_sans_na[, variable])] &lt;- 0\ndonnees_rbase_sans_na[, variable] &lt;- replace(donnees_rbase_sans_na[, variable],\n                                             is.na(donnees_rbase_sans_na[, variable]), 0)\n\n# Ou alors\ndonnees_rbase_sans_na &lt;- donnees_rbase\ndonnees_rbase_sans_na$note_contenu[is.na(donnees_rbase_sans_na$note_contenu)] &lt;- 0\n\n\n\n\nvariable &lt;- \"note_contenu\"\ndonnees_tidyverse_sans_na &lt;- donnees_tidyverse %&gt;% \n  mutate(across(variable,  ~tidyr::replace_na(.x, 0)))\n\n# Ou alors\ndonnees_tidyverse_sans_na &lt;- donnees_tidyverse %&gt;% \n  mutate(note_contenu = tidyr::replace_na(note_contenu, 0))\n\n\n\n\nvariable &lt;- \"note_contenu\"\ndonnees_datatable[, replace(.SD, is.na(.SD), 0), .SDcols = variable]\ndonnees_datatable[, lapply(.SD, function(x) fifelse(is.na(x), 0, x)), .SDcols = variable]\ndonnees_datatable[, lapply(.SD, \\(x) fifelse(is.na(x), 0, x)), .SDcols = variable]\n\n# Ou alors\ndonnees_datatable[, replace(.SD, is.na(.SD), 0), .SDcols = \"note_contenu\"]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#remplacer-toutes-les-valeurs-numériques-manquantes-par-0",
    "href": "01-aide_memoire_r_sas.html#remplacer-toutes-les-valeurs-numériques-manquantes-par-0",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "10.5 Remplacer toutes les valeurs numériques manquantes par 0",
    "text": "10.5 Remplacer toutes les valeurs numériques manquantes par 0\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On sélectionne toutes les variables numériques */\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql noprint;\n  select name into :nom_col separated by \" \" from Var where format = \"\";\nrun;\n\ndata donnees_sas_sans_missing;\n  set donnees_sas;\n  \n  %macro Missing;\n    %local i var;\n    %do i = 1 %to %sysfunc(countw(&nom_col.));\n      %let var = %scan(&nom_col., &i);\n      if missing(&var.) then &var. = 0;\n    %end;\n  %mend Missing;\n  %Missing;\n  \nrun;\nproc datasets lib = Work nolist;delete Var;run;\n\n\n\n# Dans le cas des dates, la valeur manquante a été remplacée par 1970-01-01\ndonnees_rbase_sans_na &lt;- donnees_rbase\ndonnees_rbase_sans_na[is.na(donnees_rbase_sans_na)] &lt;- 0\n\n# On remplace seulement les valeurs numériques par 0\ndonnees_rbase_sans_na &lt;- donnees_rbase\nvarNumeriques &lt;- sapply(donnees_rbase, is.numeric)\ndonnees_rbase_sans_na[, varNumeriques][is.na(donnees_rbase_sans_na[, varNumeriques])] &lt;- 0\n\n# Autre solution, avec replace\ndonnees_rbase_sans_na[, varNumeriques] &lt;- lapply(donnees_rbase_sans_na[, varNumeriques],\n                                                 function(x) {replace(x, is.na(x), 0)})\n\n\n\n\n# On remplace seulement les valeurs numériques par 0\ndonnees_tidyverse_sans_na &lt;- donnees_tidyverse %&gt;% \n  mutate(across(where(is.numeric), ~tidyr::replace_na(.x, 0)))\n\n# Autres façons d'écrire les fonctions anonymes\n# La méthode complète\ndonnees_tidyverse_sans_na &lt;- donnees_tidyverse %&gt;% \n  mutate(across(where(is.numeric), function(x) tidyr::replace_na(x, 0)))\n# Une autre façon de raccourcir (depuis R 4.1)\n# \\(x) est un raccourci pour function(x)\ndonnees_tidyverse_sans_na &lt;- donnees_tidyverse %&gt;% \n  mutate(across(where(is.numeric), \\(x) tidyr::replace_na(x, 0)))\n# Autre solution\ndonnees_tidyverse_sans_na &lt;- donnees_tidyverse %&gt;%\n  purrr::modify_if(is.numeric, ~tidyr::replace_na(.x, 0))\n\n\n\n\ndonnees_datatable_sans_na &lt;- copy(donnees_datatable)\nsetnafill(donnees_datatable[, .SD, .SDcols = is.numeric], fill = 0)\n\n# Autre solution\ndonnees_datatable_sans_na &lt;- copy(donnees_datatable)\ncols &lt;- colnames(donnees_datatable_sans_na[, .SD, .SDcols = is.numeric])\ndonnees_datatable_sans_na[, (cols) := lapply(.SD, function(x) fifelse(is.na(x), 0, x)), .SDcols = cols]\n\n# Ensemble des colonnes\ndonnees_datatable_sans_na &lt;- copy(donnees_datatable)\ndonnees_datatable_sans_na[is.na(donnees_datatable_sans_na)] &lt;- 0",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#supprimer-les-lignes-où-une-certaine-variable-est-manquante",
    "href": "01-aide_memoire_r_sas.html#supprimer-les-lignes-où-une-certaine-variable-est-manquante",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "10.6 Supprimer les lignes où une certaine variable est manquante",
    "text": "10.6 Supprimer les lignes où une certaine variable est manquante\nOn souhaite supprimer toutes les lignes où la variable age est manquante.\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata age_non_manquant;\n  set donnees_sas (where = (age ne .));\n  /* Ou alors */\n  if age ne .;\nrun;\n\n\n\nage_non_manquant &lt;- donnees_rbase[complete.cases(donnees_rbase[, \"age\"]), ]\nage_non_manquant &lt;- donnees_rbase[! is.na(donnees_rbase[, \"age\"]), ]\n\n\n\n\nage_non_manquant &lt;- donnees_tidyverse %&gt;% drop_na(age)\nage_non_manquant &lt;- donnees_tidyverse %&gt;% filter(!is.na(age))\n\n\n\n\nage_non_manquant &lt;- na.omit(donnees_datatable, cols = c(\"age\"))\nage_non_manquant &lt;- donnees_datatable[! is.na(age), ]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#supprimer-les-lignes-où-au-moins-une-variable-de-la-base-est-manquante",
    "href": "01-aide_memoire_r_sas.html#supprimer-les-lignes-où-au-moins-une-variable-de-la-base-est-manquante",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "10.7 Supprimer les lignes où au moins une variable de la base est manquante",
    "text": "10.7 Supprimer les lignes où au moins une variable de la base est manquante\nOn souhaite supprimer toutes les lignes où au moins une variable de la base est manquante.\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata non_manquant;\n  set donnees_sas;\n  if cmiss(of _all_) then delete;\nrun;\n\n\n\nnon_manquant &lt;- donnees_rbase[complete.cases(donnees_rbase), ]\n\n\n\n\nnon_manquant &lt;- donnees_tidyverse %&gt;% drop_na()\n\n\n\n\nnon_manquant &lt;- na.omit(donnees_datatable)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#trier-les-colonnes-de-la-base",
    "href": "01-aide_memoire_r_sas.html#trier-les-colonnes-de-la-base",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "11.1 Trier les colonnes de la base",
    "text": "11.1 Trier les colonnes de la base\n\n11.1.1 Mettre identifiant et date_entree au début de la base\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n%let colTri = identifiant date_entree;\ndata donnees_sas;\n  retain &colTri.;\n  set donnees_sas;\nrun;\n\n/* Autre solution */\nproc sql;\n  create table donnees_sas as\n  /* Dans la proc SQL, les variables doivent être séparées par des virgules */\n  /* On remplace les blancs entre les mots par des virgules pour la proc SQL */\n  select %sysfunc(tranwrd(&colTri., %str( ), %str(, ))), * from donnees_sas;\nquit;\n\n\n\ncolTri &lt;- c(\"identifiant\", \"date_entree\")\ndonnees_rbase &lt;- donnees_rbase[, union(colTri, colnames(donnees_rbase))]\n\n# Autres possibilités, plus longues !\ndonnees_rbase &lt;- donnees_rbase[, c(colTri, setdiff(colnames(donnees_rbase), colTri))]\ndonnees_rbase &lt;- donnees_rbase[, c(colTri, colnames(donnees_rbase)[! colnames(donnees_rbase) %in% colTri])]\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  relocate(identifiant, date_entree)\n\n# Autres solutions\ncolTri &lt;- c(\"identifiant\", \"date_entree\")\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  relocate(all_of(colTri))\ndonnees_tidyverse_tri &lt;- donnees_tidyverse %&gt;% \n  select(all_of(colTri), everything())\n\n\n\n\ncolTri &lt;- c(\"identifiant\", \"date_entree\")\ntri &lt;- union(colTri, colnames(donnees_datatable))\ndonnees_datatable &lt;- donnees_datatable[, ..tri]\n\n# Autre solution, à privilégier\n# En data.table, les instructions débutant par set modifient les éléments par référence, c'est-à-dire sans copie. Ceci est plus efficace pour manipuler des données volumineuses.\nsetcolorder(donnees_datatable, colTri)\n\n\n\n\nrequete_duckdb %&gt;% \n  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %&gt;% # strptime est une fonction duckdb\n  select(identifiant, date_entree, everything())\n\nrequete_duckdb %&gt;% \n  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %&gt;% # strptime est une fonction duckdb\n  relocate(identifiant, date_entree)\n\n\n\n\ncolTri = [\"identifiant\", \"date_entree\"]\n\ncols = colTri + [col for col in donnees_python.columns if col not in colTri]\ndonnees_python = donnees_python[cols]\n\n\n\n\n\n\n11.1.2 Mettre la variable poids_sondage au début de la base\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata donnees_sas;\n  retain poids_sondage;\n  set donnees_sas;\nrun;\n\n\n\ndonnees_rbase[, union(\"poids_sondage\", colnames(donnees_rbase))]\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  relocate(poids_sondage)\n\n\n\n\nsetcolorder(donnees_datatable, \"poids_sondage\")\n\n\n\n\n\n\n\ncols = ['poids_sondage'] + [col for col in donnees_python.columns if col != 'poids_sondage']\ndonnees_python = donnees_python[cols]\n\n\n\n\n\n\n11.1.3 Mettre la variable poids_sondage après la variable date_naissance\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nproc contents data = donnees_sas out = var;run;\n\nproc sql noprint;\n  select name into :var separated by \" \"\n  from var\n  where varnum &lt;= (select varnum from var where lowcase(name) = \"date_naissance\")\n  order by varnum;\nquit;\n\ndata donnees_sas;\n  retain &var. poids_sondage;\n  set donnees_sas;\nrun;\n\n\n\nvarAvant &lt;- c( colnames(donnees_rbase)[1 : which(\"date_naissance\" == colnames(donnees_rbase))], \"poids_sondage\" )\ndonnees_rbase &lt;- donnees_rbase[, c(varAvant, setdiff(colnames(donnees_rbase), varAvant))]\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  relocate(poids_sondage, .after = date_naissance)\n\n\n\n\nsetcolorder(donnees_datatable, \"poids_sondage\", after = \"date_naissance\")\n\n\n\n\n\n\n\n# Trouver l'index de la colonne 'date_naissance'\ndate_naissance_index = donnees_python.columns.get_loc('date_naissance')\n\n# Sélectionner toutes les colonnes jusqu'à 'date_naissance' inclus\nvarAvant = list(donnees_python.columns[:date_naissance_index + 1]) + ['poids_sondage']\n\n# Réorganiser les colonnes du DataFrame\ndonnees_python = donnees_python[varAvant + [col for col in donnees_python.columns if col not in varAvant]]\n\n\n\n\n\n\n11.1.4 Mettre la variable poids_sondage à la fin de la base\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nproc contents data = donnees_sas out = var;run;\nproc sql noprint;\n  select name into :var separated by \" \" from var\n  where lowcase(name) ne \"poids_sondage\" order by varnum;\nquit;\ndata donnees_sas;\n  retain &var. poids_sondage;\n  set donnees_sas;\nrun;\n\n\n\ndonnees_rbase &lt;- donnees_rbase[, c(setdiff(colnames(donnees_rbase), \"poids_sondage\"), \"poids_sondage\")]\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  relocate(poids_sondage, .after = last_col())\n\n\n\n\nsetcolorder(donnees_datatable, c(setdiff(colnames(donnees_datatable), \"poids_sondage\"), \"poids_sondage\"))\n\n\n\n\n\n\n\ncols = [col for col in donnees_python.columns if col != 'poids_sondage'] + ['poids_sondage']\ndonnees_python = donnees_python[cols]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#trier-les-lignes-de-la-base",
    "href": "01-aide_memoire_r_sas.html#trier-les-lignes-de-la-base",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "11.2 Trier les lignes de la base",
    "text": "11.2 Trier les lignes de la base\n\n11.2.1 Tri par ordre croissant d’identifiant et date_entree\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* 1ère possibilité */\nproc sort data = donnees_sas;by Identifiant Date_entree;run;\n\n/* 2e possibilité */\nproc sql;\n  create table donnees_sas as select * from donnees_sas\n  order by Identifiant, Date_entree;\nquit;\n\n\n\n# Tri par ordre croissant\n# L'option na.last = FALSE (resp. TRUE) indique que les valeurs manquantes doivent figurer à la fin (resp. au début) du tri, que le tri soit croissant ou décroissant\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]\n\n\n\n\n# Tri par ordre croissant\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  arrange(identifiant, date_entree)\n\n\n\n\n# Tri par ordre croissant\n# L'option na.last = FALSE (resp. TRUE) indique que les valeurs manquantes doivent figurer à la fin (resp. au début) du tri, que le tri soit croissant ou décroissant\ndonnees_datatable &lt;- donnees_datatable[order(identifiant, date_entree, na.last = FALSE)]\n\n# En data.table, les instructions débutant par set modifient les éléments par référence, c'est-à-dire sans copie.\n# Ceci est plus efficace pour manipuler des données volumineuses.\nsetorder(donnees_datatable, \"identifiant\", \"date_entree\", na.last = FALSE)\nsetorder(donnees_datatable, identifiant, date_entree, na.last = FALSE)\nsetorderv(donnees_datatable, cols = c(\"identifiant\", \"date_entree\"), order = c(1L, 1L), na.last = FALSE)\n\n\n\n\n\n\n\n# Mettre les na en premier\ndonnees_python = donnees_python.sort_values(by=['identifiant', 'date_entree'], na_position='first')\n\n\n\n\n\n\n11.2.2 Tri par ordre décroissant\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Idem par ordre croissant d'identifiant et ordre décroissant de date d'entrée */\n\n/* 1ère possibilité */\nproc sort data = donnees_sas;by Identifiant descending Date_entree;run;\n\n/* 2e possibilité */\nproc sql;\n  create table donnees_sas as select * from donnees_sas\n  order by Identifiant, Date_entree desc;\nquit;\n\n\n\n# Tri par ordre croissant de identifiant et décroissant de date_entree\ndonnees_rbase &lt;- donnees_rbase[\n  order(donnees_rbase$identifiant, donnees_rbase$date_entree, \n        na.last = FALSE, \n        decreasing = c(FALSE, TRUE), \n        method = \"radix\"\n        )\n  , ]\n\n# Autre possibilité : - devant la variable (uniquement pour les variables numériques)\ndonnees_rbase &lt;- donnees_rbase[\n  order(donnees_rbase$identifiant, -donnees_rbase$duree, \n        na.last = FALSE)\n  , ]\n\n\n\n\n# Tri par ordre croissant de identifiant et décroissant de date_entree\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  arrange(identifiant, desc(date_entree))\n\n\n\n\n# Tri par ordre croissant de identifiant et décroissant de date_entree (- avant le nom de la variable)\ndonnees_datatable &lt;- donnees_datatable[order(identifiant, -date_entree, na.last = FALSE)]\nsetorder(donnees_datatable, \"identifiant\", -\"date_entree\", na.last = FALSE)\nsetorder(donnees_datatable, identifiant, -date_entree, na.last = FALSE)\nsetorderv(donnees_datatable, cols = c(\"identifiant\", \"date_entree\"), order = c(1L, -1L), na.last = FALSE)\n\n\n\n\n\n\n\ndonnees_python = donnees_python.sort_values(by=['identifiant', 'date_entree'], na_position='first', ascending=[True, False])",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#incidence-des-valeurs-manquantes-dans-les-tris",
    "href": "01-aide_memoire_r_sas.html#incidence-des-valeurs-manquantes-dans-les-tris",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "11.3 Incidence des valeurs manquantes dans les tris",
    "text": "11.3 Incidence des valeurs manquantes dans les tris\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Dans SAS, les valeurs manquantes sont considérées comme des valeurs négatives */\n\n/* Elles sont donc situées en premier dans un tri par ordre croissant ... */\nproc sort data = donnees_sas;by identifiant date_entree;run;proc print;run;\n\n/* ... et en dernier dans un tri par ordre décroissant */\nproc sort data = donnees_sas;by identifiant descending date_entree;run;\nproc print;run;\n\n\n\n# Les valeurs manquantes sont situées en dernier dans un tri par ordre croissant ou décroissant (car par défaut l'option na.last = TRUE) ...\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree), ]\n\n# SAS considère les valeurs manquantes comme des nombres négatifs faibles.\n# Pour mimer le tri par ordre croissant en SAS :\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]\n\n# Pour mimer le tri par ordre décroissant en SAS :\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, is.na(donnees_rbase$date_entree), donnees_rbase$date_entree,\n                                     na.last = FALSE,\n                                     decreasing = c(FALSE, FALSE, TRUE),\n                                     method = \"radix\"), ]\n\n\n\n\n# Attention, avec arrange, les variables manquantes (NA) sont toujours classées en dernier, même avec desc()\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  arrange(identifiant, date_entree)\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  arrange(identifiant, desc(date_entree))\n\n# Or, SAS considère les valeurs manquantes comme des nombres négatifs faibles.\n# Elles sont donc classées en premier dans un tri par ordre croissant, et en dernier dans un tri par ordre décroissant\n\n# Pour mimer le tri par ordre croissant en SAS : les valeurs manquantes de date_entree sont classées en premier\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  arrange(identifiant, !is.na(date_entree), date_entree)\n\n# Pour mimer le tri par ordre décroissant en SAS\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  arrange(identifiant, desc(date_entree))\n\n\n\n\n# Les valeurs manquantes sont situées en dernier dans un tri par ordre croissant ou décroissant (car par défaut l'option na.last = TRUE) ...\ndonnees_datatable &lt;- donnees_datatable[order(identifiant, date_entree)]\n\n# SAS considère les valeurs manquantes comme des nombres négatifs faibles.\n# Pour mimer le tri par ordre croissant en SAS :\nsetorderv(donnees_datatable, cols = c(\"identifiant\", \"date_entree\"), order = c(1L, 1L), na.last = FALSE)\n\n# Pour mimer le tri par ordre décroissant en SAS :\ndonnees_datatable[, date_entree_na := is.na(date_entree)]\nsetorderv(donnees_datatable, cols = c(\"identifiant\", \"date_entree_na\", \"date_entree\"), order = c(1L, 1L, -1L), na.last = FALSE)\ndonnees_datatable[, date_entree_na := NULL]\n\n\n\n\n# Les valeurs manquantes sont situées en dernier dans un tri par ordre croissant ou décroissant (car par défaut l'option na.last = TRUE) ...\nrequete_duckdb %&gt;% \n  arrange(Identifiant, Note_Contenu) %&gt;% \n  select(Identifiant, Note_Contenu)\n  \n# Pour mimer le tri par ordre croissant en SAS :\n# Note : il faut faire select d'abord, sinon il y a une erreur quand \"! is.na()\" est dans la liste des colonnes\nrequete_duckdb %&gt;% \n  select(Identifiant, Note_Contenu) %&gt;% \n  arrange(Identifiant, ! is.na(Note_Contenu), Note_Contenu)\n\n# Pour mimer le tri par ordre décroissant en SAS :\n# Note : il faut faire select d'abord, sinon il y a une erreur quand \"! is.na()\" est dans la liste des colonnes\nrequete_duckdb %&gt;% \n  select(Identifiant, Note_Contenu) %&gt;% \n  arrange(Identifiant, is.na(Note_Contenu), Note_Contenu)\n\n\n\n\n# Les valeurs manquantes sont situées en dernier dans un tri par ordre croissant ou décroissant\ndonnees_python = donnees_python.sort_values(by=['identifiant', 'date_entree'])\n\n# SAS considère les valeurs manquantes comme des nombres négatifs faibles.\n# Pour mimer le tri par ordre croissant en SAS : ajouter l'option na_position = 'first'\ndonnees_python = donnees_python.sort_values(by=['identifiant', 'date_entree'], na_position='first')\n\n# Pour mimer le tri par ordre décroissant en SAS :\ndonnees_python = donnees_python.sort_values(by=['identifiant', 'date_entree'], ascending=[True, False])",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#trier-par-ordre-croissant-de-toutes-les-variables-de-la-base",
    "href": "01-aide_memoire_r_sas.html#trier-par-ordre-croissant-de-toutes-les-variables-de-la-base",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "11.4 Trier par ordre croissant de toutes les variables de la base",
    "text": "11.4 Trier par ordre croissant de toutes les variables de la base\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nproc sort data = donnees_sas;by _all_;run;\n\n\n\ntri_toutes_variables &lt;- donnees_rbase[order(colnames(donnees_rbase), na.last = FALSE)]\n\n\n\n\ntri_toutes_variables &lt;- donnees_tidyverse %&gt;% \n  arrange(pick(everything()))\ntri_toutes_variables &lt;- donnees_tidyverse %&gt;% \n  arrange(across(everything()))\n\n\n\n\ntri_toutes_variables &lt;- setorderv(donnees_datatable, na.last = FALSE)\n\n\n\n\n\n\n\ndonnees_python = donnees_python.sort_values(by=list(donnees_python.columns), na_position='first')",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#doublons-pour-toutes-les-colonnes",
    "href": "01-aide_memoire_r_sas.html#doublons-pour-toutes-les-colonnes",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "12.1 Doublons pour toutes les colonnes",
    "text": "12.1 Doublons pour toutes les colonnes\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* On extrait seulement les doublons, pas la première occurrence */\n\n/* On récupère déjà la dernière variable de la base (on en aura besoin plus loin) */\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql noprint;\n  select name into :derniere_var\n  from Var\n  where varnum = (select max(varnum) from Var);\nquit;\nproc sort data = donnees_sas;by &nom_col.;run;\ndata Doublons;\n  set donnees_sas;\n  by &nom_col.;\n  if not (first.&derniere_var. and last.&derniere_var.);\nrun;\n\n\n\n# On extrait seulement les doublons, pas la première occurrence\ndoublons &lt;- donnees_rbase[duplicated(donnees_rbase), ]\n\n\n\n\n# On extrait seulement les doublons, pas la première occurrence\ndonnees_tidyverse %&gt;% \n  group_by(across(everything())) %&gt;% \n  filter(n() &gt; 1) %&gt;% \n  slice(-1) %&gt;% \n  ungroup()\n\n# Autre solution\ndoublons &lt;- donnees_tidyverse %&gt;%  \n  group_by_all() %&gt;% \n  filter(n() &gt; 1) %&gt;%\n  slice(-1) %&gt;%\n  ungroup()\n\n\n\n\n# On extrait seulement les doublons, pas la première occurrence\ndoublons &lt;- donnees_datatable[duplicated(donnees_datatable), ]\n\n\n\n\n\n\n\n# On extrait seulement les doublons, pas la première occurrence\ndoublons = donnees_python[donnees_python.duplicated()]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#doublons-pour-une-ou-plusieurs-colonnes",
    "href": "01-aide_memoire_r_sas.html#doublons-pour-une-ou-plusieurs-colonnes",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "12.2 Doublons pour une ou plusieurs colonnes",
    "text": "12.2 Doublons pour une ou plusieurs colonnes\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* On extrait seulement les doublons, pas la première occurrence */\n%let var = identifiant;\nproc sort data = donnees_sas;by &var.;run;\ndata doublons;\n  set donnees_sas;\n  by &var.;\n  if not first.&var.;\nrun;\n\n/* À FAIRE : nodupkey ??? */\n\n\n\n# On extrait seulement les doublons, pas la première occurrence\nvariable &lt;- \"identifiant\"\ndoublons &lt;- donnees_rbase[duplicated(donnees_rbase[, variable]), ]\n\n\n\n\n# On extrait seulement les doublons, pas la première occurrence\nvariable &lt;- \"identifiant\"\ndoublons &lt;- donnees_tidyverse %&gt;%  \n  group_by(across(variable)) %&gt;% \n  filter(n() &gt; 1) %&gt;%\n  slice(-1) %&gt;%\n  ungroup()\n\n\n\n\n# On extrait seulement les doublons, pas la première occurrence\nvariable &lt;- \"identifiant\"\ndoublons &lt;- donnees_datatable[duplicated(donnees_datatable[, ..variable]), ]\n\n\n\n\n\n\n\n# On extrait seulement les doublons, pas la première occurrence\nvariable = \"identifiant\"\ndoublons = donnees_python[donnees_python[variable].duplicated()]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#récupérer-toutes-les-lignes-pour-les-identifiants-en-doublon",
    "href": "01-aide_memoire_r_sas.html#récupérer-toutes-les-lignes-pour-les-identifiants-en-doublon",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "12.3 Récupérer toutes les lignes pour les identifiants en doublon",
    "text": "12.3 Récupérer toutes les lignes pour les identifiants en doublon\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n%let var = identifiant;\n/* On groupe par la colonne identifiant, et si on aboutit à strictement plus d'une ligne, c'est un doublon */\nproc sql;\n  create table enDouble as\n  select * from donnees_sas\n  group by &var.\n  having count(*) &gt; 1;\nquit;\n\n\n\nvariable &lt;- \"identifiant\"\nenDouble &lt;- donnees_rbase[donnees_rbase[, variable] %in% \n                            donnees_rbase[duplicated(donnees_rbase[, variable]), variable]]\n\n\n\n\nvariable &lt;- \"identifiant\"\nenDouble &lt;- donnees_tidyverse %&gt;%  \n  group_by(across(variable)) %&gt;% \n  filter(n() &gt; 1) %&gt;%\n  ungroup()\n\n\n\n\nvariable &lt;- \"identifiant\"\nenDouble &lt;- donnees_datatable[donnees_datatable[[variable]] %chin%\n                                donnees_datatable[[variable]][duplicated(donnees_datatable[[variable]])], ]\n\n\n\n\n\n\n\nvariable = 'identifiant'\n\n# Identifier les valeurs dupliquées\ndoublons_values = donnees_python[variable][donnees_python[variable].duplicated()]\n\n# Filtrer les lignes qui contiennent ces valeurs dupliquées\nenDouble = donnees_python[donnees_python[variable].isin(doublons_values)]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#récupérer-toutes-les-lignes-pour-les-identifiants-sans-doublon",
    "href": "01-aide_memoire_r_sas.html#récupérer-toutes-les-lignes-pour-les-identifiants-sans-doublon",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "12.4 Récupérer toutes les lignes pour les identifiants sans doublon",
    "text": "12.4 Récupérer toutes les lignes pour les identifiants sans doublon\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n%let var = identifiant;\nproc sql;\n  create table sansDouble as\n  select * from donnees_sas\n  group by &var.\n  having count(*) = 1;\nquit;\n\n\n\nvariable &lt;- \"identifiant\"\nsansDouble &lt;- donnees_rbase[! donnees_rbase[, variable] %in%\n                              donnees_rbase[duplicated(donnees_rbase[, variable]), variable]]\n\n\n\n\nvariable &lt;- \"identifiant\"\nsansDouble &lt;- donnees_tidyverse %&gt;%  \n  group_by(across(variable)) %&gt;% \n  filter(n() == 1) %&gt;%\n  ungroup()\n\n\n\n\nvariable &lt;- \"identifiant\"\nsansDouble &lt;- donnees_datatable[! donnees_datatable[[variable]] %chin%\n                                  donnees_datatable[[variable]][duplicated(donnees_datatable[[variable]])], ]\nsansDouble &lt;- donnees_datatable[donnees_datatable[[variable]] %notin%\n                                donnees_datatable[[variable]][duplicated(donnees_datatable[[variable]])], ]\n\n\n\n\n\n\n\nvariable = 'identifiant'\n\n# Identifier les valeurs dupliquées\ndoublons_values = donnees_python[variable][donnees_python[variable].duplicated()]\n\n# Filtrer les lignes qui contiennent ces valeurs dupliquées\nsansDouble = donnees_python[~donnees_python[variable].isin(doublons_values)]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#suppression-des-doublons-pour-lensemble-des-variables",
    "href": "01-aide_memoire_r_sas.html#suppression-des-doublons-pour-lensemble-des-variables",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "12.5 Suppression des doublons pour l’ensemble des variables",
    "text": "12.5 Suppression des doublons pour l’ensemble des variables\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* 1ère méthode */\nproc sort data = donnees_sas nodupkey;\n  by _all_;\nrun;\n\n/* 2e méthode, avec first. et last. (cf. infra) */\n/* On récupère déjà la dernière variable de la base (on en aura besoin plus loin) */\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql noprint;\n  select name into :derniere_var from Var\n  where varnum = (select max(varnum) from Var);\nquit;\nproc sql noprint;\n  select name into :nom_col separated by \" \" from Var order by varnum;\nquit;\n%put Dernière variable de la base : &derniere_var.;\nproc sort data = donnees_sas;by &nom_col.;run;\ndata sansDouble;\n  set donnees_sas;\n  by &nom_col.;\n  if first.&derniere_var.;\nrun;\n\n\n\ndonnees_rbase_sansdoublon &lt;- unique(donnees_rbase)\ndonnees_rbase_sansdoublon &lt;- donnees_rbase[! duplicated(donnees_rbase), ]\n\n# Autre solution (équivalente à la solution first. de SAS)\ndonnees_rbase_sansdoublon &lt;- donnees_rbase[order(colnames(donnees_rbase), na.last = FALSE), ]\ndonnees_rbase_sansdoublon &lt;- donnees_rbase[! duplicated(donnees_rbase[, colnames(donnees_rbase)], fromLast = TRUE), ]\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  arrange(pick(everything())) %&gt;% \n  distinct()\n\n# Autre solution\ndonnees_tidyverse_sansdoublon &lt;- donnees_tidyverse %&gt;% \n  arrange(across(everything())) %&gt;% \n  distinct()\n\n\n\n\ndonnees_datatable_sansdoublon &lt;- unique(donnees_datatable)\ndonnees_datatable_sansdoublon &lt;- donnees_datatable[! duplicated(donnees_datatable), ]\n\n\n\n\n\n\n\ndonnees_python_sansdoublon = donnees_python.drop_duplicates()",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#suppression-des-doublons-pour-une-seule-variable",
    "href": "01-aide_memoire_r_sas.html#suppression-des-doublons-pour-une-seule-variable",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "12.6 Suppression des doublons pour une seule variable",
    "text": "12.6 Suppression des doublons pour une seule variable\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nproc sort data = donnees_sas;by _all_;run;\ndata sansDouble;\n  set donnees_sas;\n  by _all_;\n  if first.identifiant;\nrun;\n\n\n\ndonnees_rbase &lt;- donnees_rbase[order(colnames(donnees_rbase), na.last = FALSE), ]\nsansDouble &lt;- donnees_rbase[! duplicated(donnees_rbase$identifiant), , drop = FALSE]\n\n\n\n\n# L'option .keep_all = TRUE est nécessaire \n# À FAIRE : REVOIR LE TRI PAR RAPPORT A SAS !!!\nsansDouble &lt;- donnees_tidyverse %&gt;% \n  arrange(pick(everything())) %&gt;% \n  distinct(identifiant, .keep_all = TRUE)\nsansDouble &lt;- donnees_tidyverse %&gt;% \n  arrange(across(everything())) %&gt;% \n  distinct(identifiant, .keep_all = TRUE)\n\n\n\n\nsetorderv(donnees_datatable, cols = colnames(donnees_datatable), na.last = FALSE)\nsansDouble &lt;- donnees_datatable[! duplicated(donnees_datatable[, c(\"identifiant\")]), ]\n\n\n\n\n\n\n\n# Trier le DataFrame par toutes les colonnes avec les valeurs NaN en premier\ndonnees_python_sorted = donnees_python.sort_values(by=donnees_python.columns.tolist(), na_position='first')\n\n# Supprimer les doublons en gardant la première occurrence pour chaque identifiant\nsansDouble = donnees_python_sorted.drop_duplicates(subset=['identifiant'], keep='first')",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#identifiants-uniques",
    "href": "01-aide_memoire_r_sas.html#identifiants-uniques",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "12.7 Identifiants uniques",
    "text": "12.7 Identifiants uniques\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nproc sql;\n  create table id as select distinct identifiant from donnees_sas order by identifiant;\nquit;\n\n/* Autre possibilité */\nproc sort data = donnees_sas;by identifiant;run;\ndata id;\n  set donnees_sas (keep = identifiant);\n  by identifiant;\n  if first.identifiant;\nrun;\n\n\n\n# Sous forme de data.frame\nunique(donnees_rbase[\"identifiant\"])\n\n# Sous forme de vecteur\nunique(donnees_rbase[, \"identifiant\"])\nunique(donnees_rbase[[\"identifiant\"]])\n\n\n\n\n# Sous forme de tibble\ndonnees_tidyverse %&gt;%\n  distinct(identifiant)\n# Sous forme de vecteur\ndonnees_tidyverse %&gt;% distinct(identifiant) %&gt;% pull()\n\n\n\n\n# Sous forme de data.table\nunique(donnees_datatable[, \"identifiant\"])\n# Sous forme de vecteur\nunique(donnees_datatable[[\"identifiant\"]])\n\n\n\n\n\n\n\n# Sous forme de liste (vecteur) :\nlist(pd.unique(donnees_python['identifiant']))\n\n# Dataframe\n# Convertir les valeurs uniques en DataFrame\ndonnees_python[['identifiant']].drop_duplicates().reset_index(drop=True)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#nombre-de-lignes-uniques-sans-doublon",
    "href": "01-aide_memoire_r_sas.html#nombre-de-lignes-uniques-sans-doublon",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "12.8 Nombre de lignes uniques, sans doublon",
    "text": "12.8 Nombre de lignes uniques, sans doublon\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nproc contents data = donnees_sas out = Var noprint;run;\nproc sql noprint;select name into :nom_col separated by \", \" from Var order by varnum;quit;\nproc sql;\n  select count(*) as Nb_Lignes_Uniques\n  from (select &nom_col., count(*) from donnees_sas group by &nom_col.);\nquit;\n\n\n\nnrow(unique(donnees_rbase))\n\n\n\n\ndonnees_tidyverse %&gt;%\n  distinct() %&gt;% \n  nrow()\n\n\n\n\nuniqueN(donnees_datatable)\n\n\n\n\n\n\n\ndonnees_python.drop_duplicates().shape[0]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#transposer-une-base-1",
    "href": "01-aide_memoire_r_sas.html#transposer-une-base-1",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "13.1 Transposer une base",
    "text": "13.1 Transposer une base\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* On commence déjà par calculer un tableau croisé comptant les occurrences */\nproc freq data = donnees_sas;table Sexef * cspf / out = Nb;run;\nproc sort data = Nb;by cspf Sexef;run;\nproc print data = Nb;run;\n\n/* On transpose le tableau */\nproc transpose data = Nb out = transpose;\n  by cspf;\n  var count;\n  id Sexef;\nrun;\ndata transpose;set transpose (drop = _name_ _label_);run;\nproc print data = transpose;run;\n\n\n\n# On commence déjà par calculer un tableau croisé comptant les occurrences\n# as.data.frame.matrix est nécessaire, car le résultat de xtabs est un array\nnb &lt;- as.data.frame.matrix(xtabs( ~ cspf + sexef, data = donnees_rbase))\n\n# On transpose le tableau\n# t() renvoie un objet matrix, d'où le as.data.frame\nnb_transpose &lt;- as.data.frame(t(nb))\n\n\n\n\n# On commence déjà par calculer un tableau croisé comptant les occurrences\nnb &lt;- donnees_tidyverse %&gt;% \n  count(cspf, sexef) %&gt;% \n  spread(sexef, n)\n\n# On transpose le tableau (on fait passer sexef en ligne et cspf en colonne)\nnb_transpose &lt;- nb %&gt;% \n  # Créer les combinaisons de cspf et sexef en ligne\n  pivot_longer(cols = -cspf, names_to = \"sexef\") %&gt;% \n  # Mettre sexef en ligne et cspf en colonne\n  pivot_wider(names_from = cspf, values_from = value, values_fill = 0)\n\n# Autre solution avec les packages janitor et sjmisc\nlibrary(janitor)\nlibrary(sjmisc)\nnb &lt;- donnees_tidyverse %&gt;%\n  janitor::tabyl(cspf, sexef) %&gt;% \n  # colonne cspf comme nom de ligne\n  column_to_rownames(var=\"cspf\")\nnb_transpose &lt;- nb %&gt;%\n  sjmisc::rotate_df()\n\n\n\n\n# Etablissement d'un tableau croisé comptant les occurrences\nnb &lt;- donnees_datatable[, .N, by = list(cspf, sexef)]\nnb &lt;- dcast(nb, cspf ~ sexef, value.var = \"N\")\n\n# On transpose le tableau\ntranspose(nb, keep.names = \"sexef\", make.names = \"cspf\")\n# Autre solution\ndcast(melt(nb, id.vars = \"cspf\", variable.name = \"sexef\"), sexef ~ cspf)\n\n\n\n\n\n\n\n# Tableau croisé en python :\nnb = pd.crosstab(donnees_python['cspf'], donnees_python['sexef'])\n# Transposer le tableau croisé\nnb_transpose = nb.T",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#passer-dune-base-en-largeur-wide-à-une-base-en-longueur-long",
    "href": "01-aide_memoire_r_sas.html#passer-dune-base-en-largeur-wide-à-une-base-en-longueur-long",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "13.2 Passer d’une base en largeur (wide) à une base en longueur (long)",
    "text": "13.2 Passer d’une base en largeur (wide) à une base en longueur (long)\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Note moyenne par identifiant */\n/* On va créer une base Wide avec les notes en colonne et les identifiants en ligne */\n%let notes = note_contenu note_formateur note_moyens note_accompagnement note_materiel;\nproc sort data = donnees_sas;by identifiant;run;\nproc means data = donnees_sas mean noprint;var &notes.;output out = Temp;by identifiant;run;\ndata Wide;\n  set Temp (where = (_STAT_ = \"MEAN\") drop = _TYPE_ _FREQ_);\n  keep identifiant &notes.;\n  drop _STAT_;\nrun;\n\n/* On passe de Wide à Long */\n/* On met les notes en ligne */\nproc transpose data = Wide out = Long;by Identifiant;var &notes.;run;\n\n\nLien utile : https://stats.oarc.ucla.edu/r/faq/how-can-i-reshape-my-data-in-r/.\n\n# On souhaite mettre les notes en ligne et non en colonne\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\n# Note moyenne par identifiant\nwide_rbase &lt;- aggregate(donnees_rbase[, varNotes], donnees_rbase[, \"identifiant\", drop = FALSE], mean, na.rm = TRUE)\n\nlong_rbase &lt;- reshape(data          = wide_rbase,\n                      varying       = varNotes,\n                      v.names       = \"notes\",\n                      timevar       = \"type_note\",\n                      times         = varNotes,\n                      new.row.names = NULL,\n                      direction     = \"long\")\nlong_rbase &lt;- long_rbase[order(long_rbase$identifiant), ]\nrow.names(long_rbase) &lt;- NULL\n\n\n\n\n# On souhaite mettre les notes en ligne et non en colonne\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\n# Note moyenne par identifiant\nwide_tidyverse &lt;- donnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;% \n  summarise(across(all_of(varNotes), ~ mean(.x, na.rm = TRUE)))\n\n# On l'exprime en format long\n# Mise en garde : ne pas écrire value_to !\nlong_tidyverse &lt;- wide_tidyverse %&gt;% \n  pivot_longer(cols      = !identifiant,\n               names_to  = \"type_note\",\n               values_to = \"note\") %&gt;% \n  arrange(type_note, identifiant)\n\n\n\n\n# On souhaite mettre les notes en ligne et non en colonne\n# Note moyenne par identifiant\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nwide_datatable &lt;- donnees_datatable[, lapply(.SD, mean, na.rm = TRUE), by = identifiant, .SDcols = varNotes]\n\nlong_datatable &lt;- melt(wide_datatable,\n                       id.vars       = c(\"identifiant\"),\n                       measure.vars  = varNotes,\n                       variable.name = \"type_note\",\n                       value.name    = \"note\")\n\n\n\n\n\n\n\n# On souhaite mettre les notes en ligne et non en colonne\nvarNotes = [\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\"]\n\n# Calculer la note moyenne par identifiant\nwide_python = donnees_python.groupby('identifiant')[varNotes].mean().reset_index()\n\n# Transformer les données de large à long\nlong_python = wide_python.melt(id_vars=['identifiant'], \n                             value_vars=varNotes, \n                             var_name='type_note', \n                             value_name='notes')\n\n# Trier par identifiant\nlong_python = long_python.sort_values(by='identifiant').reset_index(drop=True)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#passer-dune-base-en-longueur-long-à-une-base-en-largeur-wide",
    "href": "01-aide_memoire_r_sas.html#passer-dune-base-en-longueur-long-à-une-base-en-largeur-wide",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "13.3 Passer d’une base en longueur (long) à une base en largeur (wide)",
    "text": "13.3 Passer d’une base en longueur (long) à une base en largeur (wide)\nLe code précédent doit être lancé au préalable.\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* On souhaite mettre les notes en ligne et non en colonne */\n/* On commence par calculer les notes moyennes par identifiant */\n%let notes = note_contenu note_formateur note_moyens note_accompagnement note_materiel;\nproc sort data = donnees_sas;by identifiant;run;\nproc means data = donnees_sas mean noprint;var &notes.;output out = Temp;by identifiant;run;\ndata Wide;\n  set Temp (where = (_STAT_ = \"MEAN\") drop = _TYPE_ _FREQ_);\n  keep identifiant &notes.;\n  drop _STAT_;\nrun;\n\n/* On passe de Wide à Long */\nproc transpose data = Wide out = Long;by Identifiant;var &notes.;run;\ndata Long;set Long (rename = (_NAME_ = Type_Note COL1 = Note));run;\n\n/* On passe de Long à Wide */\nproc transpose data = Long out = Wide;\n  by Identifiant;\n  var Note;\n  id Type_Note;\nrun;\n\n\nLien utile : https://stats.oarc.ucla.edu/r/faq/how-can-i-reshape-my-data-in-r/.\n\n# Passer de long à wide : on souhaite revenir à la situation initiale\nwide_rbase &lt;- reshape(long_rbase,\n                      timevar = \"type_note\",\n                      idvar = c(\"identifiant\", \"id\"),\n                      direction = \"wide\")\n\n\n\n\n# Passer de long à wide : on souhaite revenir à la situation initiale\n# Mise en garde : ne pas écrire value_from !\nwide_tidyverse &lt;- pivot_wider(long_tidyverse, \n                              names_from  = type_note,\n                              values_from = note)\n\n\n\n\nwide_datatable &lt;- dcast(long_datatable, identifiant ~ type_note, value.var = \"note\")\n\n\n\n\n\n\n\nwide_python = long_python.pivot_table(index='identifiant', \n                                      columns='type_note', \n                                      values='notes').reset_index()",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#numéroter-les-lignes",
    "href": "01-aide_memoire_r_sas.html#numéroter-les-lignes",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "14.1 Numéroter les lignes",
    "text": "14.1 Numéroter les lignes\n\n14.1.1 Numéroter les lignes de la base\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata donnees_sas;\n  set donnees_sas;\n  Num_observation = _n_;\nrun;\n\n/* Autre solution */\nproc sql noprint;select count(*) into :nbLignes from donnees_sas;quit;\ndata numLigne;do Num_observation = 1 to &nbLignes.;output;end;run;\n/* Autre possibilité */\ndata _NULL_;\n  set donnees_sas nobs = n;\n  call symputx('nbLignes', n);\nrun;\n%put Nombre de lignes : &nbLignes.;\n\n/* Le merge \"simple\" (sans by) va seulement concaténer les deux bases l'une à côté de l'autre */\ndata donnees_sas;\n  merge donnees_sas numLigne;\nrun;\n\n\n\n# Numéro de l'observation : 2 manières différentes\ndonnees_rbase$num_observation &lt;- seq(1, nrow(donnees_rbase))\ndonnees_rbase$num_observation &lt;- seq_len(nrow(donnees_rbase))\ndonnees_rbase$num_observation &lt;- row.names(donnees_rbase)\n\n\n\n\n# Numéro de l'observation\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  mutate(num_observation = row_number())\n\n\n\n\n# Numéro de l'observation : 2 manières différentes\ndonnees_datatable[, num_observation := .I]\ndonnees_datatable[, num_observation := seq_len(.N)]\n\n\n\n\n\n\n\n# Python commence le compte à 0 (penser à ajouter 1 pour coïncider avec la numérotation de R)\ndonnees_python['num_observation'] = range(1, len(donnees_python) + 1)\n\ndonnees_python['num_observation'] = donnees_python.index + 1\n\n\n\n\n\n\n14.1.2 Numéroter les contrats de l’individu\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Numéro du contrat de chaque individu, contrat trié par date d'entrée */\nproc sort data = donnees_sas;by identifiant date_entree;run;\n\ndata donnees_sas;\n  set donnees_sas;\n  by identifiant date_entree;\n  retain num_contrat;\n  if first.identifiant then num_contrat = 1;\n  else                      num_contrat = num_contrat + 1;\nrun;\n\n\n\n# Numéro du contrat de chaque individu, contrat trié par date d'entrée\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]\ndonnees_rbase$un &lt;- 1\n# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN = !\ndonnees_rbase$numero_contrat &lt;- ave(donnees_rbase$un, donnees_rbase$identifiant, FUN = cumsum)\ndonnees_rbase$un &lt;- NULL\n\n# Autre solution\n# Utiliser seq_along ne nécessite pas un tri préalable !\ndonnees_rbase$numero_contrat &lt;- as.numeric(ave(donnees_rbase$identifiant, donnees_rbase$identifiant, FUN = seq_along))\n\n# Autre solution : order pour éviter le as.numeric\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]\ndonnees_rbase$numero_contrat &lt;- ave(order(donnees_rbase$date_entree), donnees_rbase$identifiant, FUN = seq_along)\n\n\n\n\n# Numéro du contrat de chaque individu, contrat trié par date d'entrée\n# arrange() va permettre de trier les observations par identifiant et date d'entrée \ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  mutate(numero_contrat = row_number()) %&gt;% \n  ungroup()\n# À FAIRE : Dans group_by, à quoi sert le drop ?\n\n\n\n\n# Numéro du contrat de chaque individu, contrat trié par date d'entrée\nsetorder(donnees_datatable, \"identifiant\", \"date_entree\", na.last = FALSE)\ndonnees_datatable[, numero_contrat := rowid(identifiant)]\ndonnees_datatable[, numero_contrat := seq_len(.N), by = identifiant]\n\n# Les seuls numéros de colonnes\nrowidv(donnees_datatable, identifiant)\n\n\n\n\n\n\n\n# 1. Trier les données par 'identifiant' et 'date_entree'\ndonnees_python = donnees_python.sort_values(by=['identifiant', 'date_entree'])\n\n# 2. Créer le numéro de contrat\ndonnees_python['numero_contrat'] = donnees_python.groupby('identifiant').cumcount() + 1",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#première-et-dernière-ligne-par-identifiant",
    "href": "01-aide_memoire_r_sas.html#première-et-dernière-ligne-par-identifiant",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "14.2 Première et dernière ligne par identifiant",
    "text": "14.2 Première et dernière ligne par identifiant\n\n14.2.1 Première ligne par identifiant\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nproc sort data = donnees_sas;by identifiant date_entree;run;\n/* L'instruction options permet de ne pas afficher d'erreur si la variable numero_contrat n'existe pas */\noptions dkricond=nowarn dkrocond=nowarn;\ndata donnees_sas;\n  set donnees_sas (drop = numero_contrat);\n  by identifiant date_entree;\n  retain numero_contrat 0;\n  if first.identifiant then numero_contrat = 1;\n  else                      numero_contrat = numero_contrat + 1;\nrun;\n\noptions dkricond=warn dkrocond=warn;\n/* Pour trier les colonnes */\ndata donnees_sas;\n  retain identifiant date_entree numero_contrat numero_contrat;\n  set donnees_sas;\nrun;\n\n\n\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]\ndonnees_rbase[! duplicated(donnees_rbase$identifiant), , drop = FALSE]\n\n\n\n\ndonnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;%\n  filter(row_number() == 1) %&gt;% \n  ungroup()\n\n# Autres solutions\ndonnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;%\n  slice(1) %&gt;% \n  ungroup()\n\ndonnees_tidyverse %&gt;%  \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;%\n  slice_head(n = 1) %&gt;% \n  ungroup()\n\ndonnees_tidyverse %&gt;%  \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;%\n  filter(row_number() == nth(row_number(), 1)) %&gt;%\n  ungroup()\n\n\n\n\ndonnees_datatable[, .SD[1], by = identifiant]\n\n# On peut aussi utiliser keyby si l'on souhaite que les résultats soient triés par la variable de groupement (ici identifiant)\ndonnees_datatable[, .SD[1], keyby = identifiant]\n\n\n\n\n\n\n\ndonnees_python.drop_duplicates(subset='identifiant', keep='first')\n\n\n\n\n\n\n14.2.2 Dernière ligne par identifiant\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nproc sort data = donnees_sas;by identifiant date_entree;run;\n/* L'instruction options permet de ne pas afficher d'erreur si la variable numero_contrat n'existe pas */\noptions dkricond=nowarn dkrocond=nowarn;\ndata donnees_sas;\n  set donnees_sas (drop = numero_contrat);\n  by identifiant date_entree;\n  retain numero_contrat 0;\n  if first.identifiant then numero_contrat = 1;\n  else                      numero_contrat = numero_contrat + 1;\nrun;\n\noptions dkricond=warn dkrocond=warn;\n/* Pour trier les colonnes */\ndata donnees_sas;\n  retain identifiant date_entree numero_contrat numero_contrat;\n  set donnees_sas;\nrun;\n\n\n\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]\ndonnees_rbase[! duplicated(donnees_rbase$identifiant, fromLast = TRUE), , drop = FALSE]\n\n\n\n\ndonnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;%\n  filter(row_number() == n()) %&gt;% \n  ungroup()\n\n# Autres solutions\ndonnees_tidyverse %&gt;%  \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;%\n  slice(n()) %&gt;% \n  ungroup()\n\ndonnees_tidyverse %&gt;%  \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;%\n  filter(row_number() == nth(row_number(), -1)) %&gt;%\n  ungroup()\n\n\n\n\ndonnees_datatable[, .SD[.N], by = identifiant]\n\n\n\n\n\n\n\ndonnees_python.drop_duplicates(subset='identifiant', keep='last')",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#le-premier-contrat-le-dernier-contrat-ni-le-premier-ni-le-dernier-contrat-de-chaque-individu",
    "href": "01-aide_memoire_r_sas.html#le-premier-contrat-le-dernier-contrat-ni-le-premier-ni-le-dernier-contrat-de-chaque-individu",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "14.3 Le premier contrat, le dernier contrat, ni le premier ni le dernier contrat de chaque individu",
    "text": "14.3 Le premier contrat, le dernier contrat, ni le premier ni le dernier contrat de chaque individu\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nproc sort data = donnees_sas;by identifiant date_entree;run;\ndata donnees_sas;\n  set donnees_sas;\n  by identifiant date_entree;\n  Premier_Contrat = (first.identifiant = 1);\n  Dernier_Contrat = (last.identifiant = 1);\n  Ni_Prem_Ni_Der  = (first.identifiant = 0 and last.identifiant = 0);\nrun;\n\n\n\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]\ndonnees_rbase$premier_contrat &lt;- ifelse(! duplicated(donnees_rbase$identifiant, fromLast = FALSE), \n                                        1, 0)\ndonnees_rbase$dernier_contrat &lt;- ifelse(! duplicated(donnees_rbase$identifiant, fromLast = TRUE), \n                                        1, 0)\ndonnees_rbase$ni_prem_ni_der  &lt;- ifelse(! c(! duplicated(donnees_rbase$identifiant, fromLast = FALSE) | ! duplicated(donnees_rbase$identifiant, fromLast = TRUE)), \n                                        1, 0)\n\n\n\n\n# Premier contrat\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  group_by(identifiant) %&gt;% \n  mutate(premier_contrat = ifelse(row_number() == 1, 1, 0)) %&gt;% \n  ungroup()\n\n# Dernier contrat\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  group_by(identifiant) %&gt;% \n  mutate(dernier_contrat = ifelse(row_number() == n(), 1, 0)) %&gt;% \n  ungroup()\n\n# Ni le premier, ni le dernier contrat\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  group_by(identifiant) %&gt;% \n  mutate(ni_prem_ni_der = ifelse( ! (row_number() == n() | row_number() == 1), 1, 0)) %&gt;% \n  ungroup()\n\n\n\n\ndonnees_datatable &lt;- donnees_datatable[order(identifiant, date_entree, na.last = FALSE)]\ndonnees_datatable[, premier_contrat := fifelse(! duplicated(identifiant, fromLast = FALSE), \n                                               1, 0)]\ndonnees_datatable[, dernier_contrat := fifelse(! duplicated(identifiant, fromLast = TRUE), \n                                               1, 0)]\ndonnees_datatable[, ni_prem_ni_der  := fifelse(! c(! duplicated(identifiant, fromLast = FALSE) | ! duplicated(identifiant, fromLast = TRUE)), \n                                               1, 0)]\n\n\n\n\n\n\n\n# 1. Trier les données par 'identifiant' et 'date_entree'\ndonnees_python = donnees_python.sort_values(by=['identifiant', 'date_entree'])\n\n# Premier contrat\ndonnees_python['premier_contrat'] = 1 - donnees_python.duplicated(subset='identifiant', keep='first').astype(int)\n\n# Dernier contrat\ndonnees_python['dernier_contrat'] = 1 - donnees_python.duplicated(subset='identifiant', keep='last').astype(int)\n\n# Ni premier ni dernier contrat\ndonnees_python['ni_prem_ni_der'] = (~donnees_python['premier_contrat'].astype(bool) & ~donnees_python['dernier_contrat'].astype(bool)).astype(int)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélection-de-lignes-par-identifiant",
    "href": "01-aide_memoire_r_sas.html#sélection-de-lignes-par-identifiant",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "14.4 Sélection de lignes par identifiant",
    "text": "14.4 Sélection de lignes par identifiant\n\n14.4.1 Les 2 premières lignes de chaque identifiant\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Numéro du contrat */\nproc sort data = donnees_sas;by identifiant date_entree;run;\ndata donnees_sas;\n  set donnees_sas;\n  by identifiant date_entree;\n  retain num_contrat;\n  if first.identifiant then num_contrat = 1;\n  else                      num_contrat = num_contrat + 1;\nrun;\n\nproc sort data = donnees_sas;by identifiant numero_contrat;run;\nproc sql;\n  select * from donnees_sas group by identifiant\n  having numero_contrat &lt;= 2;\nquit;\n\n\n\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]\n\n# En utilisant la fonction by\ndeux_premieres_lignes &lt;- Reduce(rbind, by(donnees_rbase, donnees_rbase[\"identifiant\"], head, 2))\n\n# En utilisant la fonction split pour découper par identifiant, et en ne retenant que les deux premières lignes des groupes créés\ndeux_premieres_lignes &lt;- do.call(rbind, \n                                 lapply(\n                                   split(donnees_rbase, donnees_rbase$identifiant), head, 2\n                                   ))\n\n# On peut aussi utiliser les numéros de contrat\ndonnees_rbase$un &lt;- 1L\n# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN = !\ndonnees_rbase$numero_contrat &lt;- ave(donnees_rbase$un, donnees_rbase$identifiant, FUN = cumsum)\ndeux_premieres_lignes &lt;- donnees_rbase[which(donnees_rbase$numero_contrat &lt;= 2), ]\ndonnees_rbase$un &lt;- NULL\n\n# Version en R Base\n#https://stackoverflow.com/questions/14800161/select-the-top-n-values-by-group\n\n\n\n\ndeux_premieres_lignes &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  group_by(identifiant) %&gt;% \n  slice(1:2) %&gt;% \n  ungroup()\n\n\n\n\ndeux_premieres_lignes &lt;- donnees_datatable[, .SD[1:2], by = identifiant]\n\n\n\n\n\n\n\ndeux_premieres_lignes = (donnees_python\n            .sort_values(by=['identifiant', 'date_entree'], ascending=[True, True], na_position='last')\n            .groupby('identifiant')\n            .head(2)\n            .reset_index(drop=True)\n)\n\n\n\n\n\n\n14.4.2 Les 2 dernières lignes de chaque identifiant\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Numéro du contrat */\nproc sort data = donnees_sas;by identifiant date_entree;run;\ndata donnees_sas;\n  set donnees_sas;\n  by identifiant date_entree;\n  retain num_contrat;\n  if first.identifiant then num_contrat = 1;\n  else                      num_contrat = num_contrat + 1;\nrun;\n\nproc sort data = donnees_sas;by identifiant numero_contrat;run;\nproc sql;\n  select * from donnees_sas group by identifiant\n  having numero_contrat &gt;= count(*) - 1;\nquit;\n\n\n\ndeux_dernieres_lignes &lt;- donnees_rbase[unlist(tapply(seq_len(nrow(donnees_rbase)), \n                                                     donnees_rbase$identifiant, \n                                                     function(x) tail(x, 2))), ]\n\n# Version en R Base\n#https://stackoverflow.com/questions/14800161/select-the-top-n-values-by-group\n\n\n\n\n# À FAIRE : ne fait pas la même-chose !\ndeux_dernieres_lignes &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  group_by(identifiant) %&gt;% \n  slice(n() - 2) %&gt;% \n  ungroup()\n\n\n\n\ndeux_dernieres_lignes &lt;- donnees_datatable[, tail(.SD, 2), by = identifiant]\n\n\n\n\n\n\n\ndeux_dernieres_lignes = (donnees_python\n            .sort_values(by=['identifiant', 'date_entree'], ascending=[True, True], na_position='last')\n            .groupby('identifiant')\n            .tail(2)\n            .reset_index(drop=True)\n)\n\n\n\n\n\n\n14.4.3 2e ligne de l’individu (et rien si l’individu a 1 seule ligne)\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Numéro du contrat */\nproc sort data = donnees_sas;by identifiant date_entree;run;\ndata donnees_sas;\n  set donnees_sas;\n  by identifiant date_entree;\n  retain numero_contrat 0;\n  if first.identifiant then numero_contrat = 1;\n  else                      numero_contrat = numero_contrat + 1;\nrun;\n\n/* 2 stratégies possibles */\ndata Deuxieme_Contrat;\n  set donnees_sas;\n  if numero_contrat = 2;\nrun;\n\ndata Deuxieme_Contrat;\n  set donnees_sas (where = (numero_contrat = 2));\nrun;\n\n\n\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]\ndonnees_rbase[unlist(tapply(seq_len(nrow(donnees_rbase)), donnees_rbase$identifiant, function(x) head(x, 2))), ]\n\n# Avec le numéro de contrat\ndonnees_rbase$un &lt;- 1L\n# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN = !\ndonnees_rbase$numero_contrat &lt;- ave(donnees_rbase$un, donnees_rbase$identifiant, FUN = cumsum)\ndeuxieme_ligne &lt;- donnees_rbase[donnees_rbase$numero_contrat == 2, ]\ndonnees_rbase$un &lt;- NULL\n\n\n\n\ndonnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  filter(row_number() == 2) %&gt;% \n  ungroup()\n\n\n\n\ndeuxieme_ligne &lt;- donnees_datatable[, .SD[2], by = identifiant]\n\n\n\n\n\n\n\ndeuxieme_ligne_par_groupe = (\n    donnees_python\n    .sort_values(by=['identifiant', 'date_entree'], ascending=[True, True], na_position='last')\n    .groupby('identifiant')\n    .nth(1)  # 1 correspond à la deuxieme ligne\n    .reset_index()\n)\n\n\n\n\n\n\n14.4.4 L’avant-dernière ligne de l’individu (et rien si l’individu a 1 seul contrat)\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Nécessite d'avoir le numéro du contrat */\nproc sql;\n  select * from donnees_sas group by identifiant\n  having numero_contrat = count(*) - 1;\nquit;\n\n\n\ndonnees_rbase[unlist(tapply(seq_len(nrow(donnees_rbase)), donnees_rbase$identifiant, function(x) x[length(x)-1])), ]\n\n\n\n\ndonnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  filter(row_number() == nth(row_number(), -2))\n\n\n\n\ndonnees_datatable[, .SD[.N-1], by = identifiant]\n\n\n\n\n\n\n\ndeuxieme_ligne_par_groupe = (\n    donnees_python\n    .sort_values(by=['identifiant', 'date_entree'], ascending=[True, True], na_position='last')\n    .groupby('identifiant')\n    .nth(1)  # 1 correspond à la deuxieme ligne\n    .reset_index()\n)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélection-par-groupement",
    "href": "01-aide_memoire_r_sas.html#sélection-par-groupement",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "14.5 Sélection par groupement",
    "text": "14.5 Sélection par groupement\n\n14.5.1 Personnes qui ont eu au moins une entrée en 2022\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Personnes qui ont eu au moins une entrée en 2022 */\nproc sql;\n  select *\n  from donnees_sas\n  group by identifiant\n  having sum(year(date_entree) = 2022) &gt;= 1;\nquit;\n\n\n\n# Personnes qui ont eu au moins une entrée en 2022\nauMoins2022 &lt;- subset(donnees_rbase, identifiant %in% unique(identifiant[lubridate::year(date_entree) %in% c(2022)]))\n\n# Autre solution : ne semble possible que pour une seule variable\n# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN = !\nauMoins2022 &lt;- donnees_rbase[with(donnees_rbase, ave(lubridate::year(date_entree) %in% c(2022), identifiant, FUN = any)), ]\nauMoins2022 &lt;- subset(\n  transform(donnees_rbase, \n            cond = ave(lubridate::year(date_entree), identifiant, FUN = function(x) sum(ifelse(x %in% c(2022), 1, 0)))),\n  cond &gt;= 1)\nauMoins2022$cond &lt;- NULL\n\n\n\n\n# Personnes qui ont eu au moins une entrée en 2022\nauMoins2022 &lt;- donnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;%\n  filter(any(lubridate::year(date_entree) == 2022)) %&gt;% \n  ungroup()\n\n# Ou plus simplement\nauMoins2022 &lt;- donnees_tidyverse %&gt;% \n  filter(any(lubridate::year(date_entree) == 2022), .by = identifiant)\n\n\n\n\n# Personnes qui ont eu au moins une entrée en 2022\n# Une fonction year() est déjà implémentée en data.table, l'usage de lubridate est inutile\nauMoins2022 &lt;- donnees_datatable[, if(any(data.table::year(date_entree) %in% 2022)) .SD, by = identifiant]\n\n# Autre solution\nauMoins2022 &lt;- donnees_datatable[, if (sum(data.table::year(date_entree) == 2022, na.rm = TRUE) &gt; 0) .SD, by = identifiant]\n\n\n\n\n\n\n\nauMoins2022 = (\n    donnees_python\n    .groupby('identifiant')\n    .filter(lambda x: (x['date_entree'].dt.year == 2022).any())\n)\n\n\n\n\n\n\n14.5.2 Personnes qui ont suivi à la fois une formation qualifiée et une formation non qualifiée\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nproc sql;\n  create table Qualif_Non_Qualif as\n  select *\n  from donnees_sas\n  group by identifiant\n  having sum(Niveau = \"Non qualifie\") &gt;= 1 and sum(Niveau = \"Non qualifie\") &gt;= 1;\nquit;\n\n\n\n# Personnes qui ont suivi à la fois une formation qualifiée et une formation non qualifiée\n# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN = !\nqualif_non_qualif &lt;- subset(\n  transform(donnees_rbase, \n            qualif     = ave(niveau, identifiant, FUN = function(x) sum(ifelse(x == \"Qualifié\", 1, 0), na.rm = TRUE)), \n            non_qualif = ave(niveau, identifiant, FUN = function(x) sum(ifelse(x == \"Non Qualifié\", 1, 0), na.rm = TRUE))),\n  qualif &gt;= 1 & non_qualif &gt;= 1)\n\n\n\n\n# Personnes qui ont suivi à la fois une formation qualifiée et une formation non qualifiée\nqualif_non_qualif &lt;- donnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;%\n  filter(any(niveau == \"Qualifié\") & any(niveau == \"Non qualifié\")) %&gt;% \n  ungroup()\n\n# Ou plus simplement\nqualif_non_qualif &lt;- donnees_tidyverse %&gt;% \n  filter(any(niveau == \"Qualifié\") & any(niveau == \"Non qualifié\"), .by = identifiant)\n\n\n\n\n# Personnes qui ont suivi à la fois une formation qualifiée et une formation non qualifiée\n\n# Méthode la plus simple\ndonnees_datatable[, if (sum(niveau == \"Qualifié\", na.rm = TRUE) &gt; 0 & sum(niveau == \"Non qualifié\", na.rm = TRUE) &gt; 0) .SD, by = identifiant]\n\n# Autre méthode\ndonnees_datatable[, `:=` (qualif = sum(fifelse(niveau == \"Qualifié\", 1, 0), na.rm = TRUE),\n                          non_qualif = sum(fifelse(niveau == \"Non qualifié\", 1, 0), na.rm = TRUE)),\n                by = identifiant][qualif &gt; 0 & non_qualif &gt; 0]\n\n# Autre méthode\ndonnees_datatable[, `:=` (qualif = sum(niveau == \"Qualifié\", na.rm = TRUE), non_qualif = sum(niveau == \"Non qualifié\", na.rm = TRUE)), by = identifiant][qualif &gt; 0 & non_qualif &gt; 0]\n\n# Group by et Having de SQL\n# https://github.com/Rdatatable/data.table/issues/788\n\n\n\n\n\n\n\nqualif_non_qualif = (\n    donnees_python\n    .groupby('identifiant')\n    .filter(lambda x: (x['niveau'] == 'Qualifié').any() and (x['niveau'] == 'Non qualifié').any())\n)\n\n\n\n\n\n\n14.5.3 Personnes qui ont suivi deux contrats, et seulement deux, dont l’un au moins a débuté en 2022\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins a débuté en 2022 */\nproc sql;\n  create table Deux_Contrats as\n  select *\n  from donnees_sas\n  group by identifiant\n  having count(*) = 2 and sum(year(date_entree) = 2022) &gt;= 1;\nquit;\n\n\n\n# Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins a débuté en 2022\n# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN = !\ndeux_contrats &lt;- subset(\n  transform(donnees_rbase, \n            nb = ave(identifiant, identifiant, FUN = length), \n            an = ave(date_entree, identifiant, \n                     FUN = function(x) \n                       sum(ifelse(lubridate::year(x) == 2022, 1, 0), na.rm = TRUE))),\n  nb == 2 & an &gt;= 1)\n\n\n\n\n# Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins a débuté en 2022\ndeux_contrats &lt;- donnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;%\n  filter(n() == 2) %&gt;% \n  filter(any(lubridate::year(date_entree) == 2022)) %&gt;%\n  ungroup()\n\n# Ou plus simplement\ndeux_contrats &lt;- donnees_tidyverse %&gt;% \n  filter(any(lubridate::year(date_entree) == 2022 & n() == 2), .by = identifiant)\n\n\n\n\n# Personnes qui ont suivi deux contrats, et seulement deux, dont l'un au moins a débuté en 2022\n# Une fonction year() est déjà implémentée en data.table, l'usage de lubridate est inutile\ndonnees_datatable[, if (.N == 2 & sum(data.table::year(date_entree) == 2022, na.rm = TRUE) &gt;= 1) .SD, by = identifiant]\n\n\n\n\n\n\n\ndeux_contrats = (\n    donnees_python\n    .groupby('identifiant')\n    .filter(lambda x: len(x) == 2 and (x['date_entree'].dt.year == 2022).any())\n)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#ajouter-le-nombre-dobservations-par-csp",
    "href": "01-aide_memoire_r_sas.html#ajouter-le-nombre-dobservations-par-csp",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "14.6 Ajouter le nombre d’observations par CSP",
    "text": "14.6 Ajouter le nombre d’observations par CSP\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nproc sql;\n  create table donnees_sas as\n  select a.*, b.n\n  from donnees_sas a left join\n       (select CSPF, count(*) as n from donnees_sas group by CSPF) b on CSPF = CSPF\n  order by identifiant;\nquit;\n\n\n\n# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN = !\ndonnees_rbase &lt;- transform(donnees_rbase, \n                           n = ave(cspf, cspf, FUN = length))\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% add_count(cspf)\n\n# Autre solution\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  group_by(cspf) %&gt;%\n  mutate(n = n()) %&gt;% \n  ungroup()\n\n\n\n\ndonnees_datatable[, n := .N, by = cspf]\ndonnees_datatable[, n := length(identifiant), by = cspf]\n\n\n\n\n\n\n\ndonnees_python['n'] = donnees_python.groupby('cspf')['cspf'].transform('count')",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#ajouter-deux-colonnes-désignant-la-note-moyenne-et-la-somme-de-note_contenu-par-individu",
    "href": "01-aide_memoire_r_sas.html#ajouter-deux-colonnes-désignant-la-note-moyenne-et-la-somme-de-note_contenu-par-individu",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "14.7 Ajouter deux colonnes désignant la note moyenne et la somme de Note_Contenu, par individu",
    "text": "14.7 Ajouter deux colonnes désignant la note moyenne et la somme de Note_Contenu, par individu\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* 1ère solution */\nproc sort data = donnees_sas;by identifiant;run;\nproc means data = donnees_sas mean noprint;\n  var Note_Contenu;\n  by identifiant;\n  output out = Temp;\nrun;\ndata Temp;\n  set Temp (where = (_STAT_ = \"MEAN\"));\n  keep identifiant Note_Contenu;\n  rename Note_Contenu = Note_Contenu_Moyenne;\nrun;\ndata donnees_sas;\n  merge donnees_sas (in = a) Temp (in = b);\n  by identifiant;\n  if a;\nrun;\n\n/* 2e solution : plus souple */\n/* Pour supprimer la variable ajoutée lors de la 1ère solution */\ndata donnees_sas;\n  set donnees_sas (drop = Note_Contenu_Moyenne Note_Contenu_Somme);\nrun;\nproc sql;\n  create table donnees_sas as\n  select *\n  from donnees_sas a left join\n       (select identifiant,\n               mean(Note_Contenu) as Note_Contenu_Moyenne,\n               sum(Note_Contenu) as Note_Contenu_Somme\n        from donnees_sas group by identifiant) b\n       on a.identifiant = b.identifiant\n  order by identifiant;\nquit;\n\n\n\n# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN = !\ndonnees_rbase &lt;- transform(donnees_rbase, \n                           note_contenu_moyenne = ave(note_contenu, identifiant, FUN = mean, na.rm = TRUE), \n                           note_contenu_somme   = ave(note_contenu, identifiant, FUN = sum,  na.rm = TRUE))\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  group_by(identifiant) %&gt;%\n  mutate(note_contenu_moyenne = mean(note_contenu, na.rm = TRUE),\n         note_contenu_somme   = sum(note_contenu, na.rm = TRUE)) %&gt;% \n  ungroup()\n\n\n\n\ndonnees_datatable[, `:=` (note_contenu_moyenne = mean(note_contenu, na.rm = TRUE),\n                          note_contenu_somme = sum(note_contenu, na.rm = TRUE)), by = identifiant]\n\n# Moyenne de chaque note par individu\nnotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\ndonnees_datatable[, paste0(notes, \"_m\") := lapply(.SD, mean, na.rm = TRUE), .SDcols = notes, keyby = identifiant]\n\n\n\n\n\n\n\ndonnees_python['note_contenu_moyenne'] = donnees_python.groupby('identifiant')['note_contenu'].transform('mean')\ndonnees_python['note_contenu_somme'] = donnees_python.groupby('identifiant')['note_contenu'].transform('sum')",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#ajouter-une-variable-dentrée-initiale-par-individu",
    "href": "01-aide_memoire_r_sas.html#ajouter-une-variable-dentrée-initiale-par-individu",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "14.8 Ajouter une variable d’entrée initiale par individu",
    "text": "14.8 Ajouter une variable d’entrée initiale par individu\nOn souhaite ajouter dans la base une variable représentant la première date d’entrée de l’individu.\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nproc sort data = donnees_sas;by Identifiant date_entree;run;\ndata donnees_sas;\n  set donnees_sas;\n  by Identifiant date_entree;\n  format premiere_entree ddmmyy10.;\n  retain premiere_entree;\n  if first.Identifiant then premiere_entree = date_entree;\n  else                      premiere_entree = premiere_entree;\nrun;\n\n\n\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]\n# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN = !\ndonnees_rbase &lt;- transform(donnees_rbase,\n                           premiere_entree = ave(date_entree, identifiant, FUN = function(x) head(x, 1)))\n\n# Autre solution, sans le tri préalable\ndonnees_rbase &lt;- transform(donnees_rbase,\n                           premiere_entree = ave(date_entree, identifiant, FUN = function(x) min(x) ))\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;%\n  mutate(premiere_entree = head(date_entree, 1), .by = identifiant)\n\n# Autre solution\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;%\n  group_by(identifiant) %&gt;%\n  mutate(premiere_entree = case_when(row_number() == 1 ~ date_entree,\n                                     TRUE              ~ NA)) %&gt;%\n  fill(premiere_entree, .direction = c(\"down\")) %&gt;% \n  ungroup()\n\n\n\n\nsetorderv(donnees_datatable, c(\"identifiant\", \"date_entree\"), na.last = FALSE)\ndonnees_datatable[, premiere_entree := head(date_entree, 1), by = identifiant]\n\n\n\n\n\n\n\ndonnees_python['premiere_entree'] = donnees_python.groupby('identifiant')['date_entree'].transform('min')",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#ligne-où-se-trouve-une-valeur-maximale-pour-un-individu-à-revoir",
    "href": "01-aide_memoire_r_sas.html#ligne-où-se-trouve-une-valeur-maximale-pour-un-individu-à-revoir",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "14.9 Ligne où se trouve une valeur maximale pour un individu (À REVOIR)",
    "text": "14.9 Ligne où se trouve une valeur maximale pour un individu (À REVOIR)\nOn cherche, pour chaque individu, la ligne où se trouve la valeur maximale de note_contenu.\nhttps://stackoverflow.com/questions/24558328/select-the-row-with-the-maximum-value-in-each-group\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* On note un comportement un peu différent de R : la note de l'identifiant 087 est inconnue, et l'identifiant est conservé en SAS, pas en R */\n\n/* Renvoie toutes les lignes où note_contenu est maximale, s'il y a plusieurs ex-aequo */\nproc sort data = donnees_sas;by identifiant descending note_contenu;run;\ndata ligne_max_note_contenu;\n  set donnees_sas;\n  by identifiant descending note_contenu;\n  if first.note_contenu;\nrun;\n\n/* Renvoie seulement la première ligne en cas d'ex-aequo */\nproc sort data = donnees_sas;by identifiant descending note_contenu;run;\ndata ligne_max_note_contenu;\n  set donnees_sas;\n  by identifiant descending note_contenu;\n  if first.identifiant;\nrun;\n\n\n\n# On note un comportement un peu différent de R : la note de l'identifiant 087 est inconnue, et la ligne est conservée en SAS, pas en R.\n# Ceci est dû au fait que la fonction max ignore les NA.\n\n# Renvoie toutes les lignes où note_contenu est maximale, s'il y a plusieurs ex-aequo\nligne_max_note_contenu &lt;- merge(aggregate(note_contenu ~ identifiant, max, data = donnees_rbase), donnees_rbase)\n\n# Autre solution\n# MISE EN GARDE : en utilisant la fonction ave, toujours précéder la fonction de FUN = !\nligne_max_note_contenu &lt;- donnees_rbase[with(donnees_rbase, which(note_contenu == ave(note_contenu, identifiant, FUN = max))), ]\n\n# Renvoie seulement la première ligne en cas d'ex-aequo\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, -donnees_rbase$note_contenu), ]\nligne_max_note_contenu &lt;- donnees_rbase[! duplicated(donnees_rbase$identifiant), ]\n\n# Autre solution\nligne_max_note_contenu &lt;- do.call(rbind, lapply(split(donnees_rbase, as.factor(donnees_rbase$identifiant)), function(x) {return(x[which.max(x$note_contenu), ])}))\n\n\n\n\n# On note un comportement un peu différent de R : la note de l'identifiant 087 est inconnue, et l'identifiant est conservé en SAS, pas en R\n\n# Renvoie toutes les lignes où note_contenu est maximale, s'il y a plusieurs ex-aequo\nligne_max_note_contenu &lt;- donnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;% \n  slice_max(note_contenu)\n\n# Renvoie seulement la première ligne en cas d'ex-aequo\nligne_max_note_contenu &lt;- donnees_tidyverse %&gt;%\n     group_by(identifiant) %&gt;%\n     slice(which.max(note_contenu))\n\n\n\n\n# On note un comportement un peu différent de R : la note de l'identifiant 087 est inconnue, et l'identifiant est conservé en SAS, pas en R\n\n# Renvoie toutes les lignes où note_contenu est maximale, s'il y a plusieurs ex-aequo\nligne_max_note_contenu &lt;- donnees_datatable[donnees_datatable[, .I[note_contenu == max(note_contenu)], by = identifiant]$V1]\n\n# Renvoie seulement la première ligne en cas d'ex-aequo\nligne_max_note_contenu &lt;- donnees_datatable[, .SD[which.max(note_contenu)], by = identifiant]\n\n\n\n\n\n\n\n# Renvoie toutes les lignes où note_contenu est maximale, s'il y a plusieurs ex-aequo\nligne_max_note_contenu = (\n    donnees_python\n    .groupby('identifiant')\n    .apply(lambda x: x[x['note_contenu'] == x['note_contenu'].max()], include_groups=False).reset_index()\n)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#identifier-les-changements-détat",
    "href": "01-aide_memoire_r_sas.html#identifier-les-changements-détat",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "14.10 Identifier les changements d’état",
    "text": "14.10 Identifier les changements d’état\nNumérote les états successifs identiques d’un même identifiant. À chaque changement d’état d’un même individu, la variable d’état est incrémentée d’une unité.\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* On suppose que l'on dispose d'une base sur le type de financement de la formation */\ndata Financement_sas;\n  infile cards dsd dlm='|';\n  format Identifiant $3. Date ddmmyy10.  Financement $10.;\n  input  Identifiant $   Date :ddmmyy10. Financement $;\n  cards;\n  173|02/01/2022|Public\n  173|18/07/2022|Public\n  173|15/09/2022|Privé\n  173|28/12/2022|Public\n  173|02/04/2023|Privé\n  173|06/06/2024|Privé\n  211|02/07/2024|Privé\n  ;\nrun;\n\nproc sort data = Financement_sas;by Identifiant Date Financement;run;\ndata Financement_sas;\n  set Financement_sas;\n  Financement_1 = lag(Financement);\n  by Identifiant;\n  retain Etat;\n  if      first.Identifiant            then Etat = 1;\n  else if Financement = Financement_1  then Etat = Etat;\n  else if Financement ne Financement_1 then Etat = Etat + 1;\nrun;\n\n\n\n# On suppose que l'on dispose d'une base sur le type de financement de la formation\nfinancement_rbase &lt;- data.frame(\n  identifiant = c(rep(\"173\", 6), \"211\"),\n  date = c(\"02/01/2022\", \"18/07/2022\", \"15/09/2022\", \"28/12/2022\", \"02/04/2023\", \"06/06/2024\", \"02/07/2024\"),\n  financement = c(\"Public\", \"Public\", \"Privé\", \"Public\", \"Privé\", \"Privé\", \"Privé\")\n)\nfinancement_rbase$date &lt;- lubridate::dmy(financement_rbase$date)\nfinancement_rbase &lt;- financement_rbase[order(financement_rbase$identifiant, financement_rbase$date, na.last = FALSE), ]\nfinancement_rbase$etat &lt;- rep(seq_along(rle(financement_rbase$financement)$values), \n                              times = rle(financement_rbase$financement)$lengths)\n\n\n\n\n# On suppose que l'on dispose d'une base sur le type de financement de la formation\nfinancement_tidyverse &lt;- data.frame(\n  identifiant = c(rep(\"173\", 6), \"211\"),\n  date = c(\"02/01/2022\", \"18/07/2022\", \"15/09/2022\", \"28/12/2022\", \"02/04/2023\", \"06/06/2024\", \"02/07/2024\"),\n  financement = c(\"Public\", \"Public\", \"Privé\", \"Public\", \"Privé\", \"Privé\", \"Privé\")\n)\n\nfinancement_tidyverse %&gt;% \n  arrange(identifiant, date) %&gt;% \n  group_by(identifiant) %&gt;% \n  mutate(etat = consecutive_id(financement))\n\n\n\n\n# On suppose que l'on dispose d'une base sur le type de financement de la formation\nfinancement_datatable &lt;- data.table(\n  identifiant = c(rep(\"173\", 6), \"211\"),\n  date = c(\"02/01/2022\", \"18/07/2022\", \"15/09/2022\", \"28/12/2022\", \"02/04/2023\", \"06/06/2024\", \"02/07/2024\"),\n  financement = c(\"Public\", \"Public\", \"Privé\", \"Public\", \"Privé\", \"Privé\", \"Privé\")\n)\n\nsetorder(financement_datatable, identifiant, date)\nfinancement_datatable[, etat := rleid(financement_datatable), by = identifiant]\n\n\n\n\n\n\n\nfinancement_python = pd.DataFrame({\n    'identifiant': ['173']*6 + ['211'],\n    'date': ['02/01/2022', '18/07/2022', '15/09/2022', '28/12/2022', '02/04/2023', '06/06/2024', '02/07/2024'],\n    'financement': ['Public', 'Public', 'Privé', 'Public', 'Privé', 'Privé', 'Privé']\n})\n\n# Création de la fonction pour identifier les groupes consécutifs\ndef consecutive_id(series):\n    return (series != series.shift()).cumsum()\n  \n  # Transformation des dates en format datetime\nfinancement_python['date'] = pd.to_datetime(financement_python['date'], format='%d/%m/%Y')\n\n# Tri des données par identifiant et date\nfinancement_python = financement_python.sort_values(by=['identifiant', 'date'])\n\n# Application de la fonction pour identifier les groupes consécutifs\nfinancement_python['etat'] = (\n    financement_python.groupby('identifiant')['financement']\n    .transform(consecutive_id)\n)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-les-lignes-avec-au-moins-une-note-inférieure-à-10",
    "href": "01-aide_memoire_r_sas.html#sélectionner-les-lignes-avec-au-moins-une-note-inférieure-à-10",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "15.1 Sélectionner les lignes avec au moins une note inférieure à 10",
    "text": "15.1 Sélectionner les lignes avec au moins une note inférieure à 10\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\ndata Note_Inferieure_10;\n  set donnees_sas;\n  \n  %macro Inf10;\n    %global temp;\n      %let temp = ;\n    %do i = 1 %to %sysfunc(countw(&notes.));\n      %let j = %scan(&notes., &i.);\n        &j._inf_10 = (&j. &lt; 10 and not missing(&j.));\n        %let temp = &temp. &j._inf_10;\n    %end;\n  %mend Inf10;\n  %Inf10;\n  \n  if sum(of &temp.) &gt;= 1;\n  drop &temp.;\nrun;\n\n\n\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\ndonnees_rbase[apply(donnees_rbase[, varNotes], 1, function(x) any(x &lt; 10, na.rm = TRUE)), ]\n\n\n\n\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\ndonnees_tidyverse %&gt;%\n  filter(if_any(varNotes, ~ .x &lt; 10))\n\n# Autre solution\ndonnees_tidyverse %&gt;%\n  filter_at(varNotes, any_vars(. &lt; 10))\n\n\n\n\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nnote_moins_10 &lt;- donnees_datatable[donnees_datatable[, .I[rowSums(.SD &lt; 10, na.rm = TRUE) &gt;= 1], .SDcols = varNotes]]\n\n# Autre solution\n# Le Reduce(`|`, ...) permet d'appliquer la condition | (ou) à tous les élements de la ligne, qui sont une vérification d'une note &lt; 10\nnote_moins_10 &lt;- donnees_datatable[donnees_datatable[, Reduce(`|`, lapply(.SD, `&lt;`, 10)), .SDcols = varNotes]]\n\n# https://arelbundock.com/posts/datatable_rowwise/\n\n\n\n\n\n\n\nvarNotes = [\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\"]\ndonnees_python[donnees_python[varNotes].apply(lambda x: (x &lt; 10).any(), axis=1)]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélectionner-les-lignes-avec-toutes-les-notes-supérieures-à-10",
    "href": "01-aide_memoire_r_sas.html#sélectionner-les-lignes-avec-toutes-les-notes-supérieures-à-10",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "15.2 Sélectionner les lignes avec toutes les notes supérieures à 10",
    "text": "15.2 Sélectionner les lignes avec toutes les notes supérieures à 10\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\ndata Note_Sup_10;\n  set donnees_sas;\n  \n  %macro Sup10;\n    %global temp;\n      %let temp = ;\n    %do i = 1 %to %sysfunc(countw(&notes.));\n      %let j = %scan(&notes., &i.);\n        &j._sup_10 = (&j. &gt;= 10);\n        %let temp = &temp. &j._sup_10;\n    %end;\n  %mend Sup10;\n  %Sup10;\n  \n  if sum(of &temp.) = %sysfunc(countw(&notes.));\n  drop &temp.;\nrun;\n\n\n\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\n\n# Toutes les notes &gt;= 10 et non manquantes\ndonnees_rbase[apply(donnees_rbase[, varNotes], 1, function(x) all(x &gt;= 10 & ! is.na(x), na.rm = TRUE)), ]\n\n\n\n\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\n\n# Toutes les notes &gt;= 10 et non manquantes\ndonnees_tidyverse %&gt;%\n  filter(if_all(varNotes, ~ . &gt;= 10))\n\n# Autre solution\ndonnees_tidyverse %&gt;%\n  filter_at(varNotes, all_vars(. &gt;= 10))\n\n\n\n\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\n\n# Toutes les notes &gt;= 10 et non manquantes\nnote_sup_10 &lt;- donnees_datatable[\n  donnees_datatable[, .I[rowSums(.SD &gt;= 10, na.rm = TRUE) == length(varNotes)], .SDcols = varNotes]]\n\n# Autre solution\nnote_sup_10 &lt;- donnees_datatable[donnees_datatable[, Reduce(`&`, lapply(.SD, `&gt;=`, 10)), .SDcols = varNotes]]\n\n\n\n\n\n\n\nvarNotes = [\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\"]\ndonnees_python[donnees_python[varNotes].apply(lambda x: (x &gt;= 10).all() and x.notna().all(), axis=1)]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#moyenne-par-ligne",
    "href": "01-aide_memoire_r_sas.html#moyenne-par-ligne",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "15.3 Moyenne par ligne",
    "text": "15.3 Moyenne par ligne\nPour chaque observation, 5 notes sont renseignées. On calcule la moyenne de ces 5 notes pour chaque ligne.\n\n15.3.1 Moyenne par ligne\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\ndata donnees_sas;\n  set donnees_sas;\n  \n  /* 1ère solution */\n  Note_moyenne    = mean(of &notes.);\n  \n  /* 2e solution : l'équivalent des list-comprehension de Python en SAS */\n  %macro List_comprehension;\n    Note_moyenne2 = mean(of %do i = 1 %to %sysfunc(countw(&notes.));\n                                %let j = %scan(&notes., &i.);\n                                          &j.\n                                        %end;);;\n  %mend List_comprehension;\n  %List_comprehension;\nrun;\n\n\n\nvarNotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\n\ndonnees_rbase$note_moyenne &lt;- rowMeans(donnees_rbase[, varNotes], na.rm = TRUE)\n# apply permet d'appliquer une fonctions aux lignes (1) ou colonnes (2) d'un data.frame\ndonnees_rbase$note_moyenne &lt;- apply(donnees_rbase[, varNotes], 1, mean, na.rm = TRUE)\n\n\n\n\nvarNotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\n# Codes à privilégier\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  mutate(note_moyenne = rowMeans(pick(all_of(varNotes)), na.rm = TRUE))\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  mutate(note_moyenne = rowMeans(across(all_of(varNotes)), na.rm = TRUE))\n\n# Alternative lente\n# Noter l'utilisation de c_across dans ce cas de figure pour traiter automatiquement plusieurs variables\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  rowwise() %&gt;% \n  mutate(note_moyenne = mean(c_across(all_of(varNotes)), na.rm = TRUE)) %&gt;% \n  ungroup()\n\n\n\n\nvarNotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\n# On souhaite moyenner les notes par formation\ndonnees_datatable[, note_moyenne := rowMeans(.SD, na.rm = TRUE), .SDcols = varNotes]\n\n# Manière alternative, qui ne semble pas fonctionner\n#donnees_datatable[, note_moyenne := Reduce(function(...) sum(..., na.rm = TRUE), .SD),\n#                  .SDcols = varNotes,\n#                  by = 1:nrow(donnees_datatable)]\n#donnees_datatable[, do.call(function(x, y) sum(x, y, na.rm = TRUE), .SD), .SDcols = varNotes, by = 1:nrow(donnees_datatable)]\n\n\n\n\n\n\n\nvarNotes = [\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\"]\ndonnees_python['note_moyenne'] = donnees_python[varNotes].mean(axis=1, skipna=True)\n\n\n\n\n\n\n15.3.2 Moyenne des moyennes par ligne\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Note moyenne (moyenne des moyennes), non pondérée et pondérée */\nproc means data = donnees_sas mean;var Note_moyenne;run;\nproc means data = donnees_sas mean;var Note_moyenne;weight poids_sondage;run;\n\n\n\n# Note moyenne (moyenne des moyennes), non pondérée et pondérée\nmean(donnees_rbase$note_moyenne, na.rm = TRUE)\nweighted.mean(donnees_rbase$note_moyenne, donnees_rbase$poids_sondage, na.rm = TRUE)\n\n\n\n\n# Note moyenne (moyenne des moyennes) non pondérée\ndonnees_tidyverse %&gt;% pull(note_moyenne) %&gt;% mean(na.rm = TRUE)\ndonnees_tidyverse %&gt;% summarise(Moyenne = mean(note_moyenne, na.rm = TRUE))\n\n# Note moyenne (moyenne des moyennes) pondérée\ndonnees_tidyverse %&gt;% summarise(Moyenne_ponderee = weighted.mean(note_moyenne, poids_sondage, na.rm = TRUE))\n\n\n\n\n# Note moyenne (moyenne des moyennes), non pondérée et pondérée\ndonnees_datatable[, mean(note_moyenne, na.rm = TRUE)]\ndonnees_datatable[, weighted.mean(note_moyenne, poids_sondage, na.rm = TRUE)]\n\n\n\n\n\n\n\ndonnees_python['note_moyenne'].mean()\n(donnees_python['note_moyenne'] * donnees_python['poids_sondage']).sum(skipna=True) / donnees_python['poids_sondage'].sum(skipna=True)\n\n\n\n\n\n\n15.3.3 La moyenne par ligne est-elle supérieure à la moyenne ?\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* On crée une macro-variable SAS à partir de la valeur de la moyenne */\nproc sql noprint;select mean(Note_moyenne) into :moyenne from donnees_sas;quit;\ndata donnees_sas;\n  set donnees_sas;\n  Note_Superieure_Moyenne = (Note_moyenne &gt; &moyenne.);\nrun;\nproc freq data = donnees_sas;tables Note_Superieure_Moyenne;run;\n\n\n\nmoyenne &lt;- mean(donnees_rbase$note_moyenne, na.rm = TRUE)\ndonnees_rbase$note_superieure_moyenne &lt;- ifelse(donnees_rbase$note_moyenne &gt; moyenne, 1, 0)\ntable(donnees_rbase$note_superieure_moyenne, useNA = \"always\")\n\n\n\n\nmoyenne &lt;- donnees_tidyverse %&gt;% pull(note_moyenne) %&gt;% mean(na.rm = TRUE)\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% mutate(note_superieure_moyenne = ifelse(note_moyenne &gt; moyenne, 1, 0))\ndonnees_tidyverse %&gt;% pull(note_superieure_moyenne) %&gt;% table(useNA = \"always\")\n\n\n\n\nmoyenne &lt;- donnees_datatable[, mean(note_moyenne, na.rm = TRUE)]\ndonnees_datatable[, note_superieure_moyenne := fcase(note_moyenne &gt;= moyenne, 1,\n                                                     note_moyenne &lt;  moyenne, 0)]\ntable(donnees_datatable$note_superieure_moyenne, useNA = \"always\")\n\n\n\n\n\n\n\nmoyenne = donnees_python['note_moyenne'].mean()\ndonnees_python['note_superieure_moyenne'] = (donnees_python['note_moyenne'] &gt; moyenne).astype(int)\n\ndonnees_python['note_superieure_moyenne'].value_counts(dropna=False)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#moyenne-pondérée-par-ligne",
    "href": "01-aide_memoire_r_sas.html#moyenne-pondérée-par-ligne",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "15.4 Moyenne pondérée par ligne",
    "text": "15.4 Moyenne pondérée par ligne\nPour chaque observation, 5 notes sont renseignées. On calcule la moyenne de ces 5 notes pour chaque ligne, mais cette fois-ci en pondérant chacune de ces notes.\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* On souhaite affecter les pondérations suivantes aux notes :\nNote_Contenu : 30%, Note_Formateur : 20%, Note_Moyens : 25%, Note_Accompagnement : 15%, Note_Materiel : 10% */\n/* Voici une solution possible. Une alternative intéressante serait de passer par IML (non traité ici) */\n%let ponderation = 0.3 0.2 0.25 0.15 0.1;\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\n\ndata donnees_sas;\n  set donnees_sas;\n  \n  %macro Somme_pond;\n    %global temp;\n      %let temp = ;\n    %do i = 1 %to %sysfunc(countw(&notes.));\n      %let k = %scan(&notes., &i.);\n        %let l = %scan(&ponderation., &i., %str( ));\n        &k._pond = &k. * &l.;\n        %let temp = &temp. &k._pond;\n      %end;\n  %mend Somme_pond;\n  %Somme_pond;\n  \n  Note_moyenne_pond = sum(of &temp.);\n  drop &temp.;\nrun;\nproc means data = donnees_sas mean;var Note_moyenne_pond;run;\n\n\n\n# On souhaite affecter les pondérations suivantes aux notes :\n# note_contenu : 30%, note_formateur : 20%, note_moyens : 25%, note_accompagnement : 15%, note_materiel : 10%\nnotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nponderation &lt;- c(note_contenu = 30, note_formateur = 20, note_moyens = 25, note_accompagnement = 15, note_materiel = 10) / 100\n# On vérifie que la somme des poids vaut 1\nsum(ponderation)\n\n# La fonction RowMeans ne fonctionne plus, cette fois !\ndonnees_rbase$note_moyennepond &lt;- apply(donnees_rbase[, notes], 1, function(x) weighted.mean(x, ponderation, na.rm = TRUE))\n\n# Autre manière, en exploitant le calcul matriciel\n# Ne fonctionne pas dans cet exemple, du fait des NA\nas.matrix(donnees_rbase[, notes]) %*% as.matrix(ponderation)\n# Produit élément par élément\n# On peut procéder par produit tensoriel\n# À REVOIR\nas.matrix(donnees_rbase[, notes]) * matrix(t(as.matrix(ponderation)), nrow(donnees_rbase), length(notes))\n\n\n\n\n# On souhaite affecter les pondérations suivantes aux notes :\n# note_contenu : 30%, note_formateur : 20%, note_moyens : 25%, note_accompagnement : 15%, note_materiel : 10%\nnotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nponderation &lt;- c(note_contenu = 30, note_formateur = 20, note_moyens = 25, note_accompagnement = 15, note_materiel = 10) / 100\n# On vérifie que la somme des poids vaut 1\nsum(ponderation)\n\n# La fonction RowMeans ne fonctionne plus, cette fois !\n\n# Noter l'utilisation de c_across dans ce cas de figure pour traiter automatiquement plusieurs variables\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  rowwise() %&gt;%\n  mutate(note_moyenne = weighted.mean(c_across(varNotes), ponderation, na.rm = TRUE)) %&gt;% \n  ungroup()\n\n\n\n\n# On souhaite affecter les pondérations suivantes aux notes :\n# note_contenu : 30%, note_formateur : 20%, note_moyens : 25%, note_accompagnement : 15%, note_materiel : 10%\nnotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nponderation &lt;- c(note_contenu = 30, note_formateur = 20, note_moyens = 25, note_accompagnement = 15, note_materiel = 10) / 100\n# On vérifie que la somme des poids vaut 1\nsum(ponderation)\n\n# La fonction RowMeans ne fonctionne plus, cette fois !\ndonnees_datatable[, note_moyenne_pond := rowSums(mapply(FUN = `*`, .SD, ponderation), na.rm = TRUE), .SDcols = notes]\n\n\n\n\n\n\n\n# On souhaite affecter les pondérations suivantes aux notes :\n# note_contenu : 30%, note_formateur : 20%, note_moyens : 25%, note_accompagnement : 15%, note_materiel : 10%\nnotes = [\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\"]\nponderation_dict = {\"note_contenu\" : 0.3, \"note_formateur\" : 0.2, \"note_moyens\" : 0.25, \"note_accompagnement\" : 0.15, \"note_materiel\" : 0.1}\n# On vérifie que la somme des poids vaut 1\nsum(ponderation_dict.values())\n\n# Extraire les pondérations dans le meme ordre que le vecteur de notes :\nponderation = np.array([ponderation_dict[note] for note in varNotes])\n\n# Moyenne pondérée\ndonnees_python['note_moyenne'] = donnees_python[varNotes].apply(\n    lambda row: np.average(row, weights=ponderation[:len(row.dropna())]) if len(row.dropna()) &gt; 0 else np.nan,\n    axis=1\n)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#variable-retardée-lag",
    "href": "01-aide_memoire_r_sas.html#variable-retardée-lag",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "16.1 Variable retardée (lag)",
    "text": "16.1 Variable retardée (lag)\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* La date de fin du contrat précédent (lag) */\n/* Ecriture correcte d'un lag en SAS */\nproc sort data = donnees_sas;by identifiant date_entree;run;\ndata donnees_sasBon;\n  set donnees_sas;\n  by identifiant date_entree;  \n  format Date_fin_1 ddmmyy10.;\n  Date_fin_1 = lag(Date_sortie);\n  if first.identifiant then Date_fin_1 = .;\nrun;\n\n/* Ecriture incorrecte d'un lag en SAS */\n/* ATTENTION au lag DANS UNE CONDITION IF */\n/* Il faut toujours \"sortir\" le lag de la condition IF */\nproc sort data = donnees_sas;by identifiant date_entree;run;\ndata Lag_Bon;\n  set donnees_sas (keep = identifiant date_entree date_sortie);\n  format date_sortie_1 lag_faux lag_bon ddmmyy10.;\n  /* Erreur */\n  if date_entree = lag(date_sortie) + 1 then lag_faux = lag(date_sortie) + 1;\n  /* Bonne écriture */\n  date_sortie_1 = lag(date_sortie);\n  if date_entree = date_sortie_1 + 1 then lag_bon = date_sortie_1 + 1;\nrun;\n\n\n\n# La date de fin du contrat précédent\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\n\n# Il n'existe pas de fonction lag dans le R de base (à notre connaissance)\n# Il faut soit utiliser un package, soit utiliser cette astuce\ndonnees_rbase$date_sortie_1 &lt;- c(as.Date(NA), donnees_rbase$date_sortie[ seq(1, length(donnees_rbase$date_sortie) - 1)])\ndonnees_rbase$date_sortie_1 &lt;- c(as.Date(NA), donnees_rbase$date_sortie[ 1:(length(donnees_rbase$date_sortie) - 1)])\n\n# Ou, encore plus simple !\ndonnees_rbase$date_sortie_1 &lt;- c(as.Date(NA), head(donnees_rbase$date_sortie, -1))\n\n\n\n\n# La date de fin du contrat précédent\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  mutate(date_sortie_1 = lag(date_sortie))\n\n\n\n\n# La date de fin du contrat précédent\nsetorderv(donnees_datatable, cols = c(\"identifiant\", \"date_entree\"), order = c(1L, 1L), na.last = FALSE)\ndonnees_datatable[, date_sortie_1 := shift(.SD, n = 1, fill = NA, \"lag\"), .SDcols = \"date_sortie\"]\ndonnees_datatable[, .(date_sortie, date_sortie_1)]\n\n\n\n\n\n\n\ndonnees_python = donnees_python.sort_values(by=['identifiant', 'date_entree'], ascending=[True, True])\ndonnees_python['date_sortie_1'] = donnees_python['date_sortie'].shift(1)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#variable-avancée-lead",
    "href": "01-aide_memoire_r_sas.html#variable-avancée-lead",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "16.2 Variable avancée (lead)",
    "text": "16.2 Variable avancée (lead)\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nproc expand data= donnees_sas out = Lead;\n  convert date_sortie = date_sortie__1 / transformout = (lead 1);\nrun;\n\n\n\n# Il n'existe pas de fonction lead dans le R de base (à notre connaissance)\n# La date du contrat futur (lead)\ndonnees_rbase$date_sortie__1 &lt;- c(donnees_rbase$date_sortie[ 2:(length(donnees_rbase$date_sortie))], as.Date(NA))\n\n# Ou, encore plus simple !\ndonnees_rbase$date_sortie_1 &lt;- c(tail(donnees_rbase$date_sortie, -1), as.Date(NA))\n\n\n\n\n# La date du contrat futur (lead)\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  # Pour trier les données de la même façon que SAS\n  arrange(identifiant, !is.na(date_entree), date_entree) %&gt;% \n  mutate(date_sortie__1 = lead(date_sortie))\n\n\n\n\n# La date du contrat futur (lead)\nsetorderv(donnees_datatable, cols = c(\"identifiant\", \"date_entree\"), order = c(1L, 1L), na.last = FALSE)\ndonnees_datatable[, date_sortie__1 := shift(.SD, n = 1, fill = NA, \"lead\"), .SDcols = \"date_sortie\"]\ndonnees_datatable[, .(date_sortie, date_sortie__1)]\n\n\n\n\n\n\n\ndonnees_python = donnees_python.sort_values(by=['identifiant', 'date_entree'], ascending=[True, True])\ndonnees_python['date_sortie_1'] = donnees_python['date_sortie'].shift(-1)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#importation-de-bases-pour-les-jointures",
    "href": "01-aide_memoire_r_sas.html#importation-de-bases-pour-les-jointures",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "17.1 Importation de bases pour les jointures",
    "text": "17.1 Importation de bases pour les jointures\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* On suppose que l'on dispose d'une base supplémentaire avec les diplômes des personnes */\ndata Diplome;\n  infile cards dsd dlm='|';\n  format Identifiant $3. Diplome $20.;\n  input Identifiant $ Diplome $;\n  cards;\n  173|Bac\n  168|Bep-Cap\n  112|Bep-Cap\n  087|Bac+2\n  689|Bac+2\n  765|Pas de diplôme\n  113|Bac\n  999|Bac\n  554|Bep-Cap\n  ;\nrun;\n\n/* On suppose que l'on dispose aussi d'une base supplémentaire indiquant la date d'une entrevue avec un conseiller */\ndata Entrevue;\n  infile cards dsd dlm='|';\n  format Identifiant $3. Date_entrevue ddmmyy10.;\n  input Identifiant $ Date_entrevue ddmmyy10.;\n  cards;\n  173|06/08/2021\n  168|17/10/2019\n  087|12/06/2021\n  689|28/03/2018\n  099|01/09/2022\n  765|01/10/2020\n  ;\nrun;\n\n/* On récupère un extrait de la base initiale */\ndata Jointure;\n  set donnees_sas (keep = Identifiant Sexe date_entree date_sortie);\nrun;\n\n\n\n# On suppose que l'on dispose d'une base supplémentaire avec les diplômes des personnes\ndiplome_rbase &lt;- data.frame(identifiant = c(\"173\", \"168\", \"112\", \"087\", \"689\", \"765\", \"113\", \"999\", \"554\"),\n                      diplome = c(\"Bac\", \"Bep-Cap\", \"Bep-Cap\", \"Bac+2\", \"Bac+2\", \"Pas de diplôme\", \"Bac\", \"Bac\", \"Bep-Cap\"))\n\n# On suppose que l'on dispose d'une base supplémentaire indiquant la date d'une entrevue avec un conseiller\nentrevue_rbase &lt;- data.frame(identifiant = c(\"173\", \"168\", \"087\", \"689\", \"099\", \"765\"),\n                       date_entrevue = c(\"06/08/2021\", \"17/10/2019\", \"12/06/2021\", \"28/03/2018\", \"01/09/2022\", \"01/10/2020\"))\nentrevue_rbase$date_entrevue &lt;- lubridate::dmy(entrevue_rbase$date_entrevue)\n\n# On récupère un extrait de la base initiale\njointure_rbase &lt;- donnees_rbase[, c(\"identifiant\", \"sexe\", \"date_entree\", \"date_sortie\")]\n\n\n\n\n# On suppose que l'on dispose d'une base supplémentaire avec les diplômes des personnes\ndiplome_tidyverse &lt;- tibble(identifiant = c(\"173\", \"168\", \"112\", \"087\", \"689\", \"765\", \"113\", \"999\", \"554\"),\n                      diplome = c(\"Bac\", \"Bep-Cap\", \"Bep-Cap\", \"Bac+2\", \"Bac+2\", \"Pas de diplôme\", \"Bac\", \"Bac\", \"Bep-Cap\"))\n\n# On suppose que l'on dispose d'une base supplémentaire indiquant la date d'une entrevue avec un conseiller\nentrevue_tidyverse &lt;- tibble(identifiant = c(\"173\", \"168\", \"087\", \"689\", \"099\", \"765\"),\n                       date_entrevue = c(\"06/08/2021\", \"17/10/2019\", \"12/06/2021\", \"28/03/2018\", \"01/09/2022\", \"01/10/2020\"))\nentrevue_tidyverse &lt;- entrevue_tidyverse %&gt;% \n  mutate(date_entrevue = lubridate::dmy(date_entrevue))\n\n# On récupère un extrait de la base initiale\nvariable &lt;- c(\"identifiant\", \"sexe\", \"date_entree\", \"date_sortie\")\njointure_tidyverse &lt;- donnees_tidyverse %&gt;%\n  select(all_of(variable))\n\n\n\n\n# On suppose que l'on dispose d'une base supplémentaire avec les diplômes des personnes\ndiplome_datatable &lt;- data.table(identifiant = c(\"173\", \"168\", \"112\", \"087\", \"689\", \"765\", \"113\", \"999\", \"554\"),\n                                diplome = c(\"Bac\", \"Bep-Cap\", \"Bep-Cap\", \"Bac+2\", \"Bac+2\", \"Pas de diplôme\", \"Bac\", \"Bac\", \"Bep-Cap\"))\n\n# On suppose que l'on dispose d'une base supplémentaire indiquant la date d'une entrevue avec un conseiller\nentrevue_datatable &lt;- data.table(identifiant = c(\"173\", \"168\", \"087\", \"689\", \"099\", \"765\"),\n                                 date_entrevue = c(\"06/08/2021\", \"17/10/2019\", \"12/06/2021\", \"28/03/2018\", \"01/09/2022\", \"01/10/2020\"))\nentrevue_datatable[, date_entrevue := lubridate::dmy(date_entrevue)]\n\n# On récupère un extrait de la base initiale\njointure_datatable &lt;- donnees_datatable[, c(\"identifiant\", \"sexe\", \"date_entree\", \"date_sortie\")]\n\n\n\n\n\n\n\n# On suppose que l'on dispose d'une base supplémentaire avec les diplômes des personnes\ndiplome_python = pd.DataFrame({\n    'identifiant': [\"173\", \"168\", \"112\", \"087\", \"689\", \"765\", \"113\", \"999\", \"554\"],\n    'diplome': [\"Bac\", \"Bep-Cap\", \"Bep-Cap\", \"Bac+2\", \"Bac+2\", \"Pas de diplôme\", \"Bac\", \"Bac\", \"Bep-Cap\"]\n})\n\n# On suppose que l'on dispose d'une base supplémentaire indiquant la date d'une entrevue avec un conseiller\nentrevue_python = pd.DataFrame({\n    'identifiant': [\"173\", \"168\", \"087\", \"689\", \"099\", \"765\"],\n    'date_entrevue': [\"06/08/2021\", \"17/10/2019\", \"12/06/2021\", \"28/03/2018\", \"01/09/2022\", \"01/10/2020\"]\n})\nentrevue_python['date_entrevue'] = pd.to_datetime(entrevue_python['date_entrevue'], format='%d/%m/%Y') # Conversion des dates en datetime\n\n# On récupère un extrait de la base initiale\njointure_python = donnees_python[['identifiant', 'sexe', 'date_entree', 'date_sortie']]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#inner-join-les-seuls-identifiants-communs-aux-deux-bases",
    "href": "01-aide_memoire_r_sas.html#inner-join-les-seuls-identifiants-communs-aux-deux-bases",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "17.2 Inner join : les seuls identifiants communs aux deux bases",
    "text": "17.2 Inner join : les seuls identifiants communs aux deux bases\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Sont appariés les identifiants communs aux deux bases */\n/* Le tri préalable des bases de données à joindre par la variable de jointure est nécessaire avec la stratégie merge */\nproc sort data = Diplome;by identifiant;run;\nproc sort data = Jointure;by identifiant;run;\ndata Inner_Join1;\n  merge Jointure (in = a) Diplome (in = b);\n  by identifiant;\n  if a and b;\nrun;\n\n/* Autre solution */\n/* Le tri préalable des bases de données à joindre n'est pas nécessaire avec la jointure SQL */\nproc sql;\n  create table Inner_Join2 as\n  select * from Jointure a inner join Diplome b on a.identifiant = b.identifiant\n  order by a.identifiant;\nquit;\n\nproc print data = Inner_Join1 (obs = 10);run;\nproc sql;select count(*) from Inner_Join1;quit;\nproc sql;select count(*) from Inner_Join2;quit;\n\n\n\n# Sont appariés les identifiants communs aux deux bases\ninnerJoin &lt;- merge(jointure_rbase, diplome_rbase, by.x = \"identifiant\", by.y = \"identifiant\")\ndim(innerJoin)\n\n\n\n\n# Sont appariés les identifiants communs aux deux bases\ninnerJoin &lt;- jointure_tidyverse %&gt;% \n  inner_join(diplome_tidyverse, by = \"identifiant\")\ndim(innerJoin)\n\n# Autres solutions\ninnerJoin &lt;- jointure_tidyverse %&gt;% \n  inner_join(diplome_tidyverse, by = join_by(identifiant == identifiant))\ndim(innerJoin)\ninnerJoin &lt;- inner_join(jointure_tidyverse, diplome_tidyverse, by = \"identifiant\")\ndim(innerJoin)\n\n\n\n\n# Sont appariés les identifiants communs aux deux bases\ninnerJoin &lt;- merge(jointure_datatable, diplome_datatable, by.x = \"identifiant\", by.y = \"identifiant\")\ninnerJoin &lt;- jointure_datatable[diplome_datatable, nomatch = 0, on = list(identifiant == identifiant)]\ninnerJoin &lt;- jointure_datatable[diplome_datatable, nomatch = 0, on = .(identifiant == identifiant)]\ndim(innerJoin)\n\n\n\n\n\n\n\n# Sont appariés les identifiants communs aux deux bases\ninner_join = jointure_python.merge(diplome_python, \n                                  left_on='identifiant', \n                                  right_on = 'identifiant',\n                                  how='inner')\ninner_join.shape",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#left-join-les-identifiants-de-la-base-de-gauche",
    "href": "01-aide_memoire_r_sas.html#left-join-les-identifiants-de-la-base-de-gauche",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "17.3 Left join : les identifiants de la base de gauche",
    "text": "17.3 Left join : les identifiants de la base de gauche\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Sont appariés tous les identifiants de la base de gauche, et les correspondants éventuels de la base de droite */\n/* Le tri préalable des bases de données à joindre par la variable de jointure est nécessaire avec la stratégie merge */\nproc sort data = Diplome;by identifiant;run;\nproc sort data = Jointure;by identifiant;run;\ndata Left_Join1;\n  merge Jointure (in = a) Diplome (in = b);\n  by identifiant;\n  if a;\nrun;\n\n/* Autre solution */\n/* Le tri préalable des bases de données à joindre n'est pas nécessaire avec la jointure SQL */\nproc sql;\n  create table Left_Join2 as\n  select * from Jointure a left join Diplome b on a.identifiant = b.identifiant\n  order by a.identifiant;\nquit;\n\nproc print data = Left_Join1 (obs = 10);run;\nproc sql;select count(*) from Left_Join1;quit;\nproc sql;select count(*) from Left_Join2;quit;\n\n\n\n# Sont appariés tous les identifiants de la base de gauche, et les correspondants éventuels de la base de droite\nleftJoin &lt;- merge(jointure_rbase, diplome_rbase, by.x = \"identifiant\", by.y = \"identifiant\", all.x = TRUE)\ndim(leftJoin)\n\n\n\n\n# Sont appariés tous les identifiants de la base de gauche, et les correspondants éventuels de la base de droite\nleftJoin &lt;- jointure_tidyverse %&gt;% \n  left_join(diplome_tidyverse, by = \"identifiant\")\ndim(leftJoin)\n\n# Autres solutions\nleftJoin &lt;- jointure_tidyverse %&gt;% \n  left_join(diplome_tidyverse, by = join_by(identifiant == identifiant))\ndim(leftJoin)\nleftJoin &lt;- left_join(jointure_tidyverse, diplome_tidyverse, by = \"identifiant\")\ndim(leftJoin)\n\n\n\n\n# Sont appariés tous les identifiants de la base de gauche, et les correspondants éventuels de la base de droite\nleftJoin &lt;- merge(jointure_datatable, diplome_datatable, by.x = \"identifiant\", by.y = \"identifiant\", all.x = TRUE)\ndim(leftJoin)\nleftJoin &lt;- diplome_datatable[jointure_datatable, on = .(identifiant == identifiant)]\ndim(leftJoin)\n\n\n\n\n\n\n\n# Sont appariés tous les identifiants de la base de gauche, et les correspondants éventuels de la base de droite\nleft_join = jointure_python.merge(diplome_python, \n                                  left_on='identifiant', \n                                  right_on = 'identifiant',\n                                  how='left')\nleft_join.shape",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#right-join-les-identifiants-de-la-base-de-droite",
    "href": "01-aide_memoire_r_sas.html#right-join-les-identifiants-de-la-base-de-droite",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "17.4 Right join : les identifiants de la base de droite",
    "text": "17.4 Right join : les identifiants de la base de droite\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Sont appariés tous les identifiants de la base de droite et les correspondants éventuels de la base de gauche */\n/* Le tri préalable des bases de données à joindre par la variable de jointure est nécessaire avec la stratégie merge */\nproc sort data = Diplome;by identifiant;run;\nproc sort data = Jointure;by identifiant;run;\ndata Right_Join1;\n  merge Jointure (in = a) Diplome (in = b);\n  by identifiant;\n  if b;\nrun;\n\n/* Autre solution */\n/* Le tri préalable des bases de données à joindre n'est pas nécessaire avec la jointure SQL */\nproc sql;\n  create table Right_Join2 as\n  select * from Jointure a right join Diplome b on a.identifiant = b.identifiant\n  order by a.identifiant;\nquit;\n\nproc print data = Right_Join1 (obs = 10);run;\nproc sql;select count(*) from Right_Join1;quit;\nproc sql;select count(*) from Right_Join2;quit;\n\n\n\n# Sont appariés tous les identifiants de la base de droite et les correspondants éventuels de la base de gauche\nrightJoin &lt;- merge(jointure_rbase, diplome_rbase, by.x = \"identifiant\", by.y = \"identifiant\", all.y = TRUE)\ndim(rightJoin)\n\n\n\n\n# Sont appariés tous les identifiants de la base de droite et les correspondants éventuels de la base de gauche\nrightJoin &lt;- jointure_tidyverse %&gt;% \n  right_join(diplome_tidyverse, by = \"identifiant\")\ndim(rightJoin)\n\n# Autre solution\nrightJoin &lt;- jointure_tidyverse %&gt;% \n  right_join(diplome_tidyverse, by = join_by(identifiant == identifiant))\ndim(rightJoin)\nrightJoin &lt;- right_join(jointure_tidyverse, diplome_tidyverse, by = \"identifiant\")\ndim(rightJoin)\n\n\n\n\n# Sont appariés tous les identifiants de la base de droite et les correspondants éventuels de la base de gauche\nrightJoin &lt;- merge(jointure_datatable, diplome_datatable, by.x = \"identifiant\", by.y = \"identifiant\", all.y = TRUE)\ndim(rightJoin)\nrightJoin &lt;- jointure_datatable[diplome_datatable, on = .(identifiant == identifiant)]\ndim(rightJoin)\n\n\n\n\n\n\n\n# Sont appariés tous les identifiants de la base de droite et les correspondants éventuels de la base de gauche\nright_join = jointure_python.merge(diplome_python, \n                                  left_on='identifiant', \n                                  right_on = 'identifiant',\n                                  how='right')\nright_join.shape",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#full-join-les-identifiants-des-deux-bases",
    "href": "01-aide_memoire_r_sas.html#full-join-les-identifiants-des-deux-bases",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "17.5 Full join : les identifiants des deux bases",
    "text": "17.5 Full join : les identifiants des deux bases\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Sont appariés les identifiants des deux bases */\n/* Le tri préalable des bases de données à joindre par la variable de jointure est nécessaire avec la stratégie merge */\nproc sort data = Diplome;by identifiant;run;\nproc sort data = Jointure;by identifiant;run;\ndata Full_Join1;\n  merge Jointure (in = a) Diplome (in = b);\n  by identifiant;\n  if a or b;\nrun;\n\n/* Autre solution */\n/* Le tri préalable des bases de données à joindre n'est pas nécessaire avec la jointure SQL */\nproc sql;\n  create table Full_Join2 as\n  select coalesce(a.identifiant, b.identifiant) as Identifiant, *\n  from Jointure a full outer join Diplome b on a.identifiant = b.identifiant\n  order by calculated identifiant;\nquit;\n\nproc print data = Full_Join1 (obs = 10);run;\nproc sql;select count(*) from Full_Join1;quit;\nproc sql;select count(*) from Full_Join2;quit;\n\n\n\n# Sont appariés les identifiants des deux bases\nfullJoin &lt;- merge(jointure_rbase, diplome_rbase, by.x = \"identifiant\", by.y = \"identifiant\", all = TRUE)\ndim(fullJoin)\n\n\n\n\n# Sont appariés les identifiants des deux bases\nfullJoin &lt;- jointure_tidyverse %&gt;% \n  full_join(diplome_tidyverse, by = \"identifiant\")\ndim(fullJoin)\n\n# Autre solution\nfullJoin &lt;- jointure_tidyverse %&gt;% \n  full_join(diplome_tidyverse, by = join_by(identifiant == identifiant))\ndim(fullJoin)\nfullJoin &lt;- full_join(jointure_tidyverse, diplome_tidyverse, by = \"identifiant\")\ndim(fullJoin)\n\n\n\n\n# Sont appariés les identifiants des deux bases\nfullJoin &lt;- merge(jointure_datatable, diplome_datatable, by.x = \"identifiant\", by.y = \"identifiant\", all = TRUE)\ndim(fullJoin)\n\n\n\n\n\n\n\n# Sont appariés tous les identifiants de la base de droite et les correspondants éventuels de la base de gauche\nfull_join = jointure_python.merge(diplome_python, \n                                  left_on='identifiant', \n                                  right_on = 'identifiant',\n                                  how='outer')\nfull_join.shape",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#jointure-de-3-bases-ou-plus-en-une-seule-opération-exemple-avec-inner-join",
    "href": "01-aide_memoire_r_sas.html#jointure-de-3-bases-ou-plus-en-une-seule-opération-exemple-avec-inner-join",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "17.6 Jointure de 3 bases ou plus en une seule opération (exemple avec inner join)",
    "text": "17.6 Jointure de 3 bases ou plus en une seule opération (exemple avec inner join)\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nproc sort data = Jointure;by identifiant;run;\nproc sort data = Diplome;by identifiant;run;\nproc sort data = Entrevue;by identifiant;run;\ndata Inner_Join3;\n  merge Jointure (in = a) Diplome (in = b) Entrevue (in = c);\n  by identifiant;\n  if a and b and c;\nrun;\n\n/* Autre solution */\n/* Le tri préalable des bases de données à joindre n'est pas nécessaire avec la jointure SQL */\nproc sql;\n  create table Inner_Join4 as\n  select * from Jointure a inner join Diplome  b on a.identifiant = b.identifiant\n                           inner join Entrevue c on a.identifiant = c.identifiant\n  order by a.identifiant;\nquit;\n\nproc print data = Inner_Join4 (obs = 10);run;\nproc sql;select count(*) from Inner_Join3;quit;\nproc sql;select count(*) from Inner_Join4;quit;\n\n\n\n# Utilisation de la fonction Reduce\n# Elle applique successivement (et non simultanément, comme do.call) une fonction à tous les éléments d'une liste\ninnerJoin2 &lt;- Reduce(function(x, y) merge(x, y, all = FALSE, by.x = \"identifiant\", by.y = \"identifiant\"),\n                     list(jointure_rbase, diplome_rbase, entrevue_rbase))\ndim(innerJoin2)\n\n\n\n\n# Utilisation de la fonction reduce de purrr\n# Elle applique successivement (et non simultanément, comme do.call) à tous les éléments d'une liste une fonction\ninnerJoin2 &lt;- list(jointure_tidyverse, diplome_tidyverse, entrevue_tidyverse) %&gt;% \n  purrr::reduce(dplyr::inner_join, by = join_by(identifiant == identifiant))\ndim(innerJoin2)\n\n\n\n\n# Utilisation de la fonction Reduce\n# Elle applique successivement (et non simultanément, comme do.call) une fonction à tous les éléments d'une liste\ninnerJoin2 &lt;- Reduce(function(x, y) merge(x, y, all = FALSE, by.x = \"identifiant\", by.y = \"identifiant\"),\n                    list(jointure_datatable, diplome_datatable, entrevue_datatable))\ndim(innerJoin2)\n\n\n\n\n\n\n\nfrom functools import reduce\n# Liste des DataFrames à joindre\ndataframes = [jointure_python, diplome_python, entrevue_python]\n\n## Methode 1 : avec la fonction reduce\n# Fonction de jointure interne\ndef inner_join(x, y):\n    return pd.merge(x, y, on='identifiant', how='inner')\n# Application successive de la fonction de jointure à tous les éléments de la liste\ninner_join2 = reduce(inner_join, dataframes)\n\n## Méthode 2 : Sans la fonction reduce\n# Initialisation du DataFrame résultant avec le premier DataFrame de la liste\ninner_join2 = dataframes[0]\n\n# Jointure successive des autres DataFrames\nfor df in dataframes[1:]:\n    inner_join2 = pd.merge(inner_join2, df, on='identifiant', how='inner')\n\ninner_join2.shape",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#jointure-sur-inégalités",
    "href": "01-aide_memoire_r_sas.html#jointure-sur-inégalités",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "17.7 Jointure sur inégalités",
    "text": "17.7 Jointure sur inégalités\nOn cherche à obtenir les entrevues qui se sont déroulées durant le contrat. On cherche alors à apparier les bases Jointure et Entrevue par identifiant si la date d’entrevue de la base Entrevue est comprise entre la date d’entrée et la date de sortie de la base Jointure.\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* On associe l'entrevue au contrat au cours duquel elle a eu lieu */\nproc sql;\n  create table Inner_Join_Inegalite as\n  select *\n  from Jointure a inner join Entrevue b\n       on a.identifiant = b.identifiant and a.date_entree &lt;= b.date_entrevue &lt;= a.date_sortie\n  order by a.identifiant;\nquit;\nproc print data = Inner_Join_Inegalite (obs = 10);run;\nproc sql;select count(*) from Inner_Join_Inegalite;quit;\n\n\n\n# Ne semble pas natif en R-Base.\n# Une proposition indicative où l'on applique la sélection après la jointure, ce qui ne doit pas être très efficace ...\ninnerJoinInegalite &lt;- merge(jointure_rbase, entrevue_rbase, by = \"identifiant\")\ninnerJoinInegalite &lt;- with(innerJoinInegalite,\n                           innerJoinInegalite[which(date_entree &lt;= date_entrevue & date_entrevue &lt;= date_sortie), ])\ndim(innerJoinInegalite)\n\n\n\n\ninnerJoinInegalite &lt;- jointure_tidyverse %&gt;% \n  inner_join(entrevue_tidyverse, join_by(identifiant == identifiant,\n                                         date_entree &lt;= date_entrevue,\n                                         date_sortie &gt;= date_entrevue))\ndim(innerJoinInegalite)\n\n\n\n\n# Attention, l'ordre des conditions doit correspondre à l'ordre des bases dans la jointure !\n# Il semble que l'on soit forcé de spécifier tous les noms des colonnes, et ce qui est un peu problématique ...\n# À FAIRE : Peut-on faire plus simplement ??\ninnerJoinInegalite &lt;- jointure_datatable[entrevue_datatable,\n                                         .(identifiant, sexe, date_entree, date_sortie, date_entrevue),\n                                         on = .(identifiant, date_entree &lt;= date_entrevue, date_sortie &gt;= date_entrevue),\n                                         nomatch = 0L\n                                         ][order(identifiant)]\ndim(innerJoinInegalite)\n\n\n\n\n\n\n\n# En procédant en deux temps :\n# Jointure interne sur la colonne 'identifiant'\nintermediate_join = pd.merge(jointure_python, entrevue_python, on='identifiant', how='inner')\n\n# Filtrage selon les conditions d'inégalité\n#inner_join_inegalite = intermediate_join.query('date_entree &lt;= date_entrevue &lt;= date_sortie')\n\ninner_join_inegalite.shape",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#cross-join-toutes-les-combinaisons-possibles-de-csp-sexe-et-diplôme",
    "href": "01-aide_memoire_r_sas.html#cross-join-toutes-les-combinaisons-possibles-de-csp-sexe-et-diplôme",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "17.8 Cross join : toutes les combinaisons possibles de CSP, sexe et diplôme",
    "text": "17.8 Cross join : toutes les combinaisons possibles de CSP, sexe et diplôme\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nproc sql;\n  create table CrossJoin as\n  select *\n  from (select distinct CSPF    from donnees_sas) cross join\n       (select distinct Sexef   from donnees_sas) cross join\n       (select distinct Diplome from Diplome)\n  order by CSPF, Sexef, Diplome;\nquit;\nproc sql;select count(*) from CrossJoin;quit;\n\n\n\n# Toutes les combinaisons possibles de CSP, sexe et diplome\ncrossJoin &lt;- unique(expand.grid(donnees_rbase$cspf, donnees_rbase$sexef, diplome_rbase$diplome))\ncolnames(crossJoin) &lt;- c(\"cspf\", \"sexef\", \"diplome\")\ndim(crossJoin)\n\n# Autre solution\ncrossJoin2 &lt;- unique(merge(donnees_rbase[, c(\"cspf\", \"sexef\")], diplome_rbase[, \"diplome\"], by = NULL))\ndim(crossJoin2)\n\n\n\n\n# Toutes les combinaisons possibles de CSP, sexe et diplome\ncrossJoin &lt;- donnees_tidyverse %&gt;%\n  select(cspf, sexef) %&gt;% \n  cross_join(diplome_tidyverse %&gt;% select(diplome)) %&gt;% \n  distinct()\ndim(crossJoin)\n\n# Autres solutions\ncrossJoin &lt;- cross_join(donnees_tidyverse %&gt;% select(cspf, sexef), diplome_tidyverse %&gt;% select(diplome)) %&gt;% \n  distinct()\ndim(crossJoin)\n\ncrossJoin &lt;- donnees_tidyverse %&gt;% \n  tidyr::expand(cspf, sexef, diplome_tidyverse$diplome) %&gt;%\n  distinct()\ndim(crossJoin)\n\ncrossJoin &lt;- tidyr::crossing(donnees_tidyverse %&gt;% select(cspf, sexef), diplome_tidyverse %&gt;% select(diplome)) %&gt;%\n  distinct()\ndim(crossJoin)\n\n\n\n\ncrossJoin &lt;- data.table::CJ(donnees_datatable[, cspf], donnees_datatable[, sexef], diplome_datatable[, diplome], unique = TRUE)\ncolnames(crossJoin) &lt;- c(\"cspf\", \"sexef\", \"diplome\")\ndim(crossJoin)\n\n\n\n\n\n\n\n# Toutes les combinaisons possibles de CSP, sexe et diplome\ncrossJoin = pd.MultiIndex.from_product([pd.unique(donnees_python['cspf']), \n                                           pd.unique(donnees_python['sexef']), \n                                           pd.unique(diplome_python['diplome'])], \n                                          names=['cspf', 'sexef', 'diplome']).to_frame(index=False)\ncrossJoin.shape",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#semi-join",
    "href": "01-aide_memoire_r_sas.html#semi-join",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "17.9 Semi join",
    "text": "17.9 Semi join\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Identifiants de la base de gauche qui ont un correspondant dans la base de droite */\nproc sql;\n  create table Semi_Join as select * from donnees_sas\n  where Identifiant in (select distinct Identifiant from Diplome);\n  select count(*) from Semi_Join;\nquit;\n\n/* Autre possibilité */\nproc sql;\n  create table Semi_Join as select * from donnees_sas a\n  where exists (select * from Diplome b where (a.Identifiant = b.Identifiant));\n  select count(*) from Semi_Join;\nquit;\n\n\n\n# Identifiants de la base de gauche qui ont un correspondant dans la base de droite\nsemiJoin &lt;- donnees_rbase[donnees_rbase$identifiant %in% diplome_rbase$identifiant, ]\ndim(semiJoin)\n\n\n\n\n# Identifiants de la base de gauche qui ont un correspondant dans la base de droite\nsemiJoin &lt;- donnees_tidyverse %&gt;% \n  semi_join(diplome_tidyverse, join_by(identifiant == identifiant))\ndim(semiJoin)\n# Autre solution\nsemiJoin &lt;- semi_join(donnees_tidyverse, diplome_tidyverse, join_by(identifiant == identifiant))\ndim(semiJoin)\n\n\n\n\n# Identifiants de la base de gauche qui ont un correspondant dans la base de droite\nsemiJoin &lt;- donnees_datatable[identifiant %in% diplome_datatable[, identifiant], ]\ndim(semiJoin)\n\n\n\n\n\n\n\n# Toutes les combinaisons possibles de CSP, sexe et diplome\nsemiJoin = donnees_python[donnees_python['identifiant'].isin(diplome_python['identifiant'])]\nsemiJoin.shape",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#anti-join",
    "href": "01-aide_memoire_r_sas.html#anti-join",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "17.10 Anti join",
    "text": "17.10 Anti join\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Identifiants de la base de gauche qui n'ont pas de correspondant dans la base de droite */\nproc sql;\n  create table Anti_Join as select * from donnees_sas\n  where Identifiant not in (select distinct Identifiant from Diplome);\n  select count(*) from Anti_Join;\nquit;\nproc sql;\n  create table Anti_Join as select * from donnees_sas a\n  where not exists (select * from Diplome b where (a.Identifiant = b.Identifiant);\n  select count(*) from Anti_Join;\nquit;\n\n\n\n# Identifiants de la base de gauche qui n'ont pas de correspondant dans la base de droite\nantiJoin &lt;- donnees_rbase[! donnees_rbase$identifiant %in% diplome_rbase$identifiant, ]\ndim(antiJoin)\n\n\n\n\n# Identifiants de la base de gauche qui n'ont pas de correspondant dans la base de droite\nantiJoin &lt;- donnees_tidyverse %&gt;% \n  anti_join(diplome_tidyverse, join_by(identifiant == identifiant))\ndim(antiJoin)\n\n# Autre solution\nantiJoin &lt;- anti_join(donnees_tidyverse, diplome_tidyverse, join_by(identifiant == identifiant))\ndim(antiJoin)\n\n\n\n\n# Identifiants de la base de gauche qui n'ont pas de correspondant dans la base de droite\ndonnees_datatable[! diplome_datatable, on = \"identifiant\", j = ! \"diplome\"]\n\n# Autre solution\nantiJoin &lt;- donnees_datatable[! identifiant %in% diplome_datatable[, identifiant], ]\ndim(antiJoin)\n\n\n\n\n\n\n\n# Toutes les combinaisons possibles de CSP, sexe et diplome\nantiJoin = donnees_python[~donnees_python['identifiant'].isin(diplome_python['identifiant'])]\nantiJoin.shape",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#autres-fonctions-utiles",
    "href": "01-aide_memoire_r_sas.html#autres-fonctions-utiles",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "17.11 Autres fonctions utiles",
    "text": "17.11 Autres fonctions utiles\n\n17.11.1 Concaténation des identifiants\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nproc sql;\n  /* Concaténation des identifiants */\n  select Identifiant from Jointure union all\n  select Identifiant from Diplome order\n  by identifiant;\nquit;\n\n\n\n# Concaténation des identifiants avec les doublons\nsort(c(jointure_rbase$identifiant, diplome_rbase$identifiant))\n\n\n\n\n# dplyr:: permet de s'assurer que ce sont les fonctions du Tidyverse (et non leurs homonymes de R-Base qui sont utilisées)\n\n# Concaténation des identifiants\ndplyr::union_all(jointure_tidyverse$identifiant, diplome_tidyverse$identifiant) %&gt;% \n  sort()\n\n\n\n\n# Les fonctions spécifiques à data.table fonctionnent avec des formats data.table, d'où la syntaxe un peu différente de R base\n\n# Concaténation des identifiants\nvariable &lt;- \"identifiant\"\nsort(c(jointure_datatable[[variable]], diplome_datatable[[variable]]))\n\n\n\n\n\n\n\n# Toutes les combinaisons possibles de CSP, sexe et diplome\n# Concaténer les identifiants avec doublons\npd.concat([donnees_python['identifiant'], diplome_python['identifiant']]).sort_values()\n\n\n\n\n\n\n17.11.2 Identifiants uniques des 2 bases\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nproc sql;\n  /* Identifiants uniques des 2 bases */\n  select distinct Identifiant from\n  (select Identifiant from Jointure union select Identifiant from Diplome)\n  order by identifiant;\nquit;\n\n\n\n# base:: permet de s'assurer que les fonctions proviennent de R base\n# Des fonctions du même nom existent en Tidyverse, et tendent à prédominer si le package est lancé\n\n# Identifiants uniques des 2 bases\nsort(base::union(jointure_rbase$identifiant, diplome_rbase$identifiant))\nsort(base::unique(c(jointure_rbase$identifiant, diplome_rbase$identifiant)))\n\n\n\n\n# dplyr:: permet de s'assurer que ce sont les fonctions du Tidyverse (et non leurs homonymes de R-Base qui sont utilisées)\n\n# Identifiants uniques des 2 bases\nunique(dplyr::union_all(jointure_tidyverse$identifiant, diplome_tidyverse$identifiant)) %&gt;% \n  sort()\ndplyr::union(jointure_tidyverse$identifiant, diplome_tidyverse$identifiant) %&gt;% \n  sort()\n\n\n\n\n# Les fonctions spécifiques à data.table fonctionnent avec des formats data.table, d'où la syntaxe un peu différente de R base\n\n# Identifiants uniques des 2 bases\nvariable &lt;- \"identifiant\"\nsort(unique(c(jointure_datatable[[variable]], diplome_datatable[[variable]])))\nfunion(jointure_datatable[, ..variable], diplome_datatable[, ..variable])\n\n\n\n\n\n\n\n# Toutes les combinaisons possibles de CSP, sexe et diplome\n# Concaténer les identifiants avec doublons\nidentifiants = pd.concat([donnees_python['identifiant'], diplome_python['identifiant']]).sort_values()\n\npd.Series(identifiants.unique())\n\n\n\n\n\n\n17.11.3 Identifiants communs des 2 bases\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nproc sql;\n  /* Identifiants communs des 2 bases */\n  select Identifiant from Jointure intersect select Identifiant from Diplome\n  order by identifiant;\nquit;\n\n\n\n# base:: permet de s'assurer que les fonctions proviennent de R base\n# Des fonctions du même nom existent en Tidyverse, et tendent à prédominer si le package est lancé\n\n# Identifiants communs des 2 bases\nsort(base::intersect(jointure_rbase$identifiant, diplome_rbase$identifiant))\n\n\n\n\n# dplyr:: permet de s'assurer que ce sont les fonctions du Tidyverse (et non leurs homonymes de R-Base qui sont utilisées)\n\n# Identifiants communs des 2 bases\ndplyr::intersect(jointure_tidyverse$identifiant, diplome_tidyverse$identifiant) %&gt;% \n  sort()\n\n\n\n\n# Les fonctions spécifiques à data.table fonctionnent avec des formats data.table, d'où la syntaxe un peu différente de R base\n\n# Identifiants communs des 2 bases\nvariable &lt;- \"identifiant\"\nfintersect(jointure_datatable[, ..variable], diplome_datatable[, ..variable])[order(identifiant)]\n\n\n\n\n\n\n\n# Identifiants communs des 2 bases\nsorted(set(donnees_python['identifiant']).intersection(set(diplome_python['identifiant'])))\n\n\n\n\n\n\n17.11.4 Identifiants dans Jointure mais pas Diplome\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nproc sql;\n  /* Identifiants dans Jointure mais pas Diplome */\n  select distinct Identifiant from Jointure where\n  Identifiant not in (select distinct Identifiant from Diplome)\n  order by identifiant;\n  \n  /* Autre possibilité */\n  select Identifiant from Jointure except select Identifiant from Diplome;\nquit;\n\n\n\n# base:: permet de s'assurer que les fonctions proviennent de R base\n# Des fonctions du même nom existent en Tidyverse, et tendent à prédominer si le package est lancé\n\n# Identifiants dans Jointure mais pas Diplome\nsort(base::setdiff(jointure_rbase$identifiant, diplome_rbase$identifiant))\n\n\n\n\n# dplyr:: permet de s'assurer que ce sont les fonctions du Tidyverse (et non leurs homonymes de R-Base qui sont utilisées)\n\n# Identifiants dans Jointure mais pas Diplome\ndplyr::setdiff(jointure_tidyverse$identifiant, diplome_tidyverse$identifiant) %&gt;% \n  sort()\n\n\n\n\n# Les fonctions spécifiques à data.table fonctionnent avec des formats data.table, d'où la syntaxe un peu différente de R base\n\n# Identifiants dans Jointure mais pas Diplome\nvariable &lt;- \"identifiant\"\nfsetdiff(jointure_datatable[, ..variable], diplome_datatable[, ..variable])[order(identifiant)]\n\n\n\n\n\n\n\n# Identifiants communs des 2 bases\nsorted(set(donnees_python['identifiant']) - set(diplome_python['identifiant']))\n\n\n\n\n\n\n17.11.5 Identifiants dans Diplome mais pas Jointure\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\nproc sql;\n  /* Identifiants dans Diplome mais pas Jointure */\n  select distinct Identifiant from Diplome\n  where Identifiant not in (select distinct Identifiant from Jointure)\n  order by identifiant;\n  select Identifiant from Diplome except\n  select Identifiant from Jointure order by identifiant;\nquit;\n\n\n\n# base:: permet de s'assurer que les fonctions proviennent de R base\n# Des fonctions du même nom existent en Tidyverse, et tendent à prédominer si le package est lancé\n\n# Identifiants dans Diplome mais pas Jointure\nsort(base::setdiff(diplome_rbase$identifiant, jointure_rbase$identifiant))\n\n\n\n\n# dplyr:: permet de s'assurer que ce sont les fonctions du Tidyverse (et non leurs homonymes de R-Base qui sont utilisées)\n\n# Identifiants dans Diplome mais pas Jointure\ndplyr::setdiff(diplome_tidyverse$identifiant, jointure_tidyverse$identifiant) %&gt;% \n  sort()\n\n\n\n\n# Les fonctions spécifiques à data.table fonctionnent avec des formats data.table, d'où la syntaxe un peu différente de R base\n\n# Identifiants dans Diplome mais pas Jointure\nvariable &lt;- \"identifiant\"\nfsetdiff(diplome_datatable[, ..variable], jointure_datatable[, ..variable])[order(identifiant)]\n\n\n\n\n\n\n\n# Identifiants communs des 2 bases\nsorted(set(diplome_python['identifiant']) - set(donnees_python['identifiant']))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#concaténer-deux-bases-de-données",
    "href": "01-aide_memoire_r_sas.html#concaténer-deux-bases-de-données",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "18.1 Concaténer deux bases de données",
    "text": "18.1 Concaténer deux bases de données\nOn va mettre côte à côte (juxtaposer) le numéro de la ligne et la base de données.\n\n18.1.1 Les deux bases concaténées ont le même nombre de lignes\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Numéro de la ligne */\nproc sql noprint;select count(*) into :tot from donnees_sas;run;\ndata Ajout;do Num_ligne = 1 to &tot.;output;end;run;\n\n/* Le merge sans by va juxtaposer côte à côte les bases */\ndata Concatener;merge Ajout donnees_sas;run;\n\n\n\n# Numéro de la ligne\najout &lt;- data.frame(num_ligne = seq_len(nrow(donnees_rbase)))\n# cbind si les deux bases comprennent le même nombre de lignes\nconcatener &lt;- cbind(ajout, donnees_rbase)\n\n\n\n\n# Numéro de la ligne\najout &lt;- tibble(num_ligne = seq_len(nrow(donnees_tidyverse)))\n# bind_cols si les deux bases comprennent le même nombre de lignes\nconcatener &lt;- donnees_tidyverse %&gt;% bind_cols(ajout)\n\n\n\n\n# Numéro de la ligne\najout &lt;- data.table(num_ligne = seq_len(nrow(donnees_datatable)))\n# data.frame::cbind si les deux bases comprennent le même nombre de lignes\nconcatener &lt;- data.frame::cbind(ajout, donnees_datatable)\n\n\n\n\n\n\n\n# Numéro de la ligne\najout = pd.DataFrame({'num_ligne': range(1, len(donnees_python) + 1)})\n# Concatener\nconcatener = pd.concat([ajout, donnees_python], axis=1)\n\n\n\n\n\n\n18.1.2 Les deux bases concaténées n’ont pas le même nombre de lignes\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* Si l'une des bases comprend plus de ligne que l'autre, ajout d'une ligne de valeurs manquantes */\nproc sql noprint;select count(*) + 1 into :tot from donnees_sas;run;\ndata Ajout;do Num_ligne = 1 to &tot.;output;end;run;\ndata Concatener;merge Ajout donnees_sas;run;\n\n\n\n# Erreur si l'une des bases comprend plus de lignes que l'autre\najout &lt;- data.frame(num_ligne = seq_len(nrow(donnees_rbase) + 1))\n# donnees_rbase_ajout &lt;- cbind(ajout, donnees_rbase)\n\n# Proposition de solution\ncbind_alt &lt;- function(liste) {\n  # Nombre maximal de colonnes dans la liste de dataframes\n  maxCol &lt;- max(unlist(lapply(liste, nrow)))\n  # Ajout d'une colonne de valeurs manquantes pour toutes les bases ayant moins de ligne que le maximum\n  res &lt;- lapply(liste, function(x) {\n    for (i in seq_len(maxCol - nrow(x))) {\n      x[nrow(x) + i, ] &lt;- NA\n    }\n    return(x)\n  })\n  # On joint les résultats\n  return(do.call(cbind, res))\n}\nconcatener &lt;- cbind_alt(list(ajout, donnees_rbase))\n\n\n\n\n# Ne fonctionne si l'une des bases comprend plus de lignes que l'autre !\najout &lt;- tibble(num_ligne = seq_len(nrow(donnees_tidyverse) + 1))\n#concatener &lt;- donnees_tidyverse %&gt;% bind_cols(ajout)\n\n# cf. solution proposée dans R-Base\ncbind_alt &lt;- function(liste) {\n  # Nombre maximal de colonnes dans la liste de dataframes\n  maxCol &lt;- max(unlist(lapply(liste, nrow)))\n  # Ajout d'une colonne de valeurs manquantes pour toutes les bases ayant moins de ligne que le maximum\n  res &lt;- lapply(liste, function(x) {\n    for (i in seq_len(maxCol - nrow(x))) {\n      x[nrow(x) + i, ] &lt;- NA\n    }\n    return(x)\n  })\n  # On joint les résultats\n  return(bind_cols(res))\n}\nconcatener &lt;- cbind_alt(list(ajout, donnees_tidyverse))\n\n\n\n\n# data.table::cbind fonctionne aussi avec des bases comportant un nombre différent de lignes\n# Mais attention, le résultat n'est pas le même que sur SAS, il y a recycling\najout &lt;- data.table(num_ligne = seq_len(nrow(donnees_datatable) + 1))\nconcatener &lt;- data.table::cbind(ajout, donnees_datatable)\n\n\n\n\n\n\n\n# Si l'une des bases comprend plus de ligne que l'autre, ajout d'une ligne de valeurs manquantes, comme avec SAS\n\nnum_ligne = pd.DataFrame({'num_ligne': range(1, len(donnees_python) + 2)})\nconcatener = pd.concat([num_ligne, donnees_python], axis=1)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#empiler-deux-bases-de-données",
    "href": "01-aide_memoire_r_sas.html#empiler-deux-bases-de-données",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "18.2 Empiler deux bases de données",
    "text": "18.2 Empiler deux bases de données\nOn va empiler la moyenne des notes en dessous de la base des notes.\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\n/* On sélectionne un nombre réduit de variables pour simplifier l'exemple */\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\ndata Notes;set donnees_sas (keep = identifiant &notes.);run;\n/* Moyenne des notes */\nproc means data = Notes noprint mean;var &notes.;output out = Ajout mean = &notes.;run;\n\n/* On concatène avec les données. Valeur manquante si les variables ne correspondent pas */\n\n/* L'instruction set permet de concaténer les bases */\ndata Empiler;set Notes Ajout (drop = _type_ _freq_);run;\n\n/* Autre solution, proc append */\ndata Empiler;set Notes;run;\nproc append base = Empiler data = Ajout force;run;\n/* On renomme la ligne des moyennes ajoutée */\ndata Empiler;\n  set Empiler nobs = nobs;\n  if _N_ = nobs then Identifiant = \"Moyenne\";\nrun;\n\n\n\n# On va empiler la somme des notes en dessous de la base des notes\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\n# Moyenne des notes\nmoyennes &lt;- data.frame(t(colMeans(donnees_rbase[, varNotes], na.rm = TRUE)))\n# On crée la base des notes\nnotes &lt;- donnees_rbase[, varNotes]\n# rbind lorsque les bases empilées ont le même nombre de colonne\nempiler &lt;- rbind(notes, moyennes)\n\n# Mais, ne fonctionne plus si l'on concatène des bases de taille différente\nnotes &lt;- donnees_rbase[, c(\"identifiant\", varNotes)]\n# Ne fonctionne pas\n#empiler &lt;- rbind(notes, moyennes)\n\n# Une solution alternative, lorsque le nombre de colonnes diffère entre les deux bases\n# Lorsque les variables ne correspondent pas, on les crée avec des valeurs manquantes, via setdiff\nrbind_alt &lt;- function(x, y) {\n  rbind(data.frame(c(x, sapply(setdiff(names(y), names(x)), function(z) NA))),\n        data.frame(c(y, sapply(setdiff(names(x), names(y)), function(z) NA)))\n  )\n  }\nempiler &lt;- rbind_alt(notes, moyennes)\n# On renomme la ligne des moyennes ajoutée\nempiler[nrow(empiler), \"identifiant\"] &lt;- \"Moyenne\"\n\n\n\n\n# On va empiler la somme des notes en dessous de la base des notes\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\n# Moyenne des notes\nmoyennes &lt;- donnees_tidyverse %&gt;% \n  summarise(across(varNotes, ~mean(., na.rm = TRUE)))\nempiler &lt;- donnees_tidyverse %&gt;% \n  select(all_of(varNotes)) %&gt;% \n  bind_rows(moyennes)\n\n# Fonctionne toujours si l'on concatène des bases de taille différente\nempiler &lt;- donnees_tidyverse %&gt;% \n  select(identifiant, all_of(varNotes)) %&gt;% \n  bind_rows(moyennes)\nempiler &lt;- empiler %&gt;% \n  # On renomme la ligne des moyennes ajoutée\n  mutate(identifiant = ifelse(row_number() == nrow(empiler),\n                              \"Moyenne\",\n                              identifiant))\n\n\n\n\n# On va empiler la somme des notes en dessous de la base des notes\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\n# Moyenne des notes\nmoyennes &lt;- data.table(donnees_datatable[, lapply(.SD, mean, na.rm = TRUE), .SDcols = varNotes])\n\n# On crée la base des notes\nnotes &lt;- donnees_datatable[, mget(c(\"identifiant\", varNotes))]\n\n# Empilement proprement dit\nempiler &lt;- rbindlist(list(notes, moyennes), fill = TRUE)\n# On renomme la ligne des moyennes ajoutée\nset(empiler, i = nrow(empiler), j = \"identifiant\", value = \"Moyenne\")\n\n\n\n\n\n\n\n# On va empiler la somme des notes en dessous de la base des notes\nvarNotes = [\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\"]\n# Moyenne des notes\nmoyennes = pd.DataFrame(donnees_python[varNotes].mean()).T\nmoyennes['identifiant'] = 'Moyenne'\n# On crée la base des notes\nnotes = donnees_python[['identifiant'] + varNotes]\n\nfor col in notes.columns:\n    if col not in moyennes.columns:\n        moyennes[col] = np.nan\n\n# Concaténer les DataFrames\nempiler = pd.concat([notes, moyennes], ignore_index=True)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#ajouter-une-ligne-de-valeurs-manquantes-à-une-base-de-données",
    "href": "01-aide_memoire_r_sas.html#ajouter-une-ligne-de-valeurs-manquantes-à-une-base-de-données",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "18.3 Ajouter une ligne de valeurs manquantes à une base de données",
    "text": "18.3 Ajouter une ligne de valeurs manquantes à une base de données\n\nSASR basetidyversedata.tablearrow/duckdbpandas\n\n\ndata Ajout;run;\ndata Ajout_Missing;set Jointure Ajout;run;\n\n\n\najout_na &lt;- donnees_rbase\najout_na[nrow(ajout_na) + 1, ] &lt;- NA\n\n\n\n\najout_na &lt;- donnees_tidyverse %&gt;%\n  bind_rows(tibble(NA))\n\n\n\n\najout_na &lt;- rbindlist(list(donnees_datatable, data.table(NA)), fill = TRUE)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#moyenne",
    "href": "01-aide_memoire_r_sas.html#moyenne",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "19.1 Moyenne",
    "text": "19.1 Moyenne\n\n19.1.1 Moyenne\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc means data = donnees_sas mean;var note_contenu;run;\nproc sql;select mean(note_contenu) from donnees_sas;run;\n\n\n\n# Importance du na.rm = TRUE en cas de variables manquantes\nmean(donnees_rbase$note_contenu)\nmean(donnees_rbase$note_contenu, na.rm = TRUE)\n\n# La fonction mean de R est lente. Ecriture plus rapide\nsum(donnees_rbase$note_contenu, na.rm = TRUE) / sum(! is.na(donnees_rbase$note_contenu))\n\n\n\n\n# Importance du na.rm = TRUE en cas de variables manquantes\ndonnees_tidyverse %&gt;% pull(note_contenu) %&gt;% mean()\ndonnees_tidyverse %&gt;% pull(note_contenu) %&gt;% mean(na.rm = TRUE)\n\n# Autres solutions\n# Le chiffre est arrondi lorsqu'il est affiché, du fait des propriétés des tibbles\ndonnees_tidyverse %&gt;% summarise(mean(note_contenu, na.rm = TRUE))\ndonnees_tidyverse %&gt;% \n  summarise(across(note_contenu, ~mean(., na.rm = TRUE)))\n\n# Attention, en tidyverse, les syntaxes suivantes ne fonctionnent pas !\n# donnees_tidyverse %&gt;% mean(note_contenu)\n# donnees_tidyverse %&gt;% mean(note_contenu, na.rm = TRUE)\n\n\n\n\n# Importance du na.rm = TRUE en cas de variables manquantes\ndonnees_datatable[, mean(note_contenu)]\ndonnees_datatable[, mean(note_contenu, na.rm = TRUE)]\n\n# Autre solution\ndonnees_datatable[, lapply(.SD, mean, na.rm = TRUE), .SDcols = \"note_contenu\"]\n\n\n\n\n\n\n\n\n\n19.1.2 Moyenne par sélection\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Ici pour les seules femmes */\nproc means data = donnees_sas mean;\n  var note_contenu;\n  where sexef = \"Femme\";\nrun;\n\n\n\n# Ici, pour les seules femmes\nwith(subset(donnees_rbase, sexef == \"Femme\"), mean(note_contenu, na.rm = TRUE))\nmean(donnees_rbase[donnees_rbase$sexef == \"Femme\", \"note_contenu\"], na.rm = TRUE)\n\n\n\n\n# Ici, pour les seules femmes\ndonnees_tidyverse %&gt;%\n  filter(sexef == \"Femme\") %&gt;% \n  pull(note_contenu) %&gt;%\n  mean(na.rm = TRUE)\n\n# Autres solutions\ndonnees_tidyverse %&gt;%\n  filter(sexef == \"Femme\") %&gt;% \n  summarise(moyenne = mean(note_contenu, na.rm = TRUE))\ndonnees_tidyverse %&gt;%\n  filter(sexef == \"Femme\") %&gt;% \n  summarise(across(note_contenu, ~ mean(., na.rm = TRUE)))\n# Attention, syntaxe qui ne fonctionne qu'avec %&gt;%, pas avec %&gt;% !\ndonnees_tidyverse %&gt;%\n  filter(sexef == \"Femme\") %&gt;% \n  {mean(.$note_contenu, na.rm = TRUE)}\n\n\n\n\n# Ici, pour les seules femmes\ndonnees_datatable[sexef == \"Femme\", mean(note_contenu, na.rm = TRUE)]\ndonnees_datatable[sexef == \"Femme\", lapply(.SD, function(x) mean(x, na.rm = TRUE)), .SDcols = \"note_contenu\"]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#moyenne-pondérée",
    "href": "01-aide_memoire_r_sas.html#moyenne-pondérée",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "19.2 Moyenne pondérée",
    "text": "19.2 Moyenne pondérée\n\n19.2.1 Moyenne pondérée\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc means data = donnees_sas mean;\n  var note_contenu;\n  weight poids_sondage;\nrun;\n\n\n\nweighted.mean(donnees_rbase$note_contenu, donnees_rbase$poids_sondage, na.rm = TRUE)\n\n# Autre méthode, mais attention aux NA !!\nwith(donnees_rbase, sum(note_contenu * poids_sondage, na.rm = TRUE) / sum((!is.na(note_contenu)) * poids_sondage, na.rm = TRUE))\n\n\n\n\ndonnees_tidyverse %&gt;%\n  summarise(across(note_contenu, ~weighted.mean(., w = poids_sondage, na.rm = TRUE)))\n\n\n\n\ndonnees_datatable[, weighted.mean(note_contenu, poids_sondage, na.rm = TRUE)]\n\n\n\n\n\n\n\n\n\n19.2.2 Moyenne pondérée par sélection\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Par sélection (ici pour les seules femmes) */\nproc means data = donnees_sas mean;\n  var note_contenu;\n  where sexef = \"Femme\";\n  weight poids_sondage;\nrun;\n\n\n\n# Par sélection (ici pour les seules femmes)\nwith(subset(donnees_rbase, sexef == \"Femme\"), weighted.mean(note_contenu, poids_sondage, na.rm = TRUE))\n\n\n\n\n# Par sélection (ici pour les seules femmes)\ndonnees_tidyverse %&gt;%\n  filter(sexef == \"Femme\") %&gt;%\n  summarise(across(note_contenu, ~weighted.mean(., w = poids_sondage, na.rm = TRUE)))\n\n\n\n\n# Par sélection (ici pour les seules femmes)\ndonnees_datatable[sexef == \"Femme\", weighted.mean(note_contenu, poids_sondage, na.rm = TRUE)]\ndonnees_datatable[sexef == \"Femme\", lapply(.SD, function(x) weighted.mean(x, poids_sondage, na.rm = TRUE)), .SDcols = \"note_contenu\"]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#moyenne-de-plusieurs-variables",
    "href": "01-aide_memoire_r_sas.html#moyenne-de-plusieurs-variables",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "19.3 Moyenne de plusieurs variables",
    "text": "19.3 Moyenne de plusieurs variables\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\nproc means data = donnees_sas mean;\n  var &notes.;\nrun;\n\n\n\nnotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\n\n# Plusieurs solutions\n\n# Sous forme de liste\nlapply(donnees_rbase[, notes], mean, na.rm = TRUE)\n\n# Sous forme de vecteur\nsapply(donnees_rbase[, notes], mean, na.rm = TRUE)\napply(donnees_rbase[, notes], 2, mean, na.rm = TRUE)\n\n# Si l'on souhaite renommer les colonnes\nmoyennes &lt;- sapply(donnees_rbase[, notes], mean, na.rm = TRUE)\nnames(moyennes) &lt;- paste(\"Moyenne\", names(moyennes), sep = \"_\")\nmoyennes\n\n\n\n\nnotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\ndonnees_tidyverse %&gt;%\n  summarise(across(all_of(notes), ~ mean(.x, na.rm = TRUE)))\n# Si l'on souhaite renommer les colonnes\nmoyennes &lt;- donnees_tidyverse %&gt;%\n  summarise(across(all_of(notes), ~ mean(.x, na.rm = TRUE), .names = \"Moyenne_{.col}\"))\n\n# Autres solutions\n# Obsolètes\ndonnees_tidyverse %&gt;%\n  summarise_at(notes, mean, na.rm = TRUE)\ndonnees_tidyverse %&gt;%  \n  select(starts_with(\"Note\") & !ends_with(\"_100\")) %&gt;% \n  summarise_all(.funs = ~ mean(., na.rm = TRUE), .vars = notes)\n# Si l'on souhaite renommer les colonnes\nmoyennes &lt;- donnees_tidyverse %&gt;%\n  summarise_at(notes, mean, na.rm = TRUE) %&gt;% \n  rename_with(~ paste(\"Moyenne\", ., sep = \"_\"))\n\n\n\n\nnotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\nmoyennes &lt;- donnees_datatable[, lapply(.SD, mean, na.rm = TRUE), .SDcols = notes]\n\n# Si l'on souhaite renommer les colonnes\nsetnames(moyennes, notes, paste(\"Moyenne\", notes, sep = \"_\"))\nmoyennes",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#moyenne-pondérée-de-plusieurs-variables",
    "href": "01-aide_memoire_r_sas.html#moyenne-pondérée-de-plusieurs-variables",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "19.4 Moyenne pondérée de plusieurs variables",
    "text": "19.4 Moyenne pondérée de plusieurs variables\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\nproc means data = donnees_sas mean;\n  var &notes.;\n  weight poids_sondage;\nrun;\n\n\n\nwith(donnees_rbase, sapply(donnees_rbase[, notes], function(x) weighted.mean(x, poids_sondage, na.rm = TRUE)))\n\n\n\n\nnotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\ndonnees_tidyverse %&gt;%\n  summarise(across(notes, ~ weighted.mean(.x, poids_sondage, na.rm = TRUE)))\n\n# Autre solution\ndonnees_tidyverse %&gt;%\n  summarise_at(notes, ~ weighted.mean(.x, poids_sondage, na.rm = TRUE))\n\n\n\n\nmoyennes &lt;- donnees_datatable[, lapply(.SD, function(x) weighted.mean(x, poids_sondage, na.rm = TRUE)), .SDcols = notes]\nmoyennes",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#nombreuses-statistiques-somme-moyenne-médiane-mode-etc.",
    "href": "01-aide_memoire_r_sas.html#nombreuses-statistiques-somme-moyenne-médiane-mode-etc.",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "19.5 Nombreuses statistiques (somme, moyenne, médiane, mode, etc.)",
    "text": "19.5 Nombreuses statistiques (somme, moyenne, médiane, mode, etc.)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Petite différence avec SAS sur le nombre de lignes du fait des valeurs manquantes */\n/* Somme, moyenne, médiane, minimum, maximum, variance, écart-type, nombre de données non manquantes (n), nombre de données manquantes (nmiss), intervalle (entre max et min), mode */\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\n\n/* Par la proc means, en un seul tableau */\nproc means data = donnees_sas sum mean median min max var std n nmiss range mode;\n  var &notes.;\nrun;\n\n/* Par la proc univariate, variable par variable */\nproc univariate data = donnees_sas;\n  var &notes.;\nrun;\n\n\n\n# Somme, moyenne, médiane, minimum, maximum, variance, écart-type, nombre de données (manquantes et non manquantes), nombre de valeurs manquantes, Intervalle (entre max et min), mode\n# Petite différence avec SAS sur le nombre de lignes du fait des valeurs manquantes\n# Une solution pour obtenir le mode en R est d'utiliser fmode du package collapse\nlibrary(collapse)\nsapply(donnees_rbase[, notes], function(x) c(\"Somme\"      = sum(x, na.rm = TRUE),\n                                             \"Moyenne\"    = mean(x, na.rm = TRUE),\n                                             \"Médiane\"    = median(x, na.rm = TRUE),\n                                             \"Min\"        = min(x, na.rm = TRUE),\n                                             \"Max\"        = max(x, na.rm = TRUE),\n                                             # Pour la variance, la somme des carrés est divisée par n - 1, où n est le nombre de données\n                                             \"Variance\"   = var(x, na.rm = TRUE),\n                                             \"Ecart-type\" = sd(x, na.rm = TRUE),\n                                             \"N\"          = length(x),\n                                             \"NMiss\"      = sum(is.na(x)),\n                                             \"Intervalle\" = max(x, na.rm = TRUE) - min(x, na.rm = TRUE),\n                                             \"Mode\"       = collapse::fmode(x)\n))\n\n\n\n\n# Somme, moyenne, médiane, minimum, maximum, variance, écart-type, nombre de données (manquantes et non manquantes), nombre de valeurs manquantes, Intervalle (entre max et min), mode\n# Petite différence avec SAS sur le nombre de lignes du fait des valeurs manquantes\n# Une solution pour obtenir le mode en R est d'utiliser fmode du package collapse\nlibrary(collapse)\nnotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\nStatsDesc_tidyverse &lt;- function(x) {\n  c(\n    Somme      = sum(x, na.rm = TRUE),\n    Moyenne    = mean(x, na.rm = TRUE),\n    Mediane    = median(x, na.rm = TRUE),\n    Min        = min(x, na.rm = TRUE),\n    Max        = max(x, na.rm = TRUE),\n    Variance   = var(x, na.rm = TRUE),\n    Ecart_type = sd(x, na.rm = TRUE),\n    N          = length(x),\n    NMiss      = sum(is.na(x)),\n    Intervalle = max(x, na.rm = TRUE) - min(x, na.rm = TRUE),\n    Mode       = collapse::fmode(x)\n    )\n}\n\n# 1ère solution avec les notes en ligne et les statistiques en colonnes\ndonnees_tidyverse %&gt;% \n  select(all_of(notes)) %&gt;% \n  map(~ StatsDesc_tidyverse(.x)) %&gt;% \n  bind_rows() %&gt;% \n  bind_cols(tibble(Note = c(notes))) %&gt;% \n  relocate(Note)\n\n# 2e solution avec les notes en colonne\ndonnees_tidyverse %&gt;%\n  reframe(across(notes, ~ StatsDesc_tidyverse(.x))) %&gt;% \n  bind_cols(tibble(Indicateur = c(\"Somme\", \"Moyenne\", \"Mediane\", \"Min\", \"Max\", \"Variance\",\n                                  \"Ecart_type\", \"N\", \"NMiss\", \"Intervalle\", \"Mode\"))) %&gt;% \n  relocate(Indicateur)\n\n\n\n\n# Somme, moyenne, médiane, minimum, maximum, variance, écart-type, nombre de données (manquantes et non manquantes), nombre de valeurs manquantes, Intervalle (entre max et min), mode\n# Petite différence avec SAS sur le nombre de lignes du fait des valeurs manquantes\nnotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\n# Une solution pour obtenir le mode en R est d'utiliser fmode du package collapse\nlibrary(collapse)\nmoyennes &lt;- donnees_datatable[, lapply(.SD, function(x) c(sum(x, na.rm = TRUE),\n                                                          mean(x, na.rm = TRUE),\n                                                          median(x, na.rm = TRUE),\n                                                          min(x, na.rm = TRUE),\n                                                          max(x, na.rm = TRUE),\n                                                          var(x, na.rm = TRUE),\n                                                          sd(x, na.rm = TRUE),\n                                                          .N,\n                                                          sum(is.na(x)),\n                                                          max(x, na.rm = TRUE) - min(x, na.rm = TRUE),\n                                                          collapse::fmode(x)\n                                                          )),\n                              .SDcols = notes]\ncbind(data.table(Nom = c(\"Somme\", \"Moyenne\", \"Médiane\", \"Min\", \"Max\", \"Variance\", \"Ecart_type\", \"N\", \"NMiss\", \"Intervalle\", \"Mode\")), moyennes)\n\n# Autre solution\nStatsDesc &lt;- function(x) {\n  list(\n    Variable   = names(x),\n    Somme      = lapply(x, sum, na.rm = TRUE),\n    Moyenne    = lapply(x, mean, na.rm = TRUE),\n    Mediane    = lapply(x, median, na.rm = TRUE),\n    Min        = lapply(x, min, na.rm = TRUE),\n    Max        = lapply(x, max, na.rm = TRUE),\n    Variance   = lapply(x, var, na.rm = TRUE),\n    Ecart_type = lapply(x, sd, na.rm = TRUE),\n    N          = lapply(x, function(x) length(x)),\n    NMiss      = lapply(x, function(x) sum(is.na(x))),\n    Intervalle = lapply(x, function(x) max(x, na.rm = TRUE) - min(x, na.rm = TRUE)),\n    Mode       = lapply(x, collapse::fmode)\n    )\n}\ndonnees_datatable[, StatsDesc(.SD), .SDcols = notes]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#nombreuses-statistiques-pondérées-somme-moyenne-médiane-mode-etc.",
    "href": "01-aide_memoire_r_sas.html#nombreuses-statistiques-pondérées-somme-moyenne-médiane-mode-etc.",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "19.6 Nombreuses statistiques pondérées (somme, moyenne, médiane, mode, etc.)",
    "text": "19.6 Nombreuses statistiques pondérées (somme, moyenne, médiane, mode, etc.)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Somme, moyenne, médiane, minimum, maximum, variance, écart-type, nombre de données non manquantes (n), nombre de données manquantes (nmiss), intervalle, mode */\n/* Par la proc means, en un seul tableau */\n/* L'option vardef = wgt permet de diviser la variable par la somme des poids et non le nombre de données, pour être cohérent\n   avec R */\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\n\n/* Par la proc means, en un seul tableau */\nproc means data = donnees_sas sum mean median min max var std n nmiss range mode vardef = wgt;\n  var &notes.;\n  weight poids_sondage;\nrun;\n\n/* Par la proc univariate, variable par variable */\nproc univariate data = donnees_sas;\n  var &notes.;\n  weight poids_sondage;\nrun;\n\n\n\n# Une solution pour obtenir les résultats pondérés est d'utiliser les fonctions du package collapse\n# L'option na.rm est par défaut à TRUE dans le package\n# Attention, dans le package, le poids s'indique par la variable w = \nlibrary(collapse)\nsapply(donnees_rbase[, notes], function(x) c(\"Somme\"      = collapse::fsum(x, w = donnees_rbase$poids_sondage),\n                                             \"Moyenne\"    = collapse::fmean(x, w = donnees_rbase$poids_sondage),\n                                             \"Médiane\"    = collapse::fmedian(x, w = donnees_rbase$poids_sondage),\n                                             \"Min\"        = collapse::fmin(x),\n                                             \"Max\"        = collapse::fmax(x),\n                                             # Pour la variance, la somme des carrés est divisée par n - 1, où n est le nombre de données\n                                             \"Variance\"   = collapse::fvar(x, w = donnees_rbase$poids_sondage),\n                                             \"Ecart-type\" = collapse::fsd(x, w = donnees_rbase$poids_sondage),\n                                             \"N\"          = collapse::fnobs(x),\n                                             \"NMiss\"      = collapse::fnobs(is.na(x)),\n                                             \"Intervalle\" = collapse::fmax(x) - collapse::fmin(x),\n                                             \"Mode\"       = collapse::fmode(x, w = donnees_rbase$poids_sondage)\n))\n\n\n\n\n# Une solution pour obtenir les résultats pondérés est d'utiliser les fonctions du package collapse\n# L'option na.rm est par défaut à TRUE dans le package\n# Attention, dans le package, le poids s'indique par la variable w = \nlibrary(collapse)\nnotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\nStatsDescPond_tidyverse &lt;- function(x, w) {\n  c(\n    Somme      = collapse::fsum(x, w = w),\n    Moyenne    = collapse::fmean(x, w = w),\n    Mediane    = collapse::fmedian(x, w = w),\n    Min        = collapse::fmin(x),\n    Max        = collapse::fmax(x),\n    Variance   = collapse::fvar(x, w = w),\n    Ecart_type = collapse::fsd(x, w = w),\n    N          = collapse::fnobs(x),\n    NMiss      = collapse::fnobs(is.na(x)),\n    Intervalle = collapse::fmax(x) - collapse::fmin(x),\n    Mode       = collapse::fmode(x, w = w)\n  )\n}\ndonnees_tidyverse %&gt;%\n  reframe(across(notes, ~ StatsDescPond_tidyverse(.x, poids_sondage))) %&gt;% \n  bind_cols(tibble(Indicateur = c(\"Somme\", \"Moyenne\", \"Mediane\", \"Min\", \"Max\", \"Variance\",\n                                  \"Ecart_type\", \"N\", \"NMiss\", \"Intervalle\", \"Mode\"))) %&gt;% \n  relocate(Indicateur)\n\n# Autre solution\ndonnees_tidyverse %&gt;% \n  select(all_of(notes)) %&gt;% \n  map(~StatsDescPond_tidyverse(.x, donnees_tidyverse$poids_sondage)) %&gt;% \n  bind_cols()%&gt;% \n  bind_cols(tibble(Indicateur = c(\"Somme\", \"Moyenne\", \"Mediane\", \"Min\", \"Max\", \"Variance\",\n                                  \"Ecart_type\", \"N\", \"NMiss\", \"Intervalle\", \"Mode\"))) %&gt;% \n  relocate(Indicateur)\n\n\n\n\n# Une solution pour obtenir les résultats pondérés est d'utiliser les fonctions du package collapse\n# L'option na.rm est par défaut à TRUE dans le package\n# Attention, dans le package, le poids s'indique par la variable w = \nlibrary(collapse)\n# À FAIRE : y-a-t-il plus simple ???\n# Est-on obligés d'utiliser systématiquement donnees_datatable$poids_sondage ?\nnotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\n\nStatsDescPond &lt;- function(x, poids = donnees_datatable$poids_sondage) {\n  list(\n    Variables  = names(x),\n    Somme      = collapse::fsum(x, w = poids),\n    Moyenne    = collapse::fmean(x, w = poids),\n    Mediane    = collapse::fmedian(x, w = poids),\n    Min        = collapse::fmin(x),\n    Max        = collapse::fmax(x),\n    Variance   = collapse::fvar(x, w = poids),\n    Ecart_type = collapse::fsd(x, w = poids),\n    N          = collapse::fnobs(x),\n    NMiss      = collapse::fnobs(is.na(x)),\n    Intervalle = collapse::fmax(x) - collapse::fmin(x),\n    Mode       = collapse::fmode(x, w = poids)\n  )\n}\ndonnees_datatable[, StatsDescPond(.SD), .SDcols = notes]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#variance-et-variance-pondérée",
    "href": "01-aide_memoire_r_sas.html#variance-et-variance-pondérée",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "19.7 Variance et variance pondérée",
    "text": "19.7 Variance et variance pondérée\n\n19.7.1 Variance\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc means data = donnees_sas var;\n  var note_contenu;\nrun;\n\n\n\nvar(donnees_rbase$note_contenu)\n\n\n\n\ndonnees_tidyverse %&gt;% \n  summarise(var = var(note_contenu))\n\n\n\n\ndonnees_datatable[, var(note_contenu)]\n\n\n\n\n\n\n\n\n\n19.7.2 Variance pondérée\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc means data = donnees_sas var vardef = wgt;\n  var note_contenu;\n  weight poids_sondage;\nrun;\n\n\n\nlibrary(collapse)\nwith(donnees_rbase, collapse::fvar(note_contenu, w = poids_sondage))\n\n\n\n\nlibrary(collapse)\ndonnees_tidyverse %&gt;% \n  summarise(var = collapse::fvar(note_contenu, w = poids_sondage))\n\n\n\n\nlibrary(collapse)\ndonnees_datatable[, collapse::fvar(note_contenu, w = poids_sondage)]\n\n\n\n\n\n\n\n\n\n19.7.3 Calcul “manuel” de la variance pondérée\nLa variance pondérée se calcule par la formule : \\[\n\\frac{\\sum_i{w_i \\times (x_i - \\bar{x}) ^2}}{\\sum_i{w_i}} = \\frac{\\sum_i{w_ix_i^2}} {\\sum_i{w_i}} - \\bar{x}^2\n\\]\noù \\(x_i\\) désigne la variable et \\(w_i\\) le poids.\nOn la calcule “manuellement” en R pour confirmer le résultat.\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc means data = donnees_sas var vardef = wgt;\n  var note_contenu;\n  weight poids_sondage;\nrun;\n\n\n\nx_2 &lt;- with(donnees_rbase,\n            sum(poids_sondage * note_contenu**2 * complete.cases(note_contenu, poids_sondage), na.rm = TRUE))\nx_m &lt;- with(donnees_rbase,\n            sum(poids_sondage * note_contenu * complete.cases(note_contenu, poids_sondage), na.rm = TRUE))\np &lt;- with(donnees_rbase,\n          sum(poids_sondage * complete.cases(note_contenu, poids_sondage), na.rm = TRUE))\nx_2 / p - (x_m / p) ** 2\n\n\n\n\nx_2 &lt;- donnees_tidyverse %&gt;%  \n  summarise(sum(poids_sondage * note_contenu**2 * complete.cases(note_contenu, poids_sondage), na.rm = TRUE)) %&gt;% \n  pull()\nx_m &lt;- donnees_tidyverse %&gt;%  \n  summarise(sum(poids_sondage * note_contenu * complete.cases(note_contenu, poids_sondage), na.rm = TRUE)) %&gt;% \n  pull()          \np &lt;- donnees_tidyverse %&gt;% \n  summarise(sum(poids_sondage * complete.cases(note_contenu, poids_sondage), na.rm = TRUE)) %&gt;% \n  pull()\nx_2 / p - (x_m / p) ** 2\n\n\n\n\nx_2 &lt;- donnees_datatable[, sum(poids_sondage * note_contenu**2 * complete.cases(note_contenu, poids_sondage),\n                               na.rm = TRUE)]\nx_m &lt;- donnees_datatable[, sum(poids_sondage * note_contenu * complete.cases(note_contenu, poids_sondage),\n                               na.rm = TRUE)]\np &lt;- donnees_datatable[, sum(poids_sondage * complete.cases(note_contenu, poids_sondage), na.rm = TRUE)]\nx_2 / p - (x_m / p) ** 2",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#déciles-et-quantiles",
    "href": "01-aide_memoire_r_sas.html#déciles-et-quantiles",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "19.8 Déciles et quantiles",
    "text": "19.8 Déciles et quantiles\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On calcule déjà la moyenne des notes par individu */\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\ndata donnees_sas;\n  set donnees_sas;\n  Note_moyenne = mean(of &notes.);\nrun;\n\n/* Déciles et quartiles de la note moyenne */\n\n/* Par la proc means */\nproc means data = donnees_sas StackODSOutput Min P10 P20 P30 P40 Median P60 P70 Q3 P80 P90 Max Q1 Median Q3 QRANGE;\n  var Note_moyenne;\n  ods output summary = Deciles_proc_means;\nrun;\n\n/* Par la proc univariate */\nproc univariate data = donnees_sas;\n  var Note_moyenne;\n  output out = Deciles_proc_univariate pctlpts=00 to 100 by 10 25 50 75 PCTLPRE=_; \nrun;\n\n\n\n# On calcule déjà la moyenne des notes par individu\nnotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\ndonnees_rbase$note_moyenne &lt;- rowMeans(donnees_rbase[, notes], na.rm = TRUE)\n\n# Et les quantiles (déciles et quartiles)\nquantile(donnees_rbase$note_moyenne, probs = c(seq(0, 1, 0.1), 0.25, 0.5, 0.75), na.rm = TRUE)\n\n# Intervalle inter-quartile\nIQR(donnees_rbase$note_moyenne, na.rm = TRUE)\n\n\n\n\n# on calcule déjà la moyenne des notes par individu\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  mutate(note_moyenne = rowMeans(across(all_of(varNotes)), na.rm = TRUE))\n\n# Et les quantiles (déciles et quartiles)\ndonnees_tidyverse %&gt;%\n  pull(note_moyenne) %&gt;% \n  quantile(probs = c(seq(0, 1, 0.1), 0.25, 0.5, 0.75), na.rm = TRUE)\n\n# Intervalle inter-quartile\ndonnees_tidyverse %&gt;%\n  pull(note_moyenne) %&gt;% \n  IQR(na.rm = TRUE)\n\n\n\n\n# on calcule déjà la moyenne des notes par individu\nnotes &lt;- c(\"note_contenu\",\"note_formateur\",\"note_moyens\",\"note_accompagnement\",\"note_materiel\")\ndonnees_datatable[, note_moyenne := rowMeans(.SD, na.rm = TRUE), .SDcols = notes]\n\n# Et les quantiles (déciles et quartiles)\ndonnees_datatable[, quantile(.SD, probs = c(seq(0, 1, 0.1), 0.25, 0.5, 0.75), na.rm = TRUE), .SDcols = \"note_moyenne\"]\ndonnees_datatable[, lapply(.SD, quantile, probs = c(seq(0, 1, 0.1), 0.25, 0.5, 0.75), na.rm = TRUE), .SDcols = \"note_moyenne\"]\n\n# Intervalle inter-quartile\ndonnees_datatable[, IQR(note_moyenne, na.rm = TRUE)]\ndonnees_datatable[, lapply(.SD, function(x) IQR(x, na.rm = TRUE)), .SDcols = \"note_moyenne\"]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#déciles-et-quantiles-pondérés",
    "href": "01-aide_memoire_r_sas.html#déciles-et-quantiles-pondérés",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "19.9 Déciles et quantiles pondérés",
    "text": "19.9 Déciles et quantiles pondérés\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On calcule déjà la moyenne des notes par individu */\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\ndata donnees_sas;\n  set donnees_sas;\n  Note_moyenne = mean(of &notes.);\nrun;\n\n/* Par la proc means */\nproc means data = donnees_sas StackODSOutput Min P10 P20 P30 P40 Median P60 P70 Q3 P80 P90 Max Q1 Median Q3 QRANGE;\n  var Note_moyenne;\n  ods output summary = Deciles_proc_means;\n  weight poids_sondage;\nrun;\n\n/* Par la proc univariate */\nproc univariate data = donnees_sas;\n  var Note_moyenne;\n  output out = Deciles_proc_univariate pctlpts=00 to 100 by 10 25 50 75 PCTLPRE=_;\n  weight poids_sondage;\nrun;\n\n\n\n# Une solution pour obtenir les résultats pondérés est d'utiliser la fonction fquantile du package collapse\n# L'option na.rm est par défaut à TRUE dans le package\nlibrary(collapse)\n\n# On calcule déjà la moyenne des notes par individu\nnotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\ndonnees_rbase$note_moyenne &lt;- rowMeans(donnees_rbase[, notes], na.rm = TRUE)\n\n# Les quantiles (déciles et quartiles)\ncollapse::fquantile(donnees_rbase$note_moyenne, w = donnees_rbase$poids_sondage,\n                    probs = c(seq(0, 1, 0.1), 0.25, 0.5, 0.75))\n\n\n\n\n# Une solution pour obtenir les résultats pondérés est d'utiliser les fonctions du package collapse\n# L'option na.rm est par défaut à TRUE dans le package\nlibrary(collapse)\n\n# On calcule déjà la moyenne des notes par individu\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  mutate(note_moyenne = rowMeans(across(all_of(varNotes)), na.rm = TRUE))\n\n# Les quantiles (déciles et quartiles)\ndonnees_tidyverse %&gt;%\n  pull(note_moyenne) %&gt;% \n  collapse::fquantile(probs = c(seq(0, 1, 0.1), 0.25, 0.5, 0.75), w = donnees_tidyverse$poids_sondage)\n\n\n\n\n# Une solution pour obtenir les résultats pondérés est d'utiliser la fonction fquantile du package collapse\n# L'option na.rm est par défaut à TRUE dans le package\nlibrary(collapse)\n\n# On calcule déjà la moyenne des notes par individu\nnotes &lt;- c(\"note_contenu\",\"note_formateur\",\"note_moyens\",\"note_accompagnement\",\"note_materiel\")\ndonnees_datatable[, note_moyenne := rowMeans(.SD, na.rm = TRUE), .SDcols = notes]\n\n# Les quantiles (déciles et quartiles)\ndonnees_datatable[, lapply(.SD, function(x) collapse::fquantile(x, w = poids_sondage,\n                                                                probs = c(seq(0, 1, 0.1), 0.25, 0.5, 0.75)\n                                                                )),\n                           .SDcols = \"note_moyenne\"]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#rang-de-la-note",
    "href": "01-aide_memoire_r_sas.html#rang-de-la-note",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "19.10 Rang de la note",
    "text": "19.10 Rang de la note\nAjouter dans la base le rang de la note par ordre décroissant.\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On calcule déjà la moyenne des notes par individu */\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\ndata donnees_sas;\n  set donnees_sas;\n  Note_moyenne = mean(of &notes.);\nrun;\n\nproc rank data = donnees_sas out = donnees_sas descending;\n  var note_moyenne;\n  ranks rang_note_moyenne;\nrun;\n\n\n\n# On calcule déjà la moyenne des notes par individu\nnotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\ndonnees_rbase$note_moyenne &lt;- rowMeans(donnees_rbase[, notes], na.rm = TRUE)\n\n# Attention, en R, rank trie par ordre croissant par défaut, alors que le tri est par ordre décroissant en SAS\n# On exprime le rang par ordre décroissant, avec le - devant\ndonnees_rbase$rang_note_moyenne &lt;- rank(-donnees_rbase$note_moyenne)\n\n\n\n\n# On calcule déjà la moyenne des notes par individu\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  mutate(note_moyenne = rowMeans(across(all_of(varNotes)), na.rm = TRUE)) %&gt;% \n  # Attention, en R, rank trie par ordre croissant par défaut, alors que le tri est par ordre décroissant en SAS\n  # On exprime le rang par ordre décroissant, avec le - devant\n  mutate(rang_note_moyenne = rank(-note_moyenne))\n\n\n\n\n# On calcule déjà la moyenne des notes par individu\nnotes &lt;- c(\"note_contenu\",\"note_formateur\",\"note_moyens\",\"note_accompagnement\",\"note_materiel\")\ndonnees_datatable[, note_moyenne := rowMeans(.SD, na.rm = TRUE), .SDcols = notes]\n\n# Attention, en R, frank trie par ordre croissant par défaut, alors que le tri est par ordre décroissant en SAS\n# On exprime le rang par ordre décroissant, avec le - devant\ndonnees_datatable[, rang_note_moyenne := frank(-note_moyenne)]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#covariance-et-corrélation-linéaire",
    "href": "01-aide_memoire_r_sas.html#covariance-et-corrélation-linéaire",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "19.11 Covariance et corrélation linéaire",
    "text": "19.11 Covariance et corrélation linéaire\n\n19.11.1 Covariance entre deux notes\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Covariance et corrélation linéaire (Kendall, Pearson, Spearman) */\nproc corr data = donnees_sas kendall pearson spearman cov;\n  var note_contenu note_formateur;\nrun;\n\n\n\n# Covariance (Kendall, Pearson, Spearman)\nwith(donnees_rbase,\n     sapply(c(\"pearson\", \"spearman\", \"kendall\"),\n            function(x) cov(note_contenu, note_formateur, method = x, use = \"complete.obs\")))\n\n\n\n\n# Covariance (Kendall, Pearson, Spearman)\nmethodes &lt;- c(\"pearson\", \"spearman\", \"kendall\")\nmethodes %&gt;% \n  purrr::map(~ \n    donnees_tidyverse %&gt;% \n      summarise(cov = cov(note_contenu, note_formateur, method = .x, use = \"complete.obs\"))) %&gt;% \n  setNames(methodes) %&gt;% \n  as_tibble()\n\n\n\n\n# Covariance (Kendall, Pearson, Spearman)\nmethodes &lt;- c(\"pearson\", \"spearman\", \"kendall\")\nsetNames(donnees_datatable[, lapply(methodes,\n                                    function(x) cov(note_contenu, note_formateur,\n                                                    method = x,\n                                                    use = \"complete.obs\"))],\n         methodes)\n\n\n\n\n\n\n\n\n\n19.11.2 Corrélation linéaire entre deux notes\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Corrélation linéaire (Kendall, Pearson, Spearman) */\nproc corr data = donnees_sas kendall pearson spearman cov;\n  var note_contenu note_formateur;\nrun;\n\n\n\n# Corrélation linéaire (Kendall, Pearson, Spearman)\nwith(donnees_rbase,\n     sapply(c(\"pearson\", \"spearman\", \"kendall\"),\n            function(x) cor(note_contenu, note_formateur, method = x, use = \"complete.obs\")))\n\n\n\n\n# Corrélation linéaire (Kendall, Pearson, Spearman)\nmethodes &lt;- c(\"pearson\", \"spearman\", \"kendall\")\nmethodes %&gt;% \n  purrr::map(~ donnees_tidyverse %&gt;% \n               summarise(cor = cor(note_contenu, note_formateur, method = .x, use = \"complete.obs\"))) %&gt;% \n  setNames(methodes) %&gt;% \n  as_tibble()\n\n\n\n\n# Corrélation linéaire (Kendall, Pearson, Spearman)\nmethodes &lt;- c(\"pearson\", \"spearman\", \"kendall\")\nsetNames(donnees_datatable[, lapply(methodes,\n                                    function(x) cor(note_contenu, note_formateur,\n                                                    method = x,\n                                                    use = \"complete.obs\"))],\n         methodes)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#centrer-et-réduire-les-variables",
    "href": "01-aide_memoire_r_sas.html#centrer-et-réduire-les-variables",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "19.12 Centrer et réduire les variables",
    "text": "19.12 Centrer et réduire les variables\nOn souhaite centrer (moyenne nulle) et réduire (écart-type égal à 1) les notes.\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\ndata centrer_reduire;set donnees_sas (keep = &notes.);run;\nproc stdize data = centrer_reduire out = centrer_reduire method = std;\n   var &notes.;\nrun;\n\n\n\nnotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\ncentrer_reduire &lt;- scale(donnees_rbase[, notes])\n\n# Autre solution avec les fonctions apply et sweep\n# Centrer la base\ncentrer &lt;- sweep(donnees_rbase[, notes], 2, colMeans(donnees_rbase[, notes], na.rm = TRUE), FUN = \"-\")\n# Réduire la base\n# On calcule déjà l'écart-type par colonne\necart_type &lt;- t(apply(centrer, 2, sd, na.rm = TRUE))\n# Et on réduit\ncentrer_reduire &lt; sweep(centrer, 2, ecart_type, \"/\")\n\n\n\n\nnotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\ncentrer_reduire &lt;- donnees_tidyverse %&gt;% \n  select(all_of(notes)) %&gt;% \n  mutate(across(notes, ~ (.x - mean(.x, na.rm = TRUE)) / sd(.x, na.rm = TRUE) ))\n\n\n\n\nnotes &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\ncentrer_reduire &lt;- donnees_datatable[, lapply(.SD, function(x) (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)), .SDcols = notes]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#tableaux-de-fréquence-pour-1-variable",
    "href": "01-aide_memoire_r_sas.html#tableaux-de-fréquence-pour-1-variable",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "20.1 Tableaux de fréquence pour 1 variable",
    "text": "20.1 Tableaux de fréquence pour 1 variable\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc freq data = donnees_sas;\n  tables Sexe CSP;\n  format Sexe sexef. CSP $cspf.;\nrun;\n\n\n\n# Tableaux de fréquence (proc freq) (sans les valeurs manquantes)\ntable(donnees_rbase$cspf)\ntable(donnees_rbase$sexef)\n# Autre syntaxe, donnant une mise en forme différente\nftable(donnees_rbase$cspf)\n# Pour enlever les \"donnees_rbase$\", on peut utiliser with pour se placer dans l'environnement de donnees_rbase\nwith(donnees_rbase, table(cspf))\n\n# Pour les proportions\nprop.table(table(donnees_rbase$cspf)) * 100\n\n# Devient plus difficile si l'on souhaite plus (sommes et proportions cumulées par exemple)\nfreq &lt;- setNames(as.data.frame(table(donnees_rbase$cspf)), c(\"cspf\", \"Freq\"))\nfreq &lt;- transform(freq, Prop = Freq / sum(Freq) * 100)\nfreq &lt;- transform(freq,\n                  Freq_cum = cumsum(Freq),\n                  Prop_cum = cumsum(Prop))\nfreq\n\n\n\n\ndonnees_tidyverse %&gt;% \n  count(cspf) %&gt;% \n  mutate(prop = n / sum(n) * 100,\n         n_cum = cumsum(n),\n         prop_cum = cumsum(prop))\n\n# Ou alors\ndonnees_tidyverse %&gt;% \n  group_by(cspf) %&gt;% \n  summarise(n = n()) %&gt;% \n  mutate(prop = n / sum(n) * 100,\n         n_cum = cumsum(n),\n         prop_cum = cumsum(prop)\n  )\n\n\n\n\n# Tableaux de fréquence (proc freq) (avec les valeurs manquantes)\ndonnees_datatable[, table(cspf) ]\ndonnees_datatable[, table(sexef) ]\n\n# Pour les proportions\ndonnees_datatable[, prop.table(table(cspf)) ] * 100\ndonnees_datatable[, .(Nombre = .N,\n                      Pourcentage = .N / length(donnees_datatable[, cspf]) * 100),\n                  keyby = cspf]\ndonnees_datatable[, {tot = .N; .SD[, .(frac = .N / tot * 100), keyby = cspf]} ]\n\n# Autre façon d'utiliser les méthodes de data.table, avec les fréquences et proportions cumulés\ntab &lt;- data.table::dcast(donnees_datatable, cspf ~ ., fun = length)\ncolnames(tab)[colnames(tab) == \".\"] &lt;- \"Nombre\"\ntab[, Prop := lapply(.SD, function(col) col / sum(col) * 100), .SDcols = is.numeric]\ntab[, c(\"Freq_cum\", \"Prop_cum\") := list(cumsum(Nombre), cumsum(Prop))]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#tableaux-de-fréquence-avec-les-valeurs-manquantes",
    "href": "01-aide_memoire_r_sas.html#tableaux-de-fréquence-avec-les-valeurs-manquantes",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "20.2 Tableaux de fréquence avec les valeurs manquantes",
    "text": "20.2 Tableaux de fréquence avec les valeurs manquantes\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc freq data = donnees_sas;\n  tables Sexe CSP / missing;\n  format Sexe sexef. CSP $cspf.;\nrun;\n\n\n\ntable(donnees_rbase$cspf, useNA = \"always\")\nprop.table(table(donnees_rbase$cspf, useNA = \"always\")) * 100\n\n\n\n\ndonnees_tidyverse %&gt;% \n  count(cspf) %&gt;% \n  mutate(prop = n / sum(n) * 100)\n\n\n\n\ndonnees_datatable[, table(cspf, useNA = \"always\") ]\ndonnees_datatable[, prop.table(table(cspf, useNA = \"always\"))] * 100\ndonnees_datatable[, .(Nombre = .N,\n                      Pourcentage = .N / length(donnees_datatable[, cspf]) * 100),\n                  keyby = cspf]\ndonnees_datatable[, {tot = .N; .SD[, .(frac = .N / tot * 100), keyby = cspf]} ]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#tableaux-de-fréquence-triés-par-la-modalité-la-plus-courante",
    "href": "01-aide_memoire_r_sas.html#tableaux-de-fréquence-triés-par-la-modalité-la-plus-courante",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "20.3 Tableaux de fréquence triés par la modalité la plus courante",
    "text": "20.3 Tableaux de fréquence triés par la modalité la plus courante\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc freq data = donnees_sas order = freq;\n  tables Sexe CSP / missing;\n  format Sexe sexef. CSP $cspf.;\nrun;\n\n\n\nfreq &lt;- setNames(as.data.frame(table(donnees_rbase$cspf)), c(\"cspf\", \"Freq\"))\nfreq &lt;- transform(freq, Prop = Freq / sum(Freq) * 100)\nfreq[order(-freq$Freq), ]\n\n\n\n\ndonnees_tidyverse %&gt;% \n  count(cspf) %&gt;% \n  arrange(desc(n)) %&gt;% \n  mutate(prop = n / sum(n) * 100,\n         n_cum = cumsum(n),\n         prop_cum = cumsum(prop))\n\n# Autre solution\ndonnees_tidyverse %&gt;% \n  count(cspf, sort = TRUE) %&gt;% \n  mutate(prop = n / sum(n) * 100,\n         n_cum = cumsum(n),\n         prop_cum = cumsum(prop))\n\n\n\n\ndonnees_datatable[, .(Nombre = .N,\n                      Pourcentage = .N / length(donnees_datatable[, cspf]) * 100),\n                  keyby = cspf][order(-Nombre)]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#tableaux-de-fréquence-avec-la-pondération",
    "href": "01-aide_memoire_r_sas.html#tableaux-de-fréquence-avec-la-pondération",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "20.4 Tableaux de fréquence avec la pondération",
    "text": "20.4 Tableaux de fréquence avec la pondération\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc freq data = donnees_sas;\n  tables Sexe CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n\n\n\nxtabs(poids_sondage ~ cspf, data = donnees_rbase, addNA = TRUE)\nprop.table(xtabs(poids_sondage ~ cspf, data = donnees_rbase, addNA = TRUE))\n\n\n\n\ndonnees_tidyverse %&gt;% \n  count(cspf, wt = poids_sondage) %&gt;% \n  mutate(prop = n / sum(n) * 100,\n         n_cum = cumsum(n),\n         prop_cum = cumsum(prop))\n\n\n\n\ndonnees_datatable[, xtabs(poids_sondage ~ cspf, data = donnees_datatable, addNA = TRUE) ]\ndonnees_datatable[, prop.table(xtabs(poids_sondage ~ cspf, data = donnees_datatable, addNA = TRUE)) ]\ndonnees_datatable[, .(prop = sum(poids_sondage, na.rm = TRUE) / sum(donnees_datatable[, poids_sondage]) * 100), keyby = cspf]\ndonnees_datatable[, {tot = sum(poids_sondage, na.rm = TRUE); .SD[, .(prop = sum(poids_sondage, na.rm = TRUE) / tot * 100), by = cspf]} ]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#tableaux-de-contingence-pour-2-variables",
    "href": "01-aide_memoire_r_sas.html#tableaux-de-contingence-pour-2-variables",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "21.1 Tableaux de contingence pour 2 variables",
    "text": "21.1 Tableaux de contingence pour 2 variables\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\nrun;\n\n/* Tableau de contingence (tableau croisé) sans les proportions lignes, colonnes et totales */\nproc freq data = donnees_sas;\n  tables CSP * Sexe  / missing nofreq norow nocol;\n  format Sexe sexef. CSP $cspf.;\nrun;\n\n\n\n# Tableau simple\ntable(donnees_rbase$cspf, donnees_rbase$sexef, useNA = \"always\")\n# Tableau avec les sommes\naddmargins(table(donnees_rbase$cspf, donnees_rbase$sexef, useNA = \"always\"))\n\n# Proportions\ntab &lt;- table(donnees_rbase$cspf, donnees_rbase$sexef, useNA = \"always\")\n# Proportions par case\naddmargins(prop.table(tab)) * 100\n# Proportions par ligne\naddmargins(prop.table(tab, margin = 1)) * 100\n# Proportions par colonne\naddmargins(prop.table(tab, margin = 2)) * 100\n\n# Solution alternative, sans pondération\ntab &lt;- xtabs(~ cspf + sexef, data = donnees_rbase)\naddmargins(prop.table(tab)) * 100\naddmargins(prop.table(tab, margin = 1), margin = 2) * 100\naddmargins(prop.table(tab, margin = 2), margin = 1) * 100\n\n\n\n\n# Tableau de fréquence\ntab &lt;- donnees_tidyverse %&gt;% \n  group_by(cspf, sexef) %&gt;% \n  summarise(prop = n(), .groups = \"drop_last\") %&gt;% \n  ungroup() %&gt;% \n  mutate(prop = prop / sum(prop) * 100) %&gt;%\n  spread(sexef, prop) %&gt;% \n  mutate(Total = rowSums(across(where(is.numeric)), na.rm = TRUE))\ntab &lt;- bind_rows(tab, tab %&gt;% \n                   summarise(across(where(is.numeric), \\(x) sum(x, na.rm = TRUE)),\n                             across(where(is.character), ~\"Total\"))\n)\ntab\n\n# Proportions par ligne\ndonnees_tidyverse %&gt;% \n  group_by(cspf, sexef) %&gt;% \n  summarise(prop = n()) %&gt;% \n  mutate(prop = prop / sum(prop) * 100) %&gt;% \n  spread(sexef, prop)\n\n# Proportions par colonne\ndonnees_tidyverse %&gt;% \n  group_by(sexef, cspf) %&gt;% \n  summarise(prop = n()) %&gt;% \n  mutate(prop = prop / sum(prop) * 100) %&gt;% \n  spread(sexef, prop)\n\n\n\n1ère solution\n\n# Tableau simple\ndonnees_datatable[, table(cspf, sexef, useNA = \"always\") ]\n# Tableau avec les sommes\ndonnees_datatable[, addmargins(table(cspf, sexef, useNA = \"always\")) ]\n# Proportions\ntab &lt;- donnees_datatable[, table(cspf, sexef, useNA = \"always\") ]\n# Proportions par case\naddmargins(prop.table(tab)) * 100\n# Proportions par ligne\naddmargins(prop.table(tab, margin = 1)) * 100\n# Proportions par colonne\naddmargins(prop.table(tab, margin = 2)) * 100\n\n2e solution\n\n# Solution alternative, sans pondération\ntab &lt;- donnees_datatable[, xtabs(~ cspf + sexef, data = donnees_datatable) ]\ntab\naddmargins(prop.table(tab)) * 100\naddmargins(prop.table(tab, margin = 1), margin = 2) * 100\naddmargins(prop.table(tab, margin = 2), margin = 1) * 100\n\n3e solution\n\n# Autre solution, avec les Grouping sets\ntab &lt;- data.table::cube(donnees_datatable, .(Nb = .N), by = c(\"cspf\", \"sexef\"))\ntab &lt;- data.table::dcast(tab, cspf ~ sexef, value.var = \"Nb\")\n# On harmonise le tableau\ntab &lt;- rbind(tab[2:nrow(tab)], tab[1,])\nsetcolorder(tab, c(setdiff(names(tab), \"NA\"), \"NA\"))\n# On renomme la ligne et la colonne des totaux\ntab[nrow(tab), 1] &lt;- \"Total\"\nnames(tab)[which(names(tab) == \"NA\")] &lt;- \"Total\"\ntab\n\n4e solution\n\n# Autre façon d'utiliser les méthodes de data.table\ntab_prop &lt;- data.table::dcast(donnees_datatable, cspf ~ sexef, fun.aggregate = length)\n# Proportion par ligne\ntab_prop[, .SD / Reduce(`+`, .SD), cspf]\n# Proportion par colonne\ncols &lt;- unique(donnees_datatable[, (sexef)])\ntab_prop[, (lapply(.SD, function(col) col / sum(col))), .SDcols = cols]\n\n# Pour avoir les sommes lignes\n# À FAIRE : ne marche pas, à revoir !\n#tab_prop &lt;- data.table::dcast(donnees_datatable, cspf ~ sexef, fun.aggregate = length)\n#tab_prop[, Total := rowSums(.SD), .SDcols = is.numeric]\n#tab_prop &lt;- rbind(tab_prop, tab_prop[, c(cspf = \"Total\", lapply(.SD, sum, na.rm = TRUE)),\n#                                     .SDcols = is.numeric],\n#                  fill = TRUE)\n#tab_prop[, (lapply(.SD, function(col) col / sum(col))), .SDcols = -1]\n## Pour avoir les sommes colonnes\n#tab[, sum(.SD), by = 1:nrow(tab), .SDcols = is.numeric]\n#tab[, (lapply(.SD, function(col) col / sum(col))), .SDcols = -1]\n#\n## Autre solution plus pratique avec data.table\n## Manipuler des formules sur R\n#variable &lt;- c(\"cspf\", \"sexef\")\n#formule &lt;- as.formula(paste(paste(variable, collapse = \" + \"), \".\", sep = \" ~ \"))\n#tab_prop &lt;- data.table::dcast(donnees_datatable, formule, fun.aggregate = length)\n#colnames(tab_prop)[colnames(tab_prop) == \".\"] &lt;- \"total\"\n#tab_prop[, prop := total / sum(total)]\n## Le tableau est remis sous forme croisée\n#tab_prop &lt;- dcast(tab_prop, cspf ~ sexef, value.var = c(\"prop\"), fill = 0)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#tableau-de-contingence-avec-pondération",
    "href": "01-aide_memoire_r_sas.html#tableau-de-contingence-avec-pondération",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "21.2 Tableau de contingence avec pondération",
    "text": "21.2 Tableau de contingence avec pondération\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n\n\n\ntab &lt;- xtabs(poids_sondage ~ cspf + sexef, data = donnees_rbase, addNA = TRUE)\ntab\naddmargins(prop.table(tab)) * 100\naddmargins(prop.table(tab, margin = 1), margin = 2) * 100\naddmargins(prop.table(tab, margin = 2), margin = 1) * 100\n\n\n\n\n# Avec la fonction count\ndonnees_tidyverse %&gt;% \n  count(cspf, sexef, wt = poids_sondage, name = \"prop\") %&gt;% \n  ungroup() %&gt;% \n  mutate(prop = prop / sum(prop) * 100) %&gt;% \n  spread(sexef, prop)\n\n# Avec la fonction summarise\ndonnees_tidyverse %&gt;% \n  group_by(cspf, sexef) %&gt;% \n  summarise(prop = sum(poids_sondage, na.rm = TRUE)) %&gt;% \n  ungroup() %&gt;% \n  mutate(prop = prop / sum(prop) * 100) %&gt;% \n  spread(sexef, prop)\n\n# Avec ajout des sommes par ligne et colonne\ntab &lt;- donnees_tidyverse %&gt;% \n  count(cspf, sexef, wt = poids_sondage, name = \"prop\") %&gt;% \n  ungroup() %&gt;% \n  mutate(prop = prop / sum(prop) * 100) %&gt;% \n  pivot_wider(names_from = sexef, values_from = prop) %&gt;% \n  # Somme par ligne\n  mutate(Total = rowSums(across(where(is.numeric)), na.rm = TRUE))\n# Somme par colonne\ntab &lt;- bind_rows(tab, tab %&gt;% \n                   summarise(across(where(is.numeric), sum, na.rm = TRUE),\n                             across(where(is.character), ~\"Total\"))\n            )\ntab\n\n\n\n\ntab &lt;- donnees_datatable[, xtabs(poids_sondage ~ cspf + sexef, data = donnees_datatable, addNA = TRUE) ]\ntab\naddmargins(prop.table(tab)) * 100\naddmargins(prop.table(tab, margin = 1), margin = 2) * 100\naddmargins(prop.table(tab, margin = 2), margin = 1) * 100",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#copier-coller-le-tableau-dans-un-tableur-excel-etc.",
    "href": "01-aide_memoire_r_sas.html#copier-coller-le-tableau-dans-un-tableur-excel-etc.",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "21.3 Copier-coller le tableau dans un tableur (Excel, etc.)",
    "text": "21.3 Copier-coller le tableau dans un tableur (Excel, etc.)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Copier-coller le résultat sur la fenêtre html \"Results Viewer\" */\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing chisq;\n  format Sexe sexef. CSP $cspf.;\nrun;\n\n\n\n# On utilise les packages knitr et kableExtra\nlibrary(knitr)\nlibrary(kableExtra)\n\n# Création d'un tableau\ntab &lt;- xtabs(~ cspf + sexef, data = donnees_rbase)\ntab &lt;- addmargins(prop.table(tab)) * 100\n\n# Afficher de façon plus jolie un tableau\nknitr::kable(tab)\n\n# Copier-coller le résultat vers Excel\n# Il suffit d'appliquer ce code ....\nkableExtra::kable_paper(kableExtra::kbl(tab), \"hover\", full_width = F)\n# ... et de copier-coller le résultat de la fenêtre Viewer vers Excel\n\n\n\n\n# On utilise les packages knitr et kableExtra\nlibrary(knitr)\nlibrary(kableExtra)\n\n# Création d'un tableau\ntab &lt;- donnees_tidyverse %&gt;% \n  group_by(cspf, sexef) %&gt;% \n  summarise(prop = n(), .groups = \"drop_last\") %&gt;% \n  ungroup() %&gt;% \n  mutate(prop = prop / sum(prop) * 100) %&gt;% \n  spread(sexef, prop)\n\n# Afficher de façon plus jolie un tableau\ntab %&gt;% knitr::kable()\n\n# Copier-coller le résultat vers Excel\n# Il suffit d'appliquer ce code ....\ntab %&gt;% \n  knitr::kable() %&gt;% \n  kableExtra::kable_paper(\"hover\", full_width = F)\n# ... et de copier-coller le résultat de la fenêtre Viewer vers Excel\n\n\n\n\n# On utilise les packages knitr et kableExtra\nlibrary(knitr)\nlibrary(kableExtra)\n\n# Création d'un tableau\ntab &lt;- donnees_datatable[, xtabs(poids_sondage ~ cspf + sexef, data = donnees_datatable, addNA = TRUE) ]\ntab &lt;- \naddmargins(prop.table(tab)) * 100\n\n# Afficher de façon plus jolie un tableau\nknitr::kable(tab)\n\n# Copier-coller le résultat vers Excel\n# Il suffit d'appliquer ce code ....\nkableExtra::kable_paper(kableExtra::kbl(tab), \"hover\", full_width = F)\n# ... et de copier-coller le résultat de la fenêtre Viewer vers Excel",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#tests-dassociaton-chi-deux-etc.",
    "href": "01-aide_memoire_r_sas.html#tests-dassociaton-chi-deux-etc.",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "21.4 Tests d’associaton (Chi-Deux, etc.)",
    "text": "21.4 Tests d’associaton (Chi-Deux, etc.)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing chisq;\n  format Sexe sexef. CSP $cspf.;\nrun;\n\n\n\n# Test du Khi-Deux\nwith(donnees_rbase, chisq.test(cspf, sexef))\nsummary(table(donnees_rbase$cspf, donnees_rbase$sexef))\n\n\n\n\n# Test du Khi-Deux\nchisq.test(donnees_tidyverse %&gt;% pull(cspf), donnees_tidyverse %&gt;% pull(sexef))\n\n\n\n\n# Test du Khi-Deux\ndonnees_datatable[, chisq.test(cspf, sexef)]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#solutions-avec-package-r-permettant-de-pondérer",
    "href": "01-aide_memoire_r_sas.html#solutions-avec-package-r-permettant-de-pondérer",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "21.5 Solutions avec package R permettant de pondérer",
    "text": "21.5 Solutions avec package R permettant de pondérer\nAutre possibilité, avec package R, pour avoir la même présentation que la proc freq de SAS.\n5 packages paraissent pertinents : descr, flextable, questionr, survey, procs.\nDes informations sur l’usage des packages en R sont disponibles sur le site Utilit’R : https://book.utilitr.org/03_Fiches_thematiques/Fiche_comment_choisir_un_package.html.\n\n21.5.1 Package descr\nLien vers la documentation : https://cran.r-project.org/web/packages/descr/descr.pdf.\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Sans objet pour SAS */\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n\n\n\nlibrary(descr)\n# Non pondéré\nwith(donnees_rbase, descr::crosstab(cspf, sexef,                         prop.r = TRUE, prop.c = TRUE, prop.t = TRUE))\n# Pondéré\nwith(donnees_rbase, descr::crosstab(cspf, sexef, weight = poids_sondage, prop.r = TRUE, prop.c = TRUE, prop.t = TRUE))\n# Sans les proportions par ligne et colonne\nwith(donnees_rbase, descr::crosstab(cspf, sexef, weight = poids_sondage, prop.r = FALSE, prop.c = FALSE, prop.t = TRUE))\n\n\n\n\nlibrary(descr)\n# Non pondéré\nwith(donnees_tidyverse, descr::crosstab(cspf, sexef,                         prop.r = TRUE, prop.c = TRUE, prop.t = TRUE))\n# Pondéré\nwith(donnees_tidyverse, descr::crosstab(cspf, sexef, weight = poids_sondage, prop.r = TRUE, prop.c = TRUE, prop.t = TRUE))\n# Sans les proportions par ligne et colonne\nwith(donnees_tidyverse, descr::crosstab(cspf, sexef, weight = poids_sondage, prop.r = FALSE, prop.c = FALSE, prop.t = TRUE))\n\n\n\n\nlibrary(descr)\n# Non pondéré\ndonnees_datatable[, descr::crosstab(cspf, sexef,                         prop.r = TRUE, prop.c = TRUE, prop.t = TRUE)]\n# Pondéré\ndonnees_datatable[, descr::crosstab(cspf, sexef, weight = poids_sondage, prop.r = TRUE, prop.c = TRUE, prop.t = TRUE)]\n# Sans les proportions par ligne et colonne\ndonnees_datatable[, descr::crosstab(cspf, sexef, weight = poids_sondage, prop.r = FALSE, prop.c = FALSE, prop.t = TRUE)]\n\n\n\n\n\n\n\n\n\n21.5.2 Package flextable\nLien vers la documentation :\n\nhttps://ardata-fr.github.io/flextable-book/crosstabs.html\nhttps://cran.r-project.org/web/packages/flextable/flextable.pdf\n\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Sans objet pour SAS */\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n\n\n\nlibrary(flextable)\n# Non pondéré\nflextable::proc_freq(donnees_rbase, \"cspf\", \"sexef\")\n# Pondéré\nflextable::proc_freq(donnees_rbase, \"cspf\", \"sexef\", weight = \"poids_sondage\")\n# Sans les proportions par ligne et colonne\nflextable::proc_freq(donnees_rbase, \"cspf\", \"sexef\", weight = \"poids_sondage\", include.row_percent = FALSE, include.column_percent = FALSE)\n\n\n\n\nlibrary(flextable)\n# Non pondéré\nflextable::proc_freq(donnees_tidyverse, \"cspf\", \"sexef\")\n# Pondéré\nflextable::proc_freq(donnees_tidyverse, \"cspf\", \"sexef\", weight = \"poids_sondage\")\n# Sans les proportions par ligne et colonne\nflextable::proc_freq(donnees_tidyverse, \"cspf\", \"sexef\", weight = \"poids_sondage\", include.row_percent = FALSE, include.column_percent = FALSE)\n\n\n\n\nlibrary(flextable)\n# Non pondéré\nflextable::proc_freq(donnees_datatable, \"cspf\", \"sexef\")\n# Pondéré\nflextable::proc_freq(donnees_datatable, \"cspf\", \"sexef\", weight = \"poids_sondage\")\n# Sans les proportions par ligne et colonne\nflextable::proc_freq(donnees_datatable, \"cspf\", \"sexef\", weight = \"poids_sondage\", include.row_percent = FALSE, include.column_percent = FALSE)\n\n\n\n\n\n\n\n\n\n21.5.3 Package questionr\nLien vers la documentation : https://cran.r-project.org/web/packages/questionr/questionr.pdf.\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Sans objet pour SAS */\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n\n\n\nlibrary(questionr)\n# Tableau croisé\n# Sans pondération\ntab &lt;- with(donnees_rbase, questionr::wtd.table(cspf, sexef, useNA = \"ifany\"), na.rm = TRUE)\n# Avec pondération\ntab &lt;- with(donnees_rbase, questionr::wtd.table(cspf, sexef, weights = poids_sondage, useNA = \"ifany\"), na.rm = TRUE)\ntab\n# Proportions\nquestionr::prop(tab)\n# Proportions colonnes\nquestionr::cprop(tab)\n# Proportions lignes\nquestionr::rprop(tab)\n\n\n\n\n# Sans pondération\nlibrary(questionr)\n# Tableau croisé\n# Sans pondération\ntab &lt;- with(donnees_tidyverse, questionr::wtd.table(cspf, sexef, useNA = \"ifany\"), na.rm = TRUE)\n# Avec pondération\ntab &lt;- with(donnees_tidyverse, questionr::wtd.table(cspf, sexef, weights = poids_sondage, useNA = \"ifany\"), na.rm = TRUE)\ntab\n# Proportions\nquestionr::prop(tab)\n# Proportions colonnes\nquestionr::cprop(tab)\n# Proportions lignes\nquestionr::rprop(tab)\n\n\n\n\n# Sans pondération\nlibrary(questionr)\n# Tableau croisé\n# Sans pondération\ntab &lt;- donnees_datatable[, questionr::wtd.table(cspf, sexef, useNA = \"ifany\")]\n# Avec pondération\ntab &lt;- donnees_datatable[, questionr::wtd.table(cspf, sexef, weights = poids_sondage, useNA = \"ifany\")]\ntab\n# Proportions\nquestionr::prop(tab)\n# Proportions colonnes\nquestionr::cprop(tab)\n# Proportions lignes\nquestionr::rprop(tab)\n\n\n\n\n\n\n\n\n\n21.5.4 Package survey\nLien vers la documentation : https://cran.r-project.org/web/packages/survey/survey.pdf.\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Sans objet pour SAS */\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n\n\n\nlibrary(survey)\ntab &lt;- survey::svydesign(id = ~1, weights = ~poids_sondage, data = donnees_rbase)\nsurvey::svytable(poids_sondage ~ sexef + cspf, design = tab)\n\n\n\n\n# La syntaxe avec pipe n'est pas compatible avec le package survey\nlibrary(survey)\ntab &lt;- survey::svydesign(id = ~1, weights = ~poids_sondage, data = donnees_tidyverse)\nsurvey::svytable(poids_sondage ~ sexef + cspf, design = tab)\n\n\n\n\nlibrary(survey)\ntab &lt;- survey::svydesign(id = ~1, weights = ~poids_sondage, data = donnees_datatable)\nsurvey::svytable(poids_sondage ~ sexef + cspf, design = tab)\n\n\n\n\n\n\n\n\n\n21.5.5 Package procs\nLien vers la documentation : https://cran.r-project.org/web/packages/procs/vignettes/procs-freq.html.\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Sans objet pour SAS */\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n\n\n\nlibrary(procs)\nprocs::proc_freq(donnees_rbase, tables = cspf * sexef, options = v(missing))\n# Ne fonctionne pas avec le poids !!!\n#procs::proc_freq(donnees_rbase, tables = cspf * sexef, weight = poids_sondage, options = v(missing))\n\n\n\n\nlibrary(procs)\nprocs::proc_freq(donnees_tidyverse, tables = cspf * sexef, options = v(missing))\n# Ne fonctionne pas avec le poids !!!\n#procs::proc_freq(donnees_tidyverse, tables = cspf * sexef, weight = poids_sondage, options = v(missing))\n\n\n\n\nlibrary(procs)\n# Il semble nécessaire de convertire l'objet en data.frame\nprocs::proc_freq(setDF(donnees_datatable), tables = cspf * sexef, options = v(missing))\n# Ne fonctionne pas avec le poids !!!\n#procs::proc_freq(setDF(donnees_datatable), tables = cspf * sexef, weight = poids_sondage, options = v(missing))\n# On reconvertit en data.table\nsetDT(donnees_datatable)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#solutions-avec-package-r-ne-permettant-apparemment-pas-de-pondérer",
    "href": "01-aide_memoire_r_sas.html#solutions-avec-package-r-ne-permettant-apparemment-pas-de-pondérer",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "21.6 Solutions avec package R ne permettant apparemment pas de pondérer",
    "text": "21.6 Solutions avec package R ne permettant apparemment pas de pondérer\nAutres packages, qui semblent peu utiles, ne permettant apparemment pas de pondérer.\n\n21.6.1 Package Janitor\nLien vers la documentation : https://cran.r-project.org/web/packages/janitor/vignettes/tabyls.html.\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Sans objet pour SAS */\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n\n\n\nlibrary(janitor)\n# Attention, la fonction tabyl ne permet pas de pondérer\ntab &lt;- janitor::tabyl(donnees_rbase, cspf, sexef)\ntab\njanitor::adorn_totals(tab, c(\"row\", \"col\"))\n# Pourcentages\njanitor::adorn_percentages(tab, denominator = \"all\", na.rm = TRUE)\n# Pourcentages lignes\njanitor::adorn_percentages(tab, denominator = \"row\", na.rm = TRUE)\n# Pourcentages colonnes\njanitor::adorn_percentages(tab, denominator = \"col\", na.rm = TRUE)\n\n\n\n\nlibrary(janitor)\n# Attention, la fonction tabyl ne permet pas de pondérer\ntab &lt;- donnees_tidyverse %&gt;% \n  janitor::tabyl(cspf, sexef) %&gt;% \n  janitor::adorn_totals(c(\"row\", \"col\"))\ntab\n# Pourcentages\ntab %&gt;% janitor::adorn_percentages(denominator = \"all\", na.rm = TRUE)\n# Pourcentages lignes\ntab %&gt;% janitor::adorn_percentages(denominator = \"row\", na.rm = TRUE)\n# Pourcentages colonnes\ntab %&gt;% janitor::adorn_percentages(denominator = \"col\", na.rm = TRUE)\n\n\n\n\nlibrary(janitor)\n# Attention, la fonction tabyl ne permet pas de pondérer\ntab &lt;- janitor::tabyl(donnees_datatable, cspf, sexef)\ntab\njanitor::adorn_totals(tab, c(\"row\", \"col\"))\n# Pourcentages\njanitor::adorn_percentages(tab, denominator = \"all\", na.rm = TRUE)\n# Pourcentages lignes\njanitor::adorn_percentages(tab, denominator = \"row\", na.rm = TRUE)\n# Pourcentages colonnes\njanitor::adorn_percentages(tab, denominator = \"col\", na.rm = TRUE)\n\n\n\n\n\n\n\n\n\n21.6.2 Package crosstable\nLien vers la documentation : https://cran.r-project.org/web/packages/crosstable/crosstable.pdf.\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Sans objet pour SAS */\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n\n\n\nlibrary(crosstable)\ncrosstable::crosstable(donnees_rbase, cspf, by = sexef, showNA = \"always\", percent_digits = 0, percent_pattern =\"{n} ({p_col}/{p_row})\")\n\n\n\n\nlibrary(crosstable)\ncrosstable::crosstable(donnees_tidyverse, cspf, by = sexef, showNA = \"always\",\n                       percent_digits = 0, percent_pattern =\"{n} ({p_col}/{p_row})\")\n\n\n\n\nlibrary(crosstable)\ncrosstable::crosstable(donnees_datatable, cspf, by = sexef, showNA = \"always\",\n                       percent_digits = 0, percent_pattern =\"{n} ({p_col}/{p_row})\")\n\n\n\n\n\n\n\n\n\n21.6.3 Package gmodels\nLien vers la documentation : https://cran.r-project.org/web/packages/gmodels/gmodels.pdf.\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Sans objet pour SAS */\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n\n\n\nlibrary(gmodels)\ngmodels::CrossTable(donnees_rbase$cspf, donnees_rbase$sexef)\n\n\n\n\nlibrary(gmodels)\ndonnees_tidyverse %&gt;% \n  summarise(gmodels::CrossTable(cspf, sexef))\n\n\n\n\nlibrary(gmodels)\ngmodels::CrossTable(donnees_datatable$cspf, donnees_datatable$sexef)\n\n\n\n\n\n\n\n\n\n21.6.4 Package gtsummary\nLien vers la documentation : https://cran.r-project.org/web/packages/gtsummary/gtsummary.pdf.\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Sans objet pour SAS */\nproc freq data = donnees_sas;\n  tables Sexe * CSP / missing;\n  format Sexe sexef. CSP $cspf.;\n  weight poids_sondage;\nrun;\n\n\n\nlibrary(gtsummary)\n# Pourcentages par case, colonne, ligne\ngtsummary::tbl_cross(data = donnees_rbase, row = cspf, col = sexef, percent = c(\"cell\"),   margin = c(\"column\", \"row\"), missing = c(\"always\"))\ngtsummary::tbl_cross(data = donnees_rbase, row = cspf, col = sexef, percent = c(\"column\"), margin = c(\"column\", \"row\"), missing = c(\"always\"))\ngtsummary::tbl_cross(data = donnees_rbase, row = cspf, col = sexef, percent = c(\"row\"),    margin = c(\"column\", \"row\"), missing = c(\"always\"))\n\n\n\n\nlibrary(gtsummary)\n# Pourcentages par case, colonne, ligne\ngtsummary::tbl_cross(data = donnees_tidyverse, row = cspf, col = sexef, percent = c(\"cell\"),   margin = c(\"column\", \"row\"), missing = c(\"always\"))\ngtsummary::tbl_cross(data = donnees_tidyverse, row = cspf, col = sexef, percent = c(\"column\"), margin = c(\"column\", \"row\"), missing = c(\"always\"))\ngtsummary::tbl_cross(data = donnees_tidyverse, row = cspf, col = sexef, percent = c(\"row\"),    margin = c(\"column\", \"row\"), missing = c(\"always\"))\n\n\n\n\nlibrary(gtsummary)\n# Pourcentages par case, colonne, ligne\ngtsummary::tbl_cross(data = donnees_datatable, row = cspf, col = sexef, percent = c(\"cell\"),  \n                     margin = c(\"column\", \"row\"), missing = c(\"always\"))\ngtsummary::tbl_cross(data = donnees_datatable, row = cspf, col = sexef, percent = c(\"column\"),\n                     margin = c(\"column\", \"row\"), missing = c(\"always\"))\ngtsummary::tbl_cross(data = donnees_datatable, row = cspf, col = sexef, percent = c(\"row\"),   \n                     margin = c(\"column\", \"row\"), missing = c(\"always\"))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#moyenne-des-notes-par-csp-variable-en-ligne",
    "href": "01-aide_memoire_r_sas.html#moyenne-des-notes-par-csp-variable-en-ligne",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "22.1 Moyenne des notes par CSP (variable en ligne)",
    "text": "22.1 Moyenne des notes par CSP (variable en ligne)\n\n22.1.1 Moyenne non pondérée\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Moyenne de note_contenu et nombre de personnes */\n\n/* 1ère solution */\nproc sort data = donnees_sas;by cspf;run;\nproc means data = donnees_sas mean n;var note_contenu;class cspf;run;\n\n/* 2e solution */\nproc tabulate data = donnees_sas;\n  var note_contenu;\n  class cspf;\n  table (cspf all = \"Total\"), note_contenu * (mean n);\nrun;\n\n/* 3e solution */\nproc sql;\n  select cspf, mean(note_contenu) as note_contenu_moyenne, count(*) as N\n  from donnees_sas\n  group by cspf\n  order by cspf;\nquit;\n\n\n\n# Moyenne de note_contenu et nombre de personnes\naggregate(note_contenu ~ cspf, donnees_rbase, function(x) c(Moyenne = mean(x, na.rm = TRUE), Nombre = length(x)))\n\n# Moyenne de note_contenu\n# Une seule variable, une seule variable de groupe, une seule fonction\naggregate(note_contenu ~ cspf, donnees_rbase, mean, na.rm = TRUE)\n\n# rowsum (à ne pas confondre avec rowSums) calcule des sommes, et uniquement des sommes\nrowsum(donnees_rbase$note_contenu, donnees_rbase$cspf, recorder = TRUE, na.rm = TRUE)\n# Pour obtenir une moyenne, on peut écrire\nrowsum(donnees_rbase$note_contenu, donnees_rbase$cspf, recorder = TRUE, na.rm = TRUE) / as.vector(table(donnees_rbase$cspf))\n\n# Fonctions tapply et by\ntapply(donnees_rbase$note_contenu, donnees_rbase$cspf, mean, na.rm = TRUE)\nwith(donnees_rbase, tapply(note_contenu, cspf, mean, na.rm = TRUE))\ntapply(donnees_rbase$note_contenu, donnees_rbase$cspf, mean, na.rm = TRUE)\nby(donnees_rbase$note_contenu, donnees_rbase$cspf, mean, na.rm = TRUE)\n\n# Découpage avec la fonction split (très pratique en R base !)\nsapply(split(donnees_rbase, donnees_rbase$cspf), function(x) mean(x$note_contenu, na.rm = TRUE))\n\n\n\n\n# Moyenne de note_contenu et nombre de personnes\ndonnees_tidyverse %&gt;% \n  group_by(cspf) %&gt;% \n  summarise(Nombre = n(), Moyenne = mean(note_contenu, na.rm = TRUE))\n# Ou alors :\nsummarise(Nombre = n(), Moyenne = mean(note_contenu, na.rm = TRUE), .by = cspf)\n\n# Moyenne de note_contenu\n# Une seule variable, une seule variable de groupe, une seule fonction\ndonnees_tidyverse %&gt;% \n  group_by(cspf) %&gt;% \n  summarise(Moyenne = mean(note_contenu, na.rm = TRUE))\ndonnees_tidyverse %&gt;% \n  summarise(Moyenne = mean(note_contenu, na.rm = TRUE), .by = cspf)\n\n\n\n\n# Moyenne de note_contenu et nombre de personnes\ndonnees_datatable[, .(note_contenu_moyenne = mean(note_contenu, na.rm = TRUE), N = .N), by = cspf]\ndonnees_datatable[, .(note_contenu_moyenne = mean(note_contenu, na.rm = TRUE), N = .N), keyby = \"cspf\"]\n\n# Variables définies à part\nvarNotes &lt;- \"note_contenu\"\nvar_groupe &lt;- \"cspf\"\n# À FAIRE : les deux variables sont empilées, pourquoi ??\ndonnees_datatable[, lapply(.SD, function(x) c(moyenne = mean(x, na.rm = TRUE), n = length(x))),\n                  by = var_groupe,\n                  .SDcols = varNotes]\n\n\n\n\n\n\n\n\n\n22.1.2 Moyenne pondérée\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Moyenne de note_contenu et nombre de personnes */\nproc sort data = donnees_sas;by cspf;run;\nproc means data = donnees_sas mean n;\n  var note_contenu;class cspf;\n  weight poids_sondage;\nrun;\n\n/* Autre possibilité */\nproc tabulate data = donnees_sas;\n  var note_contenu;\n  class cspf;\n  weight poids_sondage;\n  table (cspf all = \"Total\"), note_contenu * (mean n);\nrun;\n\n\n\n# Avec la pondération : tapply ne fonctionne pas, il faut découper la base en facteurs avec split\nsapply(split(donnees_rbase, donnees_rbase$cspf), function(x) weighted.mean(x$note_contenu, x$poids_sondage, na.rm = TRUE))\n# À FAIRE : autre solution ?\n\n\n\n\n# Avec la pondération\ndonnees_tidyverse %&gt;% \n  group_by(cspf) %&gt;% \n  summarise(Moyenne = weighted.mean(note_contenu, poids_sondage, na.rm = TRUE))\ndonnees_tidyverse %&gt;% \n  summarise(Moyenne = weighted.mean(note_contenu, poids_sondage, na.rm = TRUE), .by = cspf)\n\n\n\n\n# Avec la pondération\nvarNotes &lt;- \"note_contenu\"\nvar_groupe &lt;- \"cspf\"\ndonnees_datatable[, lapply(.SD, function(x) weighted.mean(x, poids_sondage, na.rm = TRUE)),\n                  keyby = var_groupe,\n                  .SDcols = varNotes]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#moyenne-des-notes-par-csp-et-sexe-variables-en-ligne",
    "href": "01-aide_memoire_r_sas.html#moyenne-des-notes-par-csp-et-sexe-variables-en-ligne",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "22.2 Moyenne des notes par CSP et Sexe (variables en ligne)",
    "text": "22.2 Moyenne des notes par CSP et Sexe (variables en ligne)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let var_notes = note_contenu note_formateur note_moyens note_accompagnement note_materiel;\n%let var_groupe = cspf sexef;\nproc sort data = donnees_sas;by &var_groupe.;run;\nproc means data = donnees_sas mean n;\n  class &var_groupe.;\n  var &var_notes.;\n  output out = Resultat;\nrun;\n\n/* Autre solution */\n%macro sel;\n  %global select;\n  %local i j;\n  %let select = ;\n  %do i = 1 %to %sysfunc(countw(&var_notes.));\n    %let j = %scan(&var_notes., &i., %str( ));\n    %let select = &select. mean(&j) as &j._moyenne,;\n  %end;\n%mend sel;\n%sel;\n\n%let group = %sysfunc(tranwrd(&var_groupe., %str( ), %str(, )));\nproc sql;\n  select &group., &select. count(*) as N\n  from donnees_sas\n  group by &group.\n  order by &group.;\nquit;\n\n\n\n# Plusieurs solutions avec aggregate (plutôt lent)\naggregate(note_contenu ~ cspf + sexef, donnees_rbase, function(x) c(mean = mean(x), n = length(x)))\naggregate(cbind(note_contenu, note_materiel) ~ cspf + sexef, donnees_rbase, function(x) c(moyenne = mean(x, na.rm = TRUE), n = length(x)))\n\n# Via les formules\nvariable &lt;- c(\"note_contenu\")\nvarGroupement &lt;- c(\"cspf\", \"sexef\")\nformule &lt;- as.formula(paste(variable, paste(varGroupement, collapse = \" + \"), sep = \" ~ \"))\naggregate(formule, donnees_rbase, function(x) c(moyenne = mean(x, na.rm = TRUE), n = length(x)))\n\n# Avec by\nby(donnees_rbase[, variable], donnees_rbase[, varGroupement], function(x) c(mean = mean(x, na.rm = TRUE), n = length(x)))\n\n# Avec rowsum (à ne pas confondre avec rowSums)\n# Somme\nrowsum(donnees_rbase[, variable], interaction(donnees_rbase[, varGroupement], sep = \"_\", lex.order = TRUE))\n# Moyenne\nrowsum(donnees_rbase[, variable], interaction(donnees_rbase[, varGroupement], sep = \"_\")) / as.vector(table(interaction(donnees_rbase[, varGroupement])))\n\n\n\n\ndonnees_tidyverse %&gt;% \n  group_by(cspf, sexef) %&gt;% \n  summarise(Moyenne = mean(note_contenu, na.rm = TRUE), n = n())\n\n# Autre solution : l'ordre des modalités est modifié\ndonnees_tidyverse %&gt;% \n  summarise(Moyenne = mean(note_contenu, na.rm = TRUE), n = n(), .by = c(cspf, sexef))\n\n\n\n\ndonnees_datatable[, .(note_contenu_moyenne = mean(note_contenu, na.rm = TRUE), N = .N), keyby = c(\"cspf\", \"sexef\")]\n\n# Autre solution\ndata.table::dcast(donnees_datatable, cspf + sexef ~ ., value.var = \"note_contenu\", fun.aggregate = mean, na.rm = TRUE)\n\n# Variables définies à part\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nvar_groupe &lt;- c(\"cspf\", \"sexef\")\n# À FAIRE : les deux variables sont empilées, pourquoi ??\ndonnees_datatable[, lapply(.SD, function(x) list(moyenne = mean(x, na.rm = TRUE), n = length(x))),\n                  keyby = var_groupe,\n                  .SDcols = varNotes]\n\n# Nombre de femmes par CSP\n# Il y a un recycling de gender = \"M\", utile de le mentionner\ndonnees_datatable[, .(Femmes = sum(sexef == \"Femme\", na.rm = TRUE), Hommes = sum(sexef == \"Homme\", na.rm = TRUE)), by = .(cspf)]\n\n# À FAIRE :\n# Exemple avec les variables dans .SDcols\n# data.table::setDT(DF)[, lapply(.SD, mean, na.rm = TRUE), .SDcols = c(\"x\", \"y\"), by = list(g, h)]\n# D'autres variations (par exemple, c(x, y) ou list(\"x\", \"y\") ne fonctionnent pas !)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#tableaux-croisés-à-2-variables-de-groupement",
    "href": "01-aide_memoire_r_sas.html#tableaux-croisés-à-2-variables-de-groupement",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "22.3 Tableaux croisés à 2 variables de groupement",
    "text": "22.3 Tableaux croisés à 2 variables de groupement\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\nproc tabulate data = donnees_sas;\n  class cspf sexef;\n  var note_contenu;\n  table (cspf all = \"Ensemble\"), sexef * (note_contenu) * mean;\nrun;\n\n\n\n# Tableau croisé Cspf par Sexef\nvarGroupement &lt;- c(\"cspf\", \"sexef\")\nvariable &lt;- c(\"note_contenu\")\n\n# Solution avec tapply\ntapply(donnees_rbase[, variable], donnees_rbase[varGroupement], function(x) moyenne = mean(x, na.rm = TRUE))\n\n# Solution avec xtabs\nxtabs(note_contenu ~ cspf + sexef, aggregate(note_contenu ~ cspf + sexef, data = donnees_rbase, FUN = mean, na.rm = TRUE))\n# Ou, sous forme de formule\nformule &lt;- as.formula(paste(variable, paste(varGroupement, collapse = \" + \"), sep = \" ~ \"))\nxtabs(formule, aggregate(formule, data = donnees_rbase, FUN = mean, na.rm = TRUE))\n# Et si l'on souhaite un dataframe\nas.data.frame.matrix(xtabs(formule, aggregate(formule, data = donnees_rbase, FUN = mean, na.rm = TRUE)))\n\n# Solution avec aggregate, en calculant un tableau \"long\" et en le transformant en \"wide\"\ntableau &lt;- aggregate(note_contenu ~ cspf + sexef, data = donnees_rbase, FUN = mean, na.rm = TRUE)\ntableau &lt;- reshape(tableau, \n        timevar = varGroupement[2],\n        idvar = varGroupement[1],\n        direction = \"wide\")\ntableau[is.na(tableau)] &lt;- 0\n\n\n\n\n# Tableau croisé Cspf par Sexef\nvarGroupement &lt;- c(\"cspf\", \"sexef\")\nvariable &lt;- c(\"note_contenu\")\ndonnees_tidyverse %&gt;% \n  group_by(across(all_of(varGroupement))) %&gt;% \n  summarise(across(all_of(variable), ~ mean(.x, na.rm = TRUE), .names = \"Moyenne\")) %&gt;% \n  spread(varGroupement[2], Moyenne)\n\n# Autre solution\ndonnees_tidyverse %&gt;% \n  group_by(!!!syms(varGroupement)) %&gt;% \n  summarise(Moyenne = mean(.data[[variable]], na.rm = TRUE)) %&gt;% \n  spread(varGroupement[2], Moyenne)\n\n\n\n\n# Tableau croisé Cspf par Sexef\nvarGroupement &lt;- c(\"cspf\", \"sexef\")\nvariable &lt;- \"note_contenu\"\ndata.table::dcast(donnees_datatable, cspf ~ sexef, value.var = \"note_contenu\", fun.aggregate = mean, na.rm = TRUE)\n\n# Avec références seulement\ndata.table::dcast(donnees_datatable, get(varGroupement[1]) ~ get(varGroupement[2]), value.var = variable,\n                  fun.aggregate = mean, na.rm = TRUE)\n\n# Autre solution, plus indirecte\n# À FAIRE : attention, toujours utiliser lapply, même avec une seule variable ! LE DIRE !!!\ntab &lt;- donnees_datatable[, lapply(.SD, mean, na.rm = TRUE), keyby = varGroupement, .SDcols = \"note_contenu\"]\ndata.table::dcast(tab, get(varGroupement[1]) ~ get(varGroupement[2]), value.var = variable)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#tableaux-croisés-à-3-variables-de-groupement-ou-plus-1-variable-en-ligne-2-en-colonne-par-exemple",
    "href": "01-aide_memoire_r_sas.html#tableaux-croisés-à-3-variables-de-groupement-ou-plus-1-variable-en-ligne-2-en-colonne-par-exemple",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "22.4 Tableaux croisés à 3 variables de groupement ou plus (1 variable en ligne, 2 en colonne par exemple)",
    "text": "22.4 Tableaux croisés à 3 variables de groupement ou plus (1 variable en ligne, 2 en colonne par exemple)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Notes par croisement de CSP (en ligne) et de Sexe x Niveau */\n%let notes = note_contenu note_formateur note_moyens note_accompagnement note_materiel;\nproc tabulate data = donnees_sas;\n  class cspf sexef;\n  var &notes.;\n  table (cspf all = \"Ensemble\"), sexef * (&notes.) * mean;\nrun;\n\n/* Note_contenu par croisement de CSP (en ligne) et de Sexe x Niveau */\nproc tabulate data = donnees_sas;\n  class cspf sexef Niveau;\n  var note_moyenne;\n  table (cspf all = \"Ensemble\"), (sexef * Niveau) * (note_moyenne) * mean;\nrun;\n\n\n\n# 1er exemple : CSPF en ligne, et chacune des 5 notes croisées avec le sexe en colonne\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nvar_groupe &lt;- c(\"cspf\", \"sexef\")\n\ntableau &lt;- aggregate(donnees_rbase[, varNotes], donnees_rbase[var_groupe], function(x) moyenne = mean(x, na.rm = TRUE))\nreshape(tableau, \n        timevar = var_groupe[2],\n        idvar = var_groupe[1],\n        direction = \"wide\")\n\n# 2e exemple : CSPF en ligne, et croisement Sexe x Qualifié en colonne, note_contenu sommée\n# À FAIRE : proposer une fonction ?\nformule &lt;- as.formula(\"note_contenu ~ cspf + sexef + niveau\")\ntab &lt;- xtabs(formule, aggregate(formule, data = donnees_rbase, FUN = mean, na.rm = TRUE))\nnomsCol &lt;- do.call(paste, c(expand.grid(dimnames(tab)[-1L]), sep = \"_\"))\nnomsLig &lt;- dimnames(tab)[[1L]]\n# Transformation du tableau de résultats (en format array) vers un format matrix, puis dataframe\n# Permet d'exprimer le array (matrice multidimensionnelle) en un tableau à deux dimensions\n# On transforme le tableau en matrice ayant en nombre de lignes dim(tab)[1], c'est-à-dire le nombre de lignes du array\n# et en nombre de colonnes le reste des variables\ntab &lt;- data.frame(matrix(tab, nrow = dim(tab)[1L]))\n# Renommage des noms des colonnes de la base\ncolnames(tab) &lt;- nomsCol\n# Renommage des noms des lignes de la base\nrow.names(tab) &lt;- nomsLig\n# On annule les valeurs manquantes\ntab[is.na(tab)] &lt;- 0\ntab\n# À FAIRE : développer autour de cet exemple\n# Avec 3 variables\nxtabs(cbind(note_contenu, note_materiel) ~ cspf + sexef, donnees_rbase)\n\n\n\n\n# 1er exemple : CSPF en ligne, et chacune des 5 notes croisées avec le sexe en colonne\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nvar_groupe &lt;- c(\"cspf\", \"sexef\")\ndonnees_tidyverse %&gt;% \n  group_by(across(all_of(var_groupe))) %&gt;% \n  summarise(across(all_of(varNotes), ~ mean(.x, na.rm = TRUE))) %&gt;% \n  pivot_wider(names_from = sexef,\n              values_from = all_of(varNotes))\n\n# 2e exemple : CSPF en ligne, et croisement Sexe x Qualifié en colonne, note_contenu sommée\nvarNotes &lt;- c(\"note_contenu\")\nvar_groupe &lt;- c(\"cspf\", \"sexef\", \"niveau\")\ndonnees_tidyverse %&gt;% \n  group_by(across(all_of(var_groupe))) %&gt;% \n  summarise(across(all_of(varNotes), ~ mean(.x, na.rm = TRUE))) %&gt;% \n  pivot_wider(names_from = c(sexef, niveau),\n              values_from = all_of(varNotes),\n              values_fill = 0)\n\n\n\n\n# 1er exemple : CSPF en ligne, et chacune des 5 notes croisées avec le sexe en colonne\nvarNotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nvar_groupe &lt;- c(\"cspf\", \"sexef\")\ndata.table::dcast(donnees_datatable, get(varGroupement[1]) ~ get(varGroupement[2]), value.var = varNotes,\n                  fun.aggregate = mean, na.rm = TRUE)\n\n# 2e exemple : CSPF en ligne, et croisement Sexe x Qualifié en colonne, note_contenu sommée\ndata.table::dcast(donnees_datatable, cspf ~ sexef + niveau, value.var = \"note_contenu\",\n                  fun.aggregate = mean, na.rm = TRUE)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#boucles-imbriquées",
    "href": "01-aide_memoire_r_sas.html#boucles-imbriquées",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "23.1 Boucles imbriquées",
    "text": "23.1 Boucles imbriquées\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\ndata _null_;call symput('annee', strip(year(today())));run;\n\n/* Ensemble des premiers jours de chaque mois entre 2020 et le 31 décembre de l'année courante */\n%macro Boucles_Imbriquees(an_debut, an_fin);\n  %local i j;\n  %global liste_mois;\n  %let liste_mois = ;\n  \n  %do i = &an_debut. %to &an_fin.;\n    %do j = 1 %to 12;\n        %let liste_mois = &liste_mois. %sysfunc(putn(%sysfunc(mdy(&j., 1, &i.)), ddmmyy10.));\n      %end;\n  %end;\n%mend Boucles_Imbriquees;\n\n%let annee = %sysfunc(year(%sysfunc(today())));\n%Boucles_Imbriquees(an_debut = 2020, an_fin = &annee.);\n%put &liste_mois.;\n\n\n\n# Ensemble des premiers jours de chaque mois entre 2020 et l'année courante\nannee &lt;- lubridate::year(Sys.Date())\n# 1ère solution avec for (lente, à déconseiller !)\nlisteMois &lt;- c()\nfor (i in seq(2020, annee)) {\n  for (j in 1:12) {\n    listeMois &lt;- as.Date(c(listeMois, lubridate::ymd(sprintf(\"%02d-%02d-01\", i, j))), origin = \"1970-01-01\")\n  }\n}\n\n# 2e  solution : 2 fonctions lapply imbriquées\nlisteMois &lt;- as.Date(unlist(lapply(seq(2020, annee), \n                                   function(x) lapply(1:12, function(y) lubridate::ymd(sprintf(\"%02d-%02d-01\", x, y))))),\n                     origin = \"1970-01-01\")\n\n# 3e solution : expand.grid\nlisteMois &lt;- sort(as.Date(apply(expand.grid(seq(2020, annee), 1:12), 1, \n                                function(x) lubridate::ymd(sprintf(\"%02d-%02d-01\", x[1], x[2]))),\n                          origin = \"1970-01-01\"))\n\n# 4e solution, la plus simple !\nseq.Date(lubridate::ymd(sprintf(\"%02d-01-01\", 2020)), lubridate::ymd(sprintf(\"%02d-12-01\", annee)), by = \"month\")\n\n\n\n\n# Ensemble des premiers jours de chaque mois entre 2020 et l'année courante\nannee &lt;- lubridate::year(Sys.Date())\n\n# 1ère solution : 2 fonctions map imbriquées\nlisteMois &lt;- purrr::map(seq(2020, annee), \n                        function(x) purrr::map(1:12,\n                                               function(y) lubridate::ymd(sprintf(\"%02d-%02d-01\", x, y)))) %&gt;% \n  unlist() %&gt;% \n  as.Date(, origin = \"1970-01-01\")\n\n# 2e solution : expand_grid\nlisteMois &lt;- tidyr::expand_grid(annee = seq(2020, annee), mois = 1:12) %&gt;% \n  apply(1, function(x) lubridate::ymd(sprintf(\"%02d-%02d-01\", x[1], x[2]))) %&gt;% \n  as.Date(, origin = \"1970-01-01\") %&gt;% \n  sort()\n\n# 3e solution, la plus simple\nseq.Date(lubridate::ymd(sprintf(\"%02d-01-01\", 2020)), lubridate::ymd(sprintf(\"%02d-12-01\", annee)), by = \"month\")\n\n\n\n\n# Ensemble des premiers jours de chaque mois entre 2020 et l'année courante\nannee &lt;- lubridate::year(Sys.Date())\n\n# 1ère solution avec for (lente, à déconseiller !)\nlisteMois &lt;- c()\nfor (i in seq(2020, annee)) {\n  for (j in 1:12) {\n    listeMois &lt;- as.Date(c(listeMois, lubridate::ymd(sprintf(\"%02d-%02d-01\", i, j))), origin = \"1970-01-01\")\n  }\n}\n\n# 2e  solution : 2 fonctions lapply imbriquées\nlisteMois &lt;- as.Date(unlist(lapply(seq(2020, annee), \n                                   function(x) lapply(1:12, function(y) lubridate::ymd(sprintf(\"%02d-%02d-01\", x, y))))),\n                     origin = \"1970-01-01\")\n\n# 3e solution : expand.grid\nlisteMois &lt;- sort(as.Date(apply(expand.grid(seq(2020, annee), 1:12), 1, \n                                function(x) lubridate::ymd(sprintf(\"%02d-%02d-01\", x[1], x[2]))),\n                          origin = \"1970-01-01\"))\n\n# 4e solution, la plus simple\nseq.Date(lubridate::ymd(sprintf(\"%02d-01-01\", 2020)), lubridate::ymd(sprintf(\"%02d-12-01\", annee)), by = \"month\")",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#boucles-imbriquées-second-exemple",
    "href": "01-aide_memoire_r_sas.html#boucles-imbriquées-second-exemple",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "23.2 Boucles imbriquées (second exemple)",
    "text": "23.2 Boucles imbriquées (second exemple)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Itérer sur toutes les années et les trimestres d'une certaine plage */\n/* On va afficher les noms base_AAAA_tT_nmax où AAAA désigne les années, T les trimestres, depuis 2020 */\n\n%macro iteration(debut, fin);\n  %global liste_an;\n  %let liste_an = ;\n  %do i = &debut. %to &fin.;\n    %let liste_an = &liste_an.&i.-;\n  %end;\n%mend iteration;\n%iteration(debut = 2020, fin = %sysfunc(year(%sysfunc(today()))));\n%put &liste_an.;\n\n%let liste_trim = 1 2 3 4;\n%let liste_niv = max min;\n/* Supposons que nous ayons des noms de fichier suffixés par AXXXX_TY_NZ, avec X l'année, Y le trimestre et\n   Z max ou min. Par exemple, A2010_T2_NMax */\n/* Pour obtenir l'ensemble de ces noms de 2010 à cette année */\n%macro noms_fichiers(base = temp);\n  %global res;\n  %let res = ;\n  /* 1ère boucle */\n  %do j = 1 %to %sysfunc(countw(&liste_an., \"-\"));\n    %let y = %scan(&liste_an., &j., \"-\"); /* année */\n    /* 2e boucle */\n    %do i = 1 %to 4;\n      %let t = %scan(&liste_trim, &i.); /* trimestre */\n      /* 3e boucle */\n      %do g = 1 %to 2;\n        %let n = %scan(&liste_niv., &g.); /* niveau */\n            %let res = &res. &base._&y._t&t._n&n.;\n        %end;\n      %end;\n  %end;\n%mend noms_fichiers;\n\n%noms_fichiers(base = base);\n%put &res.;\n\n\n\n# Itérer sur toutes les années et les trimestres d'une certaine plage\n# on va afficher les noms base_AAAA_tT_nmax où AAAA désigne les années, T les trimestres, depuis 2020 \ndebut &lt;- 2020\nfin &lt;- lubridate::year(Sys.Date())\nres &lt;- unlist(lapply(debut:fin, function(x) lapply(c(\"max\", \"min\"), function(y)  sprintf(\"base_%4d_t%d_n%s\", x, 1:4, y))))\n\n\n\n\n# Itérer sur toutes les années et les trimestres d'une certaine plage\n# on va afficher les noms base_AAAA_tT_nmax où AAAA désigne les années, T les trimestres, depuis 2020 \ndebut &lt;- 2020\nfin &lt;- lubridate::year(Sys.Date())\nlisteMois &lt;- purrr::map(debut:fin, \n                        function(x) purrr::map(c(\"max\", \"min\"),\n                                               function(y) sprintf(\"base_%4d_t%d_n%s\", x, 1:4, y))) %&gt;% \n                          unlist()\n\n\n\n\n# Itérer sur toutes les années et les trimestres d'une certaine plage\n# on va afficher les noms base_AAAA_tT_nmax où AAAA désigne les années, T les trimestres, depuis 2020 \ndebut &lt;- 2020\nfin &lt;- lubridate::year(Sys.Date())\nres &lt;- unlist(lapply(debut:fin, function(x) lapply(c(\"max\", \"min\"), function(y)  sprintf(\"base_%4d_t%d_n%s\", x, 1:4, y))))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#boucles-for",
    "href": "01-aide_memoire_r_sas.html#boucles-for",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "23.3 Boucles for",
    "text": "23.3 Boucles for\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On va créer une base par année d'entrée */\nproc sql noprint;\n  select year(min(date_entree)), year(max(date_entree)) into :an_min, :an_max\n  from donnees_sas;\nquit;\n\n%macro Base_par_mois(debut, fin);\n  /* %local impose que an n'est pas de signification hors de la macro */\n  %local an;\n  /* %global impose que nom_bases peut être utilisé en dehors de la macro */\n  %global nom_bases;\n  /* On initalise la création de la macri-variable nom_bases */\n  %let nom_bases = ;\n  \n  /* On itère entre &debut. et &fin. */\n  %do an = &debut. %to &fin.;\n    data Entree_&an.;\n        set donnees_sas;\n        if year(date_entree) = &an.;\n      run;\n      /* On ajoute à la macro-variable le nom de la base */\n      %let nom_bases = &nom_bases. Entree_&an.;\n  %end;\n%mend Base_par_mois;\n\n%Base_par_mois(debut = &an_min., fin = &an_max.);\n%put &nom_bases.;\n\n/* On va désormais empiler toutes les bases (concaténation par colonne) */\n/* L'instruction set utilisée de cette façon permet cet empilement */\ndata concatene;\n  set &nom_bases.;\nrun;\n\n\n\n# On va créer une base par année d'entrée\nanMin &lt;- min(lubridate::year(donnees_rbase$date_entree), na.rm = TRUE)\nanMax &lt;- max(lubridate::year(donnees_rbase$date_entree), na.rm = TRUE)\n\nfor (i in anMin:anMax) {\n  # assign permet de faire passer une chaîne de caractères en variable R\n  assign(paste(\"entree\", i, sep = \"_\"), donnees_rbase[which(lubridate::year(donnees_rbase$date_entree) == i), ])\n}\n\n# On va désormais empiler toutes les bases (concaténation par colonne)\n# do.call applique la fonction rbind à l'ensemble des bases issues du lapply\n# get permet de faire le chemin inverse de assign\nconcatene &lt;- do.call(rbind, lapply(paste(\"entree\", anMin:anMax, sep = \"_\"), get))\n\n\n\n\n# À FAIRE : problème pour les entrées où la date est manquante\n# On va créer une base par année d'entrée\nanMin &lt;- donnees_tidyverse %&gt;% pull(date_entree) %&gt;% lubridate::year() %&gt;% min(na.rm = TRUE)\nanMax &lt;- donnees_tidyverse %&gt;% pull(date_entree) %&gt;% lubridate::year() %&gt;% max(na.rm = TRUE)\n\nfor (i in anMin:anMax) {\n  # assign permet de faire passer une chaîne de caractères en variable R\n  assign(paste(\"entree\", i, sep = \"_\"),\n         donnees_tidyverse %&gt;% filter(lubridate::year(date_entree) == as.name(i)))\n}\n\n# On va désormais empiler toutes les bases (concaténation par colonne)\n# purrr::reduce applique la fonction bind_rows à l'ensemble des bases issues du purrr::map\n# get permet de faire le chemin inverse de assign\nconcatene &lt;- purrr::map(paste(\"entree\", anMin:anMax, sep = \"_\"), get) %&gt;% \n  purrr::reduce(bind_rows)\n\n\n\n\n# On va créer une base par année d'entrée\nanMin &lt;- min(lubridate::year(donnees_datatable$date_entree), na.rm = TRUE)\nanMax &lt;- max(lubridate::year(donnees_datatable$date_entree), na.rm = TRUE)\n\nfor (i in anMin:anMax) {\n  # assign permet de faire passer une chaîne de caractères en variable R\n  assign(paste(\"entree\", i, sep = \"_\"), donnees_datatable[lubridate::year(donnees_datatable$date_entree) == i, ])\n}\n\n# On va désormais empiler toutes les bases (concaténation par colonne)\n# do.call applique la fonction rbind à l'ensemble des bases issues du lapply\n# get permet de faire le chemin inverse de assign\nconcatene &lt;- rbindlist(lapply(paste(\"entree\", anMin:anMax, sep = \"_\"), get))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#boucles-for-second-exemple",
    "href": "01-aide_memoire_r_sas.html#boucles-for-second-exemple",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "23.4 Boucles for (second exemple)",
    "text": "23.4 Boucles for (second exemple)\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* On recherche toutes les valeurs de CSP différentes et on les met dans une variable.\n   On appelle la proc SQL :\n   - utilisation du quit et non run à la fin\n   - on récupère toutes les valeurs différentes de CSP, séparés par un espace (separated by)\n   - s'il y a un espace dans les noms, on le remplace par _ \n   - on les met dans la macro-variable liste_csp\n   - on trier la liste par valeur de CSP */\n   \n/* On crée une variable de CSP formaté sans les accents et les espaces */\ndata donnees_sas;\n  set donnees_sas;\n  /* SAS ne pourra pas créer des bases de données avec des noms accentués */\n  /* On supprime dans le nom les lettres accentués. On le fait avec la fonction Translate */\n  CSPF2 = tranwrd(strip(CSPF), \" \", \"_\");\n  CSPF2 = translate(CSPF2, \"eeeeaacio\", \"éèêëàâçîô\");\nrun;\n\n/* Boucles et macros en SAS */\n/* Les boucles ne peuvent être utilisées que dans le cadre de macros */\n/* Ouverture de la macro */\n\n%macro Boucles(base = donnees_sas, var = CSPF2);\n  /* Les modalités de la variable */\n  proc sql noprint;select distinct &var. into :liste separated by \" \" from &base. order by &var.;quit;\n  /* On affiche la liste de ces modalités */\n  %put &liste.;\n  /* %let permet à SAS d'affecter une valeur à une variable en dehors d'une manipulation de base de données */\n  /* %sysfunc indique à SAS qu'il doit utiliser la fonction countw dans le cadre d'une macro (pas important) */\n  /* countw est une fonction qui compte le nombre de mots (séparés par un espace) d'une chaîne de caractères */\n  /* =&gt; on compte le nombre de CSP différentes */\n  %let nb = %sysfunc(countw(&liste.));\n  %put Nombre de modalités différentes : &nb.;\n  /* On itère pour chaque CSP différente ... */\n  %do i = 1 %to &nb.;\n    /* %scan : donne le i-ème mot de &liste. (les mots sont séparés par un espace) */\n    /* =&gt; on récupère donc la CSP numéro i */\n    %let j = %scan(&liste., &i.);\n    %put Variable : &j.;\n    /* On crée une base avec seulement les individus de la CSP correspondante */\n    data &var.;set donnees_sas;if &var. = \"&j.\";run;\n  %end;\n/* Fermeture de la macro */\n%mend Boucles;\n\n/* Lancement de la macro */\n%Boucles(base = donnees_sas, var = CSPF2);\n\n\n\n# Base par CSP\nfor (i in unique(donnees_rbase$cspf)) {\n  # Met en minuscule et enlève les accents\n  nomBase &lt;- tolower(chartr(\"éèêëàâçîô\", \"eeeeaacio\", i))\n  # assign permet de faire passer une chaîne de caractères en variable R\n  assign(nomBase, donnees_rbase[which(donnees_rbase$cspf == i), ])\n}\n\n\n\n\n# Base par CSP\nfor (i in donnees_tidyverse %&gt;% distinct(cspf) %&gt;% pull()) {\n  # Met en minuscule et enlève les accents\n  nomBase &lt;- chartr(\"éèêëàâçîô\", \"eeeeaacio\", i) %&gt;% tolower()\n  # assign permet de faire passer une chaîne de caractères en variable R\n  assign(nomBase, donnees_tidyverse %&gt;% \n           filter(cspf == as.name(i)))\n}\n\n\n\n\n# Créer une base pour chaque individu d'une certaine CSP\nfor (i in unique(donnees_datatable$cspf)) {\n  # Met en minuscule et enlève les accents\n  nomBase &lt;- tolower(chartr(\"éèêëàâçîô\", \"eeeeaacio\", i))\n  # assign permet de faire passer une chaîne de caractères en variable R\n  assign(nomBase, donnees_datatable[donnees_datatable$cspf == i, ])\n}",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#mesurer-la-durée-dexécution-dun-programme",
    "href": "01-aide_memoire_r_sas.html#mesurer-la-durée-dexécution-dun-programme",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "24.1 Mesurer la durée d’exécution d’un programme",
    "text": "24.1 Mesurer la durée d’exécution d’un programme\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%let temps_debut = %sysfunc(datetime());\nproc sort data = donnees_sas;by identifiant date_entree;run;\n%let temps_fin = %sysfunc(datetime());\n\n%let duree = %sysevalf((&temps_fin. - &temps_debut.) / 60);\n%put Durée exécution : &duree minutes;\n\n\n\nsystem.time(donnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ])\n\n# Autre possibilité\ndebut &lt;- Sys.time()\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]\nfin &lt;- Sys.time()\nsprintf(\"Temps d'exécution : %s secondes !\", fin - debut)\n\n\n\n\nsystem.time(donnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n              arrange(identifiant, date_entree))\n\n# Autre possibilité\ndebut &lt;- Sys.time()\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n              arrange(identifiant, date_entree)\nfin &lt;- Sys.time()\nsprintf(\"Temps d'exécution : %s secondes !\", fin - debut)\n\n\n\n\nsystem.time(setorder(donnees_datatable, \"identifiant\", \"date_entree\", na.last = FALSE))\n\n# Autres possibilités\ndebut &lt;- Sys.time()\nsetorder(donnees_datatable, \"identifiant\", \"date_entree\", na.last = FALSE)\nfin &lt;- Sys.time()\nsprintf(\"Temps d'exécution : %s secondes !\", fin - debut)\n\nstarted.at &lt;- proc.time()\nsetorder(donnees_datatable, \"identifiant\", \"date_entree\", na.last = FALSE)\ntimetaken(started.at)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#exécuter-le-code-dun-autre-fichier",
    "href": "01-aide_memoire_r_sas.html#exécuter-le-code-dun-autre-fichier",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "24.2 Exécuter le code d’un autre fichier",
    "text": "24.2 Exécuter le code d’un autre fichier\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* include(\"chemin\") */\n\n\n\n# encoding permet de gérer l'encodage des caractères accentués\n# echo = TRUE affiche le script dans la console\n# max.deparse.length permet de s'assurer qu'un texte long est bien visible\n\n# source(\"chemin\", encoding = \"utf-8\", echo = TRUE, max.deparse.length = 1e3)\n\n\n\n\n# encoding permet de gérer l'encodage des caractères accentués\n# echo = TRUE affiche le script dans la console\n# max.deparse.length permet de s'assurer qu'un texte long est bien visible\n\n# source(\"chemin\", encoding = \"utf-8\", echo = TRUE, max.deparse.length = 1e3)\n\n\n\n\n# encoding permet de gérer l'encodage des caractères accentués\n# echo = TRUE affiche le script dans la console\n# max.deparse.length permet de s'assurer qu'un texte long est bien visible\n\n# source(\"chemin\", encoding = \"utf-8\", echo = TRUE, max.deparse.length = 1e3)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#nombre-de-lignes-affectées-par-un-changement",
    "href": "01-aide_memoire_r_sas.html#nombre-de-lignes-affectées-par-un-changement",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "24.3 Nombre de lignes affectées par un changement",
    "text": "24.3 Nombre de lignes affectées par un changement\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Ne semble pas exister nativement */\n\n\n\n# Ne semble pas exister nativement\n\n\n\n\n# Ne semble pas exister nativement\n\n\n\n\ndonnees_datatable[, sexef2 := tolower(sexef)]\nsprintf(\"Nombre de lignes modifiées : %d\", .Last.updated)\ndonnees_datatable[, sexef2 := NULL]",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#documentation",
    "href": "01-aide_memoire_r_sas.html#documentation",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "25.1 Documentation",
    "text": "25.1 Documentation\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n\n\n\nPour en savoir plus sur l’écriture de fonctions en R :\nhttps://adv-r.hadley.nz/functions.html\n\n\nPour en savoir plus sur l’écriture de fonctions en tidyverse :\nhttps://dplyr.tidyverse.org/articles/programming.html\nhttps://brad-cannell.github.io/r_notes/tidy-evaluation.html.\n\n\nPour en savoir plus sur l’écriture de fonctions en data.table :\nhttps://cran.r-project.org/web/packages/data.table/vignettes/datatable-programming.html",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#sélection-de-données",
    "href": "01-aide_memoire_r_sas.html#sélection-de-données",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "25.2 Sélection de données",
    "text": "25.2 Sélection de données\nOn sélectionne des données (dans cet exemple, les femmes) dans une nouvelle base (dans cet exemple, extrait), via une fonction (une macro en SAS).\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%macro Selection (BaseInitiale, BaseFinale, condition);\n  data &BaseFinale.;\n    set &BaseInitiale. (&condition.);\n  run;\n%mend Selection;\n%Selection(BaseInitiale = donnees_sas, BaseFinale = extrait);\n%Selection(BaseInitiale = donnees_sas, BaseFinale = extrait, condition = where = (sexe = 2));\n\n\n\nSelection &lt;- function(baseInitiale = donnees_rbase, condition) {\n  return(eval(substitute(subset(baseInitiale, condition))))\n}\nextrait &lt;- Selection(baseInitiale = donnees_rbase)\nextrait &lt;- Selection(baseInitiale = donnees_rbase, condition = sexe == \"2\")\n\n\n\n\nSelection &lt;- function(baseInitiale = donnees_tidyverse, condition = TRUE) {\n  baseInitiale %&gt;% \n    filter({{ condition }}) %&gt;% \n    return()\n}\nextrait &lt;- Selection(baseInitiale = donnees_tidyverse)\nextrait &lt;- Selection(baseInitiale = donnees_tidyverse, condition = sexe == \"2\")\n\n\n\n\nSelection &lt;- function(baseInitiale = donnees_datatable, condition) {\n  baseInitiale[condition, , env = list(condition = condition)]\n}\nextrait &lt;- Selection(baseInitiale = donnees_datatable)\nextrait &lt;- Selection(baseInitiale = donnees_datatable, condition = quote(sexe == \"2\"))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#moyenne-dun-certain-nombre-de-variables",
    "href": "01-aide_memoire_r_sas.html#moyenne-dun-certain-nombre-de-variables",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "25.3 Moyenne d’un certain nombre de variables",
    "text": "25.3 Moyenne d’un certain nombre de variables\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%macro Moyenne (BaseInitiale, variables);\n  proc means data = &BaseInitiale. mean;\n    var &variables;\n  run;\n%mend Moyenne;\n%Moyenne(BaseInitiale = donnees_sas, variables = note_contenu note_formateur);\n\n\n\nMoyenne &lt;- function(baseInitiale = donnees_rbase, variables) {\n  moyennes &lt;- unlist(lapply(baseInitiale[, variables], mean, na.rm = TRUE))\n  names(moyennes) &lt;- paste(\"moyenne\", names(moyennes), sep = \"_\")\n  return(moyennes)\n}\nMoyenne(baseInitiale = donnees_rbase, variables = c(\"note_contenu\", \"note_formateur\"))\n\n\n\n\nMoyenne &lt;- function(baseInitiale = donnees_tidyverse, variables) {\n  baseInitiale %&gt;% \n    summarise(across({{ variables }}, function(x) mean(x,, na.rm = TRUE), .names = \"Moyenne_{.col}\")) %&gt;% \n    return()\n}\nMoyenne(baseInitiale = donnees_tidyverse, variables = c(\"note_contenu\", \"note_formateur\"))\n\n\n\n\nMoyenne &lt;- function(baseInitiale = donnees_datatable, variables) {\n  moyennes &lt;- baseInitiale[, lapply(.SD, mean, na.rm = TRUE), .SDcols = variables]\n  setnames(moyennes, paste(\"Moyenne\", variables, sep = \"_\"))\n  return(moyennes)\n}\nMoyenne(baseInitiale = donnees_datatable, variables = c(\"note_contenu\", \"note_formateur\"))",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#fonction-calculant-un-indicateur-statistique",
    "href": "01-aide_memoire_r_sas.html#fonction-calculant-un-indicateur-statistique",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "25.4 Fonction calculant un indicateur statistique",
    "text": "25.4 Fonction calculant un indicateur statistique\nCet exemple de fonction propose de calculer un indicateur statistique au choix (par exemple, moyenne, médiane, maximum, etc.) sur un certain nombre de variables numériques (au choix) d’une certaine base de données (au choix) avec éventuellement une sélection de lignes, et des arguments supplémentaires (notamment na.rm = TRUE) via le paramètre …\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%macro CalculMoyenne (baseDonnees, variables, statistique, condition);\n  proc means data = &baseDonnees. &statistique.;\n    var &variables.;\n  run;\n%mend CalculMoyenne;\n\n%CalculMoyenne(baseDonnees = donnees_sas, variables = note_formateur note_contenu);\n%CalculMoyenne(baseDonnees = donnees_sas, variables = note_formateur note_contenu, statistique = mean sum median);\n%CalculMoyenne(baseDonnees = donnees_sas, variables = note_formateur note_contenu, statistique = mean sum, condition = where sexef = \"Femme\");\n\n\n\nCalculMoyenne &lt;- function(baseDonnees, variable, statistique = \"mean\", ..., selection = TRUE) {\n  baseDonnees &lt;- eval(substitute(subset(baseDonnees, selection)))\n  moyenne &lt;- lapply(baseDonnees[, variable], get(statistique), ...)\n  names(moyenne) &lt;- paste(names(moyenne), statistique, sep = \"_\")\n  moyenne &lt;- data.frame(moyenne)\n  return(moyenne)\n}\n\nCalculMoyenne(donnees_rbase, c(\"note_formateur\", \"note_contenu\"))\nCalculMoyenne(donnees_rbase, c(\"note_formateur\", \"note_contenu\"), statistique = \"median\", na.rm = TRUE)\nCalculMoyenne(donnees_rbase, c(\"note_formateur\", \"note_contenu\"), \"mean\", na.rm = TRUE, selection = sexef == \"Femme\")\nCalculMoyenne(donnees_rbase, c(\"note_formateur\", \"note_contenu\"), \"quantile\", na.rm = TRUE, probs = seq(0, 1, 0.1), selection = sexef == \"Femme\")\n\n\n\n\nCalculMoyenne &lt;- function(baseDonnees, variable, statistique = \"mean\", ..., selection = TRUE) {\n  moyenne &lt;- baseDonnees %&gt;% \n    filter({{ selection }}) %&gt;% \n    summarise(across(variable, ~ get(statistique)(.x, ...), .names = \"{.col}_{ {{ statistique }} }\"))\n  return(moyenne)\n}\n\nCalculMoyenne(donnees_rbase, c(\"note_formateur\", \"note_contenu\"))\nCalculMoyenne(donnees_rbase, c(\"note_formateur\", \"note_contenu\"), statistique = \"median\", na.rm = TRUE)\nCalculMoyenne(donnees_rbase, c(\"note_formateur\", \"note_contenu\"), \"mean\", na.rm = TRUE, selection = sexef == \"Femme\")\nCalculMoyenne(donnees_rbase, c(\"note_formateur\", \"note_contenu\"), \"quantile\", na.rm = TRUE, probs = seq(0, 1, 0.1), selection = sexef == \"Femme\")\n\n\n\n\nCalculMoyenne &lt;- function(baseDonnees, variable, statistique = \"mean\", ..., selection = TRUE) {\n  moyenne &lt;- baseDonnees[selection, lapply(.SD, statistique, ...), .SDcols = variable, env = list(statistique = statistique, selection = selection)]\n  setnames(moyenne, paste(names(moyenne), statistique, sep = \"_\"))\n  return(moyenne)\n}\n\nCalculMoyenne(donnees_datatable, c(\"note_formateur\", \"note_contenu\"))\nCalculMoyenne(donnees_datatable, c(\"note_formateur\", \"note_contenu\"), statistique = \"median\", na.rm = TRUE)\nCalculMoyenne(donnees_datatable, c(\"note_formateur\", \"note_contenu\"), \"mean\", na.rm = TRUE, selection = quote(sexef == \"Femme\"))\nCalculMoyenne(donnees_datatable, c(\"note_formateur\", \"note_contenu\"), \"quantile\", na.rm = TRUE, probs = seq(0, 1, 0.1), selection = quote(sexef == \"Femme\"))\n\n\n\n\n\n\n\nAutres exemples de fonctions possibles : statistiques par groupes (proc tabulate), proc freq, ajout dans la base d’indicatrices de présence en stock à la fin du mois (%local).",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#outils-daide-au-débogage",
    "href": "01-aide_memoire_r_sas.html#outils-daide-au-débogage",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "26.1 Outils d’aide au débogage",
    "text": "26.1 Outils d’aide au débogage\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\noptions symbolgen mprint mlogic;\n%macro Debogage;\n  %local phrase i j;\n  %let phrase = Voici une phrase;\n  %do i = 1 %to %sysfunc(countw(&phrase.));\n    %let j = %scan(&phrase., &i.);\n    %put Mot n°&i. = &j.;\n  %end;\n%mend Debogage;\n%Debogage;\noptions nosymbolgen nomprint nomlogic;\n\n\n\n#phrase &lt;- c(\"voici\", \"une\", \"phrase\")\n#options(error=recover)\n#for (i in phrase) print(k)\n#options(error=NULL)\n\n# À FAIRE : autres outils\n#traceback()\n#browser()\n\n\n\n\n# À FAIRE : creuser\n#phrase &lt;- c(\"voici\", \"une\", \"phrase\")\n#options(error=recover)\n#for (i in phrase) print(k)\n#options(error=NULL)\n\n# À FAIRE : autres outils\n#traceback()\n#browser()\n\n\n\n\n#phrase &lt;- c(\"voici\", \"une\", \"phrase\")\n#options(error=recover)\n#for (i in phrase) print(k)\n#options(error=NULL)\n\n# À FAIRE : autres outils\n#traceback()\n#browser()",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#emploi-des-guillemets-et-doubles-guillemets",
    "href": "01-aide_memoire_r_sas.html#emploi-des-guillemets-et-doubles-guillemets",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "27.1 Emploi des guillemets et doubles guillemets",
    "text": "27.1 Emploi des guillemets et doubles guillemets\nUne macro exprimée sous format caractère doit être entourée de ““, et non ’’.\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Quelques points de vigilance en SAS (à ne connaître que si on est amené à modifier le programme SAS, pas utiles sinon) */\n/* Double guillemets pour les macro-variables */\n%let a = Bonjour;\n%put '&a.'; /* Incorrect */\n%put \"&a.\"; /* Correct */\n\n\n\n# Sans objet en R\n\n\n\n\n# Sans objet en R\n\n\n\n\n# Sans objet en R\n\n\n\n\n# Sans objet en R",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#macro-variable-définie-avec-un-statut-global-avant-son-appel-dans-le-cadre-dun-statut-local",
    "href": "01-aide_memoire_r_sas.html#macro-variable-définie-avec-un-statut-global-avant-son-appel-dans-le-cadre-dun-statut-local",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "27.2 Macro-variable définie avec un statut global avant son appel dans le cadre d’un statut local",
    "text": "27.2 Macro-variable définie avec un statut global avant son appel dans le cadre d’un statut local\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n%macro test;\n  %let reponse = oui;\n%mend test;\n%test;\n\n/* 1. Erreur car &reponse. n'est défini que dans le cas d'un environnement local */ \n%put &reponse.;\n\n/* 2. Défini auparavant dans un environnement global, elle change de valeur à l'appel de la fonction */\n%let reponse = non;\n%put Reponse : &reponse.;\n%test;\n%put Reponse après la macro : &reponse.;\n\n/* 3. Problème corrigé, en imposant la variable à local dans la macro */\n%macro test2;\n  %local reponse;\n  %let reponse = oui;\n%mend test2;\n\n%let reponse = non;\n%put Reponse : &reponse.;\n%test2;\n%put Reponse après la macro : &reponse.;\n\n\n\n# Sans objet en R\n\n\n\n\n# Sans objet en R\n\n\n\n\n# Sans objet en R\n\n\n\n\n# Sans objet en R",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#taille-des-objets-en-mémoire",
    "href": "01-aide_memoire_r_sas.html#taille-des-objets-en-mémoire",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "28.1 Taille des objets en mémoire",
    "text": "28.1 Taille des objets en mémoire\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Taille d'une base de données */\nproc sql;\n  select libname, memname, filesize format = sizekmg., filesize format = sizek.\n  from Dictionary.Tables\n  where libname = \"WORK\" and memname = upcase(\"donnees_sas\") and memtype = \"DATA\";\nquit;\n\n\n\n# Taille, en mémoire, d'une base (en Mb)\nformat(object.size(donnees_rbase), nsmall = 3, digits = 2, unit = \"Mb\")\n\n# Taille des objets en mémoire, en Gb\nsort( sapply(ls(), function(x) object.size(get(x)) ), decreasing = TRUE ) / 10**9\n\n\n\n\n# Taille, en mémoire, d'une base (en Mb)\ndonnees_tidyverse %&gt;% \n  object.size() %&gt;% \n  format(nsmall = 3, digits = 2, unit = \"Mb\")\n\n# Taille des objets en mémoire, en Gb\nsort( sapply(ls(), function(x) object.size(get(x)) ), decreasing = TRUE ) / 10**9\n\n\n\n\n# Liste des bases de données en mémoire\ndata.table::tables() \n\n# Taille, en mémoire, d'une base (en Mb)\nformat(object.size(donnees_datatable), nsmall = 3, digits = 2, unit = \"Mb\")\n\n# Taille des objets en mémoire, en Gb\nsort( sapply(ls(), function(x) object.size(get(x)) ), decreasing = TRUE ) / 10**9",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#supprimer-des-bases",
    "href": "01-aide_memoire_r_sas.html#supprimer-des-bases",
    "title": "Aide-mémoire SAS - R - pandas",
    "section": "28.2 Supprimer des bases",
    "text": "28.2 Supprimer des bases\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n/* Supprimer une base */\nproc datasets lib = work nolist;delete donnees_sas;run;\n\n/* Supprimer toutes les bases dans la work */\nproc datasets lib = work nolist kill;run;\n\n\n\n# Supprimer une base\n#rm(donnees_rbase)\n\n# Supprimer toutes les bases et tous les objets de la mémoire vive\n#rm(list = ls())\n\n\n\n\n# Supprimer une base\n#rm(donnees_tidyverse)\n\n# Supprimer toutes les bases et tous les objets de la mémoire vive\n#rm(list = ls())\n\n\n\n\n# Supprimer une base\n#rm(donnees_datatable)\n\n# Supprimer toutes les bases et tous les objets de la mémoire vive\n#rm(list = ls())",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction à l’Aide-mémoire : SAS, R (base, tidyverse, data.table), Arrow/DuckDB, et pandas",
    "section": "",
    "text": "Introduction à l’Aide-mémoire : SAS, R (base, tidyverse, data.table), Arrow/DuckDB, et pandas\nCet aide-mémoire est conçu pour fournir des rappels pratiques et des points de référence pour ces outils. Que vous soyez en train de choisir un outil pour un projet spécifique ou de chercher à approfondir vos compétences dans un environnement particulier, cet aperçu vous aidera à comprendre les forces et les applications de chacun de ces outils dans le cadre de vos analyses de données :\n\nSAS : Un logiciel complet pour l’analyse statistique et la gestion des données, largement utilisé dans les entreprises et les institutions académiques pour sa robustesse et ses capacités avancées en gestion de données et statistiques.\nR : Un langage de programmation dédié à l’analyse statistique et à la visualisation des données, qui se divise en plusieurs environnements clés :\n\nR base : La version de base du langage R, incluant des fonctions fondamentales pour la manipulation et l’analyse des données.\nR tidyverse : Une collection de packages R conçus pour rendre la manipulation des données et la création de visualisations plus cohérentes et intuitives. Ce groupe de packages facilite la transformation, la visualisation et la gestion des données avec une syntaxe uniforme.\nR data.table : Un package optimisé pour le traitement rapide des données, surtout utile pour les grands ensembles de données grâce à sa syntaxe efficace et ses performances élevées.\n\nArrow/DuckDB :\n\nArrow : Un framework open-source pour la gestion des données en mémoire et l’interopérabilité entre différents systèmes de traitement de données. Il offre un format de données colonnaire efficace pour le stockage et le transfert de données.\nDuckDB : Une base de données SQL en mémoire optimisée pour l’analyse de données, permettant des opérations SQL rapides et intégrées avec des environnements comme Python et R.\n\npandas : Une bibliothèque Python incontournable pour la manipulation et l’analyse des données, offrant des structures de données flexibles et performantes pour gérer des ensembles de données complexes avec une syntaxe intuitive et des capacités de traitement puissantes.",
    "crumbs": [
      "Accueil"
    ]
  },
  {
    "objectID": "04-specificites_sas_r.html",
    "href": "04-specificites_sas_r.html",
    "title": "Spécificités de SAS par rapport à R",
    "section": "",
    "text": "Voici une liste non-exhaustive de spécificités de SAS par rapport à R à connaître.",
    "crumbs": [
      "Spécificités de SAS et R"
    ]
  },
  {
    "objectID": "04-specificites_sas_r.html#logiciel-libre",
    "href": "04-specificites_sas_r.html#logiciel-libre",
    "title": "Spécificités de SAS par rapport à R",
    "section": "1 Logiciel libre",
    "text": "1 Logiciel libre\nDe par son statut de logiciel libre, de multiples extensions en R existent (packages). L’usage des packages :\n\npeut être un atout, car les packages permettent de réaliser plus facilement des choses complexes ;\npeut aussi être source de problèmes, d’abord de maintenance du fait des dépendances (une mise-à-jour peut casser les dépendances), ensuite du fait que des packages peuvent disparaître ou ne plus être maintenus au cours du temps, engendrant des coûts de maintenance de code ;\npeut engendrer des problèmes de rétrocompatibilité (un code écrit dans le passé ne fonctionne plus suite à une mise-à-jour) : il convient d’être conscient de ces considérations avant d’utiliser aveuglément des packages.\n\nPour en savoir plus sur les packages en R :\n\nhttps://book.utilitr.org/01_R_Insee/Fiche_installer_packages.html\nhttps://book.utilitr.org/03_Fiches_thematiques/Fiche_comment_choisir_un_package.html",
    "crumbs": [
      "Spécificités de SAS et R"
    ]
  },
  {
    "objectID": "04-specificites_sas_r.html#gestion-de-la-mémoire",
    "href": "04-specificites_sas_r.html#gestion-de-la-mémoire",
    "title": "Spécificités de SAS par rapport à R",
    "section": "2 Gestion de la mémoire",
    "text": "2 Gestion de la mémoire\nLa gestion de la mémoire est différente entre les logiciels. R importe l’ensemble des données en mémoire vive, SAS en copie une partie sur le disque dur. Ceci a plusieurs implications pour le travail statistique :\n\nsi le volume des données excède la mémoire vive, il n’est pas possible de les traiter nativement en R. Il faut alors utiliser des stratégies alternatives ;\nil faut être parcimonieux sur le nombre de colonnes à inclure dans les bases de données en R. Par exemple, il vaut mieux recréer dans le programme les variables explicatives faciles à obtenir plutôt que les inclure dans la base de données, où elles occupent de la place et accaparent de la mémoire vive.\n\nPour en savoir plus sur la façon dont R gère les données en mémoire vive : https://adv-r.hadley.nz/names-values.html.\nQuelles solutions adopter dans le cas où les données à manipuler ne tiennent pas en mémoire vive de l’ordinateur ?\n\nchercher à réduire la taille de la base de données en supprimant des colonnes inutiles ;\nchercher à modifier le processus de production pour le rendre moins gourmand en mémoire ;\naugmenter la mémoire vive de son ordinateur ;\nutiliser les packages data.table, optimisé pour les grosses volumétries, et arrow / duckdb qui peuvent gérer des données excédant la mémoire vive.",
    "crumbs": [
      "Spécificités de SAS et R"
    ]
  },
  {
    "objectID": "03-mise_en_garde.html",
    "href": "03-mise_en_garde.html",
    "title": "Mise en garde",
    "section": "",
    "text": "1 Que trouver dans cet aide-mémoire ?\nCet aide-mémoire vise à faciliter la traduction des programmes statistiques entre ces différents langages (de SAS vers R, et d’un environnement R à un autre), ainsi que leur appropriation.\nY sont présentés des codes informatiques courants pour la gestion de données statistiques, traduits dans les langages SAS et R. Ces tâches sont standards dans l’analyse statistique et réalisables en un petit nombre d’instructions.\nIl est présenté sous forme de tâches élémentaires statistiques (sélection de lignes ou de colonnes d’une base de données, repérage des doublons, etc.).\nQuatre grands environnements R sont traités : R base, tidyverse, data.table et arrow / duckdb. Ils ne doivent pas être vus comme des concurrents, mais comme des compléments :\n\ncertaines tâches peuvent être plus ou moins facilement réalisées avec l’un ou l’autre ;\nils présentent chacun des avantages et des inconvénients ;\nils laissent le choix de la stratégie de codage.\n\nCe guide est aussi destiné à permettre de jongler plus facilement entre ces différents environnements.\n\n\n2 Comment utiliser cet aide-mémoire ?\nL’attention du lecteur est attirée sur le fait que :\n\nce guide n’est pas exhaustif. Ainsi, certains environnements peuvent proposer des solutions ad-hoc simplifiant grandement la résolution de problèmes moins courants et qui n’ont pas d’équivalents simples dans tous les autres environnements (ex. des rolling joins de data.table). Elles ne sont pas traitées dans cet aide-mémoire ;\nce guide ne traite pas de ces stratégies, et le lecteur est invité à se documenter sur les environnements pour en savoir plus ;\nl’exercice de traduction de SAS vers R peut s’apparenter à la traduction d’un texte en langue étrangère. De même qu’une traduction littérale d’un texte en peut parfois être de mauvaise qualité, la traduction littérale d’une masse de codes SAS en codes R au moyen de cet aide-mémoire peut produire des résultats décevants. En effet, toute bonne traduction nécessite au moins a minima d’adapter le code SAS à une “nouvelle langue”, celle de R. La partie sur les spécificités de SAS par rapport à R peut vous aider sur ce point.\n\nEn outre, plusieurs solutions pour réaliser la même tâche peuvent être proposées :\n\ncertaines solutions peuvent être plus concises, mais moins claires ;\ncertaines façons de procéder sont plus efficaces que d’autres en R, mais cela peut dépendre des données et du matériel utilisé.",
    "crumbs": [
      "Mise en garde"
    ]
  },
  {
    "objectID": "Trucs et astuces en R.html",
    "href": "Trucs et astuces en R.html",
    "title": "Trucs et astuces en R",
    "section": "",
    "text": "Voici quelques trucs et astuces utiles à connaître sur R, issus en partie des livres The R Inferno et Advanced R, à consulter pour plus de détails.\n\n\n1 Effets des calculs en virgule flottante\n\nsqrt(2) ^ 2 == 2\n\n[1] FALSE\n\n1 / 49 * 49 == 1\n\n[1] FALSE\n\n.1 == .3 / 3\n\n[1] FALSE\n\nseq(0, 1, by=.1) == .3\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\nunique(c(.3, .4 - .1, .5 - .2, .6 - .3, .7 - .4))\n\n[1] 0.3 0.3 0.3\n\n\n\n\n2 Les types d’objet\n\n# En savoir plus sur ses données\ndata(\"cars\")\ntypeof(cars)\n\n[1] \"list\"\n\nclass(cars)\n\n[1] \"data.frame\"\n\nmode(cars)\n\n[1] \"list\"\n\nstr(cars)\n\n'data.frame':   50 obs. of  2 variables:\n $ speed: num  4 4 7 7 8 9 10 10 10 11 ...\n $ dist : num  2 10 4 22 16 10 18 26 34 17 ...\n\ndim(cars)\n\n[1] 50  2\n\nc(is.data.frame(cars), is.list(cars), is.vector(cars), is.array(cars))\n\n[1]  TRUE  TRUE FALSE FALSE\n\n\nNotation L\n\n# Notation L : imposer à R de créer un nombre sous format \"integer\", pour des raisons d'efficacité\nclass(1)\n\n[1] \"numeric\"\n\nclass(1L)\n\n[1] \"integer\"\n\n\n\n\n3 Les affectations\n\n# Importance des espaces\nx&lt;-3\n# S'agit-il de ?\nx &lt;- 3\n# Ou de ?\nx &lt; -3\n\n[1] FALSE\n\n# Il s'agit du premier cas !\nx\n\n[1] 3\n\n\n\n# Les {} permettent de réaliser une affectation (&lt;-) au sein d'un traitement plus complexe !\n# Exemple ici : sommer les positions paires multipliées par 2 et les positions impaires multipliées par 3\nsum({x &lt;- 1:6 ; x[1:length(x) %% 2 == 0] &lt;- x[1:length(x) %% 2 == 0] * 2 ; x[1:length(x) %% 2 != 0] &lt;- x[1:length(x) %% 2 != 0] * 3 ; x})\n\n[1] 51\n\n\n\n# Afficher ou non la valeur de l'objet affecté pendant l'affectation\nx &lt;- pi\n(x &lt;- pi)\n\n[1] 3.141593\n\n\n\n# Comparaisons multiples\nx &lt;- 0.5\n# Correct\n0 &lt; x & x &lt; 1\n# Incorrect\n0 &lt; x &lt; 1\n\nError: &lt;text&gt;:6:7: unexpected '&lt;'\n5: # Incorrect\n6: 0 &lt; x &lt;\n         ^\n\n\n\n# Ne pas confondre !\nseq(0:10)\n\n [1]  1  2  3  4  5  6  7  8  9 10 11\n\n0:10\n\n [1]  0  1  2  3  4  5  6  7  8  9 10\n\nseq(0, 10)\n\n [1]  0  1  2  3  4  5  6  7  8  9 10\n\n\n\n# Privilégier seq_len à : lorsqu'il y a un risque de 0\n# Fonctionnement identique\nn &lt;- 5\n1:n\n\n[1] 1 2 3 4 5\n\nseq_len(n)\n\n[1] 1 2 3 4 5\n\n# Problème avec les 0\nn &lt;- 0\n1:n\n\n[1] 1 0\n\nseq_len(n)\n\ninteger(0)\n\n\n\n# Préférer seq_along à : au cas où la taille de l'objet est 0\nx &lt;- c() ;length(x)\n\n[1] 0\n\nfor(i in 1:length(x)) print(i)\n\n[1] 1\n[1] 0\n\nfor(i in seq_along(x)) print(i)\nfor(i in seq(along=x)) print(i)\n\n\n# Différences seq, seq_len et seq_along\n\n# seq : créé une séquence d'éléments successifs, espacés éventuellement d'un pas\nseq(from = 1, to = 10, by = 2)\n\n[1] 1 3 5 7 9\n\nseq(1, 10, 2)\n\n[1] 1 3 5 7 9\n\n# seq_len : créé une séquence d'éléments de 1 jusqu'au paramètre de la fonction (supposé positif)\nseq_len(10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n# seq_along : créé une séquence d'éléments de 1 jusqu'au nombre d'éléments du vecteur\nseq_along(c(7,9,1,0))\n\n[1] 1 2 3 4\n\n# seq se comporte comme seq_along si le vecteur comprend plusieurs éléments, et comme seq_len s'il comprend un seul élément\n\n# Plusieurs éléments\nvecteur &lt;- c(10, 20, 30)\nseq_along(vecteur)\n\n[1] 1 2 3\n\nseq_len(vecteur)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nseq(vecteur)\n\n[1] 1 2 3\n\n# Un seul élement\nvecteur &lt;- 10\nseq_along(vecteur)\n\n[1] 1\n\nseq_len(vecteur)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nseq(vecteur)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\n# Equivalent des list-comprehensions de type Python en R\n# Somme des entiers de 1 à 1 000 multiples de 3 ou 5, en une ligne !\n# 4 manières de faire\nsum({l &lt;- 1:1000 ; l[l %% 3 == 0 | l %% 5 == 0]})\n\n[1] 234168\n\nsum({l &lt;- 1:1000 ; l[seq_along(l) %% 3 == 0 | seq_along(l) %% 5 == 0]})\n\n[1] 234168\n\nsum(l&lt;-(1:1000)[l %% 3 == 0 | l %% 5 == 0])\n\n[1] 234168\n\nsum((1:1000)[(1:1000 %% 3) == 0 | (1:1000 %% 5) == 0])\n\n[1] 234168\n\n\n\n# Opérations mathématiques\n# Infini\n1/0\n\n[1] Inf\n\n# Nan = not a number\n0/0\n\n[1] NaN\n\nlog(-1)\n\n[1] NaN\n\n\n\n\n4 Principe de vectorisation\nLa fonction s’applique à tous les éléments du vecteur !!\n\n# Exemple de vecteur\nvaleurs &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nvaleurs &lt;- 1:10\n\n\n# Valeurs au carré\nvaleurs ** 2\n\n [1]   1   4   9  16  25  36  49  64  81 100\n\n\n\n# logarithme des valeurs\nlog(valeurs)\n\n [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 1.7917595 1.9459101\n [8] 2.0794415 2.1972246 2.3025851\n\n\n\n# Maximum des valeurs\nmax(valeurs)\n\n[1] 10\n\n\n\n# Limite des valeurs\nrange(valeurs)\n\n[1]  1 10\n\n\n\n# Correct\nmean(valeurs)\n\n[1] 5.5\n\n\n\n# Correct\nmean(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))\n\n[1] 5.5\n\n\n\n# Inattendu\nmean(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n\n[1] 1\n\n\n\n# Attention aux parenthèses !\nn &lt;- 10\n# Inattendu ! Correspond à (1-1, 2-1, 3-1, ..., 10-1)\n1:n-1\n\n [1] 0 1 2 3 4 5 6 7 8 9\n\n# Correct\n1:(n-1)\n\n[1] 1 2 3 4 5 6 7 8 9\n\n\n\n# Minimum ou maximum élément par élément\nx1 &lt;- c(1, 2, 5, 6, 8)\nx2 &lt;- c(4, 0, 7, 2, 1)\n# Minimum : 2 possibilités\npmin(x1, x2)\n\n[1] 1 0 5 2 1\n\nmapply(min, x1, x2)\n\n[1] 1 0 5 2 1\n\n# Maximum : 2 possibilités\npmax(x1, x2)\n\n[1] 4 2 7 6 8\n\nmapply(max, x1, x2)\n\n[1] 4 2 7 6 8\n\n\n\n# Calculer (x - min) / (max - min) pour chaque élément x d'un vecteur\nx &lt;- c(1,2,3)\nsapply(x, function(xi, mn, mx) {(xi - mn) / (mx - mn)}, mn = min(x), mx = max(x))\n\n[1] 0.0 0.5 1.0\n\n\n\n\n5 Principe de coercion\nDans les comparaisons, les objets R sont successivement convertis en logical, integer, numeric, complex et character, jusqu’à ce que la comparaison puisse se faire.\n\n# TRUE / FALSE est transformé en integer (1 / 0)\nTRUE == 1\n\n[1] TRUE\n\nTRUE == 2\n\n[1] FALSE\n\nFALSE == 0\n\n[1] TRUE\n\n\n\n# TRUE est convertit en character\nTRUE == \"1\"\n\n[1] FALSE\n\n\n\n# 5 est convertit en character\n5 &lt; '7'\n\n[1] TRUE\n\n\n\n# 50 est convertit en character\n50 &lt; '7'\n\n[1] TRUE\n\n\n\n\n6 Principe de recycling\n\n# Fonctionne sans soulever de message d'erreur\nx &lt;- c(1, 2, 3)\ny &lt;- c(1, 2, 3, 4, 5, 6)\nx + y\n\n[1] 2 4 6 5 7 9\n\n\n\n# Fonctionne, mais Warning\nx &lt;- c(1, 2, 3)\ny &lt;- c(1, 2, 3, 4, 5, 6, 7)\nx + y\n\nWarning in x + y: longer object length is not a multiple of shorter object\nlength\n\n\n[1] 2 4 6 5 7 9 8\n\n\n\n\n7 Opérateurs de contrôle\n\n# Conditions if / else\nx &lt;- 1\n\n\n# Correct\nif (identical(x, 1)) {\nprint(\"x est égal à 1\")\n} else {\nprint(\"x est différent de 1\")\n}\n\n[1] \"x est égal à 1\"\n\n\n\n# Correct\nif (identical(x, 1)) {print(\"x est égal à 1\")\n} else {print(\"x est différent de 1\")}\n\n[1] \"x est égal à 1\"\n\n\n\n# Correct\nif (identical(x, 1)) print(\"x est égal à 1\") else\nprint(\"x est différent de 1\")\n\n[1] \"x est égal à 1\"\n\n\n\n# Correct\nif (identical(x, 1)) print(\"x est égal à 1\") else print(\"x est différent de 1\")\n\n[1] \"x est égal à 1\"\n\n\n\n# Incorrect\nif (identical(x, 1)) print(\"x est égal à 1\")\nelse print(\"x est différent de 1\")\n\nError: &lt;text&gt;:3:1: unexpected 'else'\n2: if (identical(x, 1)) print(\"x est égal à 1\")\n3: else\n   ^\n\n\n\n# Switch\n# Fonctions et conditions if / else\ncondition &lt;- function(langue = \"Français\") {\nif (langue == \"Français\") {\n\"salut\"\n} else if (langue == \"Anglais\") {\n\"hello\"\n} else if (langue == \"Russe\") {\n\"привет\"\n} else {\nstop(\"salut\")\n}\n}\ncondition(\"Anglais\")\n\n[1] \"hello\"\n\n\n\n# Autre possibilité avec switch, mais à réserver aux variables caractères !\ncondition &lt;- function(langue = \"Français\") {\nswitch(langue,\nFrançais = \"salut\",\nAnglais = \"hello\",\nRusse = \"привет\",\nstop(\"salut\")\n)\n}\ncondition(\"Français\")\n\n[1] \"salut\"\n\n\n\n# Penser au print\nfor(i in 1:5) i\nfor(i in 1:5) print(i)\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n\n\n\n# Différences print et cat\ncat(\"Salut !\\nComment vas-tu ?\")\n\nSalut !\nComment vas-tu ?\n\nprint(\"Salut !\\nComment vas-tu ?\")\n\n[1] \"Salut !\\nComment vas-tu ?\"\n\n\n\n\n8 Les valeurs manquantes\n\n# Transformer les valeurs manquantes en 0\nx &lt;- data.frame(X1 = c(1, NA, 2), X2 = c(NA, NA, 3))\nx\n\n  X1 X2\n1  1 NA\n2 NA NA\n3  2  3\n\nx[is.na(x)] &lt;- 0\nx\n\n  X1 X2\n1  1  0\n2  0  0\n3  2  3\n\n\n\n# Pour les valeurs manquantes, toujours utiliser is.na et non ==\nNA == c(3, 1, 3, NA)\n\n[1] NA NA NA NA\n\nis.na(c(3, 1, 3, NA))\n\n[1] FALSE FALSE FALSE  TRUE\n\n\n\n# Utiliser %in% et non == pour vérifier une appartenance à plusieurs variables\nx1 &lt;- 1:6\nx1 == c(1, 5)\n\n[1]  TRUE FALSE FALSE FALSE FALSE FALSE\n\nx1 %in% c(1, 5)\n\n[1]  TRUE FALSE FALSE FALSE  TRUE FALSE\n\n\n\n# Sélection de données en cas de valeurs manquantes\nxna &lt;- c(1, NA, 3, 2, 4, 2)\n\n\n# Avec ce code, les NA sont conservés\nxna[xna == 2]\n\n[1] NA  2  2\n\n\n\n# Code sans les NA\nxna[!is.na(xna) & xna == 2]\n\n[1] 2 2\n\n\n\n# Code compact sans les NA\nxna[which(xna == 2)]\n\n[1] 2 2\n\n\n\n# Incidence des NA dans le calcul de statistiques !\n# Besoin de l'instruction na.rm = TRUE pour en supprimer l'incidence\nx &lt;- c(1, 5, 6, NA, 8)\nmean(x)\n\n[1] NA\n\nmean(x, na.rm = TRUE)\n\n[1] 5\n\nmax(x)\n\n[1] NA\n\nmax(x, na.rm = TRUE)\n\n[1] 8\n\n\n\n# Une moyenne de NA donne NaN (Not a Number) avec na.rm = TRUE !\nmean(c(NA, NA, NA), na.rm = TRUE)\n\n[1] NaN\n\n# Et donne NA avec na.rm = FALSE !\nmean(c(NA, NA, NA), na.rm = FALSE)\n\n[1] NA\n\n\n\n\n9 Sélection d’éléments\n\n# Le 1er élément est numéroté 1 et non 0 comme dans Python\nx &lt;- 1:3\nx[c(0, 4)] &lt;- c(-1, 9)\n# Marche !!\nfor(i in 0:3) print(x[i])\n\nnumeric(0)\n[1] 1\n[1] 2\n[1] 3\n\n\n\n# Cas où les noms ne sont pas uniques\nx &lt;- c(a = 1, b = 2, a = 3)\nx[\"a\"]\n\na \n1 \n\nx[names(x) %in% \"a\"]\n\na a \n1 3 \n\n\n\n# Options drop = FALSE\nx &lt;- data.frame(X1 = c(1,2), X2 = c(3,4), x3 = c(5,6))\nis.data.frame(x[, c(1,2)])\n\n[1] TRUE\n\nis.data.frame(x[, c(1)])\n\n[1] FALSE\n\nis.data.frame(x[, c(1), drop = FALSE])\n\n[1] TRUE\n\n\n\n# Fonction subset\nx &lt;- data.frame(x1 = c(1,2), x2 = c(3,4), x3 = c(5,6))\nsubset(x, select = x1)\n\n  x1\n1  1\n2  2\n\nsubset(x, select = -x1)\n\n  x2 x3\n1  3  5\n2  4  6\n\n\n\n# Correct\nsubset(x, x1 == 1)\n\n  x1 x2 x3\n1  1  3  5\n\n\n\n# Incorrect\nsubset(x, x1 = 1)\n\n  x1 x2 x3\n1  1  3  5\n2  2  4  6\n\n\n\n# Référence à des noms de colonne non usuels\ndf &lt;- data.frame(x = rnorm(5), y = runif(5))\nnames(df) &lt;- 1:2\n\n# Correct\ndf$`1`\n\n# Incorrect\ndf$1\n\nError: &lt;text&gt;:9:4: unexpected numeric constant\n8: # Incorrect\n9: df$1\n      ^\n\n\n\n# Utilisation de assign pour assigner une valeur à un objet en le désignant sous forme caractère\nassign('objet', 3:5)\nobjet\n\n[1] 3 4 5\n\nfor(i in 1:5) assign(paste('objet', i, sep = '_'), i)\nobjet_5\n\n[1] 5\n\n\n\n\n10 Les listes\n\n# Ajouter un élément à une liste\nliste &lt;- list(1, 2)\n# Il faut passer par cette syntaxe\nliste &lt;- c(liste, list(3))\nliste\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n\n\n\n# Trier une liste\nliste &lt;- list(\"2\" = 2, \"0\" = 0, \"1\" = 1)\nliste\n\n$`2`\n[1] 2\n\n$`0`\n[1] 0\n\n$`1`\n[1] 1\n\nliste[order(names(liste))]\n\n$`0`\n[1] 0\n\n$`1`\n[1] 1\n\n$`2`\n[1] 2\n\n\n\n# Extraction de listes\nliste &lt;- list(nombres = 1:5, lettres = letters[1:5])\nliste$nombres\n\n[1] 1 2 3 4 5\n\n\n\n# On veut faire appel à un élement de la liste à partir d'une variable extérieure\nvar &lt;- \"nombres\"\n\n\n# Ne marche pas, car nombres est en caractère\nliste$var\n\nNULL\n\n\n\n# Fonctionne\nliste[[var]]\n\n[1] 1 2 3 4 5\n\n\n\n# Sélection dans une liste\nliste &lt;- list(nombres = 1:5, lettres = letters[1:5])\nliste[\"nombres\"]\n\n$nombres\n[1] 1 2 3 4 5\n\nis.list(liste[\"nombres\"])\n\n[1] TRUE\n\nliste[[\"nombres\"]]\n\n[1] 1 2 3 4 5\n\nis.list(liste[[\"nombres\"]])\n\n[1] FALSE\n\n\n\n# Suppression des éléments d'une liste\nliste &lt;- list(nombres = 1:5, lettres = letters[1:5])\nliste[-1]\n\n$lettres\n[1] \"a\" \"b\" \"c\" \"d\" \"e\"\n\nliste[\"nombres\"] &lt;- NULL\nliste\n\n$lettres\n[1] \"a\" \"b\" \"c\" \"d\" \"e\"\n\n\n\n# Dernier élément de chaque composante d'une liste\nliste &lt;- list(1:26, letters)\nlapply(liste, tail, 1)\n\n[[1]]\n[1] 26\n\n[[2]]\n[1] \"z\"\n\n\n\n\n11 Différences entre sort(), order(), rank()\nsort() trie un vecteur par ordre croissant. rank() donne le rang de chaque élément du vecteur, le plus petit élément se voyant attribué le rang 1. order() renvoie l’indice du vecteur trié par ordre croissant.\n\nvecteur &lt;- c(5,3,1,2,4)\nsort(vecteur)\n\n[1] 1 2 3 4 5\n\norder(vecteur)\n\n[1] 3 4 2 5 1\n\nrank(vecteur)\n\n[1] 5 3 1 2 4\n\n\nUne autre solution que sort() pour trier un vecteur est :\n\nvecteur &lt;- c(5,3,1,2,4)\nvecteur[order(vecteur)]\n\n[1] 1 2 3 4 5\n\n\nÀ noter aussi que sort() permet aussi d’exécuter simultanément les fonctions sort() et order(). Ainsi :\n\nvecteur &lt;- c(5,3,1,2,4)\nsort(vecteur, index.return = TRUE)\n\n$x\n[1] 1 2 3 4 5\n\n$ix\n[1] 3 4 2 5 1\n\n# Fonction sort()\nsort(vecteur, index.return = TRUE)$x\n\n[1] 1 2 3 4 5\n\nsort(vecteur)\n\n[1] 1 2 3 4 5\n\n# Fonction order()\nsort(vecteur, index.return = TRUE)$ix\n\n[1] 3 4 2 5 1\n\norder(vecteur)\n\n[1] 3 4 2 5 1\n\n\n\n\n12 Ramasse-miettes (Garbage Collector)\nSi la mémoire vive de l’ordinateur est saturée, on peut essayer de la “purger” en utilisant la fonction gc() de R.\n\ngc()\n\n          used (Mb) gc trigger (Mb) max used (Mb)\nNcells  905981 48.4    1750171 93.5  1750171 93.5\nVcells 1757386 13.5   10146329 77.5  7526916 57.5\n\n\n\n\n13 Fonctions try() et tryCatch() À FAIRE\n\n\n14 Informations sur R\n\n# Informations sur la session de R\nsessionInfo()\nSys.info()\n.Platform\n\n# Version de R\nR.version.string\n\n# Lien vers le bureau de l'utilisateur\nfile.path(path.expand('~'), \"Desktop\")\n\n# Chemin de l'exécutable R est-il installé ?\nR.home(\"bin\")\n\n# Où sont installés les packages R\n.libPaths()\n\n\n\n15 Trucs et astuces divers\n\n# Créer un objet sous forme de code R !\ndata(\"mtcars\")\ndput(mtcars)\n\nstructure(list(mpg = c(21, 21, 22.8, 21.4, 18.7, 18.1, 14.3, \n24.4, 22.8, 19.2, 17.8, 16.4, 17.3, 15.2, 10.4, 10.4, 14.7, 32.4, \n30.4, 33.9, 21.5, 15.5, 15.2, 13.3, 19.2, 27.3, 26, 30.4, 15.8, \n19.7, 15, 21.4), cyl = c(6, 6, 4, 6, 8, 6, 8, 4, 4, 6, 6, 8, \n8, 8, 8, 8, 8, 4, 4, 4, 4, 8, 8, 8, 8, 4, 4, 4, 8, 6, 8, 4), \n    disp = c(160, 160, 108, 258, 360, 225, 360, 146.7, 140.8, \n    167.6, 167.6, 275.8, 275.8, 275.8, 472, 460, 440, 78.7, 75.7, \n    71.1, 120.1, 318, 304, 350, 400, 79, 120.3, 95.1, 351, 145, \n    301, 121), hp = c(110, 110, 93, 110, 175, 105, 245, 62, 95, \n    123, 123, 180, 180, 180, 205, 215, 230, 66, 52, 65, 97, 150, \n    150, 245, 175, 66, 91, 113, 264, 175, 335, 109), drat = c(3.9, \n    3.9, 3.85, 3.08, 3.15, 2.76, 3.21, 3.69, 3.92, 3.92, 3.92, \n    3.07, 3.07, 3.07, 2.93, 3, 3.23, 4.08, 4.93, 4.22, 3.7, 2.76, \n    3.15, 3.73, 3.08, 4.08, 4.43, 3.77, 4.22, 3.62, 3.54, 4.11\n    ), wt = c(2.62, 2.875, 2.32, 3.215, 3.44, 3.46, 3.57, 3.19, \n    3.15, 3.44, 3.44, 4.07, 3.73, 3.78, 5.25, 5.424, 5.345, 2.2, \n    1.615, 1.835, 2.465, 3.52, 3.435, 3.84, 3.845, 1.935, 2.14, \n    1.513, 3.17, 2.77, 3.57, 2.78), qsec = c(16.46, 17.02, 18.61, \n    19.44, 17.02, 20.22, 15.84, 20, 22.9, 18.3, 18.9, 17.4, 17.6, \n    18, 17.98, 17.82, 17.42, 19.47, 18.52, 19.9, 20.01, 16.87, \n    17.3, 15.41, 17.05, 18.9, 16.7, 16.9, 14.5, 15.5, 14.6, 18.6\n    ), vs = c(0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, \n    0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1), am = c(1, \n    1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, \n    0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1), gear = c(4, 4, 4, 3, \n    3, 3, 3, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, \n    3, 3, 4, 5, 5, 5, 5, 5, 4), carb = c(4, 4, 1, 1, 2, 1, 4, \n    2, 2, 4, 4, 3, 3, 3, 4, 4, 4, 1, 2, 1, 1, 2, 2, 4, 2, 1, \n    2, 2, 4, 6, 8, 2)), row.names = c(\"Mazda RX4\", \"Mazda RX4 Wag\", \n\"Datsun 710\", \"Hornet 4 Drive\", \"Hornet Sportabout\", \"Valiant\", \n\"Duster 360\", \"Merc 240D\", \"Merc 230\", \"Merc 280\", \"Merc 280C\", \n\"Merc 450SE\", \"Merc 450SL\", \"Merc 450SLC\", \"Cadillac Fleetwood\", \n\"Lincoln Continental\", \"Chrysler Imperial\", \"Fiat 128\", \"Honda Civic\", \n\"Toyota Corolla\", \"Toyota Corona\", \"Dodge Challenger\", \"AMC Javelin\", \n\"Camaro Z28\", \"Pontiac Firebird\", \"Fiat X1-9\", \"Porsche 914-2\", \n\"Lotus Europa\", \"Ford Pantera L\", \"Ferrari Dino\", \"Maserati Bora\", \n\"Volvo 142E\"), class = \"data.frame\")\n\n\n\n# En tidyverse, la fonction tribble peut être utile pour créer des bases lignes par lignes\nlibrary(tidyverse)\ntribble(\n  ~x, ~y,\n  \"a\",   1,\n  \"b\",   2\n)\n\n# A tibble: 2 × 2\n  x         y\n  &lt;chr&gt; &lt;dbl&gt;\n1 a         1\n2 b         2\n\n\n\n# Outils de debogage\noptions(error = recover)\noptions(error=NULL)\n\n\n# Définir ses propres opérateurs\n# R reconnait le texte entre %% comme un opérateur binaire\n# Exemple, simplifier la fonction paste\n'%+%' &lt;- function(x, y) { paste(x, y, sep = \"\") }\n\"Groupe_\" %+% 0:9\n\n [1] \"Groupe_0\" \"Groupe_1\" \"Groupe_2\" \"Groupe_3\" \"Groupe_4\" \"Groupe_5\"\n [7] \"Groupe_6\" \"Groupe_7\" \"Groupe_8\" \"Groupe_9\"\n\n\n\n# Récupérer les éléments à la diagonale d'un dataframe\ndiag(as.matrix(mtcars))\n\n [1]  21.00   6.00 108.00 110.00   3.15   3.46  15.84   1.00   0.00   4.00\n[11]   4.00\n\n\n\n# S'assurer qu'un objet R existe déjà\nexists(\"mtcars\")\n\n[1] TRUE\n\n\n\n\n16 Le pipe sur R\nCet opérateur permet d’enchaîner les opérations et d’avoir un code plus lisible.\nIl existe différents types :\n\nLe pipe de Rbase : |&gt;\nLe pipe du tidyverse : %&gt;%\n\nLes deux pipes fonctionnent de la même manière mais diffèrent sur les points suivants :\n\n\n\n\n\n\n\n\nThème\n|&gt;\n%&gt;%\n\n\n\n\nPlaceholder (pour indiquer où placer l’objet)\n_\nx |&gt; f(y, a = _)\n.\nx %&gt;% f(y, a = .)\n\n\nPackage\nAucun : directement sur R\nMagrittr (pipe disponible lorsqu’on effectue library(tidyverse)) |\n\n\nFonction\nImpossible\nPossible\n\n\nTemps de calcul\nRapide\nPlus lent\n\n\nOpérateurs\n|&gt;\n%&gt;% %&lt;&gt;% %$% %!&gt;% %T&gt;%\n\n\n\nSource :\n\nhttps://larmarange.github.io/guide-R/manipulation/pipe.html#le-pipe-natif-de-r\n\n\n\n17 Conseils divers\nIl est déconseillé de nommer des variables temporaires var, car ce nom désigne la fonction R permettant de calculer une variance.\n\n# Exemple : variance d'un échantillon aléatoire de 1000 observations tiré d'une loi normale centrée réduite\nvar(rnorm(1000))\n\n[1] 0.9480891",
    "crumbs": [
      "Trucs et astuces"
    ]
  },
  {
    "objectID": "02-avantages_inconvenients_env_R.html",
    "href": "02-avantages_inconvenients_env_R.html",
    "title": "Avantages et inconvénients des environnements R",
    "section": "",
    "text": "Environnements R\n          Avantages\n        Inconvénients\n\n\n\n\n       R base\n\nabsence de dépendance (ne s’appuie sur aucun package) : pas besoin d’installer un package, de gérer sa mise à jour, de craindre pour sa disparition\ngarantit la rétrocompatibilité du code : utile dans des environnements de production\ndans certains cas, se révèle la solution la plus simple\nparfois, la seule façon de faire\n\n\nne permet pas de gérer des bases de données plus volumineuses que la mémoire vive\nsyntaxe plus complexe que tidyverse et parfois incohérente\nsouvent moins rapide que les autres environnements\ndemande plus de connaissance sur le fonctionnement du langage R\ncertaines tâches sont plus simples à traiter avec les autres environnements\n\n\n\n       tidyverse\n\nplus simple à prendre en main\nsyntaxe plus simple que les autres environnements et cohérente\nlargement utilisé dans la communauté R\ntend à s’imposer comme la référence de la gestion de données sur R\nsyntaxe utilisée également dans les packages arrow / duckdb\n\n\nne permet pas de gérer des bases de données plus volumineuses que la mémoire vive\nglobalement moins rapide que data.table\ncertaines tâches sont plus difficiles à réaliser que dans les autres environnements\ndette technique importante : la syntaxe est plus souvent modifiée au gré des mises à jour du langage. Ainsi, la rétrocompatibilité est moins bien assurée, ce qui peut se révéler un problème dans un environnement de production\n\n\n\n       data.table\n\nfaible dépendance : garantit une rétrocompatibilité élevée, utile dans un environnement de production\nsyntaxe proche du R base\ngénéralement plus rapide que ses concurrents R base et tidyverse\nsyntaxe plus concise que tidyverse\nutile dans la gestion des grosses volumétries ou lorsque des considérations de vitesse d’exécution sont en jeu\n\n\nne permet pas de gérer des bases de données plus volumineuses que la mémoire vive\nsyntaxe parfois jugée comme plus difficile à maîtriser que celle du tidyverse\ncertaines tâches sont plus simples à traiter avec les autres environnements\nmoins utilisé que tidyverse, communauté plus réduite\n\n\n\n       duckdb\n\nbase de de données open source. Se rapproche d’outils tels SQLite ou PostgreSQL\noptimisé pour des traitements de données orientées colonnes (OLAP : traitement analytique en ligne) : plus performant pour les analyses statistiques que SQLite\nsimple d’utilisation par rapport à des outils comme PostgreSQL\npermet de gérer des bases de données plus volumineuses que la mémoire vive\npermet la syntaxe en SQL et en tidyverse, pratique pour ceux qui connaissent\ncompatible avec de nombreux autres langages (tel Python)\ntend à être plus rapide que ses concurrents\n\n\ncapacités très importantes pour gérer de très grosses volumétries, mais a ses limites face aux données les plus volumineuses\nà privilégier pour les données saturant ou excédant la mémoire vive, moins utile pour les données de taille petite ou moyenne\noutil plus récent : est susceptible de subir des changements dans les prochaines années\nla syntaxe tidyverse est largement, mais pas totalement prise en compte, et elle peut changer à la marge\ndocumentation officielle encore incomplète\noutil moins utilisé que les autres environnements, et surtout par des personnes ayant plus d’expérience\n\n\n\n       arrow\n\ntrès similaire à duckdb\nprojet plus ancien et plus mature que duckdb, moins de changements à attendre dans le futur\nmet à disposition le format de compression de données très utilisé parquet\n\n\ntrès similaires à duckdb\nmoins de fonctions standards du tidyverse prises en charge par rapport à duckdb\njointures de bases volumineuses moins performantes qu’avec duckdb\noffre moins de fonctionnalités que duckdb\n\n\n\n\nUn “benchmarking” des vitesses de traitement des différents packages est proposé ici : https://duckdblabs.github.io/db-benchmark/.",
    "crumbs": [
      "Avantages et inconvénients des environnements R"
    ]
  }
]