[
  {
    "objectID": "01-aide_memoire_r_sas.html",
    "href": "01-aide_memoire_r_sas.html",
    "title": "Aide-mémoire SAS - R",
    "section": "",
    "text": "L’aide-mémoire a pour but de fournir des codes écrits en SAS et d’en donner la traduction en R de différentes manières possibles :\nLes éléments utilisés sont des codes typiques qui sont appliqués dans la production statistique ou dans la réalisation d’études descriptives.\nCe document s’adresse notamment aux utilisateurs de SAS qui veulent connaître la traduction du code SAS en R, aux utilisateurs de R qui ont besoin de comprendre le code SAS, ainsi qu’aux utilisateurs d’un environnement R qui sont intéressés par la traduction dans un autre environnement R.\nIl se veut complémentaire de la documentation en ligne en français Utilit’R, née à l’Insee (https://www.book.utilitr.org/). Le lecteur est invité à s’y référer pour obtenir des informations importantes sur l’utilisation de R et qui ne sont pas discutées dans ce document, comme l’importation de données en R (https://www.book.utilitr.org/03_fiches_thematiques/fiche_import_fichiers_plats).",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#importation-des-packages",
    "href": "01-aide_memoire_r_sas.html#importation-des-packages",
    "title": "Aide-mémoire SAS - R",
    "section": "1 Importation des packages",
    "text": "1 Importation des packages",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#section",
    "href": "01-aide_memoire_r_sas.html#section",
    "title": "Aide-mémoire SAS - R",
    "section": "",
    "text": "R baseTidyversedata.tablearrow/duckdb\n\n\n\nlibrary(lubridate)\n\n\n\n\nlibrary(lubridate)\nlibrary(janitor)\nlibrary(magrittr)\nlibrary(tidyverse)\n\n\n\n\nlibrary(data.table)\n\n\n\n\n#library(duckdb)\n#library(arrow)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#chemin-vers-le-bureau-et-affichage-de-la-date-et-de-lannée",
    "href": "01-aide_memoire_r_sas.html#chemin-vers-le-bureau-et-affichage-de-la-date-et-de-lannée",
    "title": "Aide-mémoire SAS - R",
    "section": "2 Chemin vers le bureau et affichage de la date et de l’année",
    "text": "2 Chemin vers le bureau et affichage de la date et de l’année\n\nSASR base\n\n\n\n/* Chemin du bureau de l'utilisateur */\n\n/* On vide la log */\ndm \"log; clear; \";\n\n/* On récupère déjà l'identifiant de l'utilisateur */\n%let user = &sysuserid;\n\n/* Chemin proprement dit */\n%let bureau = C:\\Users\\&user.\\Desktop;\nlibname bur \"&bureau.\";\n\n/* Affichage de l'année */\n%let an = %sysfunc(year(%sysfunc(today())));\n\n/* & (esperluette) indique à SAS qu'il doit remplacer an par sa valeur définie par le %let */\n%put Année : &an.;\n\n/* Autre possibilité */\ndata _null_;call symput('annee', strip(year(today())));run;\n%put Année (autre méthode) : &annee.;\n\n/* Année passée */\n%put Année passée : %eval(&an. - 1);\n\n\n\n\n# On récupère déjà l'identifiant de l'utilisateur\nuser &lt;- Sys.getenv(\"USERNAME\")\n# Chemin d'accès au bureau de l'utilisateur\nchemin &lt;- file.path(\"C:/Users\", user, \"Desktop\")\n\n# Affichage de l'année\nannee &lt;- lubridate::year(Sys.Date())\nsprintf(\"Année : %04d\", annee)\nprint(paste0(\"Année : \", annee))\nannee_1 &lt;- annee - 1\npaste0(\"Année passée: \", annee_1)\n\n\nif (annee &gt;= 2023) {\n  print(\"Nous sommes en 2023 ou après\")\n} else {\n  print(\"Nous sommes en 2022 ou avant\")\n}\n\nAfficher le répertoire de travail et le définir si besoin\n\n#Afficher \n\ngetwd()\n\n\n#Le définir si besoin \n\n#setwd(dir=\"nom du répertoire\")",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#création-dune-base-de-données",
    "href": "01-aide_memoire_r_sas.html#création-dune-base-de-données",
    "title": "Aide-mémoire SAS - R",
    "section": "3 Création d’une base de données",
    "text": "3 Création d’une base de données\nDonnées fictives sur des formations\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n\ndata Donnees;\n  infile cards dsd dlm='|';\n  format Identifiant $3. Sexe_red 1. CSP $1. Niveau $30. Date_naissance ddmmyy10. Date_entree ddmmyy10. Duree Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel poids_sondage;\n  input Identifiant $ Sexe_red CSP $ Niveau $ Date_naissance :ddmmyy10. Date_entree :ddmmyy10. Duree Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel poids_sondage;\n  cards;\n  173|2|1|Qualifie|17/06/1998|01/01/2021|308|12|6|17|4|19|117.1\n  173|2|1|qualifie|17/06/1998|01/01/2022|365|6||12|7|14|98.3\n  173|2|1|qualifie|17/06/1998|06/01/2022|185|8|10|11|1|9|214.6\n  173|2|1|Qualifie|17/06/1998|02/01/2023|365|14|15|15|10|8|84.7\n  174|1|1|qualifie|08/12/1984|17/08/2021|183|17|18|20|15|12|65.9\n  175|1|1|qualifie|16/09/1989|21/12/2022|730|5|5|8|4|9|148.2\n  198|2|4|Non qualifie|17/03/1987|28/07/2022|30|10|10|10|16|8|89.6\n  198|2|4|Qualifie|17/03/1987|17/11/2022|164|11|7|6|14|13|100.3\n  198|2|4|Qualifie|17/03/1987|21/02/2023|365|9|20|3|4|17|49.3\n  168|1|2|Qualifie|30/07/2002|04/09/2019|365|18|11|20|13|15|148.2\n  211|2|3|Non qualifie||17/12/2021|135|16|16|15|12|9|86.4\n  278|1|5|Qualifie|10/08/1948|07/06/2018|365|14|10|6|8|12|99.2\n  347|2|5|Qualifie|13/09/1955||180|12|5|7|11|12|105.6\n  112|1|3|Non qualifie|13/09/2001|02/03/2022|212|3|10|11|9|8|123.1\n  112|1|3|Non qualifie|13/09/2001|01/03/2021|365|7|13|8|19|2|137.4\n  112|1|3|Non qualifie|13/09/2001|01/12/2023|365||||||187.6\n  087|1|3|Non qualifie|||365||||||87.3\n  087|1|3|Non qualifie||31/10/2020|365||||||87.3\n  099|1|3|qualifie|06/06/1998|01/03/2021|364|12|11|10|12|13|169.3\n  099|1|3|qualifie|06/06/1998|01/03/2022|364|12|11|10|12|13|169.3\n  099|1|3|qualifie|06/06/1998|01/03/2023|364|12|11|10|12|13|169.3\n  187|2|2|qualifie|05/12/1986|01/01/2022|364|10|10|10|10|10|169.3\n  187|2|2|qualifie|05/12/1986|01/01/2023|364|10|10|10|10|10|234.1\n  689|1|1||01/12/2000|06/11/2017|123|9|7|8|13|16|189.3\n  765|1|4|Non qualifie|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9\n  765|1|4|Non qualifie|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9\n  765|1|4|Non qualifie|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9\n;\nrun;\n\n\n\n\ndonnees_rbase &lt;- data.frame(\n  Identifiant = c(\"173\", \"173\", \"173\", \"173\", \"174\", \"175\", \"198\", \"198\", \"198\", \"168\", \"211\", \"278\", \"347\", \"112\", \"112\", \"112\", \"087\", \"087\", \"099\", \"099\", \"099\", \"187\", \"187\", \"689\", \"765\", \"765\", \"765\"),\n  Sexe_red = c(\"2\", \"2\", \"2\", \"2\", \"1\", \"1\", \"2\", \"2\", \"2\", \"1\", \"2\", \"1\", \"2\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", \"1\", \"1\"),\n  CSP = c(\"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"4\", \"4\", \"4\", \"2\", \"3\", \"5\", \"5\", \"3\", \"3\", \"3\", \"3\", \"3\", \"3\", \"3\", \"3\", \"2\", \"2\", \"1\", \"4\", \"4\", \"4\"),\n  Niveau = c(\"Qualifie\", \"qualifie\", \"qualifie\", \"Non Qualifie\", \"qualifie\", \"qualifie\", \"Non qualifie\", \"Qualifie\", \"Qualifie\", \"Qualifie\", \"Non qualifie\", \"Qualifie\", \"Qualifie\", \"Non qualifie\", \n             \"Non qualifie\", \"qualifie\", \"Non qualifie\", \"Non qualifie\", \"qualifie\", \"qualifie\", \"qualifie\", \"qualifie\", \"qualifie\", NA, \"Non qualifie\", \"Non qualifie\", \"Non qualifie\"),\n  Date_naissance = c(\"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"08/12/1984\", \"16/09/1989\", \"17/03/1987\", \"17/03/1987\", \"17/03/1987\", \"30/07/2002\", NA, \"10/08/1948\", \n                     \"13/09/1955\", \"13/09/2001\", \"13/09/2001\", \"13/09/2001\", NA, NA, \"06/06/1998\", \"06/06/1998\", \"06/06/1998\", \"05/12/1986\", \"05/12/1986\", \"01/12/2000\", \"26/12/1995\", \"26/12/1995\", \"26/12/1995\"),\n  Date_entree = c(\"01/01/2021\", \"01/01/2022\", \"06/01/2022\", \"02/01/2023\", \"17/08/2021\", \"21/12/2022\", \"28/07/2022\", \"17/11/2022\", \"21/02/2023\", \"04/09/2019\", \"17/12/2021\", \"07/06/2018\", NA, \"02/03/2022\", \"01/03/2021\", \"01/12/2023\", NA, \n                  \"31/10/2020\", \"01/03/2021\", \"01/03/2022\", \"01/03/2023\", \"01/01/2022\", \"01/01/2023\", \"06/11/2017\", \"17/04/2020\", \"17/04/2020\", \"17/04/2020\"),\n  Duree = c(\"308\", \"365\", \"185\", \"365\", \"183\", \"730\", \"30\", \"164\", \"365\", \"365\", \"135\", \"365\", \"180\", \"212\", \"365\", \"365\", \"365\", \"365\", \"364\", \"364\", \"364\", \"364\", \"364\", \"123\", \"160\", \"160\", \"160\"),\n  Note_Contenu = c(\"12\", \"6\", \"8\", \"14\", \"17\", \"5\", \"10\", \"11\", \"9\", \"18\", \"16\", \"14\", \"12\", \"3\", \"7\", NA, NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"9\", \"13\", \"13\", \"13\"),\n  Note_Formateur = c(\"6\", NA, \"10\", \"15\", \"18\", \"5\", \"10\", \"7\", \"20\", \"11\", \"16\", \"10\", \"5\", \"10\", \"13\", NA, NA, NA, \"11\", \"11\", \"11\", \"10\", \"10\", \"7\", \"10\", \"10\", \"10\"),\n  Note_Moyens = c(\"17\", \"12\", \"11\", \"15\", \"20\", \"8\", \"10\", \"6\", \"3\", \"20\", \"15\", \"6\", \"7\", \"11\", \"8\", NA, NA, NA, \"10\", \"10\", \"10\", \"10\", \"10\", \"8\", \"12\", \"12\", \"12\"),\n  Note_Accompagnement = c(\"4\", \"7\", \"1\", \"10\", \"15\", \"4\", \"16\", \"14\", \"4\", \"13\", \"12\", \"8\", \"11\", \"9\", \"19\", NA, NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"13\", \"18\", \"18\", \"18\"),\n  Note_Materiel = c(\"19\", \"14\", \"9\", \"8\", \"12\", \"9\", \"8\", \"13\", \"17\", \"15\", \"9\", \"12\", \"12\", \"8\", \"2\", NA, NA, NA, \"13\", \"13\", \"13\", \"10\", \"10\", \"16\", \"10\", \"10\", \"10\"),\n  poids_sondage = c(\"117.1\", \"98.3\", \"214.6\", \"84.7\", \"65.9\", \"148.2\", \"89.6\", \"100.3\", \"49.3\", \"148.2\", \"86.4\", \"99.2\", \"105.6\", \"123.1\", \"137.4\", \"187.6\", \"87.3\", \"87.3\", \"169.3\", \"169.3\", \"169.3\", \"169.3\", \"234.1\", \"189.3\", \"45.9\", \"45.9\", \"45.9\")\n)\n\n\n\n\na &lt;- \"Identifiant|Sexe_red|CSP|Niveau|Date_naissance|Date_entree|Duree|Note_Contenu|Note_Formateur|Note_Moyens|Note_Accompagnement|Note_Materiel|poids_sondage\n173|2|1|Qualifie|17/06/1998|01/01/2021|308|12|6|17|4|19|117.1\n173|2|1|qualifie|17/06/1998|01/01/2022|365|6||12|7|14|98.3\n173|2|1|qualifie|17/06/1998|06/01/2022|185|8|10|11|1|9|214.6\n173|2|1|Qualifie|17/06/1998|02/01/2023|365|14|15|15|10|8|84.7\n174|1|1|qualifie|08/12/1984|17/08/2021|183|17|18|20|15|12|65.9\n175|1|1|qualifie|16/09/1989|21/12/2022|730|5|5|8|4|9|148.2\n198|2|4|Non qualifie|17/03/1987|28/07/2022|30|10|10|10|16|8|89.6\n198|2|4|Qualifie|17/03/1987|17/11/2022|164|11|7|6|14|13|100.3\n198|2|4|Qualifie|17/03/1987|21/02/2023|365|9|20|3|4|17|49.3\n168|1|2|Qualifie|30/07/2002|04/09/2019|365|18|11|20|13|15|148.2\n211|2|3|Non qualifie||17/12/2021|135|16|16|15|12|9|86.4\n278|1|5|Qualifie|10/08/1948|07/06/2018|365|14|10|6|8|12|99.2\n347|2|5|Qualifie|13/09/1955||180|12|5|7|11|12|105.6\n112|1|3|Non qualifie|13/09/2001|02/03/2022|212|3|10|11|9|8|123.1\n112|1|3|Non qualifie|13/09/2001|01/03/2021|365|7|13|8|19|2|137.4\n112|1|3|Non qualifie|13/09/2001|01/12/2023|365||||||187.6\n087|1|3|Non qualifie|||365||||||87.3\n087|1|3|Non qualifie||31/10/2020|365||||||87.3\n099|1|3|qualifie|06/06/1998|01/03/2021|364|12|11|10|12|13|169.3\n099|1|3|qualifie|06/06/1998|01/03/2022|364|12|11|10|12|13|169.3\n099|1|3|qualifie|06/06/1998|01/03/2023|364|12|11|10|12|13|169.3\n187|2|2|qualifie|05/12/1986|01/01/2022|364|10|10|10|10|10|169.3\n187|2|2|qualifie|05/12/1986|01/01/2023|364|10|10|10|10|10|234.1\n689|1|1||01/12/2000|06/11/2017|123|9|7|8|13|16|189.3\n765|1|4|Non qualifie|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9\n765|1|4|Non qualifie|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9\n765|1|4|Non qualifie|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9\"\n\n\n#readLines va permettre de créer un objet pour chaque ligne\n#strsplit va permettre de séparer les textes qui sont entre des \"|\" \na &lt;-  readLines(textConnection(a)) %&gt;% \n  strsplit(split='|',fixed=TRUE) \n\ndonnees_tidyverse &lt;- data.frame(matrix(unlist(a), nrow=length(a), byrow=TRUE))\n\n#La première ligne donne le nom des colonnes\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% janitor::row_to_names(row_number = 1)\n\n#On remplace les valeurs qui sont des espaces par des \"NA\" dans toute \n#la base de données \ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% mutate_all(na_if,\"\")\n\n\n\n\ndonnees_datatable &lt;- data.frame(\n  Identifiant = c(\"173\", \"173\", \"173\", \"173\", \"174\", \"175\", \"198\", \"198\", \"198\", \"168\", \"211\", \"278\", \"347\", \"112\", \"112\", \"112\", \"087\", \"087\", \"099\", \"099\", \"099\", \"187\", \"187\", \"689\", \"765\", \"765\", \"765\"),\n  Sexe_red = c(\"2\", \"2\", \"2\", \"2\", \"1\", \"1\", \"2\", \"2\", \"2\", \"1\", \"2\", \"1\", \"2\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"2\", \"2\", \"1\", \"1\", \"1\", \"1\"),\n  CSP = c(\"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"4\", \"4\", \"4\", \"2\", \"3\", \"5\", \"5\", \"3\", \"3\", \"3\", \"3\", \"3\", \"3\", \"3\", \"3\", \"2\", \"2\", \"1\", \"4\", \"4\", \"4\"),\n  Niveau = c(\"Qualifie\", \"qualifie\", \"qualifie\", \"Non Qualifie\", \"qualifie\", \"qualifie\", \"Non qualifie\", \"Qualifie\", \"Qualifie\", \"Qualifie\", \"Non qualifie\", \"Qualifie\", \"Qualifie\", \"Non qualifie\", \n             \"Non qualifie\", \"qualifie\", \"Non qualifie\", \"Non qualifie\", \"qualifie\", \"qualifie\", \"qualifie\", \"qualifie\", \"qualifie\", NA, \"Non qualifie\", \"Non qualifie\", \"Non qualifie\"),\n  Date_naissance = c(\"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"17/06/1998\", \"08/12/1984\", \"16/09/1989\", \"17/03/1987\", \"17/03/1987\", \"17/03/1987\", \"30/07/2002\", NA, \"10/08/1948\", \n                     \"13/09/1955\", \"13/09/2001\", \"13/09/2001\", \"13/09/2001\", NA, NA, \"06/06/1998\", \"06/06/1998\", \"06/06/1998\", \"05/12/1986\", \"05/12/1986\", \"01/12/2000\", \"26/12/1995\", \"26/12/1995\", \"26/12/1995\"),\n  Date_entree = c(\"01/01/2021\", \"01/01/2022\", \"06/01/2022\", \"02/01/2023\", \"17/08/2021\", \"21/12/2022\", \"28/07/2022\", \"17/11/2022\", \"21/02/2023\", \"04/09/2019\", \"17/12/2021\", \"07/06/2018\", NA, \"02/03/2022\", \"01/03/2021\", \"01/12/2023\", NA, \n                  \"31/10/2020\", \"01/03/2021\", \"01/03/2022\", \"01/03/2023\", \"01/01/2022\", \"01/01/2023\", \"06/11/2017\", \"17/04/2020\", \"17/04/2020\", \"17/04/2020\"),\n  Duree = c(\"308\", \"365\", \"185\", \"365\", \"183\", \"730\", \"30\", \"164\", \"365\", \"365\", \"135\", \"365\", \"180\", \"212\", \"365\", \"365\", \"365\", \"365\", \"364\", \"364\", \"364\", \"364\", \"364\", \"123\", \"160\", \"160\", \"160\"),\n  Note_Contenu = c(\"12\", \"6\", \"8\", \"14\", \"17\", \"5\", \"10\", \"11\", \"9\", \"18\", \"16\", \"14\", \"12\", \"3\", \"7\", NA, NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"9\", \"13\", \"13\", \"13\"),\n  Note_Formateur = c(\"6\", NA, \"10\", \"15\", \"18\", \"5\", \"10\", \"7\", \"20\", \"11\", \"16\", \"10\", \"5\", \"10\", \"13\", NA, NA, NA, \"11\", \"11\", \"11\", \"10\", \"10\", \"7\", \"10\", \"10\", \"10\"),\n  Note_Moyens = c(\"17\", \"12\", \"11\", \"15\", \"20\", \"8\", \"10\", \"6\", \"3\", \"20\", \"15\", \"6\", \"7\", \"11\", \"8\", NA, NA, NA, \"10\", \"10\", \"10\", \"10\", \"10\", \"8\", \"12\", \"12\", \"12\"),\n  Note_Accompagnement = c(\"4\", \"7\", \"1\", \"10\", \"15\", \"4\", \"16\", \"14\", \"4\", \"13\", \"12\", \"8\", \"11\", \"9\", \"19\", NA, NA, NA, \"12\", \"12\", \"12\", \"10\", \"10\", \"13\", \"18\", \"18\", \"18\"),\n  Note_Materiel = c(\"19\", \"14\", \"9\", \"8\", \"12\", \"9\", \"8\", \"13\", \"17\", \"15\", \"9\", \"12\", \"12\", \"8\", \"2\", NA, NA, NA, \"13\", \"13\", \"13\", \"10\", \"10\", \"16\", \"10\", \"10\", \"10\"),\n  poids_sondage = c(\"117.1\", \"98.3\", \"214.6\", \"84.7\", \"65.9\", \"148.2\", \"89.6\", \"100.3\", \"49.3\", \"148.2\", \"86.4\", \"99.2\", \"105.6\", \"123.1\", \"137.4\", \"187.6\", \"87.3\", \"87.3\", \"169.3\", \"169.3\", \"169.3\", \"169.3\", \"234.1\", \"189.3\", \"45.9\", \"45.9\", \"45.9\")\n)\n\n\n\nDuckdb fonctionne comme un serveur SQL. Il faut transférer les données vers le serveur SQL.\n\n# Ouvrir une connexion au serveur duckdb\ncon &lt;- DBI::dbConnect(duckdb::duckdb()); \n\n# On \"copie\" les données dans une table du nom table_duckdb\ncon %&gt;% duckdb::duckdb_register(name = \"table_duckdb\", df = donnees_tidyverse)\n\ncon %&gt;% tbl(\"table_duckdb\")\n\n# Source:   table&lt;table_duckdb&gt; [?? x 13]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1016-azure:R 4.2.0/:memory:]\n   Identifiant Sexe_red CSP   Niveau       Date_naissance Date_entree Duree\n   &lt;chr&gt;       &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt;        &lt;chr&gt;          &lt;chr&gt;       &lt;chr&gt;\n 1 173         2        1     Qualifie     17/06/1998     01/01/2021  308  \n 2 173         2        1     qualifie     17/06/1998     01/01/2022  365  \n 3 173         2        1     qualifie     17/06/1998     06/01/2022  185  \n 4 173         2        1     Qualifie     17/06/1998     02/01/2023  365  \n 5 174         1        1     qualifie     08/12/1984     17/08/2021  183  \n 6 175         1        1     qualifie     16/09/1989     21/12/2022  730  \n 7 198         2        4     Non qualifie 17/03/1987     28/07/2022  30   \n 8 198         2        4     Qualifie     17/03/1987     17/11/2022  164  \n 9 198         2        4     Qualifie     17/03/1987     21/02/2023  365  \n10 168         1        2     Qualifie     30/07/2002     04/09/2019  365  \n# ℹ more rows\n# ℹ 6 more variables: Note_Contenu &lt;chr&gt;, Note_Formateur &lt;chr&gt;,\n#   Note_Moyens &lt;chr&gt;, Note_Accompagnement &lt;chr&gt;, Note_Materiel &lt;chr&gt;,\n#   poids_sondage &lt;chr&gt;\n\n# Fermer la connexion au serveur duckdb\nDBI::dbDisconnect(con, shutdown = TRUE)\n\nPour la suite, on suppose que la connexion est ouverte sous le nom con, et que les données sont accessibles par la requête requete_duckdb. Le code modifiera la requete, mais pas la table dans le serveur SQL.\n\ncon &lt;- DBI::dbConnect(duckdb::duckdb()); \ncon %&gt;% duckdb::duckdb_register(name = \"table_duckdb\", df = donnees_tidyverse)\nrequete_duckdb &lt;- con %&gt;% tbl(\"table_duckdb\")\n\nN.B. Duckdb est envisagé pour des traitements sans charger des données en mémoire, par exemple en lisant directement un fichier .parquet sur le disque dur. Dans ce cas, les opérations sont effectuées à la volée, mais n’affectent pas les fichiers source.",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#préparer-les-données-importées",
    "href": "01-aide_memoire_r_sas.html#préparer-les-données-importées",
    "title": "Aide-mémoire SAS - R",
    "section": "4 Préparer les données importées",
    "text": "4 Préparer les données importées\n\n4.1 Casse des noms des variables\nR étant sensible à la casse, ce qui n’est pas le cas de SAS, cette section est donc pertinente pour les codes sous R.\n\nExtraire les noms des variables de la base\nMettre le nom de la colonne en minuscules\n\n\nR basetidyversedata.tablearrow/duckdb\n\n\n\n# On vérifie déjà que la base importée est bien un data.frame\nis.data.frame(donnees_rbase)\n\nOn convertit les colonnes en minuscule\n\n# Renommer les colonnes de la base\ncolnames(donnees_rbase) &lt;- tolower(colnames(donnees_rbase))\n# Autre possibilité\nsetNames(donnees_rbase, tolower(names(donnees_rbase)))\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  magrittr::set_colnames(value = casefold(colnames(.), upper = FALSE))\n\n\n\n\n# On convertit la base en format data.table\n# Expliquer les différences\ndonnees_datatable &lt;- as.data.table(donnees_datatable)\nsetDT(donnees_datatable)\n\n# On vérifie que la base est bien un data.table\nis.data.table(donnees_datatable)\n\nOn convertit les colonnes en minuscule\n\n# Renommer les colonnes de la base\ncolnames(donnees_datatable) &lt;- tolower(colnames(donnees_datatable))\n# Autre possibilité\nsetNames(donnees_datatable, tolower(names(donnees_datatable)))\n\n    identifiant sexe_red    csp       niveau date_naissance date_entree  duree\n         &lt;char&gt;   &lt;char&gt; &lt;char&gt;       &lt;char&gt;         &lt;char&gt;      &lt;char&gt; &lt;char&gt;\n 1:         173        2      1     Qualifie     17/06/1998  01/01/2021    308\n 2:         173        2      1     qualifie     17/06/1998  01/01/2022    365\n 3:         173        2      1     qualifie     17/06/1998  06/01/2022    185\n 4:         173        2      1 Non Qualifie     17/06/1998  02/01/2023    365\n 5:         174        1      1     qualifie     08/12/1984  17/08/2021    183\n 6:         175        1      1     qualifie     16/09/1989  21/12/2022    730\n 7:         198        2      4 Non qualifie     17/03/1987  28/07/2022     30\n 8:         198        2      4     Qualifie     17/03/1987  17/11/2022    164\n 9:         198        2      4     Qualifie     17/03/1987  21/02/2023    365\n10:         168        1      2     Qualifie     30/07/2002  04/09/2019    365\n11:         211        2      3 Non qualifie           &lt;NA&gt;  17/12/2021    135\n12:         278        1      5     Qualifie     10/08/1948  07/06/2018    365\n13:         347        2      5     Qualifie     13/09/1955        &lt;NA&gt;    180\n14:         112        1      3 Non qualifie     13/09/2001  02/03/2022    212\n15:         112        1      3 Non qualifie     13/09/2001  01/03/2021    365\n16:         112        1      3     qualifie     13/09/2001  01/12/2023    365\n17:         087        1      3 Non qualifie           &lt;NA&gt;        &lt;NA&gt;    365\n18:         087        1      3 Non qualifie           &lt;NA&gt;  31/10/2020    365\n19:         099        1      3     qualifie     06/06/1998  01/03/2021    364\n20:         099        1      3     qualifie     06/06/1998  01/03/2022    364\n21:         099        1      3     qualifie     06/06/1998  01/03/2023    364\n22:         187        2      2     qualifie     05/12/1986  01/01/2022    364\n23:         187        2      2     qualifie     05/12/1986  01/01/2023    364\n24:         689        1      1         &lt;NA&gt;     01/12/2000  06/11/2017    123\n25:         765        1      4 Non qualifie     26/12/1995  17/04/2020    160\n26:         765        1      4 Non qualifie     26/12/1995  17/04/2020    160\n27:         765        1      4 Non qualifie     26/12/1995  17/04/2020    160\n    identifiant sexe_red    csp       niveau date_naissance date_entree  duree\n    note_contenu note_formateur note_moyens note_accompagnement note_materiel\n          &lt;char&gt;         &lt;char&gt;      &lt;char&gt;              &lt;char&gt;        &lt;char&gt;\n 1:           12              6          17                   4            19\n 2:            6           &lt;NA&gt;          12                   7            14\n 3:            8             10          11                   1             9\n 4:           14             15          15                  10             8\n 5:           17             18          20                  15            12\n 6:            5              5           8                   4             9\n 7:           10             10          10                  16             8\n 8:           11              7           6                  14            13\n 9:            9             20           3                   4            17\n10:           18             11          20                  13            15\n11:           16             16          15                  12             9\n12:           14             10           6                   8            12\n13:           12              5           7                  11            12\n14:            3             10          11                   9             8\n15:            7             13           8                  19             2\n16:         &lt;NA&gt;           &lt;NA&gt;        &lt;NA&gt;                &lt;NA&gt;          &lt;NA&gt;\n17:         &lt;NA&gt;           &lt;NA&gt;        &lt;NA&gt;                &lt;NA&gt;          &lt;NA&gt;\n18:         &lt;NA&gt;           &lt;NA&gt;        &lt;NA&gt;                &lt;NA&gt;          &lt;NA&gt;\n19:           12             11          10                  12            13\n20:           12             11          10                  12            13\n21:           12             11          10                  12            13\n22:           10             10          10                  10            10\n23:           10             10          10                  10            10\n24:            9              7           8                  13            16\n25:           13             10          12                  18            10\n26:           13             10          12                  18            10\n27:           13             10          12                  18            10\n    note_contenu note_formateur note_moyens note_accompagnement note_materiel\n    poids_sondage\n           &lt;char&gt;\n 1:         117.1\n 2:          98.3\n 3:         214.6\n 4:          84.7\n 5:          65.9\n 6:         148.2\n 7:          89.6\n 8:         100.3\n 9:          49.3\n10:         148.2\n11:          86.4\n12:          99.2\n13:         105.6\n14:         123.1\n15:         137.4\n16:         187.6\n17:          87.3\n18:          87.3\n19:         169.3\n20:         169.3\n21:         169.3\n22:         169.3\n23:         234.1\n24:         189.3\n25:          45.9\n26:          45.9\n27:          45.9\n    poids_sondage\n\n\n\n\n\nrequete_duckdb %&gt;% colnames()\n\n [1] \"Identifiant\"         \"Sexe_red\"            \"CSP\"                \n [4] \"Niveau\"              \"Date_naissance\"      \"Date_entree\"        \n [7] \"Duree\"               \"Note_Contenu\"        \"Note_Formateur\"     \n[10] \"Note_Moyens\"         \"Note_Accompagnement\" \"Note_Materiel\"      \n[13] \"poids_sondage\"      \n\n\n\nrequete_duckdb %&gt;% rename_with(tolower) %&gt;% colnames()\n\n [1] \"identifiant\"         \"sexe_red\"            \"csp\"                \n [4] \"niveau\"              \"date_naissance\"      \"date_entree\"        \n [7] \"duree\"               \"note_contenu\"        \"note_formateur\"     \n[10] \"note_moyens\"         \"note_accompagnement\" \"note_materiel\"      \n[13] \"poids_sondage\"      \n\n\n\n\n\n\n\n4.2 Harmoniser le format des variables\nConvertir certaines variables en format ‘date’, ‘integer’ et ‘numeric’\n\nSASR basetidyversedata.tablearrow/duckdb\n\n\n\ndata Donnees_sas;\n  set Donnees_sas;\n  duree_int = input(duree, 1.);\n  note_contenu_int = input(note_contenu, 1.);\n  note_formateur_int = input(note_formateur, 1.);\n  note_moyens_int = input(note_moyens, 1.);\n  note_accompagnement_int = input(note_accompagnement, 1.);\n  note_materiel_int = input(note_materiel, 1.);\n  date_naissance_date = input(date_naissance, DDMMYY10.);\n  date_entree = input(date_entree, DDMMYY10.);\nrun;\n\n\n\nOn a importé toutes les variables en caractère. On convertit certaines variables en format ‘numeric’ et ‘date’\n\nenNumerique &lt;- c(\"duree\", \"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nenDate &lt;- c('date_naissance', 'date_entree')\n\n\ndonnees_rbase[, enNumerique] &lt;- lapply(donnees_rbase[, enNumerique], as.integer)\n\n\ndonnees_rbase[, enDate] &lt;- lapply(donnees_rbase[, enDate], lubridate::dmy)\n\n\n#Pour une seule variable \n\ndonnees_rbase$poids_sondage &lt;- as.numeric(donnees_rbase$poids_sondage)\n\nOn convertit les dates.\n\n# On récupère les variables dont le nom débute par le mot \"date\"\nvarDates &lt;- names(donnees_rbase)[grepl(\"date\", tolower(names(donnees_rbase)))]\n\n\n# On remplace / par - dans les dates\n# donnees_rbase[, varDates] &lt;- lapply(donnees_rbase[, varDates], function(x) gsub(\"/\", \"-\", x))\n\n\n# On exprime les dates en format Date\n# donnees_rbase[, varDates] &lt;- lapply(donnees_rbase[, varDates], lubridate::dmy)\n\n\n\n\nenNumerique &lt;- c(\"duree\", \"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nenDate &lt;- c('date_naissance', 'date_entree')\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%  \n  mutate_at(enNumerique, as.integer) %&gt;% \n  mutate(poids_sondage=as.numeric(poids_sondage)) %&gt;% \n  mutate_at(enDate, lubridate::dmy)\n\n\n\nOn a importé toutes les variables en caractère. On convertit certaines variables en format ‘numeric’ et ‘date’\n\nenNumerique &lt;- c(\"duree\", \"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nenDate &lt;- c('date_naissance', 'date_entree')\n\n\ndonnees_datatable[, lapply(.SD, as.integer), .SDcols = enNumerique]\n# Autre solution\nfor (j in enNumerique) {\n  set(donnees_datatable, j = j, value = as.numeric(donnees_datatable[[j]]))\n}\ndonnees_datatable[, poids_sondage := as.numeric(poids_sondage)]\n\nOn convertit les dates.\n\n# On récupère les variables dont le nom débute par le mot \"date\"\nvarDates &lt;- names(donnees_datatable)[grepl(\"date\", tolower(names(donnees_datatable)))]\n# On remplace / par - dans les dates\ndonnees_datatable[, (varDates) := lapply(.SD, function(x) gsub(\"/\", \"-\", x)), .SDcols = varDates]\n# On exprime les dates en format Date\ndonnees_datatable[, (varDates) := lapply(.SD, lubridate::dmy), .SDcols = varDates]\n\n\n\n\nenNumerique &lt;- c(\"Duree\", \"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\")\nenDate &lt;- c('Date_naissance', 'Date_entree')\n\n\nrequete_duckdb %&gt;%  \n  mutate_at(enNumerique, as.integer) %&gt;% \n  mutate(poids_sondage=as.numeric(poids_sondage)) %&gt;%\n  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %&gt;% # strptime est une fonction duckdb\n  select(enDate, Duree, Note_Contenu)\n\n# Source:   SQL [?? x 4]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1016-azure:R 4.2.0/:memory:]\n   Date_naissance Date_entree Duree Note_Contenu\n   &lt;date&gt;         &lt;date&gt;      &lt;int&gt;        &lt;int&gt;\n 1 1998-06-17     2021-01-01    308           12\n 2 1998-06-17     2022-01-01    365            6\n 3 1998-06-17     2022-01-06    185            8\n 4 1998-06-17     2023-01-02    365           14\n 5 1984-12-08     2021-08-17    183           17\n 6 1989-09-16     2022-12-21    730            5\n 7 1987-03-17     2022-07-28     30           10\n 8 1987-03-17     2022-11-17    164           11\n 9 1987-03-17     2023-02-21    365            9\n10 2002-07-30     2019-09-04    365           18\n# ℹ more rows\n\n\nNote : duckdb fait des conversions de type implicitement, mais seulement les conversions incontestables. Il faudra souvent préciser le type des variables.",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#information-sur-la-base-de-données",
    "href": "01-aide_memoire_r_sas.html#information-sur-la-base-de-données",
    "title": "Aide-mémoire SAS - R",
    "section": "5 Information sur la base de données",
    "text": "5 Information sur la base de données\n\n5.1 Extraire les 10 première lignes de la base\n\nSASR basetidyversearrow/duckdb\n\n\n\n/* Extraire les x premières lignes de la base (10 par défaut) */\n%let x = 10;\nproc print data = Donnees_sas (firstobs = 1 obs = &x.);run;\n\n/* Ou alors */\ndata Lignes&x.;set Donnees_sas (firstobs = 1 obs = &x.);proc print;run;\n\n\n\n\n# Extraire les 10 premières lignes de la base\ndonnees_rbase[1:10, ]\n\n\n\n\ndonnees_tidyverse %&gt;% \n  slice(1:10)\n\n\n\nEn duckdb, les dix premières lignes sont affichées par défaut. Si on veut les récupérer, par exemple dans une autre variable, il faut faire collect(). Attention, comme il n’y a pas d’ordre en SQL, il faut ordonner les lignes si on veut un résultat reproductible. C’est une opération qui peut être couteuse en temps CPU.\n\nrequete_duckdb %&gt;% head(10) %&gt;% collect()\n\n# A tibble: 10 × 13\n   Identifiant Sexe_red CSP   Niveau       Date_naissance Date_entree Duree\n   &lt;chr&gt;       &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt;        &lt;chr&gt;          &lt;chr&gt;       &lt;chr&gt;\n 1 173         2        1     Qualifie     17/06/1998     01/01/2021  308  \n 2 173         2        1     qualifie     17/06/1998     01/01/2022  365  \n 3 173         2        1     qualifie     17/06/1998     06/01/2022  185  \n 4 173         2        1     Qualifie     17/06/1998     02/01/2023  365  \n 5 174         1        1     qualifie     08/12/1984     17/08/2021  183  \n 6 175         1        1     qualifie     16/09/1989     21/12/2022  730  \n 7 198         2        4     Non qualifie 17/03/1987     28/07/2022  30   \n 8 198         2        4     Qualifie     17/03/1987     17/11/2022  164  \n 9 198         2        4     Qualifie     17/03/1987     21/02/2023  365  \n10 168         1        2     Qualifie     30/07/2002     04/09/2019  365  \n# ℹ 6 more variables: Note_Contenu &lt;chr&gt;, Note_Formateur &lt;chr&gt;,\n#   Note_Moyens &lt;chr&gt;, Note_Accompagnement &lt;chr&gt;, Note_Materiel &lt;chr&gt;,\n#   poids_sondage &lt;chr&gt;\n\n\n\n\n\n\n\n5.2 Renommer les variables\n\nSASR basetidyversearrow/duckdb\n\n\n\n/* On renomme la variable sexe_red en sexe */\ndata Donnees_sas;\n  set Donnees_sas (rename = (sexe_red = sexe));\nrun;\n\n\n\n\n# On renomme la variable sexe_red en sexe\ndonnees_rbase$sexe &lt;- donnees_rbase$sexe_red\n\n#Attention, lorsqu'on utilise ce code pour renommer la variable, l'ancienne variable reste dans la base de données \n\n#Supprime sexe_red\ndonnees_rbase &lt;- donnees_rbase[, -which(names(donnees_rbase) %in% c(\"sexe_red\"))]\n\n\n\n\n# On renomme la variable sexe_red en sexe\n# La fonction rename() va écraser l'ancien nom de la variable contrairement au code utilisé dans la section R base\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  rename(sexe=sexe_red)\n\n\n\n\n# On renomme la variable sexe_red en sexe\n# La fonction rename() va écraser l'ancien nom de la variable contrairement au code utilisé dans la section R base\nrequete_duckdb %&gt;% rename(sexe=Sexe_red)\n\n# Source:   SQL [?? x 13]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1016-azure:R 4.2.0/:memory:]\n   Identifiant sexe  CSP   Niveau  Date_naissance Date_entree Duree Note_Contenu\n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;          &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;       \n 1 173         2     1     Qualif… 17/06/1998     01/01/2021  308   12          \n 2 173         2     1     qualif… 17/06/1998     01/01/2022  365   6           \n 3 173         2     1     qualif… 17/06/1998     06/01/2022  185   8           \n 4 173         2     1     Qualif… 17/06/1998     02/01/2023  365   14          \n 5 174         1     1     qualif… 08/12/1984     17/08/2021  183   17          \n 6 175         1     1     qualif… 16/09/1989     21/12/2022  730   5           \n 7 198         2     4     Non qu… 17/03/1987     28/07/2022  30    10          \n 8 198         2     4     Qualif… 17/03/1987     17/11/2022  164   11          \n 9 198         2     4     Qualif… 17/03/1987     21/02/2023  365   9           \n10 168         1     2     Qualif… 30/07/2002     04/09/2019  365   18          \n# ℹ more rows\n# ℹ 5 more variables: Note_Formateur &lt;chr&gt;, Note_Moyens &lt;chr&gt;,\n#   Note_Accompagnement &lt;chr&gt;, Note_Materiel &lt;chr&gt;, poids_sondage &lt;chr&gt;\n\n\n\n\n\n\n\n5.3 Nombre de lignes et de colonnes dans la base\n\nSASR basetidyversearrow/duckdb\n\n\n\n/* Nombre de lignes */\nproc sql;select count(*) as Nb_Lignes from Donnees_sas;quit;\n\n/* Nombre de colonnes */\nproc sql;select count(*) as Nb_Colonnes from Var;quit;\n\n\n\n\n# Nombre de lignes et de colonnes dans la base\nsprintf(\"Nombre de lignes : %d | Nombre de colonnes : %d\", dim(donnees_rbase)[1], dim(donnees_rbase)[2])\n\n[1] \"Nombre de lignes : 27 | Nombre de colonnes : 13\"\n\n\n\n\n\n#Nombre de lignes\ndonnees_tidyverse %&gt;% nrow()\n\n[1] 27\n\n#Nombre de colonnes\ndonnees_tidyverse %&gt;%  ncol()\n\n[1] 13\n\n\n\n\nDuckdb/SQL ne connaît pas le nombre de lignes sans un calcul. Il faut faire count().\n\n#Nombre de lignes\nrequete_duckdb %&gt;% nrow() # retourne NA\n\n[1] NA\n\nrequete_duckdb %&gt;% count() # retourne 27\n\n# Source:   SQL [1 x 1]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1016-azure:R 4.2.0/:memory:]\n      n\n  &lt;dbl&gt;\n1    27\n\n#Nombre de colonnes\nrequete_duckdb %&gt;%  ncol()\n\n[1] 13\n\n\n\n\n\n\n\n5.4 Afficher les noms des variables de la base\n\nSASR basetidyversearrow/duckdb\n\n\n\nproc contents data=donnees_sas; run;\n\n\n\n\nls(donnees_rbase)\n\n\n\n\ndonnees_tidyverse %&gt;% colnames()\n\n\n\n\nrequete_duckdb %&gt;% colnames()\n\n [1] \"Identifiant\"         \"Sexe_red\"            \"CSP\"                \n [4] \"Niveau\"              \"Date_naissance\"      \"Date_entree\"        \n [7] \"Duree\"               \"Note_Contenu\"        \"Note_Formateur\"     \n[10] \"Note_Moyens\"         \"Note_Accompagnement\" \"Note_Materiel\"      \n[13] \"poids_sondage\"      \n\n\n\n\n\n\n\n5.5 Création de colonnes et de lignes\n\nSASR basetidyversearrow/duckdb\n\n\n\ndata Donnees_sas;\n  set Donnees_sas;\n  note2 = note_contenu / 20 * 5;\n  Age = intck('year', date_naissance, date_entree);\nrun;\n\n\n\n\n# Création de la colonne note2\ndonnees_rbase$note2 &lt;- donnees_rbase$note_contenu / 20 * 5\n\n\n# Création de la colonne age \ndonnees_rbase$age &lt;- floor(lubridate::time_length(difftime(donnees_rbase$date_entree, donnees_rbase$date_naissance), \"years\"))\n\n\n\n\n# Création de la colonne note2\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(note2= note_contenu / 20 * 5)\n\n\n# Création de la colonne age \ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n   mutate(age=as.period(interval(start = date_naissance, end = date_entree))$year)\n\n\n\n\n# Création de la colonne note2\nrequete_duckdb %&gt;% \n  mutate(note2 = as.integer(Note_Contenu) / 20 * 5) %&gt;% \n  select(note2)\n\n# Source:   SQL [?? x 1]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1016-azure:R 4.2.0/:memory:]\n   note2\n   &lt;dbl&gt;\n 1  3   \n 2  1.5 \n 3  2   \n 4  3.5 \n 5  4.25\n 6  1.25\n 7  2.5 \n 8  2.75\n 9  2.25\n10  4.5 \n# ℹ more rows\n\n\n\n# Création de la colonne age \nrequete_duckdb %&gt;% \n  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %&gt;% # strptime est une fonction duckdb\n  mutate(age = year(age(Date_entree,Date_naissance))) %&gt;% \n  select(age)\n\n# Source:   SQL [?? x 1]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1016-azure:R 4.2.0/:memory:]\n     age\n   &lt;dbl&gt;\n 1    22\n 2    23\n 3    23\n 4    24\n 5    36\n 6    33\n 7    35\n 8    35\n 9    35\n10    17\n# ℹ more rows\n\n\n\n\n\n\n\n5.6 Supression de colonnes et de lignes\nSuppression de lignes à faire\n\nSASR basetidyversearrow/duckdb\n\n\n\ndata Donnees_sas;\n  set Donnees_sas;\n  drop note2;\nrun;\n\n\n\n\ndonnees_rbase$note2 &lt;- NULL\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  select(-note2)\n\n\n\n\nrequete_duckdb %&gt;% select(- CSP, -contains(\"Date\"), -starts_with(\"Note\"))\n\n# Source:   SQL [?? x 5]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1016-azure:R 4.2.0/:memory:]\n   Identifiant Sexe_red Niveau       Duree poids_sondage\n   &lt;chr&gt;       &lt;chr&gt;    &lt;chr&gt;        &lt;chr&gt; &lt;chr&gt;        \n 1 173         2        Qualifie     308   117.1        \n 2 173         2        qualifie     365   98.3         \n 3 173         2        qualifie     185   214.6        \n 4 173         2        Qualifie     365   84.7         \n 5 174         1        qualifie     183   65.9         \n 6 175         1        qualifie     730   148.2        \n 7 198         2        Non qualifie 30    89.6         \n 8 198         2        Qualifie     164   100.3        \n 9 198         2        Qualifie     365   49.3         \n10 168         1        Qualifie     365   148.2        \n# ℹ more rows",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#formater-les-modalités-des-valeurs",
    "href": "01-aide_memoire_r_sas.html#formater-les-modalités-des-valeurs",
    "title": "Aide-mémoire SAS - R",
    "section": "6 Formater les modalités des valeurs",
    "text": "6 Formater les modalités des valeurs\n\n6.1 Valeur discrète\n\nSASR basetidyversearrow/duckdb\n\n\n\nproc format;\n  value sexef\n  1 = \"Homme\"\n  2 = \"Femme\";\n  \n  value $ cspf\n  '1' = \"Cadre\"\n  '2' = \"Profession intermédiaire\"\n  '3' = \"Employé\"\n  '4' = \"Ouvrier\"\n  '5' = \"Retraité\";\nrun;\n\n\n\n\nsexef &lt;- c(\"1\" = \"Homme\", \"2\" = \"Femme\")\ncspf &lt;- c(\"1\" = \"Cadre\", \"2\" = \"Profession intermédiaire\", \"3\" = \"Employé\", \"4\" = \"Ouvrier\", \"5\" = \"Retraité\")\n\n\n# On exprime CSP et sexe en formaté\ndonnees_rbase$cspf &lt;- cspf[donnees_rbase$csp]\ndonnees_rbase$sexef &lt;- sexef[donnees_rbase$sexe]\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(sexef = case_when(\n    sexe==\"1\" ~ \"Homme\",\n    sexe==\"2\" ~ \"Femme\",\n    TRUE ~ sexe),\n         cspf = case_when(\n    csp==\"1\" ~ \"Cadre\",\n    csp==\"2\" ~ \"Profession intermédiaire\",\n    csp==\"3\" ~ \"Employé\",\n    csp==\"4\" ~ \"Ouvrier\",\n    csp==\"5\" ~ \"Retraité\",\n    TRUE ~ csp))\n\n\n\nPréférer case_match quand il s’agit de valeurs déterminées.\n\nrequete_duckdb %&gt;% \n  mutate(sexef = case_when(\n    Sexe_red==\"1\" ~ \"Homme\",\n    Sexe_red==\"2\" ~ \"Femme\",\n    .default = Sexe_red),\n         cspf = case_match(CSP,\n    \"1\" ~ \"Cadre\",\n    \"2\" ~ \"Profession intermédiaire\",\n    \"3\" ~ \"Employé\",\n    \"4\" ~ \"Ouvrier\",\n    \"5\" ~ \"Retraité\",\n    .default = CSP)) %&gt;% \n  select(Sexe_red, sexef, CSP, cspf)\n\n# Source:   SQL [?? x 4]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1016-azure:R 4.2.0/:memory:]\n   Sexe_red sexef CSP   cspf                    \n   &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;                   \n 1 2        Femme 1     Cadre                   \n 2 2        Femme 1     Cadre                   \n 3 2        Femme 1     Cadre                   \n 4 2        Femme 1     Cadre                   \n 5 1        Homme 1     Cadre                   \n 6 1        Homme 1     Cadre                   \n 7 2        Femme 4     Ouvrier                 \n 8 2        Femme 4     Ouvrier                 \n 9 2        Femme 4     Ouvrier                 \n10 1        Homme 2     Profession intermédiaire\n# ℹ more rows\n\n\n\n\n\n\n\n6.2 Valeur continue\n\nSASR basetidyversearrow/duckdb\n\n\n\nproc format;\n  value agef\n  low-&lt;26 = \"1. De 15 à 25 ans\"\n  26&lt;-&lt;50 = \"2. De 26 à 49 ans\"\n  50-high = \"3. 50 ans ou plus\";\nrun;\n\n\n\n\ndonnees_rbase$agef[donnees_rbase$age &lt; 26] &lt;- \"1. De 15 à 25 ans\"\n# 26 &lt;= donnees_rbase$age &lt; 50 ne fonctionne pas, il faut passer en 2 étapes*\n\ndonnees_rbase$agef[26 &lt;= donnees_rbase$age & donnees_rbase$age &lt; 50] &lt;- \"2. De 26 à 49 ans\"\n\ndonnees_rbase$agef[donnees_rbase$age &gt;= 50] &lt;- \"3. 50 ans ou plus\"\n\n\n# Autre solution\nagef &lt;- cut(donnees_rbase$age, \n            breaks = c(0, 25, 49, Inf),\n            right = TRUE,\n            labels = c(\"1. De 15 à 25 ans\", \"2. De 26 à 49 ans\", \"3. 50 ans ou plus\"), \n            ordered_result = TRUE)\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  mutate(agef = case_when(\n    age &lt; 26 ~ \"1. De 15 à 25 ans\",\n    age &gt;= 26 | age &lt; 50 ~  \"2. De 26 à 49 ans\",\n    age &gt;= 50 ~ \"3. 50 ans ou plus\"))\n\n\n\n\nrequete_duckdb %&gt;%\n  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %&gt;% # strptime est une fonction duckdb\n  mutate(age = year(age(Date_entree,Date_naissance))) %&gt;% \n  mutate(agef = case_when(\n    age &lt; 26 ~ \"1. De 15 à 25 ans\",\n    age &gt;= 26 | age &lt; 50 ~  \"2. De 26 à 49 ans\",\n    age &gt;= 50 ~ \"3. 50 ans ou plus\")) %&gt;% \n  select(age, agef)\n\n# Source:   SQL [?? x 2]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1016-azure:R 4.2.0/:memory:]\n     age agef             \n   &lt;dbl&gt; &lt;chr&gt;            \n 1    22 1. De 15 à 25 ans\n 2    23 1. De 15 à 25 ans\n 3    23 1. De 15 à 25 ans\n 4    24 1. De 15 à 25 ans\n 5    36 2. De 26 à 49 ans\n 6    33 2. De 26 à 49 ans\n 7    35 2. De 26 à 49 ans\n 8    35 2. De 26 à 49 ans\n 9    35 2. De 26 à 49 ans\n10    17 1. De 15 à 25 ans\n# ℹ more rows",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#manipuler-des-lignes-et-des-colonnes",
    "href": "01-aide_memoire_r_sas.html#manipuler-des-lignes-et-des-colonnes",
    "title": "Aide-mémoire SAS - R",
    "section": "7 Manipuler des lignes et des colonnes",
    "text": "7 Manipuler des lignes et des colonnes\nA rajouter : la selection basée sur des conditions\n\n7.1 Sélection de colonnes\n\nSASR basetidyversearrow/duckdb\n\n\n\nproc sql;\n  create table work.donnees_col_select_sas as\n  select    identifiant, csp, niveau\n  from work.donnees_sas;\nquit; \n\n\n\n\ndonnees_col_select_rbase &lt;- donnees_rbase[, c(\"identifiant\", \"csp\", \"niveau\")]\n\n\n\n\ndonnees_col_select_tidyverse &lt;- donnees_tidyverse %&gt;% \n  select(identifiant, csp, niveau)\n\n\n\n\nrequete_duckdb %&gt;% select(Identifiant, CSP, starts_with(\"NI\"))\n\n# Source:   SQL [?? x 3]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1016-azure:R 4.2.0/:memory:]\n   Identifiant CSP   Niveau      \n   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;       \n 1 173         1     Qualifie    \n 2 173         1     qualifie    \n 3 173         1     qualifie    \n 4 173         1     Qualifie    \n 5 174         1     qualifie    \n 6 175         1     qualifie    \n 7 198         4     Non qualifie\n 8 198         4     Qualifie    \n 9 198         4     Qualifie    \n10 168         2     Qualifie    \n# ℹ more rows\n\n\n\n\n\n\n\n7.2 Selection de lignes\n\nSASR basetidyversearrow/duckdb\n\n\n\ndata donnees_sas; \n  set donnees_sas; \n  where sexef=\"Femme\";\n run;\n\n\n\n\ndonnees_femme_rbase &lt;- donnees_rbase[donnees_rbase$sexef==\"Femme\", ]\n\n\n\n\ndonnees_femme_tidyverse &lt;- donnees_tidyverse %&gt;% \n  filter(sexef==\"Femme\")\n\n\n\n\nrequete_duckdb %&gt;% filter(Sexe_red==2)\n\n# Source:   SQL [?? x 13]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1016-azure:R 4.2.0/:memory:]\n   Identifiant Sexe_red CSP   Niveau       Date_naissance Date_entree Duree\n   &lt;chr&gt;       &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt;        &lt;chr&gt;          &lt;chr&gt;       &lt;chr&gt;\n 1 173         2        1     Qualifie     17/06/1998     01/01/2021  308  \n 2 173         2        1     qualifie     17/06/1998     01/01/2022  365  \n 3 173         2        1     qualifie     17/06/1998     06/01/2022  185  \n 4 173         2        1     Qualifie     17/06/1998     02/01/2023  365  \n 5 198         2        4     Non qualifie 17/03/1987     28/07/2022  30   \n 6 198         2        4     Qualifie     17/03/1987     17/11/2022  164  \n 7 198         2        4     Qualifie     17/03/1987     21/02/2023  365  \n 8 211         2        3     Non qualifie &lt;NA&gt;           17/12/2021  135  \n 9 347         2        5     Qualifie     13/09/1955     &lt;NA&gt;        180  \n10 187         2        2     qualifie     05/12/1986     01/01/2022  364  \n# ℹ more rows\n# ℹ 6 more variables: Note_Contenu &lt;chr&gt;, Note_Formateur &lt;chr&gt;,\n#   Note_Moyens &lt;chr&gt;, Note_Accompagnement &lt;chr&gt;, Note_Materiel &lt;chr&gt;,\n#   poids_sondage &lt;chr&gt;",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#manipuler-des-lignes-et-des-colonnes-1",
    "href": "01-aide_memoire_r_sas.html#manipuler-des-lignes-et-des-colonnes-1",
    "title": "Aide-mémoire SAS - R",
    "section": "8 Manipuler des lignes et des colonnes",
    "text": "8 Manipuler des lignes et des colonnes\n\n8.1 Mettre un 0 devant un nombre\n\nCréer la variable mois\nMettre un 0 devant si le mois est inférieur à 9\n\n\nSASR basetidyversearrow/duckdb\n\n\n\n/* Mettre un 0 devant un nombre */\ndata Zero_devant;set Donnees_sas (keep = date_entree);\n  /* Obtenir le mois et la date */\n  Mois = month(date_entree);\n  /* Mettre le mois sur 2 positions (avec un 0 devant si le mois &lt;= 9) : format prédéfini z2. */\n  Mois_a = put(Mois, z2.);\n  drop Mois;\n  rename Mois_a = Mois;\nrun;\n\n\n\n\n# Obtenir le mois et la date\ndonnees_rbase$mois &lt;- lubridate::month(donnees_rbase$date_entree)\n\n\n# Mettre le numéro du mois sur 2 positions (avec un 0 devant si le mois &lt;= 9)\ndonnees_rbase$mois &lt;- sprintf(\"%02d\", donnees_rbase$mois)\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(mois=lubridate::month(date_entree),\n         mois=ifelse(str_length(mois)&lt;2, paste0(\"0\", mois), mois))\n\n\n\n\nrequete_duckdb %&gt;% \n  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %&gt;% # strptime est une fonction duckdb\n  mutate(mois=lubridate::month(Date_entree),\n         mois=ifelse(str_length(mois)&lt;2, paste0(\"0\", mois), mois)) %&gt;% \n  select(mois, Date_entree)\n\n# Source:   SQL [?? x 2]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1016-azure:R 4.2.0/:memory:]\n   mois  Date_entree\n   &lt;chr&gt; &lt;date&gt;     \n 1 01    2021-01-01 \n 2 01    2022-01-01 \n 3 01    2022-01-06 \n 4 01    2023-01-02 \n 5 08    2021-08-17 \n 6 12    2022-12-21 \n 7 07    2022-07-28 \n 8 11    2022-11-17 \n 9 02    2023-02-21 \n10 09    2019-09-04 \n# ℹ more rows\n\n\n\n\n\n\n\n8.2 Réexprimer en masse des valeurs\nOn souhaite rééxprimer les notes sur 100 et non sur 20\n\nSASR basetidyversearrow/duckdb\n\n\n\n%let notes = Note_Contenu   Note_Formateur Note_Moyens     Note_Accompagnement     Note_Materiel;\n/* On supprime les doubles blancs entre les variables */\n%let notes = %sysfunc(compbl(&notes.));\n%put &notes;Mois_a = Mois;\n\n\n/* 1ère solution : avec les array */\ndata Sur100_1;\n  set Donnees_sas;\n  array variables (*) &notes.;\n  do increment = 1 to dim(variables);\n    variables[increment] = variables[increment] / 20 * 100;\n  end; \n  drop increment;\nrun; \n\n\n/* 2e solution : avec une macro */\ndata Sur100_2;\n  set Donnees;\n  %macro Sur100;\n    %do i = 1 %to %sysfunc(countw(&notes.));\n      %let note = %scan(&notes., &i.);\n      &note. = &note. / 20 * 100;\n    %end;\n  %mend Sur100;\n  %Sur5;\nrun;\n\n\n/* 3e solution : l'équivalent des list-comprehension de Python en SAS */\ndata Sur100_3;\n  set Donnees_sas;\n  %macro List_comprehension;\n     %do i = 1 %to %sysfunc(countw(&notes.));\n       %let j = %scan(&notes., &i.);\n       &j. = &j. / 20 * 100\n     %end;);;\n  %mend List_comprehension;\n  %List_comprehension;\nrun;\n\n\n\n\nnotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\ndonnees_rbase[, notes] &lt;- donnees_rbase[, notes] / 20 * 100\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(across(starts_with(\"note\"), ~ .x/20*100))\n\n\n\n\nrequete_duckdb %&gt;% \n  mutate(across(starts_with(\"Note\"), ~ as.numeric(.x)/20*100)) %&gt;% \n  select(starts_with(\"Note\"))\n\n# Source:   SQL [?? x 5]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1016-azure:R 4.2.0/:memory:]\n   Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel\n          &lt;dbl&gt;          &lt;dbl&gt;       &lt;dbl&gt;               &lt;dbl&gt;         &lt;dbl&gt;\n 1           60             30          85                  20            95\n 2           30             NA          60                  35            70\n 3           40             50          55                   5            45\n 4           70             75          75                  50            40\n 5           85             90         100                  75            60\n 6           25             25          40                  20            45\n 7           50             50          50                  80            40\n 8           55             35          30                  70            65\n 9           45            100          15                  20            85\n10           90             55         100                  65            75\n# ℹ more rows\n\n\n\n\n\n\n\n8.3 Arrondir une valeur numérique\n\nSASRtidyversearrow/duckdb\n\n\n\n/* Arrondir une valeur numérique */\ndata Arrondis;set donnees_sas (keep = poids_sondage);\n  /* Arrondi à l'entier le plus proche */\n  poids_arrondi_0 = round(poids_sondage, 0.0);\n  /* Arrondi à 1 chiffre après la virgule */\n  poids_arrondi_1 = round(poids_sondage, 0.1);\n  /* Arrondi à 2 chiffre après la virgule */\n  poids_arrondi_2 = round(poids_sondage, 0.2);\n  /* Arrondi à l'entier inférieur */\n  poids_inf = floor(poids_sondage);\n  /* Arrondi à l'entier supérieur */\n  poids_inf = ceil(poids_sondage);  \nrun;\n\n\n\n\n# Arrondi à l'entier le plus proche\npoids_arrondi_0 &lt;- round(donnees_rbase$poids, 0)\n# Arrondi à 1 chiffre après la virgule\npoids_arrondi_1 &lt;- round(donnees_rbase$poids, 1)\n# Arrondi à 2 chiffre après la virgule\npoids_arrondi_2 &lt;- round(donnees_rbase$poids, 2)\n# Arrondi à l'entier inférieur\npoids_inf &lt;- floor(donnees_rbase$poids)\n# Arrondi à l'entier inférieur\npoids_inf &lt;- ceiling(donnees_rbase$poids)\n\n\n\n\ndonnees_tidyverse %&gt;% \n  mutate(\n    poids_arrondi_0 = round(poids_sondage,0), # Arrondi à l'entier le plus proche\n    poids_arrondi_1 = round(poids_sondage,1), # Arrondi à 1 chiffre après la virgule\n    poids_arrondi_2 = round(poids_sondage,2), # Arrondi à 2 chiffre après la virgule\n    poids_floor = floor(poids_sondage), # Arrondi à l'entier inférieur\n    poids_ceiling = ceiling(poids_sondage), # Arrondi à l'entier inférieur\n    ) %&gt;% \n  select(starts_with(\"poids\"))\n\n   poids_sondage poids_arrondi_0 poids_arrondi_1 poids_arrondi_2 poids_floor\n2          117.1             117           117.1           117.1         117\n3           98.3              98            98.3            98.3          98\n4          214.6             215           214.6           214.6         214\n5           84.7              85            84.7            84.7          84\n6           65.9              66            65.9            65.9          65\n7          148.2             148           148.2           148.2         148\n8           89.6              90            89.6            89.6          89\n9          100.3             100           100.3           100.3         100\n10          49.3              49            49.3            49.3          49\n11         148.2             148           148.2           148.2         148\n12          86.4              86            86.4            86.4          86\n13          99.2              99            99.2            99.2          99\n14         105.6             106           105.6           105.6         105\n15         123.1             123           123.1           123.1         123\n16         137.4             137           137.4           137.4         137\n17         187.6             188           187.6           187.6         187\n18          87.3              87            87.3            87.3          87\n19          87.3              87            87.3            87.3          87\n20         169.3             169           169.3           169.3         169\n21         169.3             169           169.3           169.3         169\n22         169.3             169           169.3           169.3         169\n23         169.3             169           169.3           169.3         169\n24         234.1             234           234.1           234.1         234\n25         189.3             189           189.3           189.3         189\n26          45.9              46            45.9            45.9          45\n27          45.9              46            45.9            45.9          45\n28          45.9              46            45.9            45.9          45\n   poids_ceiling\n2            118\n3             99\n4            215\n5             85\n6             66\n7            149\n8             90\n9            101\n10            50\n11           149\n12            87\n13           100\n14           106\n15           124\n16           138\n17           188\n18            88\n19            88\n20           170\n21           170\n22           170\n23           170\n24           235\n25           190\n26            46\n27            46\n28            46\n\n\n\n\n\nrequete_duckdb %&gt;% \n  mutate( # la fonction round de duckdb ne prend pas l'argument digits, mais la traduction fonctionne\n    poids_arrondi_0 = round(as.numeric(poids_sondage),0),\n    poids_arrondi_1 = round(as.numeric(poids_sondage),1),\n    poids_arrondi_2 = round(as.numeric(poids_sondage),-1),\n    poids_floor = floor(as.numeric(poids_sondage)),\n    poids_ceiling = ceiling(as.numeric(poids_sondage)),\n    ) %&gt;% \n  select(starts_with(\"poids\"))\n\n# Source:   SQL [?? x 6]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1016-azure:R 4.2.0/:memory:]\n   poids_sondage poids_arrondi_0 poids_arrondi_1 poids_arrondi_2 poids_floor\n   &lt;chr&gt;                   &lt;dbl&gt;           &lt;dbl&gt;           &lt;dbl&gt;       &lt;dbl&gt;\n 1 117.1                     117           117.              120         117\n 2 98.3                       98            98.3             100          98\n 3 214.6                     215           215.              210         214\n 4 84.7                       85            84.7              80          84\n 5 65.9                       66            65.9              70          65\n 6 148.2                     148           148.              150         148\n 7 89.6                       90            89.6              90          89\n 8 100.3                     100           100.              100         100\n 9 49.3                       49            49.3              50          49\n10 148.2                     148           148.              150         148\n# ℹ more rows\n# ℹ 1 more variable: poids_ceiling &lt;dbl&gt;",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#les-tris",
    "href": "01-aide_memoire_r_sas.html#les-tris",
    "title": "Aide-mémoire SAS - R",
    "section": "9 Les tris",
    "text": "9 Les tris\n\n9.1 Trier par colonne\n\nSASR basetidyversearrow/duckdb\n\n\n\n/* On met identifiant date_entree et date_sortie au début de la base */\n%let colTri = identifiant date_entree;\ndata Donnees_sas;\n  retain &colTri.;\n  set Donnees_sas;\nrun;\n\n\n/* Autre solution */\nproc sql;\n  create table Donnees_sas as \n  /* On remplace les blancs entre les mots par des virgules pour la proc SQL */\n  /* Dans la proc SQL, les variables doivent être séparées par des virgules */\n  select %sysfunc(tranwrd(&colTri., %str( ), %str(, ))), * from Donnees_sas;\nquit;\n\n\n\n\n# On met identifiant date_entree et date_sortie au début\ncolTri &lt;- c(\"identifiant\", \"date_entree\")\ndonnees_rbase[, c(colTri, colnames(donnees_rbase)[! colnames(donnees_rbase) %in% colTri])]\n\n\n\n\n# On met identifiant date_entree au début\ndonnees_tidyverse %&gt;% \n  select(identifiant, date_entree, everything())\ndonnees_tidyverse %&gt;% \n  relocate(identifiant, date_entree)\n\n\n\n\n# On met identifiant date_entree au début\nrequete_duckdb %&gt;% \n  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %&gt;% # strptime est une fonction duckdb\n  select(Identifiant, Date_entree, everything())\n\n# Source:   SQL [?? x 13]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1016-azure:R 4.2.0/:memory:]\n   Identifiant Date_entree Sexe_red CSP   Niveau       Date_naissance Duree\n   &lt;chr&gt;       &lt;date&gt;      &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt;        &lt;date&gt;         &lt;chr&gt;\n 1 173         2021-01-01  2        1     Qualifie     1998-06-17     308  \n 2 173         2022-01-01  2        1     qualifie     1998-06-17     365  \n 3 173         2022-01-06  2        1     qualifie     1998-06-17     185  \n 4 173         2023-01-02  2        1     Qualifie     1998-06-17     365  \n 5 174         2021-08-17  1        1     qualifie     1984-12-08     183  \n 6 175         2022-12-21  1        1     qualifie     1989-09-16     730  \n 7 198         2022-07-28  2        4     Non qualifie 1987-03-17     30   \n 8 198         2022-11-17  2        4     Qualifie     1987-03-17     164  \n 9 198         2023-02-21  2        4     Qualifie     1987-03-17     365  \n10 168         2019-09-04  1        2     Qualifie     2002-07-30     365  \n# ℹ more rows\n# ℹ 6 more variables: Note_Contenu &lt;chr&gt;, Note_Formateur &lt;chr&gt;,\n#   Note_Moyens &lt;chr&gt;, Note_Accompagnement &lt;chr&gt;, Note_Materiel &lt;chr&gt;,\n#   poids_sondage &lt;chr&gt;\n\nrequete_duckdb %&gt;% \n  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %&gt;% # strptime est une fonction duckdb\n  relocate(Identifiant, Date_entree)\n\n# Source:   SQL [?? x 13]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1016-azure:R 4.2.0/:memory:]\n   Identifiant Date_entree Sexe_red CSP   Niveau       Date_naissance Duree\n   &lt;chr&gt;       &lt;date&gt;      &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt;        &lt;date&gt;         &lt;chr&gt;\n 1 173         2021-01-01  2        1     Qualifie     1998-06-17     308  \n 2 173         2022-01-01  2        1     qualifie     1998-06-17     365  \n 3 173         2022-01-06  2        1     qualifie     1998-06-17     185  \n 4 173         2023-01-02  2        1     Qualifie     1998-06-17     365  \n 5 174         2021-08-17  1        1     qualifie     1984-12-08     183  \n 6 175         2022-12-21  1        1     qualifie     1989-09-16     730  \n 7 198         2022-07-28  2        4     Non qualifie 1987-03-17     30   \n 8 198         2022-11-17  2        4     Qualifie     1987-03-17     164  \n 9 198         2023-02-21  2        4     Qualifie     1987-03-17     365  \n10 168         2019-09-04  1        2     Qualifie     2002-07-30     365  \n# ℹ more rows\n# ℹ 6 more variables: Note_Contenu &lt;chr&gt;, Note_Formateur &lt;chr&gt;,\n#   Note_Moyens &lt;chr&gt;, Note_Accompagnement &lt;chr&gt;, Note_Materiel &lt;chr&gt;,\n#   poids_sondage &lt;chr&gt;\n\n\n\n\n\n\n\n9.2 Trier les lignes par ordre croissant ou décroissant\n\nSASR basetidyversearrow/duckdb\n\n\n\n/* Trier la base par ligne (individu et date de début de la formation) par ordre décroissant : 2 possibilités */\nproc sort data = Donnees_sas;by Identifiant Date_entree;run;\nproc sql;create table Donnes as select * from Donnees_sas order by Identifiant, Date_entree;quit;\n\n\n/* Idem par ordre croissant d'identifiant et ordre décroissant de date d'entrée*/\nproc sort data = Donnees_sas;by Identifiant Date_entree descending;run;\nproc sql;create table Donnes as select * from Donnees_sas order by Identifiant, desc Date_entree;quit;\n\n\n\n\n# Trier la base par ligne (individu et date de début de la formation) par ordre croissant\n# L'option na.last = FALSE (resp. TRUE) indique que les valeurs manquantes doivent figurer à la fin (resp. au début) du tri, que le tri\n# soit croissant ou décroissant\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]\n\n# Tri par ordre croissant de identifiant et décroissant de date_entree (- avant le nom de la variable)\n\n#donnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, -donnees_rbase$date_entree, na.last = FALSE), ]\n\n\n\n\n# Trier la base par ligne (individu et date de début de la formation) par ordre croissant\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  arrange(identifiant, date_entree)\n\n\n# Tri par ordre croissant de identifiant et décroissant de date_entree \ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  arrange(identifiant, desc(date_entree))\n\n\n\n\n# Trier la base par ligne (individu et date de début de la formation) par ordre croissant\nrequete_duckdb %&gt;% \n  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %&gt;% # strptime est une fonction duckdb\n  arrange(Identifiant, Date_entree) %&gt;% select(Identifiant, Date_entree, Note_Contenu)\n\n# Source:     SQL [?? x 3]\n# Database:   DuckDB v0.9.2 [unknown@Linux 6.5.0-1016-azure:R 4.2.0/:memory:]\n# Ordered by: Identifiant, Date_entree\n   Identifiant Date_entree Note_Contenu\n   &lt;chr&gt;       &lt;date&gt;      &lt;chr&gt;       \n 1 087         2020-10-31  &lt;NA&gt;        \n 2 087         NA          &lt;NA&gt;        \n 3 099         2021-03-01  12          \n 4 099         2022-03-01  12          \n 5 099         2023-03-01  12          \n 6 112         2021-03-01  7           \n 7 112         2022-03-02  3           \n 8 112         2023-12-01  &lt;NA&gt;        \n 9 168         2019-09-04  18          \n10 173         2021-01-01  12          \n# ℹ more rows\n\n# Tri par ordre croissant de identifiant et décroissant de date_entree \nrequete_duckdb %&gt;% \n  mutate_at(enDate, ~ as.Date(strptime(.,'%d/%m/%Y'))) %&gt;% # strptime est une fonction duckdb\n  arrange(Identifiant, desc(Date_entree)) %&gt;% select(Identifiant, Date_entree, Note_Contenu)\n\n# Source:     SQL [?? x 3]\n# Database:   DuckDB v0.9.2 [unknown@Linux 6.5.0-1016-azure:R 4.2.0/:memory:]\n# Ordered by: Identifiant, desc(Date_entree)\n   Identifiant Date_entree Note_Contenu\n   &lt;chr&gt;       &lt;date&gt;      &lt;chr&gt;       \n 1 087         2020-10-31  &lt;NA&gt;        \n 2 087         NA          &lt;NA&gt;        \n 3 099         2023-03-01  12          \n 4 099         2022-03-01  12          \n 5 099         2021-03-01  12          \n 6 112         2023-12-01  &lt;NA&gt;        \n 7 112         2022-03-02  3           \n 8 112         2021-03-01  7           \n 9 168         2019-09-04  18          \n10 173         2023-01-02  14          \n# ℹ more rows\n\n\n\n\n\n\n\n9.3 Incidence des valeurs manquantes dans les tris, différence entre SAS et R\n\nSASR basetidyversearrow/duckdb\n\n\n\nproc sort data = Donnees_sas;by identifiant date_entree;run;\nproc print;run;\n\n\n/* ... et en dernier selon un tri par ordre décroissant*/\nproc sort data = Donnees_sas;\n  by identifiant descending date_entree;\nrun;\nproc print;run;\n\nEn effet, les valeurs manquantes sont considérées comme des valeurs négatives\n\n\n\n# Les valeurs manquantes sont situées en dernier dans un tri par ordre croissant ou décroissant (car par défaut l'option na.last = TRUE) ...\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree), ]\n\n# Pour mimer le tri SAS, il faut écrire :\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]\n\n\n\n\n# Les valeurs manquantes sont situées en dernier dans un tri par ordre croissant ou décroissant (car par défaut l'option na.last = TRUE) ...\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  arrange(identifiant, date_entree)\n\n# Pour mimer le tri SAS, il faut écrire :\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  arrange(identifiant, !is.na(date_entree), date_entree)\n\n\n\n\n# Les valeurs manquantes sont situées en dernier dans un tri par ordre croissant ou décroissant (car par défaut l'option na.last = TRUE) ...\nrequete_duckdb %&gt;% arrange(Identifiant, Note_Contenu) %&gt;% select(Identifiant, Note_Contenu)\n\n# Source:     SQL [?? x 2]\n# Database:   DuckDB v0.9.2 [unknown@Linux 6.5.0-1016-azure:R 4.2.0/:memory:]\n# Ordered by: Identifiant, Note_Contenu\n   Identifiant Note_Contenu\n   &lt;chr&gt;       &lt;chr&gt;       \n 1 087         &lt;NA&gt;        \n 2 087         &lt;NA&gt;        \n 3 099         12          \n 4 099         12          \n 5 099         12          \n 6 112         3           \n 7 112         7           \n 8 112         &lt;NA&gt;        \n 9 168         18          \n10 173         12          \n# ℹ more rows\n\n# Pour mimer le tri SAS, il faut écrire :\n# Note : il faut faire select d'abord, sinon il y a une erreur quand \"! is.na()\" est dans la liste des colonnes\nrequete_duckdb %&gt;% select(Identifiant, Note_Contenu) %&gt;% arrange(Identifiant, ! is.na(Note_Contenu), Note_Contenu) \n\n# Source:     SQL [?? x 2]\n# Database:   DuckDB v0.9.2 [unknown@Linux 6.5.0-1016-azure:R 4.2.0/:memory:]\n# Ordered by: Identifiant, !is.na(Note_Contenu), Note_Contenu\n   Identifiant Note_Contenu\n   &lt;chr&gt;       &lt;chr&gt;       \n 1 087         &lt;NA&gt;        \n 2 087         &lt;NA&gt;        \n 3 099         12          \n 4 099         12          \n 5 099         12          \n 6 112         &lt;NA&gt;        \n 7 112         3           \n 8 112         7           \n 9 168         18          \n10 173         12          \n# ℹ more rows",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#manipuler-des-dates",
    "href": "01-aide_memoire_r_sas.html#manipuler-des-dates",
    "title": "Aide-mémoire SAS - R",
    "section": "10 Manipuler des dates",
    "text": "10 Manipuler des dates\n\n10.1 Créer une date\n\nSASR basetidyverse\n\n\n\ndata Donnees;\n  set Donnees;\n  /* Date de sortie du dispositif : ajout de la durée à la date d'entrée */\n  format date_sortie ddmmyy10.;\n  date_sortie = intnx('day', date_entree, duree);\nrun;\n\n\n\n\n# Date de sortie du dispositif\ndonnees_rbase$date_sortie &lt;- donnees_rbase$date_entree + lubridate::days(donnees_rbase$duree)\n\n\n\n\n# Date de sortie du dispositif\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(date_sortie = date_entree + lubridate::days(duree))\n\n\n\n\n\n\n10.2 Calculer des durées\n\nSASR basetidyverse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n10.3 Ajouter une durée à une date\n\nSASR basetidyverse",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#manipuler-des-chaînes-de-caractères",
    "href": "01-aide_memoire_r_sas.html#manipuler-des-chaînes-de-caractères",
    "title": "Aide-mémoire SAS - R",
    "section": "11 Manipuler des chaînes de caractères",
    "text": "11 Manipuler des chaînes de caractères\n\n11.1 Majuscule, minuscule\n\nSASR basetidyverse\n\n\n\n/*Première lettre en majuscule*/\ndata Donnees_sas;\n  set Donnees_sas;\n  Niveau = propcase(Niveau);\nrun;\n\n\n/*Majuscule*/\ndata Donnees_sas;\n  set Donnees_sas;\n  CSP_majuscule = upcase(CSPF);\nrun;\n\n\n/*Minuscule*/\ndata Donnees_sas;\n  set Donnees_sas;\n  CSP_minuscule = lowcase(CSPF);\nrun;\n\n\n\n\nPremière lettre en majuscule\n\n\ndonnees_rbase$niveau &lt;- paste0(toupper(substr(donnees_rbase$niveau, 1, 1)), tolower(substr(donnees_rbase$niveau, 2, length(donnees_rbase$niveau))))\n\n\nMajuscule\n\n\ndonnees_rbase$csp_maj &lt;- toupper(donnees_rbase$cspf)\n\n\nMinuscule\n\n\ndonnees_rbase$csp_maj &lt;- tolower(donnees_rbase$cspf)\n\n\n\n\nPremière lettre en majuscule\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%  \n  mutate(niveau=str_to_title(niveau))\n\n\nMajuscule\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(csp_maj=toupper(cspf))\n\n\nMinuscule\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(csp_maj=tolower(cspf))\n\n\n\n\n\n\n11.2 Remplacer une chaîne de catactère par une autre\n\nSASR base\n\n\n\n/*Minuscule*/\ndata Donnees_sas;\n  set Donnees_sas;\n  Niveau = tranwrd(Niveau, \"Qualifie\", \"Qualifié\");\nrun;\n\n\n\n\n# Le mot qualifie n'a pas d'accent : on le corrige\ndonnees_rbase$niveau &lt;- gsub(\"Qualifie\", \"Qualifié\", donnees_rbase$niveau)\n\n\n\n\n\n\n11.3 Supprimer des blancs\n\nSASR basetidyverse\n\n\n\n/* Manipuler des chaînes de caractères =&gt; R = gsub, grepl etc. */\ndata Exemple_chaines;\nTexte = \"              Ce   Texte   mériterait   d être   corrigé                  \";\nTexte1 = \"Je m'appelle\";\nTexte2 = \"SAS\";\nrun;\ndata Exemple_chaines;set Exemple_chaines;\n/* Enlever les blancs au début et à la fin de la chaîne de caractère */\nEnlever_Blancs_Initiaux = strip(Texte);\n/* Enlever les doubles blancs dans la chaîne de caractères */\nEnlever_Blancs_Entre = compbl(Enlever_Blancs_Initiaux);\nrun;\n\n\n\n\ntexte_rbsase &lt;- \"              Ce   Texte   mériterait   d être   corrigé                  \"\ntexte_rbase_1 &lt;- \"Je m'appelle\"\ntexte_rbase_2 &lt;- \"R\"\n\n# trimws enlève les espaces au début et à la fin d'une chaîne de caractère\ntexte_rbase &lt;- gsub(\"\\\\s+\", \" \", trimws(texte_rbsase))\n\n\n\n\ntexte_tidyverse &lt;- \"              Ce   Texte   mériterait   d être   corrigé                  \"\ntexte_tidyverse_1 &lt;- \"Je m'appelle\"\ntexte_tidyverse_2 &lt;- \"R\"\n\n# str_squish() supprime les espaces blancs au début et à la fin, et remplace tous les espaces blancs internes par un seul espace\ntexte_tidyverse &lt;- str_squish(texte_tidyverse)\n\n\n\n\n\n\n11.4 Concaténer des chaînes de caractères\n\nSASR basetidyverse\n\n\n\n/* Trois méthodes pour concaténer des chaînes de caractères */\nConcatener  = Texte1||\" \"||Texte2;\nConcatener2 = Texte1!!\" \"!!Texte2;\nConcatener3 = catx(\" \", Texte1, Texte2);\n/* Extraire les 2e, 3e et 4e caractères de Concatener */\n/* 2 correspond à la position du 1er caractère à récupérer, 3 le nombre total de caractères à partir du point de départ */\nextrait = substr(Concatener, 2, 3);\nrun;\n\n\n\n\n# Concaténer des chaînes de caractères\npaste(texte_rbase_1, texte_rbase_2, sep = \" \")\n\n[1] \"Je m'appelle R\"\n\n\n\n\n\n# Concaténer des chaînes de caractères\n\nstr_c(texte_tidyverse_1, texte_tidyverse_2, sep = \" \")\n\n[1] \"Je m'appelle R\"\n\n\n\n\n\n\n\n11.5 Nombre de caractères dans une chaîne de caractères\n\nSASR basetidyverse\n\n\n\ndata Donnees;\nset Donnees;\n/* Nombre de caractères dans une chaîne de caractères*/\ntaille_id = length(identifiant);\nrun;\n\n\n\n\n# Nombre de caractères dans une chaîne de caractères\ndonnees_rbase$taille_id &lt;- nchar(donnees_rbase$identifiant)\n\n\n\n\n# Nombre de caractères dans une chaîne de caractères\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n   mutate(taille_id = str_split(identifiant, '') %&gt;% \n              lengths)\n\n\n\n\n\n\n11.6 Transformer plusieurs caractères différents\n\nSASR base\n\n\n\n/* Transformer plusieurs caractères différents */\nchaine = \"éèêëàâçîô\";\n/* On transforme le é en e, le â en a, le î en i, ... */\nchaine_sans_accent = translate(chaine, \"eeeeaacio\", \"éèêëàâçîô\");\nrun;\n\n\n\n\n# Transformer plusieurs caractères différents\nchaine &lt;- \"éèêëàâçîô\"\nchartr(\"éèêëàâçîô\", \"eeeeaacio\", chaine)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#gestion-ligne-par-ligne",
    "href": "01-aide_memoire_r_sas.html#gestion-ligne-par-ligne",
    "title": "Aide-mémoire SAS - R",
    "section": "12 Gestion ligne par ligne",
    "text": "12 Gestion ligne par ligne\n\n12.1 Numéro de l’observation\n\nSASR basetidyverse\n\n\n\n/* Numéro de l'observation */\ndata Donnees;set Donnees;\nNum_observation = _n_;\nrun;\n\n/* Autre solution */\nproc sql noprint;select count(*) into :nbLignes from Donnees;quit;\ndata numLigne;do Num_observation = 1 to &nbLignes.;output;end;run;\n\n\n\n\n# Numéro de l'observation : 2 manières différentes\n\ndonnees_rbase$num_observation &lt;- row.names(donnees_rbase)\ndonnees_rbase$num_observation &lt;- seq(1 : nrow(donnees_rbase))\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(num_observation= row_number())\n\n\n\n\n\n\n12.2 Trier des colonnes\n\nSASR basetidyverse\n\n\n\n/* Numéro du contrat de chaque individu, contrat trié par date de survenue */\nproc sort data = Donnees;by identifiant date_entree;run;\ndata Donnees;set Donnees;\nby identifiant date_entree;\nretain numero_contrat 0;\nif first.identifiant then numero_contrat = 1;\nelse numero_contrat = numero_contrat + 1;\nrun;\n\n\n\n\n# Numéro du contrat de chaque individu, contrat trié par date de survenue\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\ndonnees_rbase$a &lt;- 1\ndonnees_rbase$numero_contrat &lt;- ave(donnees_rbase$a, donnees_rbase$identifiant, FUN = cumsum)\n\n\n# Pour trier les colonnes\ntri &lt;- c(\"identifiant\", \"date_entree\", \"numero_contrat\", \"num_observation\")\ndonnees_rbase_tri &lt;- donnees_rbase[, c(tri, colnames(donnees_rbase)[! colnames(donnees_rbase) %in% tri])]\n\n\n\n\n# Numéro du contrat de chaque individu, contrat trié par date de survenue \n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;% \n  arrange(identifiant, date_entree) %&gt;% \n  mutate(numero_contrat=row_number())\n\n\n# Pour trier les colonnes\n\ndonnees_tidyverse_tri &lt;- donnees_tidyverse %&gt;% \n  select(identifiant, date_entree, numero_contrat, num_observation, everything())\n\n\n\n\n\n\n12.3 Identifier le 1er, le 2e, le dernier contrat d’un individu\n\nSASR basetidyverse\n\n\n\n  /* 2e contrat de l'individu (et rien si l'individu a fait 1 seul contrat */\n  data Deuxieme_Contrat;set Donnees;if numero_contrat = 2;run;\n  data Deuxieme_Contrat;set Donnees (where = (numero_contrat = 2));run;\n\n\n\n\n# Filtre sur le deuxième contrat \n\ndeuxieme_contrat_rbase &lt;- donnees_rbase[donnees_rbase$numero_contrat == 2, ]\n\n\n# Créer une base avec les seuls premiers contrats, et une base avec les seuls derniers contrats\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\npremier_contrat_rbase &lt;- donnees_rbase[!duplicated(donnees_rbase$identifiant, fromLast = FALSE), ]\ndernier_contrat_rbase &lt;- donnees_rbase[!duplicated(donnees_rbase$identifiant, fromLast = TRUE), ]\nni_prem_ni_der_rbase  &lt;- donnees_rbase[! (!duplicated(donnees_rbase$identifiant, fromLast = FALSE) | !duplicated(donnees_rbase$identifiant, fromLast = TRUE)), ]\n\n\n\n\n# Filtre sur le deuxième contrat \n\ndeuxieme_contrat_tidyverse &lt;- donnees_tidyverse %&gt;% \n  filter(numero_contrat == 2)\n\n\n# Créer une base avec les seuls premiers contrats, et une base avec les seuls derniers contrats\n\npremier_contrat_tidyverse &lt;- donnees_tidyverse %&gt;% \n  filter(numero_contrat==1)\n\ndernier_contrat_tidyverse &lt;- donnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;% \n  filter(numero_contrat==max(numero_contrat)) %&gt;% \n  ungroup()\n\nni_prem_ni_der_tidyverse  &lt;- donnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;% \n  filter(numero_contrat!=1 & numero_contrat != max(numero_contrat)) %&gt;% \n  ungroup()\n\n\n\n\n\n\n12.4 Date de fin du contrat précédent\n\nSASR base\n\n\n\n/* La date de fin du contrat précédent */\nproc sort data = Donnees;by identifiant date_entree;run;\ndata DonneesBon;set Donnees;\nby identifiant date_entree;\nformat Date_fin_1 ddmmyy10.;\nDate_fin_1 = lag(Date_sortie);\nif first.identifiant then Date_fin_1 = .;\nrun;\n\n\n\n\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\n\n\n# Il faut soit utiliser un package, soit utiliser cette astuce car il n'existe pas de fonction lag dans le R de base (à notre connaissance)\ndonnees_rbase$date_sortie_1 &lt;- c(as.Date(NA), donnees_rbase$date_sortie[ 1:(length(donnees_rbase$date_sortie) - 1)])\ndonnees_rbase$date_sortie_1[!duplicated(donnees_rbase$identifiant, fromLast = FALSE)] &lt;- as.Date(NA)\n\n\n\n\n\n\n12.5 Valeur retardée (lag)\n\nSASR basetidyverse\n\n\n\n/* ATTENTION au lag DANS UNE CONDITION IF (cf. document) */\nproc sort data = Donnees;by identifiant date_entree;run;\ndata Lag_Bon;set Donnees (keep = identifiant date_entree date_sortie);\nformat date_sortie_1 lag_faux lag_bon ddmmyy10.;\n/* Erreur */\nif date_entree = lag(date_sortie) + 1 then lag_faux = lag(date_sortie) + 1;\n/* Bonne écriture */\ndate_sortie_1 = lag(date_sortie);\nif date_entree = date_sortie_1 + 1 then lag_bon = date_sortie_1 + 1;\nrun;\n\n\n\n\n# Il n'existe pas de fonction lag dans le R de base (à notre connaissance)\n# Il faut soit utiliser un package, soit utiliser cette astuce\ndonnees_rbase$date_sortie_1 &lt;- c(as.Date(NA), donnees_rbase$date_sortie[ 1:(length(donnees_rbase$date_sortie) - 1)])\ndonnees_rbase$date_sortie_1[!duplicated(donnees_rbase$identifiant, fromLast = FALSE)] &lt;- as.Date(NA)\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(date_sortie_1 = lag(date_sortie))\n\n\n\n\n\n\n12.6 Transposer une base\n\nSASR basetidyverse\n\n\n\n/* Transposer une base */\nproc freq data = Donnees;table Sexef * cspf / out = Nb;run;\nproc sort data = Nb;by cspf Sexef;run;\nproc print data = Nb;run;\nproc transpose data = Nb out = transpose;by cspf;var count;id Sexef;run;\ndata transpose;set transpose (drop = _name_ _label_);run;\nproc print data = transpose;run;\n\n\n\n\n# as.data.frame.matrix est nécessaire, car le résultat de xtabs est un array\nnb_rbase &lt;- as.data.frame.matrix(xtabs( ~ cspf + sexef, data = donnees_rbase))\nnb_transpose_rbase &lt;- as.data.frame(t(nb_rbase))\n\n\n\n\nnb_tidyverse &lt;- donnees_tidyverse %&gt;% janitor::tabyl(cspf, sexef) %&gt;% \n                # colonne cspf comme nom de ligne\n                  column_to_rownames(var=\"cspf\")\n\nnb_transpose_tridyverse &lt;- nb_tidyverse %&gt;% sjmisc::rotate_df()",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#les-valeurs-manquantes",
    "href": "01-aide_memoire_r_sas.html#les-valeurs-manquantes",
    "title": "Aide-mémoire SAS - R",
    "section": "13 Les valeurs manquantes",
    "text": "13 Les valeurs manquantes\n\n13.1 Repérer les valeurs manquantes\n\nSASR basetidyverse\n\n\n\n/* Repérer les valeurs manquantes */\ndata Missing;set Donnees;\n/* 1ère solution */\nif missing(age) or missing(Niveau) then missing1 = 1;else missing1 = 0;\nif age = . or Niveau = '' then missing2 = 1;else missing2 = 0;\nkeep Age Niveau Missing1 Missing2;\nrun;\n\n\n\n\ndonnees_rbase$missing &lt;- ifelse(is.na(donnees_rbase$age) | is.na(donnees_rbase$niveau), 1, 0)\nageManquant_rbase_faux &lt;- donnees_rbase[is.na(donnees_rbase$age),  ] # Faux : crée une basse de données avec que des NA\nageManquant_rbase_correct &lt;- donnees_rbase[is.na(donnees_rbase$age), ] # Correct\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(missing = ifelse(is.na(age) | is.na(niveau), 1, 0))\n\nageManquant_tidyverse &lt;- donnees_tidyverse %&gt;% \n  filter(is.na(age))\n\n\n\n\n\n\n13.2 Incidence des valeurs manquantes, différent entre SAS et R\n\nSASR base\n\n\n\n\n\n\n13.2.1 Opérations\nIl suffit de rajouter l’argument na.rm=TRUE\n\nmean(donnees_rbase$note_formateur) # s'il existe un seul NA et que l'on ne précise rien, la fonction retournera NA\n\n\n# Il faut donc rajouter l'argument na.rm=TRUE (remove NA) afin de calculer la moyenne sans prendre en compte les NA\n\nmean(donnees_rbase$note_formateur, na.rm = TRUE)\n\n\n\n13.2.2 Tris",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#les-doublons",
    "href": "01-aide_memoire_r_sas.html#les-doublons",
    "title": "Aide-mémoire SAS - R",
    "section": "14 Les doublons",
    "text": "14 Les doublons\n\n14.1 Repérage des doublons\n\nSASR basetidyverse\n\n\n\n    /* On récupère déjà la dernière variable de la base (on en aura besoin plus loin) */\n    proc contents data = Donnees out = Var noprint;run;\n    proc sql noprint;select name into :derniere_var from Var where varnum = (select max(varnum) from Var);quit;\n\n    /* 1ère méthode */\n    proc sort data = Donnees;by &nom_col.;run;\n    data Doublons;set Donnees;by &nom_col.;\n    if first.&derniere_var. = 0 or last.&derniere_var. = 0;\n    run;\n\n    /* 2e méthode */\n\n    /* On remplace les blancs entre les mots par des virgules pour la proc sql */\n\n    /* Dans la proc SQL, les variables doivent être séparées par des virgules */\n    %let nom_col_sql = %sysfunc(tranwrd(&nom_col., %str( ), %str(, )));\n\n    /* On groupe par toutes les colonnes, et si on aboutit à strictement plus qu'une ligne, c'est un doublon */\n    proc sql;create table Doublons as select * from Donnees group by &nom_col_sql. having count(*) &gt; 1;quit;\n\n    /* Suppression des doublons */\n\n    /* 1ère méthode */\n    proc sort data = Donnees nodupkey;by &nom_col.;run;\n\n    /* 2e méthode, avec first. et last. (cf. infra) */\n\n    /* On récupère déjà la dernière variable de la base (on en aura besoin plus loin) */\n    proc contents data = Donnees out = Var noprint;run;\n    proc sql noprint;select name into :derniere_var from Var where varnum = (select max(varnum) from Var);quit;\n    proc sql noprint;select name into :nom_col separated by \" \" from Var order by varnum;quit;\n    %put Dernière variable de la base : &derniere_var.;\n    %put &nom_col.;\n    proc sort data = Donnees;by &nom_col.;run;\n    data Donnees;set Donnees;by &nom_col.;if first.&derniere_var.;run;\n\n\n\n\n# Repérage\ndoublons_rbase &lt;- donnees_rbase[duplicated(donnees_rbase), ]\n\n#doublons ici : toute la ligne est identique avec une autre ligne \n#avec cette commande, s'il y existe des doublons i.e. deux observations qui ont les mêmes observations pour toutes les variables, la base doublons_rbase stockera uniquement un des doublons mais pas toutes les lignes qui sont identiques \n\n\n\n\n# Repérage\ndoublons_tidyverse &lt;- donnees_tidyverse %&gt;%  \n  group_by(identifiant, sexe) %&gt;% \n  filter(n()&gt;1)\n\n#doublons ici : les observations qui ont le même identifiant et le même sexe \n#avec cette commande, la base doublons_tidyverse va stocker toutes les observations qui sont en doubles i.e. qui ont le même identifiant et le même sexe \n\n\n\n\n\n\n14.2 Suppression des doublons\n\nSASR basetidyverse\n\n\n\n\n\n\ndonnees_rbase &lt;- donnees_rbase[! duplicated(donnees_rbase), ]\n\n\n# Autre solution (solution first. de SAS)\ndonnees_rbase &lt;- donnees_rbase[order(colnames(donnees_rbase), na.last = FALSE), ]\ndonnees_rbase &lt;- donnees_rbase[!duplicated(donnees_rbase[, colnames(donnees_rbase)], fromLast = TRUE), ]\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  distinct()",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#les-jointures-de-base",
    "href": "01-aide_memoire_r_sas.html#les-jointures-de-base",
    "title": "Aide-mémoire SAS - R",
    "section": "15 Les jointures de base",
    "text": "15 Les jointures de base\n\n15.1 Inner Join : identifiants communs aux bases\n\nSASR basetidyverse\n\n\n\n    /* On suppose que l'on dispose d'une base supplémentaire avec les diplômes des personnes */\n    data Diplome;\n    infile cards dsd dlm='|';\n    format Identifiant $3. Diplome $50.;\n    input Identifiant $ Diplome $;\n    cards;\n    173|Bac\n    168|Bep-Cap\n    112|Bep-Cap\n    087|Bac+2\n    689|Bac+2\n    765|Pas de diplôme\n    112|Bac\n    999|Bac\n    554|Bep-Cap\n    ;\n    run;\n    data Jointure;set Donnees (keep = Identifiant Sexe Age);run;\n\n    /* Le tri préalable des bases de données à joindre par la variable de jointure est nécessaire avec la stratégie merge */\n    proc sort data = Diplome;by identifiant;run;\n    proc sort data = Jointure;by identifiant;run;\n    data Inner_Join1;\n    merge Jointure (in = a) Diplome (in = b);\n    by identifiant;\n    if a and b;\n    run;\n\n    /* Le tri préalable des bases de données à joindre n'est pas nécessaire avec la jointure SQL */\n    proc sql;\n    create table Inner_Join2 as\n    select * from Jointure a inner join Diplome b on a.identifiant = b.identifiant\n    order by a.identifiant;\n    quit;\n    proc print data = Inner_Join1;run;\n    proc sql;select count(*) from Inner_Join1;quit;\n\n\n\n\n# On suppose que l'on dispose d'une base supplémentaire avec les diplômes des personnes\ndiplome_rbase &lt;- data.frame(identifiant_i = c(\"173\", \"168\", \"112\", \"087\", \"689\", \"765\", \"112\", \"999\", \"554\"),\ndiplome= c(\"Bac\", \"Bep-Cap\", \"Bep-Cap\", \"Bac+2\", \"Bac+2\", \"Pas de diplôme\", \"Bac\", \"Bac\", \"Bep-Cap\"),\nage_dip = c(22, 27, 18, 23, 21, 15, 21, 18, 20)\n)\n\n\n# 1. Inner join : les seuls identifiants communs aux deux bases\njointure_rbase &lt;- donnees_rbase[, c(\"identifiant\", \"sexe\", \"age\")]\ninnerJoin_rbase &lt;- merge(jointure_rbase, diplome_rbase, by.x = \"identifiant\", by.y = \"identifiant_i\")\ndim(innerJoin_rbase)\n\n\n\n\n# On suppose que l'on dispose d'une base supplémentaire avec les diplômes des personnes\ndiplome_tidyverse &lt;- data.frame(identifiant= c(\"173\", \"168\", \"112\", \"087\", \"689\", \"765\", \"112\", \"999\", \"554\"),\ndiplome= c(\"Bac\", \"Bep-Cap\", \"Bep-Cap\", \"Bac+2\", \"Bac+2\", \"Pas de diplôme\", \"Bac\", \"Bac\", \"Bep-Cap\"),\nage_dip = c(22, 27, 18, 23, 21, 15, 21, 18, 20)\n)\n\n\n# 1. Inner join : les seuls identifiants communs aux deux bases\njointure_tidyverse&lt;- donnees_tidyverse %&gt;% \n  select(identifiant, sexe, age)\n\ninnerJoin_tidyverse &lt;- jointure_tidyverse %&gt;% \n  inner_join(diplome_tidyverse, by=\"identifiant\")\n\n\n\n\n\n\n15.2 Left et Right Join : identifiants de l’une des bases\n\nSASR basetidyverse\n\n\n\n    /* Le tri préalable des bases de données à joindre par la variable de jointure est nécessaire avec la stratégie merge */\n    proc sort data = Diplome;by identifiant;run;\n    proc sort data = Jointure;by identifiant;run;\n    data Left_Join1;\n    merge Jointure (in = a) Diplome (in = b);\n    by identifiant;\n    if a;\n    run;\n\n\n\n\n# 2. Left join : les identifiants de la base de gauche\nleftJoin_rbase &lt;- merge(jointure_rbase, diplome_rbase, by.x = \"identifiant\", by.y = \"identifiant_i\", all.x = TRUE)\ndim(leftJoin_rbase)\n\n\n\n\n# 2. Left join : les identifiants de la base de gauche\nleftJoin_tidyverse &lt;- jointure_tidyverse %&gt;% \n  left_join(diplome_tidyverse, by=\"identifiant\")\n\n\n\n\n\n\n15.3 Full Join : identifiants de l’une ou l’autre des bases\n\nSASR basetidyverse\n\n\n\n    /* Le tri préalable des bases de données à joindre par la variable de jointure est nécessaire avec la stratégie merge */\n    proc sort data = Diplome;by identifiant;run;\n    proc sort data = Jointure;by identifiant;run;\n    data Full_Join1;\n    merge Jointure (in = a) Diplome (in = b);\n    by identifiant;\n    if a or b;\n    run;\n\n\n\n\n# 3. Full join : les identifiants des deux bases\nfullJoin_rbase &lt;- merge(jointure_rbase, diplome_rbase, by.x = \"identifiant\", by.y = \"identifiant_i\", all = TRUE)\ndim(fullJoin_rbase)\n\n\n\n\n# 3. Full join : les identifiants des deux bases\nfullJoin_tidyverse &lt;- jointure_tidyverse %&gt;% \n  full_join(diplome_tidyverse)\n\n\n\n\n\n\n15.4 Cross Join : toutes les combinaisons possibles\n\nSASR basetidyverse\n\n\n\n    /* 4. Cross join : toutes les combinaisons possibles de CSP, sexe et Diplome */\n    proc sql;\n    select *\n    from (select distinct CSPF from Donnees) cross join (select distinct Sexef from Donnees) cross join (select distinct Diplome from Diplome)\n    order by CSPF, Sexef, Diplome;\n    quit;\n\n\n\n\n# 4. Cross join : toutes les combinaisons possibles de CSP, sexe et Diplome\ncrossJoin_rbase &lt;- unique(expand.grid(donnees_rbase$cspf, donnees_rbase$sexef, diplome_rbase$diplome))\ncolnames(crossJoin_rbase) &lt;- c(\"cspf\", \"sexef\", \"diplome\")\ncrossJoin_rbase\n\n\n\n\n# 4. Cross join \ncrossJoin_tidyverse &lt;- cross_join(jointure_tidyverse, diplome_tidyverse) #à refaire\n\n\n\n\n\n\n15.5 Empiler les bases\n\nSASR basetidyverse\n\n\n\n\n\n\n# Lorsque les variables ne correspondent pas, on les crée avec des valeurs manquantes, via setdiff\nempilement_rbase &lt;- rbind(\ndata.frame(c(donnees_rbase, sapply(setdiff(names(diplome_rbase), names(donnees_rbase)), function(x) NA))),\ndata.frame(c(diplome_rbase, sapply(setdiff(names(donnees_rbase), names(diplome_rbase)), function(x) NA)))\n)\n\n\n\n\n# bind_rows permet d'empiler les deux bases de données quel que soit l'ordre et le nombre respectif de colonnes alors que rbind ne fonctionnera pas si les bases de données n'ont pas les mêmes colonnes dans le même ordre. \n\nempilement_tidyverse &lt;- bind_rows(donnees_tidyverse, diplome_tidyverse)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#statistiques-descriptives",
    "href": "01-aide_memoire_r_sas.html#statistiques-descriptives",
    "title": "Aide-mémoire SAS - R",
    "section": "16 Statistiques descriptives",
    "text": "16 Statistiques descriptives\n\n16.1 Somme, moyenne, médiane, minimum, maximum, nombre de valeurs\n\nSASR basetidyverse\n\n\n\n    /* Moyenne de chaque note */\n    %let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\n    proc means data = Donnees mean;var &notes.;run;\n\n    /* Somme, moyenne, médiane, minimum, maximum, nombre de données */\n    proc means data = Donnees sum mean median min max n;var &notes.;run;\n\n    /* Notes pondérées (poids de sondage) */\n    proc means data = Donnees sum mean median min max n;var &notes.;weight poids_sondage;run;\n\n\n\n\nMoyenne\n\n\n# Moyenne de chaque note\nnotes_rbase &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\nlapply(donnees_rbase[, notes_rbase], mean, na.rm = TRUE)\n\n\nMoyenne, médiane, maximum, minimum\n\n\nsapply(donnees_rbase[, notes], function(x) c(\"Somme\" = sum(x, na.rm = TRUE), \"Moyenne\" = mean(x, na.rm = TRUE),\n\"Médiane\" = median(x, na.rm = TRUE), \"Max\" = max(x, na.rm = TRUE),\n\"Min\" = min(x, na.rm = TRUE)))\n\n\nMoyenne avec pondération\n\n\n# Avec la pondération\nwith(donnees_rbase, sapply(donnees_rbase[, notes], function(x) weighted.mean(x, poids_sondage, na.rm = TRUE)))\n\n\nRésumé statistique\n\n\nsummary(donnees_rbase[, notes])\n\n\n\n\nMoyenne par identifiant\n\n\nnotes_tidyverse &lt;- donnees_tidyverse %&gt;%  \n  select(starts_with(\"Note\")) %&gt;% \n  summarise_all(.funs = c(mean=\"mean\"))\n\n\nMoyenne par identifiant par pondération\n\n\nnotes_tidyverse &lt;- donnees_tidyverse %&gt;%  \n  select(starts_with(\"Note\"), poids_sondage) %&gt;% \n  summarise(across(note_contenu:note_materiel, ~weighted.mean(., w = poids_sondage)))\n\n\n\n\n\n\n16.2 Quantiles\n\nSASR basetidyverse\n\n\n\n\n\n\n# Déciles et quartiles de la note moyenne\nquantile(donnees_rbase$note_moyens, probs = c(seq(0, 1, 0.1), 0.25, 0.75), na.rm = TRUE)\n\n\n\n\ndonnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;%  \n  summarise(quantile = scales::percent(c(0.25, 0.5, 0.75)),\n            note_moyens = quantile(note_moyens, c(0.25, 0.5, 0.75), na.rm = TRUE))\n\n\n\n\n\n\n16.3 Tableaux de fréquence / contingence : proc freq\n\nSASR basetidyverse\n\n\n\n    /* Tableaux de fréquence : proc freq */\n    proc freq data = Donnees;\n    tables Sexe CSP / missing;\n    format Sexe sexef. CSP $cspf.;\n    /*weight poids_sondage;*/\n    run;\n\n\n\nL’équivalent de proc freq sur SAS :\n\ntable(donnees_rbase$sexef, useNA = \"always\")\n\n\n\n\ntableau_contingence &lt;- donnees_tidyverse %&gt;% \n  group_by(sexef) %&gt;% \n  summarise(n=n())\n\ntableau_contingence\n\n\n\n\n\n\n16.4 Proportion\n\nSASR basetidyverse\n\n\n\n\n\n\nprop.table(table(donnees_rbase$sexef, useNA = \"always\")) * 100\n\n\n\n\nproportion &lt;- donnees_tidyverse %&gt;% \n  group_by(sexef) %&gt;% \n  summarise(n=n(),\n            pourcentage=round(n/length(donnees_tidyverse$sexef)*100,2))\n\nproportion",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#fonction-macros-sas",
    "href": "01-aide_memoire_r_sas.html#fonction-macros-sas",
    "title": "Aide-mémoire SAS - R",
    "section": "17 Fonction, macros SAS",
    "text": "17 Fonction, macros SAS\n\n17.1 Boucles, itérations\n\nSASR basetidyverse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n17.2 Créations automatiques de bases, empilements de bases\n\nSASR basetidyverse",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#fin-du-programme",
    "href": "01-aide_memoire_r_sas.html#fin-du-programme",
    "title": "Aide-mémoire SAS - R",
    "section": "18 Fin du programme",
    "text": "18 Fin du programme\n\n18.1 Supprimer toutes les bases de la mémoire vive (work RAM)\n\nSASR baseDuckdb\n\n\n\n    /* Supprimer toutes les bases de la mémoire vive (la work) =&gt; rm(list = ls()) */\n    proc datasets lib = work nolist kill;run;\n\n\n\n\n#rm(list = ls()) #conflit avec cellule d'après sinon \n\n\n\n\nDBI::dbDisconnect(con, shutdown = TRUE)",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#points-de-vigilance-en-sas",
    "href": "01-aide_memoire_r_sas.html#points-de-vigilance-en-sas",
    "title": "Aide-mémoire SAS - R",
    "section": "19 Points de vigilance en SAS",
    "text": "19 Points de vigilance en SAS",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#footnotes",
    "href": "01-aide_memoire_r_sas.html#footnotes",
    "title": "Aide-mémoire SAS - R",
    "section": "Notes de bas de page",
    "text": "Notes de bas de page\n\n\nDares/SCS, nassab.abdallah@travail.gouv.fr↩︎\nDares/DIP, damien.euzenat@travail.gouv.fr↩︎\nDares/DFA, sebastien.li-thiao-te@travail.gouv.fr↩︎",
    "crumbs": [
      "Aide-mémoire"
    ]
  },
  {
    "objectID": "02-avantages_inconvenients_env_R.html",
    "href": "02-avantages_inconvenients_env_R.html",
    "title": "Avantages et inconvénients des environnements R",
    "section": "",
    "text": "Environnements R\n          Avantages\n        Inconvénients\n\n\n\n\n       R base\n\nabsence de dépendance (ne s’appuie sur aucun package) : pas besoin d’installer un package, de gérer sa mise à jour, de craindre pour sa disparition\ngarantit la rétrocompatibilité du code : utile dans des environnements de production\ndans certains cas, se révèle la solution la plus simple\nparfois, la seule façon de faire\n\n\nne permet pas de gérer des bases de données plus volumineuses que la mémoire vive\nsyntaxe plus complexe et parfois incohérente\nsouvent moins rapide que les autres environnements\ndemande plus de connaissance sur le fonctionnement du langage R\ncertaines tâches sont plus simples à traiter avec les autres environnements\n\n\n\n       tidyverse\n\nplus simple à prendre en main\nsyntaxe plus simple que les autres environnements et cohérente\nlargement utilisé dans la communauté R\ntend à s’imposer comme la référence de la gestion de données sur R\nsyntaxe utilisée également dans les packages Arrow / DuckDb\n\n\nne permet pas de gérer des bases de données plus volumineuses que la mémoire vive\nglobalement moins rapide que data.table\ntâches non prévues plus difficiles à réaliser\nforte dépendance : la rétrocompatibilité n’est pas assurée, potentiel problème dans un environnement de production\n\n\n\n       data.table\n\nfaible dépendance : garantit une rétrocompatibilité élevée\nsyntaxe proche du R Base\nplus rapide et puissant que ses concur\n\n\nne permet pas de gérer des bases de données plus volumineuses que la mémoire vive\nsyntaxe parfois déroutante, incohérente, et peu explicite\ncertaines tâches sont plus simples à traiter avec les autres environnements\nmoins utilisé",
    "crumbs": [
      "Avantages et inconvénients des environnements R"
    ]
  },
  {
    "objectID": "Trucs et astuces en R.html",
    "href": "Trucs et astuces en R.html",
    "title": "Trucs et astuces en R",
    "section": "",
    "text": "Voici quelques trucs et astuces utiles à connaître sur R, des livres The R Inferno et Advanced R, à consulter pour plus de détails."
  },
  {
    "objectID": "Trucs et astuces en R.html#effets-des-calculs-en-virgule-flottante",
    "href": "Trucs et astuces en R.html#effets-des-calculs-en-virgule-flottante",
    "title": "Trucs et astuces en R",
    "section": "1.1 Effets des calculs en virgule flottante",
    "text": "1.1 Effets des calculs en virgule flottante\n\nsqrt(2) ^ 2 == 2\n\n[1] FALSE\n\n1 / 49 * 49 == 1\n\n[1] FALSE\n\n.1 == .3 / 3\n\n[1] FALSE\n\nseq(0, 1, by=.1) == .3\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\nunique(c(.3, .4 - .1, .5 - .2, .6 - .3, .7 - .4))\n\n[1] 0.3 0.3 0.3"
  },
  {
    "objectID": "Trucs et astuces en R.html#les-types-dobjet",
    "href": "Trucs et astuces en R.html#les-types-dobjet",
    "title": "Trucs et astuces en R",
    "section": "1.2 Les types d’objet",
    "text": "1.2 Les types d’objet\n\n# En savoir plus sur ses données\ndata(\"cars\")\ntypeof(cars)\n\n[1] \"list\"\n\nclass(cars)\n\n[1] \"data.frame\"\n\nmode(cars)\n\n[1] \"list\"\n\nstr(cars)\n\n'data.frame':   50 obs. of  2 variables:\n $ speed: num  4 4 7 7 8 9 10 10 10 11 ...\n $ dist : num  2 10 4 22 16 10 18 26 34 17 ...\n\ndim(cars)\n\n[1] 50  2\n\nc(is.data.frame(cars), is.list(cars), is.vector(cars), is.array(cars))\n\n[1]  TRUE  TRUE FALSE FALSE\n\n\nNotation L\n\n# Notation L : imposer à R de créer un nombre sous format \"integer\", pour des raisons d'efficacité\nclass(1)\n\n[1] \"numeric\"\n\nclass(1L)\n\n[1] \"integer\""
  },
  {
    "objectID": "Trucs et astuces en R.html#les-affectations",
    "href": "Trucs et astuces en R.html#les-affectations",
    "title": "Trucs et astuces en R",
    "section": "1.3 Les affectations",
    "text": "1.3 Les affectations\n\n# Importance des espaces\nx&lt;-3\nx\n\n[1] 3\n\n# S'agit-il de ?\nx &lt;- 3\nx &lt; -3\n\n[1] FALSE\n\n\n\n# Les {} permettent de réaliser une affectation (&lt;-) au sein d'un traitement plus complexe !\n# Exemple ici : sommer les positions paires multipliées par 2 et les positions impaires multipliées par 3\nsum({x &lt;- 1:6 ; x[1:length(x) %% 2 == 0] &lt;- x[1:length(x) %% 2 == 0] * 2 ; x[1:length(x) %% 2 != 0] &lt;- x[1:length(x) %% 2 != 0] * 3 ; x})\n\n[1] 51\n\n\n\n# Afficher ou non la valeur de l'objet affecté pendant l'affectation\nx &lt;- pi\n(x &lt;- pi)\n\n[1] 3.141593\n\n\n\n# Comparaisons multiples\nx &lt;- 0.5\n# Correct\n0 &lt; x & x &lt; 1\n# Incorrect\n0 &lt; x &lt; 1\n\nError: &lt;text&gt;:6:7: unexpected '&lt;'\n5: # Incorrect\n6: 0 &lt; x &lt;\n         ^\n\n\n\n# Ne pas confondre !\nseq(0:10)\n\n [1]  1  2  3  4  5  6  7  8  9 10 11\n\n0:10\n\n [1]  0  1  2  3  4  5  6  7  8  9 10\n\nseq(0, 10)\n\n [1]  0  1  2  3  4  5  6  7  8  9 10\n\n\n\n# Privilégier seq_len à : lorsqu'il y a un risque de 0\n# Fonctionnement identique\nn &lt;- 5\n1:n\n\n[1] 1 2 3 4 5\n\nseq_len(n)\n\n[1] 1 2 3 4 5\n\n# Problème avec les 0\nn &lt;- 0\n1:n\n\n[1] 1 0\n\nseq_len(n)\n\ninteger(0)\n\n\n\n# Préférer seq_along à : au cas où la taille de l'objet est 0\nx &lt;- c() ;length(x)\n\n[1] 0\n\nfor(i in 1:length(x)) print(i)\n\n[1] 1\n[1] 0\n\nfor(i in seq_along(x)) print(i)\nfor(i in seq(along=x)) print(i)\n\n\n# Equivalent des list-comprehensions de type Python en R\n# Somme des entiers de 1 à 1 000 multiples de 3 ou 5, en une ligne !\n# 4 manières de faire\nsum({l &lt;- 1:1000 ; l[l %% 3 == 0 | l %% 5 == 0]})\n\n[1] 234168\n\nsum({l &lt;- 1:1000 ; l[seq_along(l) %% 3 == 0 | seq_along(l) %% 5 == 0]})\n\n[1] 234168\n\nsum(l&lt;-(1:1000)[l %% 3 == 0 | l %% 5 == 0])\n\n[1] 234168\n\nsum((1:1000)[(1:1000 %% 3) == 0 | (1:1000 %% 5) == 0])\n\n[1] 234168\n\n\n\n# Opérations mathématiques\n# Infini\n1/0\n\n[1] Inf\n\n# Nan = not a number\n0/0\n\n[1] NaN\n\nlog(-1)\n\n[1] NaN"
  },
  {
    "objectID": "Trucs et astuces en R.html#principe-de-vectorisation",
    "href": "Trucs et astuces en R.html#principe-de-vectorisation",
    "title": "Trucs et astuces en R",
    "section": "1.4 Principe de vectorisation",
    "text": "1.4 Principe de vectorisation\nLa fonction s’applique à tous les éléments du vecteur !!\n\n# Exemple de vecteur\nvaleurs &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nvaleurs &lt;- 1:10\n\n\n# Valeurs au carré\nvaleurs ** 2\n\n [1]   1   4   9  16  25  36  49  64  81 100\n\n\n\n# logarithme des valeurs\nlog(valeurs)\n\n [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 1.7917595 1.9459101\n [8] 2.0794415 2.1972246 2.3025851\n\n\n\n# Maximum des valeurs\nmax(valeurs)\n\n[1] 10\n\n\n\n# Limite des valeurs\nrange(valeurs)\n\n[1]  1 10\n\n\n\n# Correct\nmean(valeurs)\n\n[1] 5.5\n\n\n\n# Correct\nmean(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))\n\n[1] 5.5\n\n\n\n# Inattendu\nmean(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n\n[1] 1\n\n\n\n# Attention aux parenthèses !\nn &lt;- 10\n# Inattendu ! Correspond à (1-1, 2-1, 3-1, ..., 10-1)\n1:n-1\n\n [1] 0 1 2 3 4 5 6 7 8 9\n\n# Correct\n1:(n-1)\n\n[1] 1 2 3 4 5 6 7 8 9\n\n\n\n# Minimum ou maximum élément par élément\nx1 &lt;- c(1, 2, 5, 6, 8)\nx2 &lt;- c(4, 0, 7, 2, 1)\n# Minimum : 2 possibilités\npmin(x1, x2)\n\n[1] 1 0 5 2 1\n\nmapply(min, x1, x2)\n\n[1] 1 0 5 2 1\n\n# Maximum : 2 possibilités\npmax(x1, x2)\n\n[1] 4 2 7 6 8\n\nmapply(max, x1, x2)\n\n[1] 4 2 7 6 8\n\n\n\n# Calculer (x - min) / (max - min) pour chaque élément x d'un vecteur\nx &lt;- c(1,2,3)\nsapply(x, function(xi, mn, mx) {(xi - mn) / (mx - mn)}, mn = min(x), mx = max(x))\n\n[1] 0.0 0.5 1.0"
  },
  {
    "objectID": "Trucs et astuces en R.html#principe-de-coercion",
    "href": "Trucs et astuces en R.html#principe-de-coercion",
    "title": "Trucs et astuces en R",
    "section": "1.5 Principe de coercion",
    "text": "1.5 Principe de coercion\nDans les comparaisons, les objets R sont successivement convertis en logical, integer, numeric, complex et character, jusqu’à ce que la comparaison puisse se faire.\n\n# TRUE / FALSE est transformé en integer (1 / 0)\nTRUE == 1\n\n[1] TRUE\n\nTRUE == 2\n\n[1] FALSE\n\nFALSE == 0\n\n[1] TRUE\n\n\n\n# TRUE est convertit en character\nTRUE == \"1\"\n\n[1] FALSE\n\n\n\n# 5 est convertit en character\n5 &lt; '7'\n\n[1] TRUE\n\n\n\n# 50 est convertit en character\n50 &lt; '7'\n\n[1] TRUE"
  },
  {
    "objectID": "Trucs et astuces en R.html#principe-de-recycling",
    "href": "Trucs et astuces en R.html#principe-de-recycling",
    "title": "Trucs et astuces en R",
    "section": "1.6 Principe de recycling",
    "text": "1.6 Principe de recycling\n\n# Fonctionne sans soulever de message d'erreur\nx &lt;- c(1, 2, 3)\ny &lt;- c(1, 2, 3, 4, 5, 6)\nx + y\n\n[1] 2 4 6 5 7 9\n\n\n\n# Fonctionne, mais Warning\nx &lt;- c(1, 2, 3)\ny &lt;- c(1, 2, 3, 4, 5, 6, 7)\nx + y\n\nWarning in x + y: longer object length is not a multiple of shorter object\nlength\n\n\n[1] 2 4 6 5 7 9 8"
  },
  {
    "objectID": "Trucs et astuces en R.html#opérateurs-de-contrôle",
    "href": "Trucs et astuces en R.html#opérateurs-de-contrôle",
    "title": "Trucs et astuces en R",
    "section": "1.7 Opérateurs de contrôle",
    "text": "1.7 Opérateurs de contrôle\n\n# Conditions if / else\nx &lt;- 1\n\n\n# Correct\nif (identical(x, 1)) {\nprint(\"x est égal à 1\")\n} else {\nprint(\"x est différent de 1\")\n}\n\n[1] \"x est égal à 1\"\n\n\n\n# Correct\nif (identical(x, 1)) {print(\"x est égal à 1\")\n} else {print(\"x est différent de 1\")}\n\n[1] \"x est égal à 1\"\n\n\n\n# Correct\nif (identical(x, 1)) print(\"x est égal à 1\") else\nprint(\"x est différent de 1\")\n\n[1] \"x est égal à 1\"\n\n\n\n# Correct\nif (identical(x, 1)) print(\"x est égal à 1\") else print(\"x est différent de 1\")\n\n[1] \"x est égal à 1\"\n\n\n\n# Incorrect\nif (identical(x, 1)) print(\"x est égal à 1\")\nelse print(\"x est différent de 1\")\n\nError: &lt;text&gt;:3:1: unexpected 'else'\n2: if (identical(x, 1)) print(\"x est égal à 1\")\n3: else\n   ^\n\n\n\n# Switch\n# Fonctions et conditions if / else\ncondition &lt;- function(langue = \"Français\") {\nif (langue == \"Français\") {\n\"salut\"\n} else if (langue == \"Anglais\") {\n\"hello\"\n} else if (langue == \"Russe\") {\n\"привет\"\n} else {\nstop(\"salut\")\n}\n}\ncondition(\"Anglais\")\n\n[1] \"hello\"\n\n\n\n# Autre possibilité avec switch, mais à réserver aux variables caractères !\ncondition &lt;- function(langue = \"Français\") {\nswitch(langue,\nFrançais = \"salut\",\nAnglais = \"hello\",\nRusse = \"привет\",\nstop(\"salut\")\n)\n}\ncondition(\"Français\")\n\n[1] \"salut\"\n\n\n\n# Penser au print\nfor(i in 1:5) i\nfor(i in 1:5) print(i)\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n\n\n\n# Différences print et cat\ncat(\"Salut !\\nComment vas-tu ?\")\n\nSalut !\nComment vas-tu ?\n\nprint(\"Salut !\\nComment vas-tu ?\")\n\n[1] \"Salut !\\nComment vas-tu ?\""
  },
  {
    "objectID": "Trucs et astuces en R.html#les-valeurs-manquantes",
    "href": "Trucs et astuces en R.html#les-valeurs-manquantes",
    "title": "Trucs et astuces en R",
    "section": "1.8 Les valeurs manquantes",
    "text": "1.8 Les valeurs manquantes\n\n# Transformer les valeurs manquantes en 0\nx &lt;- data.frame(X1 = c(1, NA, 2), X2 = c(NA, NA, 3))\nx\n\n  X1 X2\n1  1 NA\n2 NA NA\n3  2  3\n\nx[is.na(x)] &lt;- 0\nx\n\n  X1 X2\n1  1  0\n2  0  0\n3  2  3\n\n\n\n# Pour les valeurs manquantes, toujours utiliser is.na et non ==\nNA == c(3, 1, 3, NA)\n\n[1] NA NA NA NA\n\nis.na(c(3, 1, 3, NA))\n\n[1] FALSE FALSE FALSE  TRUE\n\n\n\n# Utiliser %in% et non == pour vérifier une appartenance à plusieurs variables\nx1 &lt;- 1:6\nx1 == c(1, 5)\n\n[1]  TRUE FALSE FALSE FALSE FALSE FALSE\n\nx1 %in% c(1, 5)\n\n[1]  TRUE FALSE FALSE FALSE  TRUE FALSE\n\n\n\n# Sélection de données en cas de valeurs manquantes\nxna &lt;- c(1, NA, 3, 2, 4, 2)\n\n\n# Avec ce code, les NA sont conservés\nxna[xna == 2]\n\n[1] NA  2  2\n\n\n\n# Code sans les NA\nxna[!is.na(xna) & xna == 2]\n\n[1] 2 2\n\n\n\n# Code compact sans les NA\nxna[which(xna == 2)]\n\n[1] 2 2\n\n\n\n# Incidence des NA dans le calcul de statistiques !\n# Besoin de l'instruction na.rm = TRUE pour en supprimer l'incidence\nx &lt;- c(1, 5, 6, NA, 8)\nmean(x)\n\n[1] NA\n\nmean(x, na.rm = TRUE)\n\n[1] 5\n\nmax(x)\n\n[1] NA\n\nmax(x, na.rm = TRUE)\n\n[1] 8"
  },
  {
    "objectID": "Trucs et astuces en R.html#sélection-déléments",
    "href": "Trucs et astuces en R.html#sélection-déléments",
    "title": "Trucs et astuces en R",
    "section": "1.9 Sélection d’éléments",
    "text": "1.9 Sélection d’éléments\n\n# Le 1er élément est numéroté 1 et non 0 comme dans Python\nx &lt;- 1:3\nx[c(0, 4)] &lt;- c(-1, 9)\n# Marche !!\nfor(i in 0:3) print(x[i])\n\nnumeric(0)\n[1] 1\n[1] 2\n[1] 3\n\n\n\n# Cas où les noms ne sont pas uniques\nx &lt;- c(a = 1, b = 2, a = 3)\nx[\"a\"]\n\na \n1 \n\nx[names(x) %in% \"a\"]\n\na a \n1 3 \n\n\n\n# Options drop = FALSE\nx &lt;- data.frame(X1 = c(1,2), X2 = c(3,4), x3 = c(5,6))\nis.data.frame(x[, c(1,2)])\n\n[1] TRUE\n\nis.data.frame(x[, c(1)])\n\n[1] FALSE\n\nis.data.frame(x[, c(1), drop = FALSE])\n\n[1] TRUE\n\n\n\n# Fonction subset\nx &lt;- data.frame(x1 = c(1,2), x2 = c(3,4), x3 = c(5,6))\nsubset(x, select = x1)\n\n  x1\n1  1\n2  2\n\nsubset(x, select = -x1)\n\n  x2 x3\n1  3  5\n2  4  6\n\n\n\n# Correct\nsubset(x, x1 == 1)\n\n  x1 x2 x3\n1  1  3  5\n\n\n\n# Incorrect\nsubset(x, x1 = 1)\n\n  x1 x2 x3\n1  1  3  5\n2  2  4  6\n\n\n\n# Référence à des noms de colonne non usuels\ndf &lt;- data.frame(x = rnorm(5), y = runif(5))\nnames(df) &lt;- 1:2\n# Incorrect\ndf$1\n# Correct\ndf$`1`\n\nError: &lt;text&gt;:5:4: unexpected numeric constant\n4: # Incorrect\n5: df$1\n      ^\n\n\n\n# Utilisation de assign pour assigner une valeur à un objet en le désignant sous forme caractère\nassign('objet', 3:5)\nobjet\n\n[1] 3 4 5\n\nfor(i in 1:5) assign(paste('objet', i, sep = '_'), i)\nobjet_5\n\n[1] 5"
  },
  {
    "objectID": "Trucs et astuces en R.html#les-listes",
    "href": "Trucs et astuces en R.html#les-listes",
    "title": "Trucs et astuces en R",
    "section": "1.10 Les listes",
    "text": "1.10 Les listes\n\n# Ajouter un élément à une liste\nliste &lt;- list(1, 2)\nliste\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\nliste &lt;- c(liste, list(3))\nliste\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n\n\n\n# Trier une liste\nliste &lt;- list(\"2\" = 2, \"0\" = 0, \"1\" = 1)\nliste\n\n$`2`\n[1] 2\n\n$`0`\n[1] 0\n\n$`1`\n[1] 1\n\nliste[order(names(liste))]\n\n$`0`\n[1] 0\n\n$`1`\n[1] 1\n\n$`2`\n[1] 2\n\n\n\n# Extraction de listes\nliste &lt;- list(nombres = 1:5, lettres = letters[1:5])\nliste$nombres\n\n[1] 1 2 3 4 5\n\n\n\n# On veut faire appel à un élement de la liste à partir d'une variable extérieure\nvar &lt;- \"nombres\"\n\n\n# Ne marche pas, car nombres est en caractère\nliste$var\n\nNULL\n\n\n\n# Fonctionne\nliste[[var]]\n\n[1] 1 2 3 4 5\n\n\n\n# Sélection dans une liste\nliste &lt;- list(nombres = 1:5, lettres = letters[1:5])\nliste[\"nombres\"]\n\n$nombres\n[1] 1 2 3 4 5\n\nis.list(liste[\"nombres\"])\n\n[1] TRUE\n\nliste[[\"nombres\"]]\n\n[1] 1 2 3 4 5\n\nis.list(liste[[\"nombres\"]])\n\n[1] FALSE\n\n\n\n# Suppression des éléments d'une liste\nliste &lt;- list(nombres = 1:5, lettres = letters[1:5])\nliste[-1]\n\n$lettres\n[1] \"a\" \"b\" \"c\" \"d\" \"e\"\n\nliste[\"nombres\"] &lt;- NULL\nliste\n\n$lettres\n[1] \"a\" \"b\" \"c\" \"d\" \"e\""
  },
  {
    "objectID": "Trucs et astuces en R.html#informations-sur-r",
    "href": "Trucs et astuces en R.html#informations-sur-r",
    "title": "Trucs et astuces en R",
    "section": "1.11 Informations sur R",
    "text": "1.11 Informations sur R\n\n# Informations sur la session de R\nsessionInfo()\nSys.info()\n.Platform\n\n# Version de R\nR.version.string\n\n# Lien vers le bureau de l'utilisateur\nfile.path(path.expand('~'), \"Desktop\")\n\n# Chemin de l'exécutable R est-il installé ?\nR.home(\"bin\")\n\n# Où sont installés les packages R\n.libPaths()"
  },
  {
    "objectID": "Trucs et astuces en R.html#trucs-et-astuces-divers",
    "href": "Trucs et astuces en R.html#trucs-et-astuces-divers",
    "title": "Trucs et astuces en R",
    "section": "1.12 Trucs et astuces divers",
    "text": "1.12 Trucs et astuces divers\n\n# Créer un objet sous forme de code R !\ndata(\"cars\")\ndput(cars)\n\nstructure(list(speed = c(4, 4, 7, 7, 8, 9, 10, 10, 10, 11, 11, \n12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 16, \n16, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 20, 20, 20, 20, 20, \n22, 23, 24, 24, 24, 24, 25), dist = c(2, 10, 4, 22, 16, 10, 18, \n26, 34, 17, 28, 14, 20, 24, 28, 26, 34, 34, 46, 26, 36, 60, 80, \n20, 26, 54, 32, 40, 32, 40, 50, 42, 56, 76, 84, 36, 46, 68, 32, \n48, 52, 56, 64, 66, 54, 70, 92, 93, 120, 85)), class = \"data.frame\", row.names = c(NA, \n-50L))\n\n\n\n# Outils de debuggage\noptions(error = recover)\noptions(error=NULL)\n\n\n# Définir ses propres opérateurs\n# R reconnait le texte entre %% comme un opérateur binaire\n# Exemple, simplifier la fonction paste\n'%+%' &lt;- function(x, y) { paste(x, y, sep = \"\") }\n\"Groupe_\" %+% 0:9\n\n [1] \"Groupe_0\" \"Groupe_1\" \"Groupe_2\" \"Groupe_3\" \"Groupe_4\" \"Groupe_5\"\n [7] \"Groupe_6\" \"Groupe_7\" \"Groupe_8\" \"Groupe_9\""
  },
  {
    "objectID": "Trucs et astuces en R.html#comment-utiliser-cet-aide-mémoire",
    "href": "Trucs et astuces en R.html#comment-utiliser-cet-aide-mémoire",
    "title": "Trucs et astuces en R",
    "section": "2.1 Comment utiliser cet aide-mémoire ?",
    "text": "2.1 Comment utiliser cet aide-mémoire ?\nSont présentés dans cet aide-mémoire des programmes statistiques courants pour la gestion de données statistiques, traduits dans les langages SAS et R (environnements R-Base, Tidyverse et data.table). Ces tâches sont standards dans l’analyse statistique et réalisables en un petit nombre d’instructions.\nCet aide-mémoire vise à faciliter la traduction des programmes statistiques entre ces différents langages (de SAS vers R, et d’un environnement R à un autre), et leur appropriation.\nIl est présenté sous forme de tâches élémentaires statistiques (sélection de lignes ou de colonnes d’une base de données, repérage des doublons, etc.).\nTrois grands environnements R sont traités : R-Base, Tidyverse et data.table. Ils ne doivent pas être vus comme des concurrents, mais comme des compléments :\n\ncertaines tâches peuvent être plus ou moins facilement réalisés avec l’un ou l’autre ;\nils présentent chacun des avantages et des inconvénients ;\nils laissent le choix de la stratégie de codage.\n\nCe guide est destiné à vous permettre de jongler plus facilement entre les environnements.\nPlusieurs solutions pour réaliser la même tâche sont proposées dans ce guide :\n\ncertaines solutions peuvent être plus concises, mais moins claires ;\nd’autres plus ou moins rapides en fonction des données et des matériels et logiciels utilisés ;\ncertaines façons de procéder sont plus efficaces que d’autres en R, mais cela peut dépendre des données et du matériel utilisé.\n\nL’attention du lecteur est attirée sur le fait que :\n\nce guide n’est pas exhaustf. Ainsi, les environnements peuvent proposer des solutions ad-hoc simplifiant grandement la résolution de problèmes moins courants et qui ne sont pas présents dans les autres environnements (ex. des rolling joins de data.table) ;\nce guide ne traite pas de ces stratégies, et le lecteur est invité à se documenter sur les environnements pour en savoir plus ;\nl’exercice de traduction de SAS vers R peut s’apparenter à la traduction d’un texte en langue étrangère. De même qu’une traduction littérale d’un texte en peut parfois être de mauvaise qualité, la traduction littérale d’une masse de codes SAS en codes R au moyen de cet aide-mémoire peut produire des résultats décevants. En effet, toute bonne traduction nécessite au moins a minima d’adapter le code SAS à une “nouvelle langue”, celle de R. La partie sur les spécificités de SAS par rapport à R peut vous aider sur ce point."
  },
  {
    "objectID": "Trucs et astuces en R.html#spécificités-de-sas-par-rapport-à-r",
    "href": "Trucs et astuces en R.html#spécificités-de-sas-par-rapport-à-r",
    "title": "Trucs et astuces en R",
    "section": "2.2 Spécificités de SAS par rapport à R",
    "text": "2.2 Spécificités de SAS par rapport à R\nVoici une liste non-exhaustive de spécificités de SAS par rapport à R à connaître.\nR est sensible à la casse, ce qui n’est pas le cas de SAS. Un même nom de variable en majuscule et en minuscule désigne deux variables différentes en R, une seule en SAS.\nR est un logiciel libre (ce qui implique notamment qu’il est gratuit, librement reproductible, modifiable et diffusable, et son code source est ouvert). En revanche, SAS est un logiciel propriétaire.\nSAS est un langage centralisé, R un langage décentralisé.\nDe par son statut de logiciel libre, de multiples extensions existent (packages). L’usage des packages :\n\npeut être un atout, car les packages permettent de réaliser plus facilement des choses complexes ;\npeut aussi être source de problèmes, d’abord de maintenance du fait des dépendances (une mise-à-jour peut casser les dépendances), ensuite du fait que des packages peuvent disparaître ou ne plus être maintenus au cours du temps, engendrant des coûts de maintenance de code ;\npeut engendrer des problèmes de rétrocompatibilité (un code écrit dans le passé ne fonctionne plus suite à une mise-à-jour) : il convient d’être conscient de ces considérations avant d’utiliser aveuglément des packages.\n\nR propose plusieurs façons de procéder (différents environnements, différents packages, etc.), tandis que SAS tend à ne proposer qu’une ou deux solutions.\nR est le langage / logiciel, à ne pas confondre avec RStudio, qui est uniquement un IDE (Integrated Development Environment, interface graphique), parmi d’autres. Une telle distinction n’a pas lieu pour SAS.\nLa gestion de la mémoire est différente entre les logiciels. R importe l’ensemble des données en mémoire vive, SAS en copie une partie sur le disque dur. Ceci a plusieurs implications pour le travail statistique :\n\nsi le volume des données excède la mémoire vive, il n’est pas possible de les traiter nativement en R. Il faut alors utiliser des stratégies alternatives ;\nil faut être parcimonieux sur le nombre de colonnes à inclure dans les bases de données en R. Par exemple, il vaut mieux recréer dans le programme les variables explicatives faciles à obtenir plutôt que les inclure dans la base de données, où elles occupent de la place et accaparent de la mémoire vive.\n\nQuelles solutions adopter dans le cas où les données à mpanipuler ne tiennent pas en mémoire vive de l’ordinateur ?\n\nchercher à réduire la taille de la base de données en supprimant des colonnes inutiles ;\nchercher à modifier le processus de production pour le rendre moins gourmand en mémoire ;\naugmenter la mémoire vive de son ordinateur ;\nutiliser les packages Arrow et DuckDb qui peuvent gérer des données excédant la mémoire vive.\n\nR a plusieurs spécificités à connaître par rapport à SAS : COMPLETER\n\nvectorisation plutôt que boucle (ex.)\nrecycling\nfonctions plutôt que macro\ngestion de la mémoire spécifique : shallow / deep copy, créer une colonne / une ligne pour l’exemple / Exemple de boucle inefficace / certaines façons sont +/- efficaces"
  }
]