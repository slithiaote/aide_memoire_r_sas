[
  {
    "objectID": "Trucs et astuces en R.html",
    "href": "Trucs et astuces en R.html",
    "title": "Trucs et astuces en R",
    "section": "",
    "text": "Voici quelques trucs et astuces utiles à connaître sur R, des livres The R Inferno et Advanced R, à consulter pour plus de détails.\nOptions quarto"
  },
  {
    "objectID": "Trucs et astuces en R.html#les-types-dobjet",
    "href": "Trucs et astuces en R.html#les-types-dobjet",
    "title": "Trucs et astuces en R",
    "section": "1.1 Les types d’objet",
    "text": "1.1 Les types d’objet\n\n# En savoir plus sur ses données\ndata(\"cars\")\nx &lt;- cars\ntypeof(x)\n\n[1] \"list\"\n\nclass(x)\n\n[1] \"data.frame\"\n\nmode(x)\n\n[1] \"list\"\n\nstr(x)\n\n'data.frame':   50 obs. of  2 variables:\n $ speed: num  4 4 7 7 8 9 10 10 10 11 ...\n $ dist : num  2 10 4 22 16 10 18 26 34 17 ...\n\ndim(x)\n\n[1] 50  2\n\nis.data.frame(x)\n\n[1] TRUE\n\nis.list(x)\n\n[1] TRUE\n\nis.vector(x)\n\n[1] FALSE\n\nis.array(x)\n\n[1] FALSE"
  },
  {
    "objectID": "Trucs et astuces en R.html#les-affectations",
    "href": "Trucs et astuces en R.html#les-affectations",
    "title": "Trucs et astuces en R",
    "section": "1.2 Les affectations",
    "text": "1.2 Les affectations\n\n# Importance des espaces\nx&lt;-3\nx\n\n[1] 3\n\n# S'agit-il de ?\nx &lt;- 3\nx &lt; -3\n\n[1] FALSE\n\n\n\n# Les {} permettent de réaliser une affectation (&lt;-) au sein d'un traitement plus complexe !\n# Exemple ici : sommer les positions paires multipliées par 2 et les positions impaires multipliées par 3\nsum({x &lt;- 1:6 ; x[1:length(x) %% 2 == 0] &lt;- x[1:length(x) %% 2 == 0] * 2 ; x[1:length(x) %% 2 != 0] &lt;- x[1:length(x) %% 2 != 0] * 3 ; x})\n\n[1] 51\n\n\n\n# Afficher ou non la valeur de l'objet affecté pendant l'affectation\nx &lt;- pi\n(x &lt;- pi)\n\n[1] 3.141593\n\n\n\n# Comparaisons multiples\nx &lt;- 0.5\n# Correct\n0 &lt; x & x &lt; 1\n# Incorrect\n0 &lt; x &lt; 1\n\nError: &lt;text&gt;:6:7: unexpected '&lt;'\n5: # Incorrect\n6: 0 &lt; x &lt;\n         ^\n\n\n\n# Ne pas confondre !\nseq(0:10)\n\n [1]  1  2  3  4  5  6  7  8  9 10 11\n\n0:10\n\n [1]  0  1  2  3  4  5  6  7  8  9 10\n\nseq(0, 10)\n\n [1]  0  1  2  3  4  5  6  7  8  9 10\n\n\n\n# Privilégier seq_len à : lorsqu'il y a un risque de 0\n# Fonctionnement identique\nn &lt;- 5\n1:n\n\n[1] 1 2 3 4 5\n\nseq_len(n)\n\n[1] 1 2 3 4 5\n\n# Problème avec les 0\nn &lt;- 0\n1:n\n\n[1] 1 0\n\nseq_len(n)\n\ninteger(0)\n\n\n\n# Préférer seq_along à : au cas où la taille de l'objet est 0\nx &lt;- c() ;length(x)\n\n[1] 0\n\nfor(i in 1:length(x)) print(i)\n\n[1] 1\n[1] 0\n\nfor(i in seq_along(x)) print(i)\nfor(i in seq(along=x)) print(i)\n\n\n# Equivalent des list-comprehensions de type Python en R\n# Somme des entiers de 1 à 1 000 multiples de 3 ou 5, en une ligne !\n# 3 manières de faire\nsum({l &lt;- 1:1000 ; l[l %% 3 == 0 | l %% 5 == 0]})\n\n[1] 234168\n\nsum({l &lt;- 1:1000 ; l[seq_along(l) %% 3 == 0 | seq_along(l) %% 5 == 0]})\n\n[1] 234168\n\nsum(l&lt;-(1:1000)[l %% 3 == 0 | l %% 5 == 0])\n\n[1] 234168\n\nsum((1:1000)[(1:1000 %% 3) == 0 | (1:1000 %% 5) == 0])\n\n[1] 234168\n\n\n\n# Opérations mathématiques\n# Infini\n1/0\n\n[1] Inf\n\n# Nan = not a number\n0/0\n\n[1] NaN\n\nlog(-1)\n\n[1] NaN"
  },
  {
    "objectID": "Trucs et astuces en R.html#principe-de-vectorisation",
    "href": "Trucs et astuces en R.html#principe-de-vectorisation",
    "title": "Trucs et astuces en R",
    "section": "1.3 Principe de vectorisation",
    "text": "1.3 Principe de vectorisation\nLa fonction s’applique à tous les éléments du vecteur !!\n\n# Exemple de vecteur\nvaleurs &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nvaleurs &lt;- 1:10\n\n\n# Valeurs au carré\nvaleurs ** 2\n\n [1]   1   4   9  16  25  36  49  64  81 100\n\n\n\n# logarithme des valeurs\nlog(valeurs)\n\n [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 1.7917595 1.9459101\n [8] 2.0794415 2.1972246 2.3025851\n\n\n\n# Maximum des valeurs\nmax(valeurs)\n\n[1] 10\n\n\n\n# Limite des valeurs\nrange(valeurs)\n\n[1]  1 10\n\n\n\n# Problèmes\n# Correct\nmean(valeurs)\n\n[1] 5.5\n\n\n\n# Correct\nmean(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))\n\n[1] 5.5\n\n\n\n# Inattendu\nmean(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n\n[1] 1\n\n\n\n# Attention aux parenthèses !\nn &lt;- 10\n1:n-1\n\n [1] 0 1 2 3 4 5 6 7 8 9\n\n1:(n-1)\n\n[1] 1 2 3 4 5 6 7 8 9\n\n\n\n# Minimum ou maximum élément par élément\nx1 &lt;- c(1, 2, 5, 6, 8)\nx2 &lt;- c(4, 0, 7, 2, 1)\n# Minimum : 2 possibilités\npmin(x1, x2)\n\n[1] 1 0 5 2 1\n\nmapply(min, x1, x2)\n\n[1] 1 0 5 2 1\n\n# Maximum : 2 possibilités\npmax(x1, x2)\n\n[1] 4 2 7 6 8\n\nmapply(max, x1, x2)\n\n[1] 4 2 7 6 8\n\n\n\n# Calculer (x - min) / (max - min) pour chaque élément x d'un vecteur\nx &lt;- c(1,2,3)\nsapply(x, function(xi, mn, mx) {(xi - mn) / (mx - mn)}, mn = min(x), mx = max(x))\n\n[1] 0.0 0.5 1.0"
  },
  {
    "objectID": "Trucs et astuces en R.html#principe-de-coercion",
    "href": "Trucs et astuces en R.html#principe-de-coercion",
    "title": "Trucs et astuces en R",
    "section": "1.4 Principe de coercion",
    "text": "1.4 Principe de coercion\nDans les comparaisons, les objets R sont successivement convertis en logical, integer, numeric, complexe et character, jusqu’à ce que la comaraison puisse se faire\n\n# TRUE / FALSE est transformé en integer (1 / 0)\nTRUE == 1\n\n[1] TRUE\n\nTRUE == 2\n\n[1] FALSE\n\n\n\n# TRUE est converti en character\nTRUE == \"1\"\n\n[1] FALSE\n\n\n\n# 5 est converti en character\n5 &lt; '7'\n\n[1] TRUE\n\n\n\n# 50 est converti en character\n50 &lt; '7'\n\n[1] TRUE"
  },
  {
    "objectID": "Trucs et astuces en R.html#opérateurs-de-contrôle",
    "href": "Trucs et astuces en R.html#opérateurs-de-contrôle",
    "title": "Trucs et astuces en R",
    "section": "1.5 Opérateurs de contrôle",
    "text": "1.5 Opérateurs de contrôle\n\n# Conditions if / else\nx &lt;- 1\n\n\n# Correct\nif (identical(x, 1)) {\nprint(\"x est égal à 1\")\n} else {\nprint(\"x est différent de 1\")\n}\n\n[1] \"x est égal à 1\"\n\n\n\n# Correct\nif (identical(x, 1)) {print(\"x est égal à 1\")\n} else {print(\"x est différent de 1\")}\n\n[1] \"x est égal à 1\"\n\n\n\n# Correct\nif (identical(x, 1)) print(\"x est égal à 1\") else\nprint(\"x est différent de 1\")\n\n[1] \"x est égal à 1\"\n\n\n\n# Correct\nif (identical(x, 1)) print(\"x est égal à 1\") else print(\"x est différent de 1\")\n\n[1] \"x est égal à 1\"\n\n\n\n# Incorrect\nif (identical(x, 1)) print(\"x est égal à 1\")\nelse print(\"x est différent de 1\")\n\nError: &lt;text&gt;:3:1: unexpected 'else'\n2: if (identical(x, 1)) print(\"x est égal à 1\")\n3: else\n   ^\n\n\n\n# Switch\n# Fonctions et conditions if / else\ncondition &lt;- function(langue = \"Français\") {\nif (langue == \"Français\") {\n\"salut\"\n} else if (langue == \"Anglais\") {\n\"hello\"\n} else if (langue == \"Russe\") {\n\"привет\"\n} else {\nstop(\"salut\")\n}\n}\ncondition(\"Anglais\")\n\n[1] \"hello\"\n\n\n\n# Autre possibilité avec switch, mais à réserver aux variables caractères !\ncondition &lt;- function(langue = \"Français\") {\nswitch(langue,\nFrançais = \"salut\",\nAnglais = \"hello\",\nRusse = \"привет\",\nstop(\"salut\")\n)\n}\ncondition(\"Français\")\n\n[1] \"salut\"\n\n\n\n# Penser au print\nfor(i in 1:10) i\nfor(i in 1:10) print(i)\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n\n\n\n# Différences print et cat\ncat(\"Salut !\\nComment vas-tu ?\")\n\nSalut !\nComment vas-tu ?\n\nprint(\"Salut !\\nComment vas-tu ?\")\n\n[1] \"Salut !\\nComment vas-tu ?\""
  },
  {
    "objectID": "Trucs et astuces en R.html#les-valeurs-manquantes",
    "href": "Trucs et astuces en R.html#les-valeurs-manquantes",
    "title": "Trucs et astuces en R",
    "section": "1.6 Les valeurs manquantes",
    "text": "1.6 Les valeurs manquantes\n\n# Transformer les valeurs manquantes en 0\nx &lt;- data.frame(X1 = c(1, NA, 2), X2 = c(NA, NA, 3))\nx[is.na(x)] &lt;- 0\n\n\n# Pour les valeurs manquantes, toujours utiliser is.na et non ==\nNA == c(3, 1, 3, NA)\n\n[1] NA NA NA NA\n\nis.na(c(3, 1, 3, NA))\n\n[1] FALSE FALSE FALSE  TRUE\n\n\n\n# Utiliser %in% et non == pour vérifier une appartenance à plusieurs variables\nx1 &lt;- 1:6\nx1 == c(1, 5)\n\n[1]  TRUE FALSE FALSE FALSE FALSE FALSE\n\nx1 %in% c(1, 5)\n\n[1]  TRUE FALSE FALSE FALSE  TRUE FALSE\n\n\n\n# Sélection de données en cas de valeurs manquantes\nxna &lt;- c(1, NA, 3, 2, 4, 2)\n\n\n# Avec ce code, les NA sont conservés\nxna[xna == 2]\n\n[1] NA  2  2\n\n\n\n# Code sans les NA\nxna[!is.na(xna) & xna == 2]\n\n[1] 2 2\n\n\n\n# Code compact sans les NA\nxna[which(xna == 2)]\n\n[1] 2 2"
  },
  {
    "objectID": "Trucs et astuces en R.html#sélection-déléments",
    "href": "Trucs et astuces en R.html#sélection-déléments",
    "title": "Trucs et astuces en R",
    "section": "1.7 Sélection d’éléments",
    "text": "1.7 Sélection d’éléments\n\n# Le 1er élément est numéroté 1 et non 0 comme dans Python\nx &lt;- 1:3\nx[c(0, 4)] &lt;- c(-1, 9)\n# Marche !!\nfor(i in 0:3) print(x[i])\n\nnumeric(0)\n[1] 1\n[1] 2\n[1] 3\n\n\n\n# Cas où les noms ne sont pas uniques\nx &lt;- c(a = 1, b = 2, a = 3)\nx[\"a\"]\n\na \n1 \n\nx[names(x) %in% 'a']\n\na a \n1 3 \n\n\n\n# Options drop = FALSE\nx &lt;- data.frame(X1 = c(1,2), X2 = c(3,4), x3 = c(5,6))\nis.data.frame(x[, c(1,2)])\n\n[1] TRUE\n\nis.data.frame(x[, c(1)])\n\n[1] FALSE\n\nis.data.frame(x[, c(1), drop = FALSE])\n\n[1] TRUE\n\n\n\n# Fonction subset\nx &lt;- data.frame(x1 = c(1,2), x2 = c(3,4), x3 = c(5,6))\nsubset(x, select = x1)\n\n  x1\n1  1\n2  2\n\nsubset(x, select = -x1)\n\n  x2 x3\n1  3  5\n2  4  6\n\n\n\n# Correct\nsubset(x, x1 == 1)\n\n  x1 x2 x3\n1  1  3  5\n\n\n\n# Incorrect\nsubset(x, x1 = 1)\n\n  x1 x2 x3\n1  1  3  5\n2  2  4  6\n\n\n\n# Référence à des noms de colonne non usuels\ndf &lt;- data.frame(x = rnorm(5), y = runif(5))\nnames(df) &lt;- 1:2\n# Incorrect\ndf$1\n# Correct\ndf$`1`\n\nError: &lt;text&gt;:5:4: unexpected numeric constant\n4: # Incorrect\n5: df$1\n      ^\n\n\n\n# Utilisation de assign pour assigner une valeur à un objet en le désignant sous forme caractère\nassign('objet', 3:5)\nobjet\n\n[1] 3 4 5\n\nfor(i in 1:5) assign(paste('objet', i, sep = '_'), i)\nobjet_5\n\n[1] 5"
  },
  {
    "objectID": "Trucs et astuces en R.html#les-listes",
    "href": "Trucs et astuces en R.html#les-listes",
    "title": "Trucs et astuces en R",
    "section": "1.8 Les listes",
    "text": "1.8 Les listes\n\n# Ajouter un élément à une liste\nliste &lt;- list(1, 2)\nliste\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\nliste &lt;- c(liste, list(3))\nliste\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n\n\n\n# Trier une liste\nliste &lt;- list(\"2\" = 2, \"0\" = 0, \"1\" = 1)\nliste\n\n$`2`\n[1] 2\n\n$`0`\n[1] 0\n\n$`1`\n[1] 1\n\nliste[order(names(liste))]\n\n$`0`\n[1] 0\n\n$`1`\n[1] 1\n\n$`2`\n[1] 2\n\n\n\n# Extraction de listes\nliste &lt;- list(nombres = 1:5, lettres = letters[1:5])\nliste$nombres\n\n[1] 1 2 3 4 5\n\n\n\n# On veut faire appel à un élement de la liste à partir d'une variable extérieure\nvar &lt;- \"nombres\"\n\n\n# Ne marche pas, car nombres est en caractère\nliste$var\n\nNULL\n\n\n\n# Fonctionne\nliste[[var]]\n\n[1] 1 2 3 4 5\n\n\n\n# Sélection dans une liste\nliste &lt;- list(nombres = 1:5, lettres = letters[1:5])\nliste[\"nombres\"]\n\n$nombres\n[1] 1 2 3 4 5\n\nis.list(liste[\"nombres\"])\n\n[1] TRUE\n\nliste[[\"nombres\"]]\n\n[1] 1 2 3 4 5\n\nis.list(liste[[\"nombres\"]])\n\n[1] FALSE\n\n\n\n# Suppression des éléments d'une liste\nliste &lt;- list(nombres = 1:5, lettres = letters[1:5])\nliste[-1]\n\n$lettres\n[1] \"a\" \"b\" \"c\" \"d\" \"e\"\n\nliste[\"nombres\"] &lt;- NULL\nliste\n\n$lettres\n[1] \"a\" \"b\" \"c\" \"d\" \"e\""
  },
  {
    "objectID": "Trucs et astuces en R.html#effets-des-calculs-en-virgule-flottante",
    "href": "Trucs et astuces en R.html#effets-des-calculs-en-virgule-flottante",
    "title": "Trucs et astuces en R",
    "section": "1.9 Effets des calculs en virgule flottante",
    "text": "1.9 Effets des calculs en virgule flottante\n\n.1 == .3 / 3\n\n[1] FALSE\n\nseq(0, 1, by=.1) == .3\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\nunique(c(.3, .4 - .1, .5 - .2, .6 - .3, .7 - .4))\n\n[1] 0.3 0.3 0.3"
  },
  {
    "objectID": "Trucs et astuces en R.html#trucs-et-astuces-divers",
    "href": "Trucs et astuces en R.html#trucs-et-astuces-divers",
    "title": "Trucs et astuces en R",
    "section": "1.10 Trucs et astuces divers",
    "text": "1.10 Trucs et astuces divers\n\n# Créer un objet sous forme de code R !\ndata(\"cars\")\ndput(cars)\n\nstructure(list(speed = c(4, 4, 7, 7, 8, 9, 10, 10, 10, 11, 11, \n12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 16, \n16, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 20, 20, 20, 20, 20, \n22, 23, 24, 24, 24, 24, 25), dist = c(2, 10, 4, 22, 16, 10, 18, \n26, 34, 17, 28, 14, 20, 24, 28, 26, 34, 34, 46, 26, 36, 60, 80, \n20, 26, 54, 32, 40, 32, 40, 50, 42, 56, 76, 84, 36, 46, 68, 32, \n48, 52, 56, 64, 66, 54, 70, 92, 93, 120, 85)), class = \"data.frame\", row.names = c(NA, \n-50L))\n\n\n\n# Outils de debuggage\noptions(error = recover)\noptions(error=NULL)\n\n\n# Définir ses propres opérateurs\n# R reconnait le texte entre %% comme un opérateur binaire\n# Exemple, simplifier la fonction paste\n'%+%' &lt;- function(x, y) { paste(x, y, sep = \"\") }\n\"Groupe_\" %+% 0:9\n\n [1] \"Groupe_0\" \"Groupe_1\" \"Groupe_2\" \"Groupe_3\" \"Groupe_4\" \"Groupe_5\"\n [7] \"Groupe_6\" \"Groupe_7\" \"Groupe_8\" \"Groupe_9\"\n\n\n\nunordered list\n\nsub-item 1\nsub-item 2\n\nsub-sub-item 1"
  },
  {
    "objectID": "Trucs et astuces en R.html#comment-utiliser-cet-aide-mémoire",
    "href": "Trucs et astuces en R.html#comment-utiliser-cet-aide-mémoire",
    "title": "Trucs et astuces en R",
    "section": "2.1 Comment utiliser cet aide-mémoire ?",
    "text": "2.1 Comment utiliser cet aide-mémoire ?\nSont présentés dans cet aide-mémoire des programmes statistiques courants pour la gestion de données statistiques, traduits dans les langages SAS et R (environnements R-Base, Tidyverse et data.table). Ces tâches sont standards dans l’analyse statistique et réalisables en un petit nombre d’instructions.\nCet aide-mémoire vise à faciliter la traduction des programmes statistiques entre ces différents langages (de SAS vers R, et d’un environnement R à un autre), et leur appropriation.\nIl est présenté sous forme de tâches élémentaires statistiques (sélection de lignes ou de colonnes d’une base de données, repérage des doublons, etc.).\nTrois grands environnements R sont traités : R-Base, Tidyverse et data.table. Ils ne doivent pas être vus comme des concurrents, mais comme des compléments :\n\ncertaines tâches peuvent être plus ou moins facilement réalisés avec l’un ou l’autre ;\nils présentent chacun des avantages et des inconvénients ;\nils laissent le choix de la stratégie de codage.\n\nCe guide est destiné à vous permettre de jongler plus facilement entre les environnements.\nPlusieurs solutions pour réaliser la même tâche sont proposées dans ce guide :\n\ncertaines solutions peuvent être plus concises, mais moins claires ;\nd’autres plus ou moins rapides en fonction des données et des matériels et logiciels utilisés ;\ncertaines façons de procéder sont plus efficaces que d’autres en R, mais cela peut dépendre des données et du matériel utilisé.\n\nL’attention du lecteur est attirée sur le fait que :\n\nce guide n’est pas exhaustf. Ainsi, les environnements peuvent proposer des solutions ad-hoc simplifiant grandement la résolution de problèmes moins courants et qui ne sont pas présents dans les autres environnements (ex. des rolling joins de data.table) ;\nce guide ne traite pas de ces stratégies, et le lecteur est invité à se documenter sur les environnements pour en savoir plus ;\nl’exercice de traduction de SAS vers R peut s’apparenter à la traduction d’un texte en langue étrangère. De même qu’une traduction littérale d’un texte en peut parfois être de mauvaise qualité, la traduction littérale d’une masse de codes SAS en codes R au moyen de cet aide-mémoire peut produire des résultats décevants. En effet, toute bonne traduction nécessite au moins a minima d’adapter le code SAS à une “nouvelle langue”, celle de R. La partie sur les spécificités de SAS par rapport à R peut vous aider sur ce point."
  },
  {
    "objectID": "Trucs et astuces en R.html#spécificités-de-sas-par-rapport-à-r",
    "href": "Trucs et astuces en R.html#spécificités-de-sas-par-rapport-à-r",
    "title": "Trucs et astuces en R",
    "section": "2.2 Spécificités de SAS par rapport à R",
    "text": "2.2 Spécificités de SAS par rapport à R\nVoici une liste non-exhaustive de spécificités de SAS par rapport à R à connaître.\nR est sensible à la casse, ce qui n’est pas le cas de SAS. Un même nom de variable en majuscule et en minuscule désigne deux variables différentes en R, une seule en SAS.\nR est un logiciel libre (ce qui implique notamment qu’il est gratuit, librement reproductible, modifiable et diffusable, et son code source est ouvert). En revanche, SAS est un logiciel propriétaire.\nSAS est un langage centralisé, R un langage décentralisé.\nDe par son statut de logiciel libre, de multiples extensions existent (packages). L’usage des packages :\n\npeut être un atout, car les packages permettent de réaliser plus facilement des choses complexes ;\npeut aussi être source de problèmes, d’abord de maintenance du fait des dépendances (une mise-à-jour peut casser les dépendances), ensuite du fait que des packages peuvent disparaître ou ne plus être maintenus au cours du temps, engendrant des coûts de maintenance de code ;\npeut engendrer des problèmes de rétrocompatibilité (un code écrit dans le passé ne fonctionne plus suite à une mise-à-jour) : il convient d’être conscient de ces considérations avant d’utiliser aveuglément des packages.\n\nR propose plusieurs façons de procéder (différents environnements, différents packages, etc.), tandis que SAS tend à ne proposer qu’une ou deux solutions.\nR est le langage / logiciel, à ne pas confondre avec RStudio, qui est uniquement un IDE (Integrated Development Environment, interface graphique), parmi d’autres. Une telle distinction n’a pas lieu pour SAS.\nLa gestion de la mémoire est différente entre les logiciels. R importe l’ensemble des données en mémoire vive, SAS en copie une partie sur le disque dur. Ceci a plusieurs implications pour le travail statistique :\n\nsi le volume des données excède la mémoire vive, il n’est pas possible de les traiter nativement en R. Il faut alors utiliser des stratégies alternatives ;\nil faut être parcimonieux sur le nombre de colonnes à inclure dans les bases de données en R. Par exemple, il vaut mieux recréer dans le programme les variables explicatives faciles à obtenir plutôt que les inclure dans la base de données, où elles occupent de la place et accaparent de la mémoire vive.\n\nQuelles solutions adopter dans le cas où les données à mpanipuler ne tiennent pas en mémoire vive de l’ordinateur ?\n\nchercher à réduire la taille de la base de données en supprimant des colonnes inutiles ;\nchercher à modifier le processus de production pour le rendre moins gourmand en mémoire ;\naugmenter la mémoire vive de son ordinateur ;\nutiliser les packages Arrow et DuckDb qui peuvent gérer des données excédant la mémoire vive.\n\nR a plusieurs spécificités à connaître par rapport à SAS : COMPLETER\n\nvectorisation plutôt que boucle (ex.)\nrecycling\nfonctions plutôt que macro\ngestion de la mémoire spécifique : shallow / deep copy, créer une colonne / une ligne pour l’exemple / Exemple de boucle inefficace / certaines façons sont +/- efficaces"
  },
  {
    "objectID": "Trucs et astuces en R.html#avantages-et-inconvénients-des-environnements-r",
    "href": "Trucs et astuces en R.html#avantages-et-inconvénients-des-environnements-r",
    "title": "Trucs et astuces en R",
    "section": "2.3 Avantages et inconvénients des environnements R",
    "text": "2.3 Avantages et inconvénients des environnements R\n\n2.3.1 R Base\n\n2.3.1.1 Avantages :\n\nabsence de dépendance (ne s’appuie sur aucun package) : pas besoin d’installer un package, de gérer sa mise à jour, de craindre pour sa disparition\ngarantit la rétrocompatibilité du code : utile dans des environnements de production\ndans certains cas, se révèle la solution la plus simple\nparfois, la seule façon de faire\n\n\n\n2.3.1.2 Inconvénients :\n\nne permet pas de gérer des bases de données plus volumineuses que la mémoire vive\nsyntaxe plus complexe et parfois incohérente\nsouvent moins rapide que les autres environnements\ndemande plus de connaissance sur le fonctionnement du langage R\ncertaines tâches sont plus simples à traiter avec les autres environnements\n\n\n\n\n2.3.2 Tidyverse\n\n2.3.2.1 Avantages :\n\nplus simple à prendre en main\nsyntaxe plus simple que les autres environnements et cohérente\nlargement utilisé dans la communauté R\ntend à s’imposer comme la référence de la gestion de données sur R\nsyntaxe utilisée également dans les packages Arrow / DuckDb\n\n\n\n2.3.2.2 Inconvénients :\n\nne permet pas de gérer des bases de données plus volumineuses que la mémoire vive\nforte dépendance : la rétrocompatibilité n’est pas assurée, potentiel problème dans un environnement de production\nglobalement moins rapide que data.table\ntâches non prévues plus difficiles à réaliser\ncertaines tâches sont plus simples à traiter avec les autres environnements\n\n\n\n\n2.3.3 data.table\n\n2.3.3.1 Avantages :\n\nfaible dépendance : garantit une rétrocompatibilité élevée\nsyntaxe proche du R Base\nplus rapide et puissant que ses concurrents\n\n\n\n2.3.3.2 Inconvénients :\n\nne permet pas de gérer des bases de données plus volumineuses que la mémoire vive\nsyntaxe parfois déroutante, incohérente, et peu explicite\nmoins utilisé\ncertaines tâches sont plus simples à traiter avec les autres environnements"
  },
  {
    "objectID": "Trucs et astuces en R.html#footnotes",
    "href": "Trucs et astuces en R.html#footnotes",
    "title": "Trucs et astuces en R",
    "section": "Notes de bas de page",
    "text": "Notes de bas de page\n\n\nDares/SCS, nassab.abdallah@travail.gouv.fr↩︎\nDares/DIP, damien.euzenat@travail.gouv.fr↩︎"
  },
  {
    "objectID": "qmd_minimal.html",
    "href": "qmd_minimal.html",
    "title": "Aide-mémoire SAS - R",
    "section": "",
    "text": "SASR basetidyversedata.tablearrow\n\n\nproc sql;\n  select count(*) as Nb_Lignes from Donnees_sas;\nquit;\n\n\n\n\n# Nombre de lignes et de colonnes dans la base\nsprintf(\n  \"Nombre de lignes : %d | Nombre de colonnes : %d\",\n  dim(donnees_rbase)[1], \n  dim(donnees_rbase)[2]\n)\n\n\n\n\n# Nombre de lignes\ndonnees_dplyr |&gt; nrow()\n\n# Nombre de colonnes\ndonnees_dplyr |&gt;  ncol()\n\n\n\n\n# Nombre de lignes\ndonnees_dt[, .N]\n\n# Nombre de colonnes\nprint(dim(donnees_dt)[2])\n\n\n\n\n# Nombre de lignes\ndonnees_arrow |&gt; nrow()\n\n# Nombre de colonnes\ndonnees_arrow |&gt;  ncol()"
  },
  {
    "objectID": "qmd_minimal.html#nombre-de-lignes-et-de-colonnes-dans-la-table",
    "href": "qmd_minimal.html#nombre-de-lignes-et-de-colonnes-dans-la-table",
    "title": "Aide-mémoire SAS - R",
    "section": "",
    "text": "SASR basetidyversedata.tablearrow\n\n\nproc sql;\n  select count(*) as Nb_Lignes from Donnees_sas;\nquit;\n\n\n\n\n# Nombre de lignes et de colonnes dans la base\nsprintf(\n  \"Nombre de lignes : %d | Nombre de colonnes : %d\",\n  dim(donnees_rbase)[1], \n  dim(donnees_rbase)[2]\n)\n\n\n\n\n# Nombre de lignes\ndonnees_dplyr |&gt; nrow()\n\n# Nombre de colonnes\ndonnees_dplyr |&gt;  ncol()\n\n\n\n\n# Nombre de lignes\ndonnees_dt[, .N]\n\n# Nombre de colonnes\nprint(dim(donnees_dt)[2])\n\n\n\n\n# Nombre de lignes\ndonnees_arrow |&gt; nrow()\n\n# Nombre de colonnes\ndonnees_arrow |&gt;  ncol()"
  },
  {
    "objectID": "qmd_minimal.html#afficher-les-noms-des-variables-de-la-table",
    "href": "qmd_minimal.html#afficher-les-noms-des-variables-de-la-table",
    "title": "Aide-mémoire SAS - R",
    "section": "Afficher les noms des variables de la table",
    "text": "Afficher les noms des variables de la table\n\nSASR basetidyversedata.tablearrow\n\n\nproc contents data = donnees_sas; run;\n\n\n\nnames(donnees_rbase)\n\n\n\n\ncolnames(donnees_dplyr)\n\n\n\n\nnames(donnees_dt)\n\n\n\n\ndonnees_arrow |&gt; colnames()"
  },
  {
    "objectID": "qmd_minimal.html#footnotes",
    "href": "qmd_minimal.html#footnotes",
    "title": "Aide-mémoire SAS - R",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nDares/DIP, damien.euzenat@travail.gouv.fr↩︎\nDares/SCS, nassab.abdallah@travail.gouv.fr↩︎\nDares/DIP, damien.euzenat@travail.gouv.fr↩︎\nDares/SCS, nassab.abdallah@travail.gouv.fr↩︎\nDares/DIP, damien.euzenat@travail.gouv.fr↩︎\nDares/SCS, nassab.abdallah@travail.gouv.fr↩︎"
  },
  {
    "objectID": "01-aide_memoire_r_sas.html",
    "href": "01-aide_memoire_r_sas.html",
    "title": "Aide-mémoire SAS - R",
    "section": "",
    "text": "L’aide-mémoire a pour but de fournir des codes écrits en SAS et d’en donner la traduction en R de trois manières possibles :\nLes éléments utilisés sont des codes typiques qui sont appliqués dans la production statistique ou dans la réalisation d’études descriptives.\nCe code s’adresse aux utilisateurs de SAS qui veulent connaître la traduction du code SAS en R ainsi qu’aux utilisateurs de R qui ont besoin de comprendre le code SAS.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#importation-des-packages",
    "href": "01-aide_memoire_r_sas.html#importation-des-packages",
    "title": "Aide-mémoire SAS - R",
    "section": "1 Importation des packages",
    "text": "1 Importation des packages\n\nlibrary(lubridate)\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(janitor)\nlibrary(SASmarkdown)\nlibrary(magrittr)",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#chemin-vers-le-bureau-et-affichage-de-la-date-et-de-lannée",
    "href": "01-aide_memoire_r_sas.html#chemin-vers-le-bureau-et-affichage-de-la-date-et-de-lannée",
    "title": "Aide-mémoire SAS - R",
    "section": "2 Chemin vers le bureau et affichage de la date et de l’année",
    "text": "2 Chemin vers le bureau et affichage de la date et de l’année\n\nSASR base\n\n\n/* Chemin du bureau de l'utilisateur */\n\n/* On vide la log */\ndm \"log; clear; \";\n\n/* On récupère déjà l'identifiant de l'utilisateur */\n%let user = &sysuserid;\n\n/* Chemin proprement dit */\n%let bureau = C:\\Users\\&user.\\Desktop;\nlibname bur \"&bureau.\";\n\n/* Affichage de l'année */\n%let an = %sysfunc(year(%sysfunc(today())));\n\n/* & (esperluette) indique à SAS qu'il doit remplacer an par sa valeur définie par le %let */\n%put Année : &an.;\n\n/* Autre possibilité */\ndata _null_;call symput('annee', strip(year(today())));run;\n%put Année (autre méthode) : &annee.;\n\n/* Année passée */\n%put Année passée : %eval(&an. - 1);\n\n\n\n# On récupère déjà l'identifiant de l'utilisateur\nuser &lt;- Sys.getenv(\"USERNAME\")\n# Chemin d'accès au bureau de l'utilisateur\nchemin &lt;- file.path(\"C:/Users\", user, \"Desktop\")\n\n# Affichage de l'année\nannee &lt;- lubridate::year(Sys.Date())\nsprintf(\"Année : %04d\", annee)\nprint(paste0(\"Année : \", annee))\nannee_1 &lt;- annee - 1\npaste0(\"Année passée: \", annee_1)\n\n\nif (annee &gt;= 2023) {\n  print(\"Nous sommes en 2023 ou après\")\n} else {\n  print(\"Nous sommes en 2022 ou avant\")\n}",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#création-dune-base-de-données",
    "href": "01-aide_memoire_r_sas.html#création-dune-base-de-données",
    "title": "Aide-mémoire SAS - R",
    "section": "3 Création d’une base de données",
    "text": "3 Création d’une base de données\n\nSASR basetidyverse\n\n\n/* Données fictives sur des formations */\ndata Donnees;\ninfile cards dsd dlm='|';\nformat Identifiant $3. Sexe_red 1. CSP $1. Niveau $30. Date_naissance ddmmyy10. Date_entree ddmmyy10. Duree Note_Contenu Note_Formateur Note_Moyens\nNote_Accompagnement Note_Materiel poids_sondage;\ninput Identifiant $ Sexe_red CSP $ Niveau $ Date_naissance :ddmmyy10. Date_entree :ddmmyy10. Duree Note_Contenu Note_Formateur Note_Moyens\nNote_Accompagnement Note_Materiel poids_sondage;\ncards;\n173|2|1|Qualifie|17/06/1998|01/01/2021|308|12|6|17|4|19|117.1\n173|2|1|qualifie|17/06/1998|01/01/2022|365|6||12|7|14|98.3\n173|2|1|qualifie|17/06/1998|06/01/2022|185|8|10|11|1|9|214.6\n173|2|1|Qualifie|17/06/1998|02/01/2023|365|14|15|15|10|8|84.7\n174|1|1|qualifie|08/12/1984|17/08/2021|183|17|18|20|15|12|65.9\n175|1|1|qualifie|16/09/1989|21/12/2022|730|5|5|8|4|9|148.2\n198|2|4|Non qualifie|17/03/1987|28/07/2022|30|10|10|10|16|8|89.6\n198|2|4|Qualifie|17/03/1987|17/11/2022|164|11|7|6|14|13|100.3\n198|2|4|Qualifie|17/03/1987|21/02/2023|365|9|20|3|4|17|49.3\n168|1|2|Qualifie|30/07/2002|04/09/2019|365|18|11|20|13|15|148.2\n211|2|3|Non qualifie||17/12/2021|135|16|16|15|12|9|86.4\n278|1|5|Qualifie|10/08/1948|07/06/2018|365|14|10|6|8|12|99.2\n347|2|5|Qualifie|13/09/1955||180|12|5|7|11|12|105.6\n112|1|3|Non qualifie|13/09/2001|02/03/2022|212|3|10|11|9|8|123.1\n112|1|3|Non qualifie|13/09/2001|01/03/2021|365|7|13|8|19|2|137.4\n112|1|3|Non qualifie|13/09/2001|01/12/2023|365||||||187.6\n087|1|3|Non qualifie|||365||||||87.3\n087|1|3|Non qualifie||31/10/2020|365||||||87.3\n099|1|3|qualifie|06/06/1998|01/03/2021|364|12|11|10|12|13|169.3\n099|1|3|qualifie|06/06/1998|01/03/2022|364|12|11|10|12|13|169.3\n099|1|3|qualifie|06/06/1998|01/03/2023|364|12|11|10|12|13|169.3\n187|2|2|qualifie|05/12/1986|01/01/2022|364|10|10|10|10|10|169.3\n187|2|2|qualifie|05/12/1986|01/01/2023|364|10|10|10|10|10|234.1\n689|1|1||01/12/2000|06/11/2017|123|9|7|8|13|16|189.3\n765|1|4|Non qualifie|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9\n765|1|4|Non qualifie|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9\n765|1|4|Non qualifie|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9\n;\nrun;\n\n\n\n# Création de la base R\na &lt;- \"Identifiant|Sexe_red|CSP|Niveau|Date_naissance|Date_entree|Duree|Note_Contenu|Note_Formateur|Note_Moyens|Note_Accompagnement|Note_Materiel|poids_sondage\n173|2|1|Qualifie|17/06/1998|01/01/2021|308|12|6|17|4|19|117.1\n173|2|1|qualifie|17/06/1998|01/01/2022|365|6||12|7|14|98.3\n173|2|1|qualifie|17/06/1998|06/01/2022|185|8|10|11|1|9|214.6\n173|2|1|Qualifie|17/06/1998|02/01/2023|365|14|15|15|10|8|84.7\n174|1|1|qualifie|08/12/1984|17/08/2021|183|17|18|20|15|12|65.9\n175|1|1|qualifie|16/09/1989|21/12/2022|730|5|5|8|4|9|148.2\n198|2|4|Non qualifie|17/03/1987|28/07/2022|30|10|10|10|16|8|89.6\n198|2|4|Qualifie|17/03/1987|17/11/2022|164|11|7|6|14|13|100.3\n198|2|4|Qualifie|17/03/1987|21/02/2023|365|9|20|3|4|17|49.3\n168|1|2|Qualifie|30/07/2002|04/09/2019|365|18|11|20|13|15|148.2\n211|2|3|Non qualifie||17/12/2021|135|16|16|15|12|9|86.4\n278|1|5|Qualifie|10/08/1948|07/06/2018|365|14|10|6|8|12|99.2\n347|2|5|Qualifie|13/09/1955||180|12|5|7|11|12|105.6\n112|1|3|Non qualifie|13/09/2001|02/03/2022|212|3|10|11|9|8|123.1\n112|1|3|Non qualifie|13/09/2001|01/03/2021|365|7|13|8|19|2|137.4\n112|1|3|Non qualifie|13/09/2001|01/12/2023|365||||||187.6\n087|1|3|Non qualifie|||365||||||87.3\n087|1|3|Non qualifie||31/10/2020|365||||||87.3\n099|1|3|qualifie|06/06/1998|01/03/2021|364|12|11|10|12|13|169.3\n099|1|3|qualifie|06/06/1998|01/03/2022|364|12|11|10|12|13|169.3\n099|1|3|qualifie|06/06/1998|01/03/2023|364|12|11|10|12|13|169.3\n187|2|2|qualifie|05/12/1986|01/01/2022|364|10|10|10|10|10|169.3\n187|2|2|qualifie|05/12/1986|01/01/2023|364|10|10|10|10|10|234.1\n689|1|1||01/12/2000|06/11/2017|123|9|7|8|13|16|189.3\n765|1|4|Non qualifie|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9\n765|1|4|Non qualifie|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9\n765|1|4|Non qualifie|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9\"\n\n\nfichier &lt;- file.path(chemin, \"Passage SAS à R.csv\")\n# On copie ce fichier texte sur le bureau de l'utilisateur\nwriteLines(a, con = fichier)\n\nError in file(con, \"w\"): cannot open the connection\n\n# On va importer ce fichier texte en base R (dataframe)\n# On importe la base de données dans R\n# on importe par défaut les colonnes en texte\n\ndonnees_rbase &lt;- read.csv(file.path(chemin, \"Passage SAS à R.csv\"), sep = \"|\", header = TRUE, na.strings = \"\",colClasses = rep(\"character\",length(data)))\n\nError in file(file, \"rt\"): cannot open the connection\n\n\n\n\n\n# Création de la base R\na &lt;- \"Identifiant|Sexe_red|CSP|Niveau|Date_naissance|Date_entree|Duree|Note_Contenu|Note_Formateur|Note_Moyens|Note_Accompagnement|Note_Materiel|poids_sondage\n173|2|1|Qualifie|17/06/1998|01/01/2021|308|12|6|17|4|19|117.1\n173|2|1|qualifie|17/06/1998|01/01/2022|365|6||12|7|14|98.3\n173|2|1|qualifie|17/06/1998|06/01/2022|185|8|10|11|1|9|214.6\n173|2|1|Qualifie|17/06/1998|02/01/2023|365|14|15|15|10|8|84.7\n174|1|1|qualifie|08/12/1984|17/08/2021|183|17|18|20|15|12|65.9\n175|1|1|qualifie|16/09/1989|21/12/2022|730|5|5|8|4|9|148.2\n198|2|4|Non qualifie|17/03/1987|28/07/2022|30|10|10|10|16|8|89.6\n198|2|4|Qualifie|17/03/1987|17/11/2022|164|11|7|6|14|13|100.3\n198|2|4|Qualifie|17/03/1987|21/02/2023|365|9|20|3|4|17|49.3\n168|1|2|Qualifie|30/07/2002|04/09/2019|365|18|11|20|13|15|148.2\n211|2|3|Non qualifie||17/12/2021|135|16|16|15|12|9|86.4\n278|1|5|Qualifie|10/08/1948|07/06/2018|365|14|10|6|8|12|99.2\n347|2|5|Qualifie|13/09/1955||180|12|5|7|11|12|105.6\n112|1|3|Non qualifie|13/09/2001|02/03/2022|212|3|10|11|9|8|123.1\n112|1|3|Non qualifie|13/09/2001|01/03/2021|365|7|13|8|19|2|137.4\n112|1|3|Non qualifie|13/09/2001|01/12/2023|365||||||187.6\n087|1|3|Non qualifie|||365||||||87.3\n087|1|3|Non qualifie||31/10/2020|365||||||87.3\n099|1|3|qualifie|06/06/1998|01/03/2021|364|12|11|10|12|13|169.3\n099|1|3|qualifie|06/06/1998|01/03/2022|364|12|11|10|12|13|169.3\n099|1|3|qualifie|06/06/1998|01/03/2023|364|12|11|10|12|13|169.3\n187|2|2|qualifie|05/12/1986|01/01/2022|364|10|10|10|10|10|169.3\n187|2|2|qualifie|05/12/1986|01/01/2023|364|10|10|10|10|10|234.1\n689|1|1||01/12/2000|06/11/2017|123|9|7|8|13|16|189.3\n765|1|4|Non qualifie|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9\n765|1|4|Non qualifie|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9\n765|1|4|Non qualifie|26/12/1995|17/04/2020|160|13|10|12|18|10|45.9\"\n\n\n#readLines va permettre de créer un objet pour chaque ligne\n#strsplit va permettre de séparer les textes qui sont entre des \"|\" \na &lt;-  readLines(textConnection(a)) %&gt;% \n  strsplit(split='|',fixed=TRUE) \n\ndonnees_tidyverse &lt;- data.frame(matrix(unlist(a), nrow=length(a), byrow=TRUE))\n\n#La première ligne donne le nom des colonnes\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% janitor::row_to_names(row_number = 1)\n\n#On remplace les valeurs qui sont des espaces par des \"NA\" dans toute \n#la base de données \ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% mutate_all(na_if,\"\")",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#manipuler-les-colonnes-de-la-base-de-données",
    "href": "01-aide_memoire_r_sas.html#manipuler-les-colonnes-de-la-base-de-données",
    "title": "Aide-mémoire SAS - R",
    "section": "4 Manipuler les colonnes de la base de données",
    "text": "4 Manipuler les colonnes de la base de données\nR étant sensible à la casse, ce qui n’est pas le cas de SAS, cette section est donc pertinente pour les codes sous R.\n\nExtraire les noms des variables de la base\nMettre le nom de la colonne en minuscules\n\n\nR basetidyverse\n\n\n\n# R est sensible à la casse, il est pertinent d'harmoniser les noms des variables en minuscule\nnomCol &lt;- tolower(colnames(donnees_rbase))\n\nError in is.data.frame(x): object 'donnees_rbase' not found\n\n\n\ncolnames(donnees_rbase) &lt;- tolower(colnames(donnees_rbase))\n\nError in is.data.frame(x): object 'donnees_rbase' not found\n\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  magrittr::set_colnames(value = casefold(colnames(.), upper = FALSE))",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#harmoniser-le-format-des-variables",
    "href": "01-aide_memoire_r_sas.html#harmoniser-le-format-des-variables",
    "title": "Aide-mémoire SAS - R",
    "section": "5 Harmoniser le format des variables",
    "text": "5 Harmoniser le format des variables\nConvertir certaines variables en format ‘date’, ‘integer’ et ‘numeric’\n\nSASR basetidyverse\n\n\n  data Donnees_sas;\n  set Donnees_sas;\n  duree_int = input(duree, 1.);\n  note_contenu_int = input(note_contenu, 1.);\n  note_formateur_int = input(note_formateur, 1.);\n  note_moyens_int = input(note_moyens, 1.);\n  note_accompagnement_int = input(note_accompagnement, 1.);\n  note_materiel_int = input(note_materiel, 1.);\n  date_naissance_date = input(date_naissance, DDMMYY10.);\n  date_entree = input(date_entree, DDMMYY10.);\nrun;\n\n\n\nenNumerique &lt;- c(\"duree\", \"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nenDate &lt;-c('date_naissance', 'date_entree')\n\n\ndonnees_rbase[, enNumerique] &lt;- lapply(donnees_rbase[, enNumerique], as.integer)\n\nError in lapply(donnees_rbase[, enNumerique], as.integer): object 'donnees_rbase' not found\n\ndonnees_rbase[, enDate] &lt;- lapply(donnees_rbase[, enDate], lubridate::dmy)\n\nError in lapply(donnees_rbase[, enDate], lubridate::dmy): object 'donnees_rbase' not found\n\ndonnees_rbase$poids_sondage &lt;- as.numeric(donnees_rbase$poids_sondage)\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\n\n\n\n\nenNumerique &lt;- c(\"duree\", \"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\nenDate &lt;-c('date_naissance', 'date_entree')\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%  \n  mutate_at(enNumerique, as.integer) %&gt;% \n  mutate(poids_sondage=as.numeric(poids_sondage)) %&gt;% \n  mutate_at(enDate, lubridate::dmy)",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#information-sur-la-base-de-données",
    "href": "01-aide_memoire_r_sas.html#information-sur-la-base-de-données",
    "title": "Aide-mémoire SAS - R",
    "section": "6 Information sur la base de données",
    "text": "6 Information sur la base de données\n\n6.1 Extraire les 10 première lignes de la base\n\nSASR basetidyverse\n\n\n/* Extraire les x premières lignes de la base (10 par défaut) */\n\n%let x = 10;\nproc print data = Donnees_sas (firstobs = 1 obs = &x.);run;\n\n/* Ou alors */\ndata Lignes&x.;set Donnees_sas (firstobs = 1 obs = &x.);proc print;run;\n\n\n\n# Extraire les 10 premières lignes de la base\ndonnees_rbase &lt;- data.frame(donnees_rbase)\n\nError in data.frame(donnees_rbase): object 'donnees_rbase' not found\n\nView(donnees_rbase[1:10, ])\n\nError in as.data.frame(x): object 'donnees_rbase' not found\n\nhead(donnees_rbase)\n\nError in head(donnees_rbase): object 'donnees_rbase' not found\n\n\n\n\n\ndonnees_tidyverse %&gt;% \n  slice(1:10) %&gt;% \n  head()\n\n\n\n\n\n\n6.2 Renommer les variables\n\nSASR basetidyverse\n\n\n/* On renomme la variable sexe_red en sexe */\n  \n  data Donnees_sas;\n  set Donnees_sas (rename = (sexe_red = sexe));\n  run;\n\n\n\n# On renomme la variable sexe_red en sexe\ndonnees_rbase$sexe &lt;- donnees_rbase$sexe_red\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\n#Attention, lorsqu'on utilise ce code pour renommer la variable, l'ancienne variable reste dans la base de données \n\ndonnees_rbase &lt;- donnees_rbase[, -which(names(donnees_rbase) %in% c(\"sexe_red\"))]\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\n\n\n\n\n# On renomme la variable sexe_red en sexe\n# La fonction rename() va écraser l'ancien nom de la variable contrairement au code utilisé dans la section R base\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  rename(sexe=sexe_red)\n\n\n\n\n\n\n6.3 Nombre de lignes et de colonnes dans la base\n\nSASR basetidyverse\n\n\n/* Nombre de lignes */\n  \n  proc sql;select count(*) as Nb_Lignes from Donnees_sas;quit;\n\n/* Nombre de colonnes */\n\n  proc sql;select count(*) as Nb_Colonnes from Var;quit;\n\n\n\n# Nombre de lignes et de colonnes dans la base\nsprintf(\"Nombre de lignes : %d | Nombre de colonnes : %d\", dim(donnees_rbase)[1], dim(donnees_rbase)[2])\n\nError in sprintf(\"Nombre de lignes : %d | Nombre de colonnes : %d\", dim(donnees_rbase)[1], : object 'donnees_rbase' not found\n\n\n\n\n\n#Nombre de lignes\ndonnees_tidyverse %&gt;% nrow()\n\n#Nombre de colonnes\ndonnees_tidyverse %&gt;%  ncol()\n\n\n\n\n\n\n6.4 Afficher les noms des variables de la base\n\nSASR basetidyverse\n\n\n  proc contents data=donnees_sas; run;\n\n\n\nls(donnees_rbase)\n\nError in as.environment(pos): no item called \"donnees_rbase\" on the search list\n\n\n\n\n\ndonnees_tidyverse %&gt;% colnames()\n\n\n\n\n\n\n6.5 Création de colonnes et de lignes\n\nSASR basetidyverse\n\n\ndata Donnees_sas;\n  set Donnees_sas;\n  note2 = note_contenu / 20 * 5;\n  Age = intck('year', date_naissance, date_entree);\n  run;\n\n\n\n# Création de la colonne note2\ndonnees_rbase$note2 &lt;- donnees_rbase$note_contenu / 20 * 5\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\n\n\n# Création de la colonne age \ndonnees_rbase$age &lt;- floor(lubridate::time_length(difftime(donnees_rbase$date_entree, donnees_rbase$date_naissance), \"years\"))\n\nError in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'time_length': object 'donnees_rbase' not found\n\n\n\n\n\n# Création de la colonne note2\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(note2= note_contenu / 20 * 5)\n\n\n# Création de la colonne age \ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n   mutate(age=as.period(interval(start = date_naissance, end = date_entree))$year)\n\n\n\n\n\n\n6.6 Supression de colonnes et de lignes\n\nSASR basetidyverse\n\n\ndata Donnees_sas;\n  set Donnees_sas;\n  drop note2;\n  run;\n\n\n\ndonnees_rbase$note2 &lt;- NULL\n\nError in donnees_rbase$note2 &lt;- NULL: object 'donnees_rbase' not found\n\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  select(-note2)",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#formater-les-modalités-des-valeurs",
    "href": "01-aide_memoire_r_sas.html#formater-les-modalités-des-valeurs",
    "title": "Aide-mémoire SAS - R",
    "section": "7 Formater les modalités des valeurs",
    "text": "7 Formater les modalités des valeurs\n\n7.1 Valeur discrète\n\nSASR basetidyverse\n\n\nproc format;\n  value sexef\n  1 = \"Homme\"\n  2 = \"Femme\";\n\n  value $ cspf\n  '1' = \"Cadre\"\n  '2' = \"Profession intermédiaire\"\n  '3' = \"Employé\"\n  '4' = \"Ouvrier\"\n  '5' = \"Retraité\";\nrun;\n\n\n\nsexef &lt;- c(\"1\" = \"Homme\", \"2\" = \"Femme\")\ncspf &lt;- c(\"1\" = \"Cadre\", \"2\" = \"Profession intermédiaire\", \"3\" = \"Employé\", \"4\" = \"Ouvrier\", \"5\" = \"Retraité\")\n\n\n# On exprime CSP et sexe en formaté\ndonnees_rbase$cspf &lt;- cspf[donnees_rbase$csp]\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\ndonnees_rbase$sexef &lt;- sexef[donnees_rbase$sexe]\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(sexef = case_when(\n    sexe==\"1\" ~ \"Homme\",\n    sexe==\"2\" ~ \"Femme\",\n    TRUE ~ sexe),\n         cspf = case_when(\n    csp==\"1\" ~ \"Cadre\",\n    csp==\"2\" ~ \"Profession intermédiaire\",\n    csp==\"3\" ~ \"Employé\",\n    csp==\"4\" ~ \"Ouvrier\",\n    csp==\"5\" ~ \"Retraité\",\n    TRUE ~ csp))\n\n\n\n\n\n\n7.2 Valeur continue\n\nSASR basetidyverse\n\n\nproc format;\n  value agef\n  low-&lt;26 = \"1. De 15 à 25 ans\"\n  26&lt;-&lt;50 = \"2. De 26 à 49 ans\"\n  50-high = \"3. 50 ans ou plus\";\nrun;\n\n\n\ndonnees_rbase$agef[donnees_rbase$age &lt; 26]                     &lt;- \"1. De 15 à 25 ans\"\n\nError in donnees_rbase$agef[donnees_rbase$age &lt; 26] &lt;- \"1. De 15 à 25 ans\": object 'donnees_rbase' not found\n\n# 26 &lt;= donnees_rbase$age &lt; 50 ne fonctionne pas, il faut passer en 2 étapes\ndonnees_rbase$agef[26 &lt;= donnees_rbase$age & donnees_rbase$age &lt; 50] &lt;- \"2. De 26 à 49 ans\"\n\nError in donnees_rbase$agef[26 &lt;= donnees_rbase$age & donnees_rbase$age &lt; : object 'donnees_rbase' not found\n\ndonnees_rbase$agef[donnees_rbase$age &gt;= 50]                    &lt;- \"3. 50 ans ou plus\"\n\nError in donnees_rbase$agef[donnees_rbase$age &gt;= 50] &lt;- \"3. 50 ans ou plus\": object 'donnees_rbase' not found\n\n# Autre solution\nagef &lt;- cut(donnees_rbase$age, \n            breaks = c(0, 25, 49, Inf),\n            right = TRUE,\n            labels = c(\"1. De 15 à 25 ans\", \"2. De 26 à 49 ans\", \"3. 50 ans ou plus\"), \n            ordered_result = TRUE)\n\nError in cut(donnees_rbase$age, breaks = c(0, 25, 49, Inf), right = TRUE, : object 'donnees_rbase' not found\n\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%\n  mutate(agef = case_when(\n    age &lt; 26 ~ \"1. De 15 à 25 ans\",\n    age &gt;= 26 | age &lt; 50 ~  \"2. De 26 à 49 ans\",\n    age &gt;= 50 ~ \"3. 50 ans ou plus\"))",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#manipuler-des-lignes-et-des-colonnes",
    "href": "01-aide_memoire_r_sas.html#manipuler-des-lignes-et-des-colonnes",
    "title": "Aide-mémoire SAS - R",
    "section": "8 Manipuler des lignes et des colonnes",
    "text": "8 Manipuler des lignes et des colonnes\nA rajouter : la selection basée sur des conditions\n\n8.1 Sélection de colonnes\n\nSASR basetidyverse\n\n\nproc sql;\n  create table work.donnees_col_select_sas as\n  select    identifiant, csp, niveau\n  from work.donnees_sas;\nquit; \n\n\n\ndonnees_col_select_rbase &lt;- donnees_rbase[, c(\"identifiant\", \"csp\", \"niveau\")]\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\n\n\n\n\ndonnees_col_select_tidyverse &lt;- donnees_tidyverse %&gt;% \n  select(identifiant, csp, niveau)\n\n\n\n\n\n\n8.2 Selection de lignes\n\nSASR basetidyverse\n\n\n  data donnees_sas; \n  set donnees_sas; \n  where sexef=\"Femme\";\n  run;\n  \n\n\n\ndonnees_femme_rbase &lt;- donnees_rbase[donnees_rbase$sexef==\"Femme\", ]\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\n\n\n\n\ndonnees_femme_tidyverse &lt;- donnees_tidyverse %&gt;% \n  filter(sexef==\"Femme\")",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#manipuler-des-lignes-et-des-colonnes-1",
    "href": "01-aide_memoire_r_sas.html#manipuler-des-lignes-et-des-colonnes-1",
    "title": "Aide-mémoire SAS - R",
    "section": "9 Manipuler des lignes et des colonnes",
    "text": "9 Manipuler des lignes et des colonnes\n\n9.1 Mettre un 0 devant un nombre\n\nCréer la variable mois\nMettre un 0 devant si le mois est inférieur à 9\n\n\nSASR basetidyverse\n\n\n/* Mettre un 0 devant un nombre */\n  \n  data Zero_devant;set Donnees_sas (keep = date_entree);\n  /* Obtenir le mois et la date */\n   Mois = month(date_entree);\n  /* Mettre le mois sur 2 positions (avec un 0 devant si le mois &lt;= 9) : format prédéfini z2. */\n  Mois_a = put(Mois, z2.);\n  drop Mois;\n  rename Mois_a = Mois;\n  run;\n\n\n\n# Obtenir le mois et la date\ndonnees_rbase$mois &lt;- lubridate::month(donnees_rbase$date_entree)\n\nError in lubridate::month(donnees_rbase$date_entree): object 'donnees_rbase' not found\n\n# Mettre le numéro du mois sur 2 positions (avec un 0 devant si le mois &lt;= 9)\ndonnees_rbase$mois &lt;- sprintf(\"%02d\", donnees_rbase$mois)\n\nError in sprintf(\"%02d\", donnees_rbase$mois): object 'donnees_rbase' not found\n\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(mois=lubridate::month(date_entree),\n         mois=ifelse(str_length(mois)&lt;2, paste0(\"0\", mois), mois))\n\n\n\n\n\n\n9.2 Réexprimer en masse des valeurs\n\nSASR basetidyverse\n\n\n/* On souhaite rééxprimer toutes les notes sur 100 et non sur 20 */\n  \n   %let notes = Note_Contenu   Note_Formateur Note_Moyens     Note_Accompagnement     Note_Materiel;\n/* On supprime les doubles blancs entre les variables */\n   %let notes = %sysfunc(compbl(&notes.));\n%put &notes;\n  \n/* 1ère solution : avec les array */\n  \n  data Sur100_1;\n  set Donnees_sas;\n  array variables (*) &notes.;\n  do increment = 1 to dim(variables);\n    variables[increment] = variables[increment] / 20 * 100;\n  end; \n  drop increment;\nrun; \n  \n  \n/* 2e solution : avec une macro */\n\n  data Sur100_2;\n  set Donnees;\n  %macro Sur100;\n    %do i = 1 %to %sysfunc(countw(&notes.));\n      %let note = %scan(&notes., &i.);\n      &note. = &note. / 20 * 100;\n    %end;\n  %mend Sur100;\n  %Sur5;\nrun; \n  \n  \n/* 3e solution : l'équivalent des list-comprehension de Python en SAS */\n\n\n  data Sur100_3;\n  set Donnees_sas;\n  %macro List_comprehension;\n    %do i = 1 %to %sysfunc(countw(&notes.));\n      %let j = %scan(&notes., &i.);\n        &j. = &j. / 20 * 100\n    %end;);;\n  %mend List_comprehension;\n  %List_comprehension;\nrun;\n\n\n\n# On souhaite rééxprimer les notes sur 100 et non sur 20\nnotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\ndonnees_rbase[, notes] &lt;- donnees_rbase[, notes] / 20 * 100\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\n\n\n\n\nnotes &lt;- c(\"note_contenu\", \"note_formateur\", \"note_moyens\", \"note_accompagnement\", \"note_materiel\")\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(across(notes, ~ .x/20*100))\n\n\n\n\n\n\n9.3 Passer une variable de numérique à caractère et vice-versa\n\nSASR basetidyverse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.4 Arrondir une valeur numérique\n\nSASR\n\n\n/* Arrondir une valeur numérique */\n data Arrondis;set Donnees_sas (keep = Poids);\n/* Arrondi à l'entier le plus proche */\n poids_arrondi_0 = round(poids, 0.0);\n/* Arrondi à 1 chiffre après la virgule */\n poids_arrondi_1 = round(poids, 0.1);\n/* Arrondi à 2 chiffre après la virgule */\n poids_arrondi_2 = round(poids, 0.2);\n/* Arrondi à l'entier inférieur */\n poids_inf = floor(poids);\n/* Arrondi à l'entier inférieur */\n poids_inf = ceil(poids);  \nrun;\n\n\n\n# Arrondi à l'entier le plus proche\npoids_arrondi_0 &lt;- round(donnees_rbase$poids, 0)\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\n# Arrondi à 1 chiffre après la virgule\npoids_arrondi_1 &lt;- round(donnees_rbase$poids, 1)\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\n# Arrondi à 2 chiffre après la virgule\npoids_arrondi_2 &lt;- round(donnees_rbase$poids, 2)\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\n# Arrondi à l'entier inférieur\npoids_inf &lt;- floor(donnees_rbase$poids)\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\n# Arrondi à l'entier inférieur\npoids_inf &lt;- ceiling(donnees_rbase$poids)\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#les-tris",
    "href": "01-aide_memoire_r_sas.html#les-tris",
    "title": "Aide-mémoire SAS - R",
    "section": "10 Les tris",
    "text": "10 Les tris\n\n10.1 Trier par colonne\n\nSASR basetidyverse\n\n\n/* On met identifiant date_entree et date_sortie au début de la base */\n %let colTri = identifiant date_entree;\ndata Donnees_sas;\n  retain &colTri.;\n  set Donnees_sas;\nrun;\n  \n/* Autre solution */\n proc sql;\n  create table Donnees_sas as \n  /* On remplace les blancs entre les mots par des virgules pour la proc SQL */\n  /* Dans la proc SQL, les variables doivent être séparées par des virgules */\n   select %sysfunc(tranwrd(&colTri., %str( ), %str(, ))), * from Donnees_sas;\nquit;\n\n\n\n# On met identifiant date_entree et date_sortie au début\ncolTri &lt;- c(\"identifiant\", \"date_entree\")\ndonnees_rbase[, c(colTri, colnames(donnees_rbase)[! colnames(donnees_rbase) %in% colTri])]\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\n\n\n\n\n# On met identifiant date_entree et date_sortie au début\ndonnees_tidyverse %&gt;% \n  select(identifiant, date_entree, everything())\n\n\n\n\n\n\n10.2 Trier les lignes par ordre croissant ou décroissant\n\nSASR basetidyverse\n\n\n/* Trier la base par ligne (individu et date de début de la formation) par ordre décroissant : 2 possibilités */\n\nproc sort data = Donnees_sas;by Identifiant Date_entree;run;\nproc sql;create table Donnes as select * from Donnees_sas order by Identifiant, Date_entree;quit;\n  \n/* Idem par ordre croissant d'identifiant et ordre décroissant de date d'entrée*/\n\nproc sort data = Donnees_sas;by Identifiant Date_entree descending;run;\nproc sql;create table Donnes as select * from Donnees_sas order by Identifiant, desc Date_entree;quit;\n\n\n\n# Trier la base par ligne (individu et date de début de la formation) par ordre croissant\n# L'option na.last = FALSE (resp. TRUE) indique que les valeurs manquantes doivent figurer à la fin (resp. au début) du tri, que le tri\n# soit croissant ou décroissant\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\n# Tri par ordre croissant de identifiant et décroissant de date_entree (- avant le nom de la variable)\n\n#donnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, -donnees_rbase$date_entree, na.last = FALSE), ]\n\n\n\n\n# Trier la base par ligne (individu et date de début de la formation) par ordre croissant\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  arrange(identifiant, date_entree)\n\n# Tri par ordre croissant de identifiant et décroissant de date_entree \ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  arrange(identifiant, desc(date_entree))\n\n\n\n\n\n\n10.3 Incidence des valeurs manquantes dans les tris, différence entre SAS et R\n\nSASR base\n\n\nproc sort data = Donnees_sas;\nby identifiant date_entree;run;\nproc print\n;run;\n\n/* ... et en dernier selon un tri par ordre décroissant */\n\nproc sort data = Donnees_sas;\nby identifiant descending date_entree;\nrun;\nproc print;\nrun;\n\n/* En effet, les valeurs manquantes sont considérées comme des valeurs négatives */\n\n\n\n# Les valeurs manquantes sont situées en dernier dans un tri par ordre croissant ou décroissant (car par défaut l'option na.last = TRUE) ...\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree), ]\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\n# Pour mimer le tri SAS, il faut écrire :\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#manipuler-des-dates",
    "href": "01-aide_memoire_r_sas.html#manipuler-des-dates",
    "title": "Aide-mémoire SAS - R",
    "section": "11 Manipuler des dates",
    "text": "11 Manipuler des dates\n\n11.1 Créer une date\n\nSASR basetidyverse\n\n\ndata Donnees;\nset Donnees;\n/* Date de sortie du dispositif : ajout de la durée à la date d'entrée */\nformat date_sortie ddmmyy10.;\ndate_sortie = intnx('day', date_entree, duree);\nrun;\n\n\n\n# Date de sortie du dispositif\ndonnees_rbase$date_sortie &lt;- donnees_rbase$date_entree + lubridate::days(donnees_rbase$duree)\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\n\n\n\n\n# Date de sortie du dispositif\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(date_sortie = date_entree + lubridate::days(duree))\n\n\n\n\n\n\n11.2 Calculer des durées\n\nSASR basetidyverse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n11.3 Ajouter une durée à une date\n\nSASR basetidyverse",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#manipuler-des-chaînes-de-caractères",
    "href": "01-aide_memoire_r_sas.html#manipuler-des-chaînes-de-caractères",
    "title": "Aide-mémoire SAS - R",
    "section": "12 Manipuler des chaînes de caractères",
    "text": "12 Manipuler des chaînes de caractères\n\n12.1 Majuscule, minuscule\n\nSASR basetidyverse\n\n\n/*Première lettre en majuscule*/\n\n  data Donnees_sas;\n  set Donnees_sas;\n  Niveau = propcase(Niveau);\n  run;\n\n\n/*Majuscule*/\n\n  data Donnees_sas;\n  set Donnees_sas;\n  CSP_majuscule = upcase(CSPF);\n  run;\n\n/*Minuscule*/\n\n  data Donnees_sas;\n  set Donnees_sas;\n  CSP_minuscule = lowcase(CSPF);\n  run;\n\n\n\nPremière lettre en majuscule\n\n\ndonnees_rbase$niveau &lt;- paste0(toupper(substr(donnees_rbase$niveau, 1, 1)), tolower(substr(donnees_rbase$niveau, 2, length(donnees_rbase$niveau))))\n\nError in substr(donnees_rbase$niveau, 1, 1): object 'donnees_rbase' not found\n\n\n\nMajuscule\n\n\ndonnees_rbase$csp_maj &lt;- toupper(donnees_rbase$cspf)\n\nError in toupper(donnees_rbase$cspf): object 'donnees_rbase' not found\n\n\n\nMinuscule\n\n\ndonnees_rbase$csp_maj &lt;- tolower(donnees_rbase$cspf)\n\nError in tolower(donnees_rbase$cspf): object 'donnees_rbase' not found\n\n\n\n\n\nPremière lettre en majuscule\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;%  \n  mutate(niveau=str_to_title(niveau))\n\n\nMajuscule\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(csp_maj=toupper(cspf))\n\n\nMinuscule\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(csp_maj=tolower(cspf))\n\n\n\n\n\n\n12.2 Remplacer une chaîne de catactère par une autre\n\nSASR base\n\n\ndata Donnees_sas;\nset Donnees_sas;\nNiveau = tranwrd(Niveau, \"Qualifie\", \"Qualifié\");\nrun;\n\n\n\n# Le mot qualifie n'a pas d'accent : on le corrige\ndonnees_rbase$niveau &lt;- gsub(\"Qualifie\", \"Qualifié\", donnees_rbase$niveau)\n\nError in is.factor(x): object 'donnees_rbase' not found\n\n\n\n\n\n\n\n12.3 Supprimer des blancs\n\nSASR basetidyverse\n\n\n/* Manipuler des chaînes de caractères =&gt; R = gsub, grepl etc. */\ndata Exemple_chaines;\nTexte = \"              Ce   Texte   mériterait   d être   corrigé                  \";\nTexte1 = \"Je m'appelle\";\nTexte2 = \"SAS\";\nrun;\ndata Exemple_chaines;set Exemple_chaines;\n/* Enlever les blancs au début et à la fin de la chaîne de caractère */\nEnlever_Blancs_Initiaux = strip(Texte);\n/* Enlever les doubles blancs dans la chaîne de caractères */\nEnlever_Blancs_Entre = compbl(Enlever_Blancs_Initiaux);\nrun;\n\n\n\ntexte_rbsase &lt;- \"              Ce   Texte   mériterait   d être   corrigé                  \"\ntexte_rbase_1 &lt;- \"Je m'appelle\"\ntexte_rbase_2 &lt;- \"R\"\n\n# trimws enlève les espaces au début et à la fin d'une chaîne de caractère\ntexte_rbase &lt;- gsub(\"\\\\s+\", \" \", trimws(texte_rbsase))\n\n\n\n\ntexte_tidyverse &lt;- \"              Ce   Texte   mériterait   d être   corrigé                  \"\ntexte_tidyverse_1 &lt;- \"Je m'appelle\"\ntexte_tidyverse_2 &lt;- \"R\"\n\n# str_squish() supprime les espaces blancs au début et à la fin, et remplace tous les espaces blancs internes par un seul espace\ntexte_tidyverse &lt;- str_squish(texte_tidyverse)\n\n\n\n\n\n\n12.4 Concaténer des chaînes de caractères\n\nSASR base\n\n\n/* Trois méthodes pour concaténer des chaînes de caractères */\nConcatener  = Texte1||\" \"||Texte2;\nConcatener2 = Texte1!!\" \"!!Texte2;\nConcatener3 = catx(\" \", Texte1, Texte2);\n/* Extraire les 2e, 3e et 4e caractères de Concatener */\n/* 2 correspond à la position du 1er caractère à récupérer, 3 le nombre total de caractères à partir du point de départ */\nextrait = substr(Concatener, 2, 3);\nrun;\n\n\n\n# Concaténer des chaînes de caractères\npaste(texte_rbase_1, texte_rbase_2, sep = \" \")\n\n\n\n\n\n\n12.5 Nombre de caractères dans une chaîne de caractères\n\nSASR basetidyverse\n\n\ndata Donnees;\nset Donnees;\n/* Nombre de caractères dans une chaîne de caractères*/\ntaille_id = length(identifiant);\nrun;\n\n\n\n# Nombre de caractères dans une chaîne de caractères\ndonnees_rbase$taille_id &lt;- nchar(donnees_rbase$identifiant)\n\nError in nchar(donnees_rbase$identifiant): object 'donnees_rbase' not found\n\n\n\n\n\n# Nombre de caractères dans une chaîne de caractères\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n   mutate(taille_id = str_split(identifiant, '') %&gt;% \n              lengths)\n\n\n\n\n\n\n12.6 Transformer plusieurs caractères différents\n\nSASR basetidyverse\n\n\n/* Transformer plusieurs caractères différents */\nchaine = \"éèêëàâçîô\";\n/* On transforme le é en e, le â en a, le î en i, ... */\nchaine_sans_accent = translate(chaine, \"eeeeaacio\", \"éèêëàâçîô\");\nrun;\n\n\n\n# Transformer plusieurs caractères différents\nchaine &lt;- \"éèêëàâçîô\"\nchartr(\"éèêëàâçîô\", \"eeeeaacio\", chaine)",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#gestion-ligne-par-ligne",
    "href": "01-aide_memoire_r_sas.html#gestion-ligne-par-ligne",
    "title": "Aide-mémoire SAS - R",
    "section": "13 Gestion ligne par ligne",
    "text": "13 Gestion ligne par ligne\n\n13.1 Numéro de l’observation\n\nSASR basetidyverse\n\n\n/* Numéro de l'observation */\ndata Donnees;set Donnees;\nNum_observation = _n_;\nrun;\n\n/* Autre solution */\nproc sql noprint;select count(*) into :nbLignes from Donnees;quit;\ndata numLigne;do Num_observation = 1 to &nbLignes.;output;end;run;\n\n\n\n# Numéro de l'observation : 2 manières différentes\n\ndonnees_rbase$num_observation &lt;- row.names(donnees_rbase)\n\nError in row.names(donnees_rbase): object 'donnees_rbase' not found\n\ndonnees_rbase$num_observation &lt;- seq(1 : nrow(donnees_rbase))\n\nError in nrow(donnees_rbase): object 'donnees_rbase' not found\n\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(num_observation= row_number())\n\n\n\n\n\n\n13.2 Trier des colonnes\n\nSASR basetidyverse\n\n\n/* Numéro du contrat de chaque individu, contrat trié par date de survenue */\nproc sort data = Donnees;by identifiant date_entree;run;\ndata Donnees;set Donnees;\nby identifiant date_entree;\nretain numero_contrat 0;\nif first.identifiant then numero_contrat = 1;\nelse numero_contrat = numero_contrat + 1;\nrun;\n\n\n\n# Numéro du contrat de chaque individu, contrat trié par date de survenue\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\ndonnees_rbase$a &lt;- 1\n\nError in donnees_rbase$a &lt;- 1: object 'donnees_rbase' not found\n\ndonnees_rbase$numero_contrat &lt;- ave(donnees_rbase$a, donnees_rbase$identifiant, FUN = cumsum)\n\nError in interaction(...): object 'donnees_rbase' not found\n\n# Pour trier les colonnes\ntri &lt;- c(\"identifiant\", \"date_entree\", \"numero_contrat\", \"num_observation\")\ndonnees_rbase_tri &lt;- donnees_rbase[, c(tri, colnames(donnees_rbase)[! colnames(donnees_rbase) %in% tri])]\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\n\n\n\n\n# Numéro du contrat de chaque individu, contrat trié par date de survenue \n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;% \n  arrange(identifiant, date_entree) %&gt;% \n  mutate(numero_contrat=row_number())\n\n# arrange() va permettre de trier les observations par identifiant et date d'entrée \n\n# Pour trier les colonnes\n\ndonnees_tidyverse_tri &lt;- donnees_tidyverse %&gt;% \n  select(identifiant, date_entree, numero_contrat, num_observation, everything())\n\n\n\n\n\n\n13.3 Identifier le 1er, le 2e, le dernier contrat d’un individu\n\nSASR basetidyverse\n\n\n/* 2e contrat de l'individu (et rien si l'individu a fait 1 seul contrat */\ndata Deuxieme_Contrat;set Donnees;if numero_contrat = 2;run;\ndata Deuxieme_Contrat;set Donnees (where = (numero_contrat = 2));run;\n\n\n\n# Filtre sur le deuxième contrat \n\ndeuxieme_contrat_rbase &lt;- donnees_rbase[donnees_rbase$numero_contrat == 2, ]\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\n\n\n# Créer une base avec les seuls premiers contrats, et une base avec les seuls derniers contrats\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\npremier_contrat_rbase &lt;- donnees_rbase[!duplicated(donnees_rbase$identifiant, fromLast = FALSE), ]\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\ndernier_contrat_rbase &lt;- donnees_rbase[!duplicated(donnees_rbase$identifiant, fromLast = TRUE), ]\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\nni_prem_ni_der_rbase  &lt;- donnees_rbase[! (!duplicated(donnees_rbase$identifiant, fromLast = FALSE) | !duplicated(donnees_rbase$identifiant, fromLast = TRUE)), ]\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\n\n\n\n\n# Filtre sur le deuxième contrat \n\ndeuxieme_contrat_tidyverse &lt;- donnees_tidyverse %&gt;% \n  filter(numero_contrat == 2)\n\n\n# Créer une base avec les seuls premiers contrats, et une base avec les seuls derniers contrats\n\npremier_contrat_tidyverse &lt;- donnees_tidyverse %&gt;% \n  filter(numero_contrat==1)\n\ndernier_contrat_tidyverse &lt;- donnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;% \n  filter(numero_contrat==max(numero_contrat)) %&gt;% \n  ungroup()\n\nni_prem_ni_der_tidyverse  &lt;- donnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;% \n  filter(numero_contrat!=1 & numero_contrat != max(numero_contrat)) %&gt;% \n  ungroup()\n\n\n\n\n\n\n13.4 Date de fin du contrat précédent\n\nSASR basetidyverse\n\n\n/* La date de fin du contrat précédent */\nproc sort data = Donnees;by identifiant date_entree;run;\ndata DonneesBon;set Donnees;\nby identifiant date_entree;\nformat Date_fin_1 ddmmyy10.;\nDate_fin_1 = lag(Date_sortie);\nif first.identifiant then Date_fin_1 = .;\nrun;\n\n\n\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entre, na.last = FALSE), ]\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\n\n\n# Il faut soit utiliser un package, soit utiliser cette astuce car il n'existe pas de fonction lag dans le R de base (à notre connaissance)\ndonnees_rbase$date_sortie_1 &lt;- c(as.Date(NA), donnees_rbase$date_sortie[ 1:(length(donnees_rbase$date_sortie) - 1)])\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\ndonnees_rbase$date_sortie_1[!duplicated(donnees_rbase$identifiant, fromLast = FALSE)] &lt;- as.Date(NA)\n\nError in donnees_rbase$date_sortie_1[!duplicated(donnees_rbase$identifiant, : object 'donnees_rbase' not found\n\n\n\n\n\n\n\n\n\n\n13.5 Valeur retardée (lag)\n\nSASR basetidyverse\n\n\n/* ATTENTION au lag DANS UNE CONDITION IF (cf. document) */\nproc sort data = Donnees;by identifiant date_entree;run;\ndata Lag_Bon;set Donnees (keep = identifiant date_entree date_sortie);\nformat date_sortie_1 lag_faux lag_bon ddmmyy10.;\n/* Erreur */\nif date_entree = lag(date_sortie) + 1 then lag_faux = lag(date_sortie) + 1;\n/* Bonne écriture */\ndate_sortie_1 = lag(date_sortie);\nif date_entree = date_sortie_1 + 1 then lag_bon = date_sortie_1 + 1;\nrun;\n\n\n\n# Il n'existe pas de fonction lag dans le R de base (à notre connaissance)\n# Il faut soit utiliser un package, soit utiliser cette astuce\ndonnees_rbase$date_sortie_1 &lt;- c(as.Date(NA), donnees_rbase$date_sortie[ 1:(length(donnees_rbase$date_sortie) - 1)])\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\ndonnees_rbase$date_sortie_1[!duplicated(donnees_rbase$identifiant, fromLast = FALSE)] &lt;- as.Date(NA)\n\nError in donnees_rbase$date_sortie_1[!duplicated(donnees_rbase$identifiant, : object 'donnees_rbase' not found\n\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(date_sortie_1 = lag(date_sortie))\n\n\n\n\n\n\n13.6 Transposer une base\n\nSASR basetidyverse\n\n\n/* Transposer une base */\nproc freq data = Donnees;table Sexef * cspf / out = Nb;run;\nproc sort data = Nb;by cspf Sexef;run;\nproc print data = Nb;run;\nproc transpose data = Nb out = transpose;by cspf;var count;id Sexef;run;\ndata transpose;set transpose (drop = _name_ _label_);run;\nproc print data = transpose;run;\n\n\n\n# as.data.frame.matrix est nécessaire, car le résultat de xtabs est un array\nnb_rbase &lt;- as.data.frame.matrix(xtabs( ~ cspf + sexef, data = donnees_rbase))\n\nError in terms.formula(formula, data = data): object 'donnees_rbase' not found\n\nnb_transpose_rbase &lt;- as.data.frame(t(nb_rbase))\n\nError in t(nb_rbase): object 'nb_rbase' not found\n\n\n\n\n\nnb_tidyverse &lt;- donnees_tidyverse %&gt;% janitor::tabyl(cspf, sexef) %&gt;% \n                # colonne cspf comme nom de ligne\n                  column_to_rownames(var=\"cspf\")\n\nnb_transpose_tridyverse &lt;- nb_tidyverse %&gt;% sjmisc::rotate_df()",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#les-valeurs-manquantes",
    "href": "01-aide_memoire_r_sas.html#les-valeurs-manquantes",
    "title": "Aide-mémoire SAS - R",
    "section": "14 Les valeurs manquantes",
    "text": "14 Les valeurs manquantes\n\n14.1 Repérer les valeurs manquantes\n\nSASR basetidyverse\n\n\n/* Repérer les valeurs manquantes */\ndata Missing;set Donnees;\n/* 1ère solution */\nif missing(age) or missing(Niveau) then missing1 = 1;else missing1 = 0;\nif age = . or Niveau = '' then missing2 = 1;else missing2 = 0;\nkeep Age Niveau Missing1 Missing2;\nrun;\n\n\n\ndonnees_rbase$missing &lt;- ifelse(is.na(donnees_rbase$age) | is.na(donnees_rbase$niveau), 1, 0)\n\nError in ifelse(is.na(donnees_rbase$age) | is.na(donnees_rbase$niveau), : object 'donnees_rbase' not found\n\nageManquant_rbase_faux &lt;- donnees_rbase[is.na(donnees_rbase$age),  ] # Faux : crée une basse de données avec que des NA\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\nageManquant_rbase_correct &lt;- donnees_rbase[is.na(donnees_rbase$age), ] # Correct\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  mutate(missing = ifelse(is.na(age) | is.na(niveau), 1, 0))\n\nageManquant_tidyverse &lt;- donnees_tidyverse %&gt;% \n  filter(is.na(age))\n\n\n\n\n\n\n14.2 Incidence des valeurs manquantes, différent entre SAS et R\n\nSASR base\n\n\n\n\n\n\n14.2.1 Opérations\nIl suffit de rajouter l’argument na.rm=TRUE\n\nmean(donnees_rbase$note_formateur) # s'il existe un seul NA et que l'on ne précise rien, la fonction retournera NA\n\nError in mean(donnees_rbase$note_formateur): object 'donnees_rbase' not found\n\n\n\n# Il faut donc rajouter l'argument na.rm=TRUE (remove NA) afin de calculer la moyenne sans prendre en compte les NA\n\nmean(donnees_rbase$note_formateur, na.rm = TRUE)\n\nError in mean(donnees_rbase$note_formateur, na.rm = TRUE): object 'donnees_rbase' not found\n\n\n\n\n14.2.2 Tris\n\n# Trier la base par ligne (individu et date de début de la formation) par ordre croissant\n\n# L'option na.last = FALSE (resp. TRUE) indique que les valeurs manquantes doivent figurer à la fin (resp. au début) du tri, que le tri\n\n# soit croissant ou décroissant\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\n# Tri par ordre croissant de identifiant et décroissant de date_entree (- avant le nom de la variable)\n# donnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, -donnees_rbase$date_entree, na.last = FALSE), ] #ne marche pas pour les dates à refaire\n\n\n# Trier la base par colonne (noms de variables)\n# On met identifiant date_entree et date_sortie au début\n# colTri &lt;- c(\"identifiant\", \"date_entree\", \"date_sortie\")\n# donnees_rbase[, c(colTri, colnames(donnees_rbase)[! colnames(donnees_rbase) %in% colTri])]\n\n\n# Les valeurs manquantes sont situées en dernier dans un tri par ordre croissant ou décroissant (car par défaut l'option na.last = TRUE) ...\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree), ]\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\n\n\n# Pour mimer le tri SAS, il faut écrire :\ndonnees_rbase &lt;- donnees_rbase[order(donnees_rbase$identifiant, donnees_rbase$date_entree, na.last = FALSE), ]\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#les-doublons",
    "href": "01-aide_memoire_r_sas.html#les-doublons",
    "title": "Aide-mémoire SAS - R",
    "section": "15 Les doublons",
    "text": "15 Les doublons\n\n15.1 Repérage des doublons\n\nSASR basetidyverse\n\n\n/* On récupère déjà la dernière variable de la base (on en aura besoin plus loin) */\nproc contents data = Donnees out = Var noprint;run;\nproc sql noprint;select name into :derniere_var from Var where varnum = (select max(varnum) from Var);quit;\n\n/* 1ère méthode */\nproc sort data = Donnees;by &nom_col.;run;\ndata Doublons;set Donnees;by &nom_col.;\nif first.&derniere_var. = 0 or last.&derniere_var. = 0;\nrun;\n\n/* 2e méthode */\n\n/* On remplace les blancs entre les mots par des virgules pour la proc sql */\n\n/* Dans la proc SQL, les variables doivent être séparées par des virgules */\n%let nom_col_sql = %sysfunc(tranwrd(&nom_col., %str( ), %str(, )));\n\n/* On groupe par toutes les colonnes, et si on aboutit à strictement plus qu'une ligne, c'est un doublon */\nproc sql;create table Doublons as select * from Donnees group by &nom_col_sql. having count(*) &gt; 1;quit;\n\n/* Suppression des doublons */\n\n/* 1ère méthode */\nproc sort data = Donnees nodupkey;by &nom_col.;run;\n\n/* 2e méthode, avec first. et last. (cf. infra) */\n\n/* On récupère déjà la dernière variable de la base (on en aura besoin plus loin) */\nproc contents data = Donnees out = Var noprint;run;\nproc sql noprint;select name into :derniere_var from Var where varnum = (select max(varnum) from Var);quit;\nproc sql noprint;select name into :nom_col separated by \" \" from Var order by varnum;quit;\n%put Dernière variable de la base : &derniere_var.;\n%put &nom_col.;\nproc sort data = Donnees;by &nom_col.;run;\ndata Donnees;set Donnees;by &nom_col.;if first.&derniere_var.;run;\n\n\n\n# Repérage\ndoublons_rbase &lt;- donnees_rbase[duplicated(donnees_rbase), ]\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\n#doublons ici : toute la ligne est identique avec une autre ligne \n#avec cette commande, s'il y existe des doublons i.e. deux observations qui ont les mêmes observations pour toutes les variables, la base doublons_rbase stockera uniquement un des doublons mais pas toutes les lignes qui sont identiques \n\n\n\n\n# Repérage\ndoublons_tidyverse &lt;- donnees_tidyverse %&gt;%  \n  group_by(identifiant, sexe) %&gt;% \n  filter(n()&gt;1)\n\n#doublons ici : les observations qui ont le même identifiant et le même sexe \n#avec cette commande, la base doublons_tidyverse va stocker toutes les observations qui sont en doubles i.e. qui ont le même identifiant et le même sexe \n\n\n\n\n\n\n15.2 Suppression des doublons\n\nSASR basetidyverse\n\n\n\n\n\n\ndonnees_rbase &lt;- donnees_rbase[! duplicated(donnees_rbase), ]\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\n\n\n# Autre solution (solution first. de SAS)\ndonnees_rbase &lt;- donnees_rbase[order(colnames(donnees_rbase), na.last = FALSE), ]\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\ndonnees_rbase &lt;- donnees_rbase[!duplicated(donnees_rbase[, colnames(donnees_rbase)], fromLast = TRUE), ]\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\n\n\n\n\ndonnees_tidyverse &lt;- donnees_tidyverse %&gt;% \n  distinct()",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#les-jointures-de-base",
    "href": "01-aide_memoire_r_sas.html#les-jointures-de-base",
    "title": "Aide-mémoire SAS - R",
    "section": "16 Les jointures de base",
    "text": "16 Les jointures de base\n\n16.1 Inner Join : identifiants communs aux bases\n\nSASR basetidyverse\n\n\n/* On suppose que l'on dispose d'une base supplémentaire avec les diplômes des personnes */\ndata Diplome;\ninfile cards dsd dlm='|';\nformat Identifiant $3. Diplome $50.;\ninput Identifiant $ Diplome $;\ncards;\n173|Bac\n168|Bep-Cap\n112|Bep-Cap\n087|Bac+2\n689|Bac+2\n765|Pas de diplôme\n112|Bac\n999|Bac\n554|Bep-Cap\n;\nrun;\ndata Jointure;set Donnees (keep = Identifiant Sexe Age);run;\n\n/* Le tri préalable des bases de données à joindre par la variable de jointure est nécessaire avec la stratégie merge */\nproc sort data = Diplome;by identifiant;run;\nproc sort data = Jointure;by identifiant;run;\ndata Inner_Join1;\nmerge Jointure (in = a) Diplome (in = b);\nby identifiant;\nif a and b;\nrun;\n\n/* Le tri préalable des bases de données à joindre n'est pas nécessaire avec la jointure SQL */\nproc sql;\ncreate table Inner_Join2 as\nselect * from Jointure a inner join Diplome b on a.identifiant = b.identifiant\norder by a.identifiant;\nquit;\nproc print data = Inner_Join1;run;\nproc sql;select count(*) from Inner_Join1;quit;\n\n\n\n# On suppose que l'on dispose d'une base supplémentaire avec les diplômes des personnes\ndiplome_rbase &lt;- data.frame(identifiant_i = c(\"173\", \"168\", \"112\", \"087\", \"689\", \"765\", \"112\", \"999\", \"554\"),\ndiplome= c(\"Bac\", \"Bep-Cap\", \"Bep-Cap\", \"Bac+2\", \"Bac+2\", \"Pas de diplôme\", \"Bac\", \"Bac\", \"Bep-Cap\"),\nage_dip = c(22, 27, 18, 23, 21, 15, 21, 18, 20)\n)\n\n\n# 1. Inner join : les seuls identifiants communs aux deux bases\njointure_rbase &lt;- donnees_rbase[, c(\"identifiant\", \"sexe\", \"age\")]\n\nError in eval(expr, envir, enclos): object 'donnees_rbase' not found\n\ninnerJoin_rbase &lt;- merge(jointure_rbase, diplome_rbase, by.x = \"identifiant\", by.y = \"identifiant_i\")\n\nError in merge(jointure_rbase, diplome_rbase, by.x = \"identifiant\", by.y = \"identifiant_i\"): object 'jointure_rbase' not found\n\ndim(innerJoin_rbase)\n\nError in eval(expr, envir, enclos): object 'innerJoin_rbase' not found\n\n\n\n\n\n# On suppose que l'on dispose d'une base supplémentaire avec les diplômes des personnes\ndiplome_tidyverse &lt;- data.frame(identifiant= c(\"173\", \"168\", \"112\", \"087\", \"689\", \"765\", \"112\", \"999\", \"554\"),\ndiplome= c(\"Bac\", \"Bep-Cap\", \"Bep-Cap\", \"Bac+2\", \"Bac+2\", \"Pas de diplôme\", \"Bac\", \"Bac\", \"Bep-Cap\"),\nage_dip = c(22, 27, 18, 23, 21, 15, 21, 18, 20)\n)\n\n\n# 1. Inner join : les seuls identifiants communs aux deux bases\njointure_tidyverse&lt;- donnees_tidyverse %&gt;% \n  select(identifiant, sexe, age)\n\ninnerJoin_tidyverse &lt;- jointure_tidyverse %&gt;% \n  inner_join(diplome_tidyverse, by=\"identifiant\")\n\n\n\n\n\n\n16.2 Left et Right Join : identifiants de l’une des bases\n\nSASR basetidyverse\n\n\n/* Le tri préalable des bases de données à joindre par la variable de jointure est nécessaire avec la stratégie merge */\nproc sort data = Diplome;by identifiant;run;\nproc sort data = Jointure;by identifiant;run;\ndata Left_Join1;\nmerge Jointure (in = a) Diplome (in = b);\nby identifiant;\nif a;\nrun;\n\n\n\n# 2. Left join : les identifiants de la base de gauche\nleftJoin_rbase &lt;- merge(jointure_rbase, diplome_rbase, by.x = \"identifiant\", by.y = \"identifiant_i\", all.x = TRUE)\n\nError in merge(jointure_rbase, diplome_rbase, by.x = \"identifiant\", by.y = \"identifiant_i\", : object 'jointure_rbase' not found\n\ndim(leftJoin_rbase)\n\nError in eval(expr, envir, enclos): object 'leftJoin_rbase' not found\n\n\n\n\n\n# 2. Left join : les identifiants de la base de gauche\nleftJoin_tidyverse &lt;- jointure_tidyverse %&gt;% \n  left_join(diplome_tidyverse, by=\"identifiant\")\n\n\n\n\n\n\n16.3 Full Join : identifiants de l’une ou l’autre des bases\n\nSASR basetidyverse\n\n\n/* Le tri préalable des bases de données à joindre par la variable de jointure est nécessaire avec la stratégie merge */\nproc sort data = Diplome;by identifiant;run;\nproc sort data = Jointure;by identifiant;run;\ndata Full_Join1;\nmerge Jointure (in = a) Diplome (in = b);\nby identifiant;\nif a or b;\nrun;\n\n\n\n# 3. Full join : les identifiants des deux bases\nfullJoin_rbase &lt;- merge(jointure_rbase, diplome_rbase, by.x = \"identifiant\", by.y = \"identifiant_i\", all = TRUE)\n\nError in merge(jointure_rbase, diplome_rbase, by.x = \"identifiant\", by.y = \"identifiant_i\", : object 'jointure_rbase' not found\n\ndim(fullJoin_rbase)\n\nError in eval(expr, envir, enclos): object 'fullJoin_rbase' not found\n\n\n\n\n\n# 3. Full join : les identifiants des deux bases\nfullJoin_tidyverse &lt;- jointure_tidyverse %&gt;% \n  full_join(diplome_tidyverse)\n\n\n\n\n\n\n16.4 Cross Join : toutes les combinaisons possibles\n\nSASR basetidyverse\n\n\n/* 4. Cross join : toutes les combinaisons possibles de CSP, sexe et Diplome */\nproc sql;\nselect *\nfrom (select distinct CSPF from Donnees) cross join (select distinct Sexef from Donnees) cross join (select distinct Diplome from Diplome)\norder by CSPF, Sexef, Diplome;\nquit;\n\n\n\n# 4. Cross join : toutes les combinaisons possibles de CSP, sexe et Diplome\ncrossJoin_rbase &lt;- unique(expand.grid(donnees_rbase$cspf, donnees_rbase$sexef, diplome_rbase$diplome))\n\nError in expand.grid(donnees_rbase$cspf, donnees_rbase$sexef, diplome_rbase$diplome): object 'donnees_rbase' not found\n\ncolnames(crossJoin_rbase) &lt;- c(\"cspf\", \"sexef\", \"diplome\")\n\nError in colnames(crossJoin_rbase) &lt;- c(\"cspf\", \"sexef\", \"diplome\"): object 'crossJoin_rbase' not found\n\ncrossJoin_rbase\n\nError in eval(expr, envir, enclos): object 'crossJoin_rbase' not found\n\n\n\n\n\n# 4. Cross join \ncrossJoin_tidyverse &lt;- cross_join(jointure_tidyverse, diplome_tidyverse) #à refaire\n\n\n\n\n\n\n16.5 Empiler les bases\n\nSASR basetidyverse\n\n\n\n\n\n\n# Lorsque les variables ne correspondent pas, on les crée avec des valeurs manquantes, via setdiff\nempilement_rbase &lt;- rbind(\ndata.frame(c(donnees_rbase, sapply(setdiff(names(diplome_rbase), names(donnees_rbase)), function(x) NA))),\ndata.frame(c(diplome_rbase, sapply(setdiff(names(donnees_rbase), names(diplome_rbase)), function(x) NA)))\n)\n\nError in data.frame(c(donnees_rbase, sapply(setdiff(names(diplome_rbase), : object 'donnees_rbase' not found\n\n\n\n\n\n# bind_rows permet d'empiler les deux bases de données quel que soit l'ordre et le nombre respectif de colonnes alors que rbind ne fonctionnera pas si les bases de données n'ont pas les mêmes colonnes dans le même ordre. \n\nempilement_tidyverse &lt;- bind_rows(donnees_tidyverse, diplome_tidyverse)",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#statistiques-descriptives",
    "href": "01-aide_memoire_r_sas.html#statistiques-descriptives",
    "title": "Aide-mémoire SAS - R",
    "section": "17 Statistiques descriptives",
    "text": "17 Statistiques descriptives\n\n17.1 Somme, moyenne, médiane, minimum, maximum, nombre de valeurs\n\nSASR basetidyverse\n\n\n/* Moyenne de chaque note */\n%let notes = Note_Contenu Note_Formateur Note_Moyens Note_Accompagnement Note_Materiel;\nproc means data = Donnees mean;var &notes.;run;\n\n/* Somme, moyenne, médiane, minimum, maximum, nombre de données */\nproc means data = Donnees sum mean median min max n;var &notes.;run;\n\n/* Notes pondérées (poids de sondage) */\nproc means data = Donnees sum mean median min max n;var &notes.;weight poids_sondage;run;\n\n\n\nMoyenne\n\n\n# Moyenne de chaque note\nnotes_rbase &lt;- tolower(c(\"Note_Contenu\", \"Note_Formateur\", \"Note_Moyens\", \"Note_Accompagnement\", \"Note_Materiel\"))\nlapply(donnees_rbase[, notes_rbase], mean, na.rm = TRUE)\n\nError in lapply(donnees_rbase[, notes_rbase], mean, na.rm = TRUE): object 'donnees_rbase' not found\n\n\n\nMoyenne, médiane, maximum, minimum\n\n\nsapply(donnees_rbase[, notes], function(x) c(\"Somme\" = sum(x, na.rm = TRUE), \"Moyenne\" = mean(x, na.rm = TRUE),\n\"Médiane\" = median(x, na.rm = TRUE), \"Max\" = max(x, na.rm = TRUE),\n\"Min\" = min(x, na.rm = TRUE)))\n\nError in lapply(X = X, FUN = FUN, ...): object 'donnees_rbase' not found\n\n\n\nMoyenne avec pondération\n\n\n# Avec la pondération\nwith(donnees_rbase, sapply(donnees_rbase[, notes], function(x) weighted.mean(x, poids_sondage, na.rm = TRUE)))\n\nError in with(donnees_rbase, sapply(donnees_rbase[, notes], function(x) weighted.mean(x, : object 'donnees_rbase' not found\n\n\n\nRésumé statistique\n\n\nsummary(donnees_rbase[, notes])\n\nError in summary(donnees_rbase[, notes]): object 'donnees_rbase' not found\n\n\n\n\n\nMoyenne par identifiant\n\n\nnotes_tidyverse &lt;- donnees_tidyverse %&gt;%  \n  select(starts_with(\"Note\")) %&gt;% \n  summarise_all(.funs = c(mean=\"mean\"))\n\n\nMoyenne par identifiant par pondération\n\n\nnotes_tidyverse &lt;- donnees_tidyverse %&gt;%  \n  select(starts_with(\"Note\"), poids_sondage) %&gt;% \n  summarise(across(note_contenu:note_materiel, ~weighted.mean(., w = poids_sondage)))\n\n\n\n\n\n\n17.2 Quantiles\n\nSASR basetidyverse\n\n\n\n\n\n\n# Déciles et quartiles de la note moyenne\nquantile(donnees_rbase$note_moyens, probs = c(seq(0, 1, 0.1), 0.25, 0.75), na.rm = TRUE)\n\nError in quantile(donnees_rbase$note_moyens, probs = c(seq(0, 1, 0.1), : object 'donnees_rbase' not found\n\n\n\n\n\ndonnees_tidyverse %&gt;% \n  group_by(identifiant) %&gt;%  \n  summarise(quantile = scales::percent(c(0.25, 0.5, 0.75)),\n            note_moyens = quantile(note_moyens, c(0.25, 0.5, 0.75), na.rm = TRUE))\n\n\n\n\n\n\n17.3 Tableaux de fréquence / contingence : proc freq\n\nSASR basetidyverse\n\n\n/* Tableaux de fréquence : proc freq */\nproc freq data = Donnees;\ntables Sexe CSP / missing;\nformat Sexe sexef. CSP $cspf.;\n/*weight poids_sondage;*/\nrun;\n\n\nL’équivalent de proc freq sur SAS :\n\ntable(donnees_rbase$sexef, useNA = \"always\")\n\nError in table(donnees_rbase$sexef, useNA = \"always\"): object 'donnees_rbase' not found\n\n\n\n\n\ntableau_contingence &lt;- donnees_tidyverse %&gt;% \n  group_by(sexef) %&gt;% \n  summarise(n=n())\n\ntableau_contingence\n\n\n\n\n\n\n17.4 Proportion\n\nSASR basetidyverse\n\n\n\n\n\n\nprop.table(table(donnees_rbase$sexef, useNA = \"always\")) * 100\n\nError in table(donnees_rbase$sexef, useNA = \"always\"): object 'donnees_rbase' not found\n\n\n\n\n\nproportion &lt;- donnees_tidyverse %&gt;% \n  group_by(sexef) %&gt;% \n  summarise(n=n(),\n            pourcentage=round(n/length(donnees_tidyverse$sexef)*100,2))\n\nproportion",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#fonction-macros-sas",
    "href": "01-aide_memoire_r_sas.html#fonction-macros-sas",
    "title": "Aide-mémoire SAS - R",
    "section": "18 Fonction, macros SAS",
    "text": "18 Fonction, macros SAS\n\n18.1 Boucles, itérations\n\nSASR basetidyverse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n18.2 Créations automatiques de bases, empilements de bases\n\nSASR basetidyverse",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#fin-du-programme",
    "href": "01-aide_memoire_r_sas.html#fin-du-programme",
    "title": "Aide-mémoire SAS - R",
    "section": "19 Fin du programme",
    "text": "19 Fin du programme\n\n19.1 Supprimer toutes les bases de la mémoire vive (work RAM)\n\nSASR base\n\n\n/* Supprimer toutes les bases de la mémoire vive (la work) =&gt; rm(list = ls()) */\nproc datasets lib = work nolist kill;run;\n\n\n\nrm(list = ls())",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#points-de-vigilance-en-sas",
    "href": "01-aide_memoire_r_sas.html#points-de-vigilance-en-sas",
    "title": "Aide-mémoire SAS - R",
    "section": "20 Points de vigilance en SAS",
    "text": "20 Points de vigilance en SAS",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01-aide_memoire_r_sas.html#footnotes",
    "href": "01-aide_memoire_r_sas.html#footnotes",
    "title": "Aide-mémoire SAS - R",
    "section": "Notes de bas de page",
    "text": "Notes de bas de page\n\n\nDares/SCS, nassab.abdallah@travail.gouv.fr↩︎\nDares/DIP, damien.euzenat@travail.gouv.fr↩︎",
    "crumbs": [
      "Introduction"
    ]
  }
]